#pragma warning disable
using System;
using System.IO;
using System.Reflection;
using System.Threading;
using dnlib.Utils;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;
using System.Text.RegularExpressions;
using dnlib.DotNet.Pdb;
using System.Collections.Generic;
using System.Diagnostics;
using System.Security.Cryptography;
using System.Linq;
using System.Xml;
using dnlib.Threading;
using dnlib.IO;
using dnlib.PE;
using System.Runtime.Serialization;
using System.Text;
using dnlib.DotNet.Emit;
using System.Runtime.InteropServices;
using dnlib.W32Resources;
using System.Runtime.ExceptionServices;
using System.Security;
using dnlib.DotNet.Pdb.Symbols;
using System.Runtime.CompilerServices;
using System.Globalization;
using System.Reflection.Emit;
using SR = System.Reflection;
using System.Collections;
using System.Runtime.InteropServices.ComTypes;
using System.Diagnostics.SymbolStore;
using dnlib.DotNet.Pdb.WindowsPdb;
using System.IO.Compression;
using System.Runtime.Serialization.Formatters.Binary;
using dnlib.DotNet.Pdb.Portable;
using dnlib.DotNet;
using DNW = dnlib.DotNet.Writer;
using Microsoft.Win32.SafeHandles;

#if NET35
namespace System.Runtime.InteropServices {
	[AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Method, AllowMultiple = false)]
	sealed class DefaultDllImportSearchPathsAttribute : Attribute {
		public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths) => _paths = paths;
		public DllImportSearchPath Paths => _paths;
		internal DllImportSearchPath _paths;
	}

	[Flags]
	enum DllImportSearchPath {
		LegacyBehavior					= 0,
		AssemblyDirectory				= 2,
		UseDllDirectoryForDependencies	= 0x100,
		ApplicationDirectory			= 0x200,
		UserDirectories					= 0x400,
		System32						= 0x800,
		SafeDirectories					= 0x1000,
	}
}
#endif




#if NET35
namespace System.Runtime.ExceptionServices {
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	sealed class HandleProcessCorruptedStateExceptionsAttribute : Attribute {
	}
}
#endif




namespace dnlib {
	/// <summary>
	/// dnlib settings
	/// </summary>
	public static class Settings {
		/// <summary>
		/// <c>true</c> if dnlib is thread safe. (<c>THREAD_SAFE</c> was defined during compilation)
		/// </summary>
		public static bool IsThreadSafe {
			get {
#if THREAD_SAFE
				return true;
#else
				return false;
#endif
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Assembly table
	/// </summary>
	public abstract class AssemblyDef : IHasCustomAttribute, IHasDeclSecurity, IHasCustomDebugInformation, IAssembly, IListListener<ModuleDef>, ITypeDefFinder, IDnlibDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.Assembly, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 14;

		/// <inheritdoc/>
		public int HasDeclSecurityTag => 2;

		/// <summary>
		/// From column Assembly.HashAlgId
		/// </summary>
		public AssemblyHashAlgorithm HashAlgorithm {
			get => hashAlgorithm;
			set => hashAlgorithm = value;
		}
		/// <summary/>
		protected AssemblyHashAlgorithm hashAlgorithm;

		/// <summary>
		/// From columns Assembly.MajorVersion, Assembly.MinorVersion, Assembly.BuildNumber,
		/// Assembly.RevisionNumber.
		/// </summary>
		/// <exception cref="ArgumentNullException">If <paramref name="value"/> is <c>null</c></exception>
		public Version Version {
			get => version;
			set => version = value ?? throw new ArgumentNullException(nameof(value));
		}
		/// <summary/>
		protected Version version;

		/// <summary>
		/// From column Assembly.Flags
		/// </summary>
		public AssemblyAttributes Attributes {
			get => (AssemblyAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Assembly.PublicKey
		/// </summary>
		/// <remarks>An empty <see cref="PublicKey"/> is created if the caller writes <c>null</c></remarks>
		public PublicKey PublicKey {
			get => publicKey;
			set => publicKey = value ?? new PublicKey();
		}
		/// <summary/>
		protected PublicKey publicKey;

		/// <summary>
		/// Gets the public key token which is calculated from <see cref="PublicKey"/>
		/// </summary>
		public PublicKeyToken PublicKeyToken => publicKey.Token;

		/// <summary>
		/// From column Assembly.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Assembly.Locale
		/// </summary>
		public UTF8String Culture {
			get => culture;
			set => culture = value;
		}
		/// <summary>Name</summary>
		protected UTF8String culture;

		/// <inheritdoc/>
		public IList<DeclSecurity> DeclSecurities {
			get {
				if (declSecurities is null)
					InitializeDeclSecurities();
				return declSecurities;
			}
		}
		/// <summary/>
		protected IList<DeclSecurity> declSecurities;
		/// <summary>Initializes <see cref="declSecurities"/></summary>
		protected virtual void InitializeDeclSecurities() =>
			Interlocked.CompareExchange(ref declSecurities, new List<DeclSecurity>(), null);

		/// <inheritdoc/>
		public PublicKeyBase PublicKeyOrToken => publicKey;

		/// <inheritdoc/>
		public string FullName => GetFullNameWithPublicKeyToken();

		/// <inheritdoc/>
		public string FullNameToken => GetFullNameWithPublicKeyToken();

		/// <summary>
		/// Gets all modules. The first module is always the <see cref="ManifestModule"/>.
		/// </summary>
		public IList<ModuleDef> Modules {
			get {
				if (modules is null)
					InitializeModules();
				return modules;
			}
		}
		/// <summary/>
		protected LazyList<ModuleDef> modules;
		/// <summary>Initializes <see cref="modules"/></summary>
		protected virtual void InitializeModules() =>
			Interlocked.CompareExchange(ref modules, new LazyList<ModuleDef>(this), null);

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;


		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 14;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);
		/// <inheritdoc/>
		public bool HasDeclSecurities => DeclSecurities.Count > 0;

		/// <summary>
		/// <c>true</c> if <see cref="Modules"/> is not empty
		/// </summary>
		public bool HasModules => Modules.Count > 0;

		/// <summary>
		/// Gets the manifest (main) module. This is always the first module in <see cref="Modules"/>.
		/// <c>null</c> is returned if <see cref="Modules"/> is empty.
		/// </summary>
		public ModuleDef ManifestModule => Modules.Count == 0 ? null : Modules[0];

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(AssemblyAttributes andMask, AssemblyAttributes orMask) =>
			attributes = (attributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, AssemblyAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PublicKey"/> bit
		/// </summary>
		public bool HasPublicKey {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.PublicKey) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.PublicKey);
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitecture {
			get => (AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask;
			set => ModifyAttributes(~AssemblyAttributes.PA_Mask, value & AssemblyAttributes.PA_Mask);
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitectureFull {
			get => (AssemblyAttributes)attributes & AssemblyAttributes.PA_FullMask;
			set => ModifyAttributes(~AssemblyAttributes.PA_FullMask, value & AssemblyAttributes.PA_FullMask);
		}

		/// <summary>
		/// <c>true</c> if unspecified processor architecture
		/// </summary>
		public bool IsProcessorArchitectureNone => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_None;

		/// <summary>
		/// <c>true</c> if neutral (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureMSIL => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_MSIL;

		/// <summary>
		/// <c>true</c> if x86 (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureX86 => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_x86;

		/// <summary>
		/// <c>true</c> if IA-64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureIA64 => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_IA64;

		/// <summary>
		/// <c>true</c> if x64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureX64 => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_AMD64;

		/// <summary>
		/// <c>true</c> if ARM (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureARM => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_ARM;

		/// <summary>
		/// <c>true</c> if eg. reference assembly (not runnable)
		/// </summary>
		public bool IsProcessorArchitectureNoPlatform => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_NoPlatform;

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PA_Specified"/> bit
		/// </summary>
		public bool IsProcessorArchitectureSpecified {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Specified) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.PA_Specified);
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.EnableJITcompileTracking"/> bit
		/// </summary>
		public bool EnableJITcompileTracking {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.EnableJITcompileTracking) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.EnableJITcompileTracking);
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.DisableJITcompileOptimizer"/> bit
		/// </summary>
		public bool DisableJITcompileOptimizer {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.DisableJITcompileOptimizer) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.DisableJITcompileOptimizer);
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.Retargetable"/> bit
		/// </summary>
		public bool IsRetargetable {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.Retargetable) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.Retargetable);
		}

		/// <summary>
		/// Gets/sets the content type
		/// </summary>
		public AssemblyAttributes ContentType {
			get => (AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask;
			set => ModifyAttributes(~AssemblyAttributes.ContentType_Mask, value & AssemblyAttributes.ContentType_Mask);
		}

		/// <summary>
		/// <c>true</c> if content type is <c>Default</c>
		/// </summary>
		public bool IsContentTypeDefault => ((AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_Default;

		/// <summary>
		/// <c>true</c> if content type is <c>WindowsRuntime</c>
		/// </summary>
		public bool IsContentTypeWindowsRuntime => ((AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_WindowsRuntime;

		/// <summary>
		/// Finds a module in this assembly
		/// </summary>
		/// <param name="name">Name of module</param>
		/// <returns>A <see cref="ModuleDef"/> instance or <c>null</c> if it wasn't found.</returns>
		public ModuleDef FindModule(UTF8String name) {
			var modules = Modules;
			int count = modules.Count;
			for (int i = 0; i < count; i++) {
				var module = modules[i];
				if (module is null)
					continue;
				if (UTF8String.CaseInsensitiveEquals(module.Name, name))
					return module;
			}
			return null;
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a file
		/// </summary>
		/// <param name="fileName">File name of an existing .NET assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="fileName"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(string fileName, ModuleContext context) =>
			Load(fileName, new ModuleCreationOptions(context));

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a file
		/// </summary>
		/// <param name="fileName">File name of an existing .NET assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="fileName"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(string fileName, ModuleCreationOptions options = null) {
			if (fileName is null)
				throw new ArgumentNullException(nameof(fileName));
			ModuleDef module = null;
			try {
				module = ModuleDefMD.Load(fileName, options);
				var asm = module.Assembly;
				if (asm is null)
					throw new BadImageFormatException($"{fileName} is only a .NET module, not a .NET assembly. Use ModuleDef.Load().");
				return asm;
			}
			catch {
				if (module is not null)
					module.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a byte[]
		/// </summary>
		/// <param name="data">Contents of a .NET assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="data"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(byte[] data, ModuleContext context) =>
			Load(data, new ModuleCreationOptions(context));

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a byte[]
		/// </summary>
		/// <param name="data">Contents of a .NET assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="data"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(byte[] data, ModuleCreationOptions options = null) {
			if (data is null)
				throw new ArgumentNullException(nameof(data));
			ModuleDef module = null;
			try {
				module = ModuleDefMD.Load(data, options);
				var asm = module.Assembly;
				if (asm is null)
					throw new BadImageFormatException($"{module.ToString()} is only a .NET module, not a .NET assembly. Use ModuleDef.Load().");
				return asm;
			}
			catch {
				if (module is not null)
					module.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="addr"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(IntPtr addr, ModuleContext context) =>
			Load(addr, new ModuleCreationOptions(context));

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="addr"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(IntPtr addr, ModuleCreationOptions options = null) {
			if (addr == IntPtr.Zero)
				throw new ArgumentNullException(nameof(addr));
			ModuleDef module = null;
			try {
				module = ModuleDefMD.Load(addr, options);
				var asm = module.Assembly;
				if (asm is null)
					throw new BadImageFormatException($"{module.ToString()} (addr: {addr.ToInt64():X8}) is only a .NET module, not a .NET assembly. Use ModuleDef.Load().");
				return asm;
			}
			catch {
				if (module is not null)
					module.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleContext)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(Stream stream, ModuleContext context) =>
			Load(stream, new ModuleCreationOptions(context));

		/// <summary>
		/// Creates an <see cref="AssemblyDef"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleContext)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="AssemblyDef"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		/// <exception cref="BadImageFormatException">If it's not a .NET assembly (eg. not a .NET file or only a .NET module)</exception>
		public static AssemblyDef Load(Stream stream, ModuleCreationOptions options = null) {
			if (stream is null)
				throw new ArgumentNullException(nameof(stream));
			ModuleDef module = null;
			try {
				module = ModuleDefMD.Load(stream, options);
				var asm = module.Assembly;
				if (asm is null)
					throw new BadImageFormatException($"{module.ToString()} is only a .NET module, not a .NET assembly. Use ModuleDef.Load().");
				return asm;
			}
			catch {
				if (module is not null)
					module.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Gets the assembly name with the public key
		/// </summary>
		public string GetFullNameWithPublicKey() => GetFullName(publicKey);

		/// <summary>
		/// Gets the assembly name with the public key token
		/// </summary>
		public string GetFullNameWithPublicKeyToken() => GetFullName(publicKey.Token);

		string GetFullName(PublicKeyBase pkBase) => Utils.GetAssemblyNameString(name, version, culture, pkBase, Attributes);

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. For speed, enable <see cref="ModuleDef.EnableTypeDefFindCache"/>
		/// if possible (read the documentation first).
		/// </summary>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public TypeDef Find(string fullName, bool isReflectionName) {
			var modules = Modules;
			int count = modules.Count;
			for (int i = 0; i < count; i++) {
				var module = modules[i];
				if (module is null)
					continue;
				var type = module.Find(fullName, isReflectionName);
				if (type is not null)
					return type;
			}
			return null;
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. Its scope (i.e., module or assembly) is ignored when
		/// looking up the type. For speed, enable <see cref="ModuleDef.EnableTypeDefFindCache"/>
		/// if possible (read the documentation first).
		/// </summary>
		/// <param name="typeRef">The type ref</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public TypeDef Find(TypeRef typeRef) {
			var modules = Modules;
			int count = modules.Count;
			for (int i = 0; i < count; i++) {
				var module = modules[i];
				if (module is null)
					continue;
				var type = module.Find(typeRef);
				if (type is not null)
					return type;
			}
			return null;
		}

		/// <summary>
		/// Writes the assembly to a file on disk. If the file exists, it will be truncated.
		/// </summary>
		/// <param name="filename">Filename</param>
		/// <param name="options">Writer options</param>
		public void Write(string filename, ModuleWriterOptions options = null) =>
			ManifestModule.Write(filename, options);

		/// <summary>
		/// Writes the assembly to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		/// <param name="options">Writer options</param>
		public void Write(Stream dest, ModuleWriterOptions options = null) =>
			ManifestModule.Write(dest, options);

		/// <summary>
		/// Checks whether this assembly is a friend assembly of <paramref name="targetAsm"/>
		/// </summary>
		/// <param name="targetAsm">Target assembly</param>
		public bool IsFriendAssemblyOf(AssemblyDef targetAsm) {
			if (targetAsm is null)
				return false;
			if (this == targetAsm)
				return true;

			// Both must be unsigned or both must be signed according to the
			// InternalsVisibleToAttribute documentation.
			if (PublicKeyBase.IsNullOrEmpty2(publicKey) != PublicKeyBase.IsNullOrEmpty2(targetAsm.PublicKey))
				return false;

			foreach (var ca in targetAsm.CustomAttributes.FindAll("System.Runtime.CompilerServices.InternalsVisibleToAttribute")) {
				if (ca.ConstructorArguments.Count != 1)
					continue;
				var arg = ca.ConstructorArguments.Count == 0 ? default : ca.ConstructorArguments[0];
				if (arg.Type.GetElementType() != ElementType.String)
					continue;
				var asmName = arg.Value as UTF8String;
				if (UTF8String.IsNull(asmName))
					continue;

				var asmInfo = new AssemblyNameInfo(asmName);
				if (asmInfo.Name != name)
					continue;
				if (!PublicKeyBase.IsNullOrEmpty2(publicKey)) {
					if (!PublicKey.Equals(asmInfo.PublicKeyOrToken as PublicKey))
						continue;
				}
				else if (!PublicKeyBase.IsNullOrEmpty2(asmInfo.PublicKeyOrToken))
					continue;

				return true;
			}

			return false;
		}

		/// <summary>
		/// Adds or updates an existing <c>System.Reflection.AssemblySignatureKeyAttribute</c>
		/// attribute. This attribute is used in enhanced strong naming with key migration.
		/// See http://msdn.microsoft.com/en-us/library/hh415055.aspx
		/// </summary>
		/// <param name="identityPubKey">Identity public key</param>
		/// <param name="identityKey">Identity strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		public void UpdateOrCreateAssemblySignatureKeyAttribute(StrongNamePublicKey identityPubKey, StrongNameKey identityKey, StrongNamePublicKey signaturePubKey) {
			var manifestModule = ManifestModule;
			if (manifestModule is null)
				return;

			// Remove all existing attributes
			CustomAttribute ca = null;
			for (int i = 0; i < CustomAttributes.Count; i++) {
				var caTmp = CustomAttributes[i];
				if (caTmp.TypeFullName != "System.Reflection.AssemblySignatureKeyAttribute")
					continue;
				CustomAttributes.RemoveAt(i);
				i--;
				if (ca is null)
					ca = caTmp;
			}

			if (IsValidAssemblySignatureKeyAttribute(ca))
				ca.NamedArguments.Clear();
			else
				ca = CreateAssemblySignatureKeyAttribute();

			var counterSig = StrongNameKey.CreateCounterSignatureAsString(identityPubKey, identityKey, signaturePubKey);
			ca.ConstructorArguments[0] = new CAArgument(manifestModule.CorLibTypes.String, new UTF8String(signaturePubKey.ToString()));
			ca.ConstructorArguments[1] = new CAArgument(manifestModule.CorLibTypes.String, new UTF8String(counterSig));
			CustomAttributes.Add(ca);
		}

		bool IsValidAssemblySignatureKeyAttribute(CustomAttribute ca) {
			if (dnlib.Settings.IsThreadSafe)
				return false;
			if (ca is null)
				return false;
			var ctor = ca.Constructor;
			if (ctor is null)
				return false;
			var sig = ctor.MethodSig;
			if (sig is null || sig.Params.Count != 2)
				return false;
			if (sig.Params[0].GetElementType() != ElementType.String)
				return false;
			if (sig.Params[1].GetElementType() != ElementType.String)
				return false;
			if (ca.ConstructorArguments.Count != 2)
				return false;
			return true;
		}

		CustomAttribute CreateAssemblySignatureKeyAttribute() {
			var manifestModule = ManifestModule;
			var owner = manifestModule.UpdateRowId(new TypeRefUser(manifestModule, "System.Reflection", "AssemblySignatureKeyAttribute", manifestModule.CorLibTypes.AssemblyRef));
			var methodSig = MethodSig.CreateInstance(manifestModule.CorLibTypes.Void, manifestModule.CorLibTypes.String, manifestModule.CorLibTypes.String);
			var ctor = manifestModule.UpdateRowId(new MemberRefUser(manifestModule, MethodDef.InstanceConstructorName, methodSig, owner));
			var ca = new CustomAttribute(ctor);
			ca.ConstructorArguments.Add(new CAArgument(manifestModule.CorLibTypes.String, UTF8String.Empty));
			ca.ConstructorArguments.Add(new CAArgument(manifestModule.CorLibTypes.String, UTF8String.Empty));
			return ca;
		}

		/// <summary>
		/// Gets the original <c>System.Runtime.Versioning.TargetFrameworkAttribute</c> custom attribute information if possible.
		/// It reads this from the original metadata and doesn't use <see cref="CustomAttributes"/>.
		/// Returns false if the custom attribute isn't present or if it is invalid.
		/// </summary>
		/// <param name="framework">Framework name</param>
		/// <param name="version">Version</param>
		/// <param name="profile">Profile</param>
		/// <returns></returns>
		public virtual bool TryGetOriginalTargetFrameworkAttribute(out string framework, out Version version, out string profile) {
			framework = null;
			version = null;
			profile = null;
			return false;
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnLazyAdd(int index, ref ModuleDef module) {
			if (module is null)
				return;
#if DEBUG
			if (module.Assembly is null)
				throw new InvalidOperationException("Module.Assembly is null");
#endif
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnAdd(int index, ModuleDef module) {
			if (module is null)
				return;
			if (module.Assembly is not null)
				throw new InvalidOperationException("Module already has an assembly. Remove it from that assembly before adding it to this assembly.");
			module.Assembly = this;
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnRemove(int index, ModuleDef module) {
			if (module is not null)
				module.Assembly = null;
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<ModuleDef>.OnClear() {
			foreach (var module in modules.GetEnumerable_NoLock()) {
				if (module is not null)
					module.Assembly = null;
			}
		}

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// An Assembly row created by the user and not present in the original .NET file
	/// </summary>
	public class AssemblyDefUser : AssemblyDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyDefUser()
			: this(UTF8String.Empty, new Version(0, 0, 0, 0)) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyDefUser(UTF8String name)
			: this(name, new Version(0, 0, 0, 0), new PublicKey()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyDefUser(UTF8String name, Version version)
			: this(name, version, new PublicKey()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <param name="publicKey">Public key</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyDefUser(UTF8String name, Version version, PublicKey publicKey)
			: this(name, version, publicKey, UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <param name="publicKey">Public key</param>
		/// <param name="locale">Locale</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyDefUser(UTF8String name, Version version, PublicKey publicKey, UTF8String locale) {
			if (name is null)
				throw new ArgumentNullException(nameof(name));
			if (locale is null)
				throw new ArgumentNullException(nameof(locale));
			modules = new LazyList<ModuleDef>(this);
			this.name = name;
			this.version = version ?? throw new ArgumentNullException(nameof(version));
			this.publicKey = publicKey ?? new PublicKey();
			culture = locale;
			attributes = (int)AssemblyAttributes.None;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmName">Assembly name info</param>
		/// <exception cref="ArgumentNullException">If <paramref name="asmName"/> is <c>null</c></exception>
		public AssemblyDefUser(AssemblyName asmName)
			: this(new AssemblyNameInfo(asmName)) {
			hashAlgorithm = (AssemblyHashAlgorithm)asmName.HashAlgorithm;
			attributes = (int)asmName.Flags;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmName">Assembly name info</param>
		/// <exception cref="ArgumentNullException">If <paramref name="asmName"/> is <c>null</c></exception>
		public AssemblyDefUser(IAssembly asmName) {
			if (asmName is null)
				throw new ArgumentNullException(nameof(asmName));
			modules = new LazyList<ModuleDef>(this);
			name = asmName.Name;
			version = asmName.Version ?? new Version(0, 0, 0, 0);
			publicKey = asmName.PublicKeyOrToken as PublicKey ?? new PublicKey();
			culture = asmName.Culture;
			attributes = (int)AssemblyAttributes.None;
			hashAlgorithm = AssemblyHashAlgorithm.SHA1;
		}
	}

	/// <summary>
	/// Created from a row in the Assembly table
	/// </summary>
	sealed class AssemblyDefMD : AssemblyDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeDeclSecurities() {
			var list = readerModule.Metadata.GetDeclSecurityRidList(Table.Assembly, origRid);
			var tmp = new LazyList<DeclSecurity, RidList>(list.Count, list, (list2, index) => readerModule.ResolveDeclSecurity(list2[index]));
			Interlocked.CompareExchange(ref declSecurities, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeModules() {
			var list = readerModule.GetModuleRidList();
			var tmp = new LazyList<ModuleDef, RidList>(list.Count + 1, this, list, (list2, index) => {
				ModuleDef module;
				if (index == 0)
					module = readerModule;
				else
					module = readerModule.ReadModule(list2[index - 1], this);
				if (module is null)
					module = new ModuleDefUser("INVALID", Guid.NewGuid());
				module.Assembly = this;
				return module;
			});
			Interlocked.CompareExchange(ref modules, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.Assembly, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		public override bool TryGetOriginalTargetFrameworkAttribute(out string framework, out Version version, out string profile) {
			if (!hasInitdTFA)
				InitializeTargetFrameworkAttribute();
			framework = tfaFramework;
			version = tfaVersion;
			profile = tfaProfile;
			return tfaReturnValue;
		}
		volatile bool hasInitdTFA;
		string tfaFramework;
		Version tfaVersion;
		string tfaProfile;
		bool tfaReturnValue;

		void InitializeTargetFrameworkAttribute() {
			if (hasInitdTFA)
				return;

			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.Assembly, origRid);
			var gpContext = new GenericParamContext();
			for (int i = 0; i < list.Count; i++) {
				var caRid = list[i];
				if (!readerModule.TablesStream.TryReadCustomAttributeRow(caRid, out var caRow))
					continue;
				var caType = readerModule.ResolveCustomAttributeType(caRow.Type, gpContext);
				if (!TryGetName(caType, out var ns, out var name))
					continue;
				if (ns != nameSystemRuntimeVersioning || name != nameTargetFrameworkAttribute)
					continue;
				var ca = CustomAttributeReader.Read(readerModule, caType, caRow.Value, gpContext);
				if (ca is null || ca.ConstructorArguments.Count != 1)
					continue;
				var s = ca.ConstructorArguments[0].Value as UTF8String;
				if (s is null)
					continue;
				if (TryCreateTargetFrameworkInfo(s, out var tmpFramework, out var tmpVersion, out var tmpProfile)) {
					tfaFramework = tmpFramework;
					tfaVersion = tmpVersion;
					tfaProfile = tmpProfile;
					tfaReturnValue = true;
					break;
				}
			}

			hasInitdTFA = true;
		}
		static readonly UTF8String nameSystemRuntimeVersioning = new UTF8String("System.Runtime.Versioning");
		static readonly UTF8String nameTargetFrameworkAttribute = new UTF8String("TargetFrameworkAttribute");

		static bool TryGetName(ICustomAttributeType caType, out UTF8String ns, out UTF8String name) {
			ITypeDefOrRef type;
			if (caType is MemberRef mr)
				type = mr.DeclaringType;
			else
				type = (caType as MethodDef)?.DeclaringType;
			if (type is TypeRef tr) {
				ns = tr.Namespace;
				name = tr.Name;
				return true;
			}
			if (type is TypeDef td) {
				ns = td.Namespace;
				name = td.Name;
				return true;
			}
			ns = null;
			name = null;
			return false;
		}

		static bool TryCreateTargetFrameworkInfo(string attrString, out string framework, out Version version, out string profile) {
			framework = null;
			version = null;
			profile = null;

			// See corclr/src/mscorlib/src/System/Runtime/Versioning/BinaryCompatibility.cs
			var values = attrString.Split(new char[] { ',' });
			if (values.Length < 2 || values.Length > 3)
				return false;
			var frameworkRes = values[0].Trim();
			if (frameworkRes.Length == 0)
				return false;

			Version versionRes = null;
			string profileRes = null;
			for (int i = 1; i < values.Length; i++) {
				var kvp = values[i].Split('=');
				if (kvp.Length != 2)
					return false;

				var key = kvp[0].Trim();
				var value = kvp[1].Trim();

				if (key.Equals("Version", StringComparison.OrdinalIgnoreCase)) {
					if (value.StartsWith("v", StringComparison.OrdinalIgnoreCase))
						value = value.Substring(1);
					if (!TryParse(value, out versionRes))
						return false;
					versionRes = new Version(versionRes.Major, versionRes.Minor, versionRes.Build == -1 ? 0 : versionRes.Build, 0);
				}
				else if (key.Equals("Profile", StringComparison.OrdinalIgnoreCase)) {
					if (!string.IsNullOrEmpty(value))
						profileRes = value;
				}
			}
			if (versionRes is null)
				return false;

			framework = frameworkRes;
			version = versionRes;
			profile = profileRes;
			return true;
		}

		static int ParseInt32(string s) => int.TryParse(s, out int res) ? res : 0;

		static bool TryParse(string s, out Version version) {
			Match m;

			m = Regex.Match(s, @"^(\d+)\.(\d+)$");
			if (m.Groups.Count == 3) {
				version = new Version(ParseInt32(m.Groups[1].Value), ParseInt32(m.Groups[2].Value));
				return true;
			}

			m = Regex.Match(s, @"^(\d+)\.(\d+)\.(\d+)$");
			if (m.Groups.Count == 4) {
				version = new Version(ParseInt32(m.Groups[1].Value), ParseInt32(m.Groups[2].Value), ParseInt32(m.Groups[3].Value));
				return true;
			}

			m = Regex.Match(s, @"^(\d+)\.(\d+)\.(\d+)\.(\d+)$");
			if (m.Groups.Count == 5) {
				version = new Version(ParseInt32(m.Groups[1].Value), ParseInt32(m.Groups[2].Value), ParseInt32(m.Groups[3].Value), ParseInt32(m.Groups[4].Value));
				return true;
			}

			version = null;
			return false;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Assembly</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public AssemblyDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.AssemblyTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"Assembly rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			if (rid != 1)
				modules = new LazyList<ModuleDef>(this);
			bool b = readerModule.TablesStream.TryReadAssemblyRow(origRid, out var row);
			Debug.Assert(b);
			hashAlgorithm = (AssemblyHashAlgorithm)row.HashAlgId;
			version = new Version(row.MajorVersion, row.MinorVersion, row.BuildNumber, row.RevisionNumber);
			attributes = (int)row.Flags;
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			culture = readerModule.StringsStream.ReadNoNull(row.Locale);
			publicKey = new PublicKey(readerModule.BlobStream.Read(row.PublicKey));
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Hashes some data according to a <see cref="AssemblyHashAlgorithm"/>
	/// </summary>
	readonly struct AssemblyHash : IDisposable {
		readonly HashAlgorithm hasher;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks>If <paramref name="hashAlgo"/> is an unsupported hash algorithm, then
		/// <see cref="AssemblyHashAlgorithm.SHA1"/> will be used as the hash algorithm.</remarks>
		/// <param name="hashAlgo">The algorithm to use</param>
		public AssemblyHash(AssemblyHashAlgorithm hashAlgo) =>
			hasher = hashAlgo switch {
				AssemblyHashAlgorithm.MD5 => MD5.Create(),
				AssemblyHashAlgorithm.SHA_256 => SHA256.Create(),
				AssemblyHashAlgorithm.SHA_384 => SHA384.Create(),
				AssemblyHashAlgorithm.SHA_512 => SHA512.Create(),
				_ => SHA1.Create(),
			};

		/// <inheritdoc/>
		public void Dispose() {
			if (hasher is not null)
				((IDisposable)hasher).Dispose();
		}

		/// <summary>
		/// Hash data
		/// </summary>
		/// <remarks>If <paramref name="hashAlgo"/> is an unsupported hash algorithm, then
		/// <see cref="AssemblyHashAlgorithm.SHA1"/> will be used as the hash algorithm.</remarks>
		/// <param name="data">The data</param>
		/// <param name="hashAlgo">The algorithm to use</param>
		/// <returns>Hashed data or null if <paramref name="data"/> was <c>null</c></returns>
		public static byte[] Hash(byte[] data, AssemblyHashAlgorithm hashAlgo) {
			if (data is null)
				return null;

			using (var asmHash = new AssemblyHash(hashAlgo)) {
				asmHash.Hash(data);
				return asmHash.ComputeHash();
			}
		}

		/// <summary>
		/// Hash data
		/// </summary>
		/// <param name="data">Data</param>
		public void Hash(byte[] data) => Hash(data, 0, data.Length);

		/// <summary>
		/// Hash data
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="offset">Offset</param>
		/// <param name="length">Length</param>
		public void Hash(byte[] data, int offset, int length) {
			if (hasher.TransformBlock(data, offset, length, data, offset) != length)
				throw new IOException("Could not calculate hash");
		}

		/// <summary>
		/// Hash stream data
		/// </summary>
		/// <param name="stream">Stream</param>
		/// <param name="length">Number of bytes to hash</param>
		/// <param name="buffer">Temp buffer</param>
		public void Hash(Stream stream, uint length, byte[] buffer) {
			while (length > 0) {
				int len = length > (uint)buffer.Length ? buffer.Length : (int)length;
				if (stream.Read(buffer, 0, len) != len)
					throw new IOException("Could not read data");
				Hash(buffer, 0, len);
				length -= (uint)len;
			}
		}

		/// <summary>
		/// Computes the hash
		/// </summary>
		public byte[] ComputeHash() {
			hasher.TransformFinalBlock(Array2.Empty<byte>(), 0, 0);
			return hasher.Hash;
		}

		/// <summary>
		/// Creates a public key token from the hash of some <paramref name="publicKeyData"/>
		/// </summary>
		/// <remarks>A public key is hashed, and the last 8 bytes of the hash, in reverse
		/// order, is used as the public key token</remarks>
		/// <param name="publicKeyData">The data</param>
		/// <returns>A new <see cref="PublicKeyToken"/> instance</returns>
		public static PublicKeyToken CreatePublicKeyToken(byte[] publicKeyData) {
			if (publicKeyData is null)
				return new PublicKeyToken();
			var hash = Hash(publicKeyData, AssemblyHashAlgorithm.SHA1);
			var pkt = new byte[8];
			for (int i = 0; i < pkt.Length && i < hash.Length; i++)
				pkt[i] = hash[hash.Length - i - 1];
			return new PublicKeyToken(pkt);
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Any ALG_CLASS_HASH type in WinCrypt.h can be used by Microsoft's CLI implementation
	/// </summary>
	public enum AssemblyHashAlgorithm : uint {
		/// <summary/>
		None				= 0,
		/// <summary/>
		MD2					= 0x8001,
		/// <summary/>
		MD4					= 0x8002,
		/// <summary>This is a reserved value in the CLI</summary>
		MD5					= 0x8003,
		/// <summary>The only algorithm supported by the CLI</summary>
		SHA1				= 0x8004,
		/// <summary/>
		MAC					= 0x8005,
		/// <summary/>
		SSL3_SHAMD5			= 0x8008,
		/// <summary/>
		HMAC				= 0x8009,
		/// <summary/>
		TLS1PRF				= 0x800A,
		/// <summary/>
		HASH_REPLACE_OWF	= 0x800B,
		/// <summary/>
		SHA_256				= 0x800C,
		/// <summary/>
		SHA_384				= 0x800D,
		/// <summary/>
		SHA_512				= 0x800E,
	}

	public static partial class Extensions {
		internal static string GetName(this AssemblyHashAlgorithm hashAlg) =>
			hashAlg switch {
				AssemblyHashAlgorithm.MD2 => null,
				AssemblyHashAlgorithm.MD4 => null,
				AssemblyHashAlgorithm.MD5 => "MD5",
				AssemblyHashAlgorithm.SHA1 => "SHA1",
				AssemblyHashAlgorithm.MAC => null,
				AssemblyHashAlgorithm.SSL3_SHAMD5 => null,
				AssemblyHashAlgorithm.HMAC => null,
				AssemblyHashAlgorithm.TLS1PRF => null,
				AssemblyHashAlgorithm.HASH_REPLACE_OWF => null,
				AssemblyHashAlgorithm.SHA_256 => "SHA256",
				AssemblyHashAlgorithm.SHA_384 => "SHA384",
				AssemblyHashAlgorithm.SHA_512 => "SHA512",
				_ => null,
			};
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Flags used by <see cref="AssemblyNameComparer"/>
	/// </summary>
	[Flags]
	public enum AssemblyNameComparerFlags {
		/// <summary>
		/// Compare assembly simple name
		/// </summary>
		Name = 1,

		/// <summary>
		/// Compare assembly version
		/// </summary>
		Version = 2,

		/// <summary>
		/// Compare assembly public key token
		/// </summary>
		PublicKeyToken = 4,

		/// <summary>
		/// Compare assembly culture
		/// </summary>
		Culture = 8,

		/// <summary>
		/// Compare content type
		/// </summary>
		ContentType = 0x10,

		/// <summary>
		/// Compare assembly simple name, version, public key token, locale and content type
		/// </summary>
		All = Name | Version | PublicKeyToken | Culture | ContentType,
	}

	/// <summary>
	/// Compares two assembly names
	/// </summary>
	public readonly struct AssemblyNameComparer : IEqualityComparer<IAssembly> {
		/// <summary>
		/// Compares the name, version, public key token, culture and content type
		/// </summary>
		public static readonly AssemblyNameComparer CompareAll = new AssemblyNameComparer(AssemblyNameComparerFlags.All);

		/// <summary>
		/// Compares only the name and the public key token
		/// </summary>
		public static readonly AssemblyNameComparer NameAndPublicKeyTokenOnly = new AssemblyNameComparer(AssemblyNameComparerFlags.Name | AssemblyNameComparerFlags.PublicKeyToken);

		/// <summary>
		/// Compares only the name
		/// </summary>
		public static readonly AssemblyNameComparer NameOnly = new AssemblyNameComparer(AssemblyNameComparerFlags.Name);

		readonly AssemblyNameComparerFlags flags;

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.Name"/> bit
		/// </summary>
		public bool CompareName => (flags & AssemblyNameComparerFlags.Name) != 0;

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.Version"/> bit
		/// </summary>
		public bool CompareVersion => (flags & AssemblyNameComparerFlags.Version) != 0;

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.PublicKeyToken"/> bit
		/// </summary>
		public bool ComparePublicKeyToken => (flags & AssemblyNameComparerFlags.PublicKeyToken) != 0;

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.Culture"/> bit
		/// </summary>
		public bool CompareCulture => (flags & AssemblyNameComparerFlags.Culture) != 0;

		/// <summary>
		/// Gets the <see cref="AssemblyNameComparerFlags.ContentType"/> bit
		/// </summary>
		public bool CompareContentType => (flags & AssemblyNameComparerFlags.ContentType) != 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Comparison flags</param>
		public AssemblyNameComparer(AssemblyNameComparerFlags flags) => this.flags = flags;

		/// <summary>
		/// Compares two assembly names
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public int CompareTo(IAssembly a, IAssembly b) {
			if (a == b)
				return 0;
			if (a is null)
				return -1;
			if (b is null)
				return 1;

			int v;

			if (CompareName && (v = UTF8String.CaseInsensitiveCompareTo(a.Name, b.Name)) != 0)
				return v;
			if (CompareVersion && (v = Utils.CompareTo(a.Version, b.Version)) != 0)
				return v;
			if (ComparePublicKeyToken && (v = PublicKeyBase.TokenCompareTo(a.PublicKeyOrToken, b.PublicKeyOrToken)) != 0)
				return v;
			if (CompareCulture && (v = Utils.LocaleCompareTo(a.Culture, b.Culture)) != 0)
				return v;
			if (CompareContentType && (v = a.ContentType.CompareTo(b.ContentType)) != 0)
				return v;

			return 0;
		}

		/// <summary>
		/// Compares two assembly names
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if equal, <c>false</c> otherwise</returns>
		public bool Equals(IAssembly a, IAssembly b) => CompareTo(a, b) == 0;

		/// <summary>
		/// Figures out which of two assembly names is closer to another assembly name
		/// </summary>
		/// <param name="requested">Requested assembly name</param>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>-1 if both are equally close, 0 if <paramref name="a"/> is closest, 1 if
		/// <paramref name="b"/> is closest</returns>
		public int CompareClosest(IAssembly requested, IAssembly a, IAssembly b) {
			if (a == b)
				return 0;
			if (a is null)
				return !CompareName ? 1 : UTF8String.CaseInsensitiveEquals(requested.Name, b.Name) ? 1 : 0;
			if (b is null)
				return !CompareName ? 0 : UTF8String.CaseInsensitiveEquals(requested.Name, a.Name) ? 0 : 1;

			// Compare the most important parts first:
			//	1. Assembly simple name
			//	2. Public key token
			//	3. Version
			//	4. Locale
			//	5. Content type

			if (CompareName) {
				// If the name only matches one of a or b, return that one.
				bool na = UTF8String.CaseInsensitiveEquals(requested.Name, a.Name);
				bool nb = UTF8String.CaseInsensitiveEquals(requested.Name, b.Name);
				if (na && !nb)
					return 0;
				if (!na && nb)
					return 1;
				if (!na && !nb)
					return -1;
			}

			if (ComparePublicKeyToken) {
				bool pa, pb;
				if (PublicKeyBase.IsNullOrEmpty2(requested.PublicKeyOrToken)) {
					// If one of them has a pkt but the other one hasn't, return the one with
					// no pkt.
					pa = PublicKeyBase.IsNullOrEmpty2(a.PublicKeyOrToken);
					pb = PublicKeyBase.IsNullOrEmpty2(b.PublicKeyOrToken);
				}
				else {
					// If one of them has the correct pkt, but the other one has an incorrect
					// pkt, return the one with the correct pkt.
					pa = PublicKeyBase.TokenEquals(requested.PublicKeyOrToken, a.PublicKeyOrToken);
					pb = PublicKeyBase.TokenEquals(requested.PublicKeyOrToken, b.PublicKeyOrToken);
				}
				if (pa && !pb)
					return 0;
				if (!pa && pb)
					return 1;
			}

			if (CompareVersion && !Utils.Equals(a.Version, b.Version)) {
				var rv = Utils.CreateVersionWithNoUndefinedValues(requested.Version);
				if (rv == new Version(0, 0, 0, 0))
					rv = new Version(ushort.MaxValue, ushort.MaxValue, ushort.MaxValue, ushort.MaxValue);
				int va = Utils.CompareTo(a.Version, rv);
				int vb = Utils.CompareTo(b.Version, rv);
				if (va == 0)
					return 0;	// vb != 0 so return 0
				if (vb == 0)
					return 1;	// va != 0 so return 1
				if (va > 0 && vb < 0)
					return 0;
				if (va < 0 && vb > 0)
					return 1;
				// Now either both a and b's version > req version or both are < req version
				if (va > 0) {
					// a.Version and b.Version > req.Version. Pick the one that is closest.
					return Utils.CompareTo(a.Version, b.Version) < 0 ? 0 : 1;
				}
				else {
					// a.Version and b.Version < req.Version. Pick the one that is closest.
					return Utils.CompareTo(a.Version, b.Version) > 0 ? 0 : 1;
				}
			}

			if (CompareCulture) {
				bool la = Utils.LocaleEquals(requested.Culture, a.Culture);
				bool lb = Utils.LocaleEquals(requested.Culture, b.Culture);
				if (la && !lb)
					return 0;
				if (!la && lb)
					return 1;
			}

			if (CompareContentType) {
				bool ca = requested.ContentType == a.ContentType;
				bool cb = requested.ContentType == b.ContentType;
				if (ca && !cb)
					return 0;
				if (!ca && cb)
					return 1;
			}

			return -1;
		}

		/// <summary>
		/// Gets the hash code of an assembly name
		/// </summary>
		/// <param name="a">Assembly name</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IAssembly a) {
			if (a is null)
				return 0;

			int hash = 0;

			if (CompareName)
				hash += UTF8String.GetHashCode(a.Name);
			if (CompareVersion)
				hash += Utils.CreateVersionWithNoUndefinedValues(a.Version).GetHashCode();
			if (ComparePublicKeyToken)
				hash += PublicKeyBase.GetHashCodeToken(a.PublicKeyOrToken);
			if (CompareCulture)
				hash += Utils.GetHashCodeLocale(a.Culture);
			if (CompareContentType)
				hash += (int)a.ContentType;

			return hash;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Stores assembly name information
	/// </summary>
	public sealed class AssemblyNameInfo : IAssembly {
		AssemblyHashAlgorithm hashAlgId;
		Version version;
		AssemblyAttributes flags;
		PublicKeyBase publicKeyOrToken;
		UTF8String name;
		UTF8String culture;

		/// <summary>
		/// Gets/sets the <see cref="AssemblyHashAlgorithm"/>
		/// </summary>
		public AssemblyHashAlgorithm HashAlgId {
			get => hashAlgId;
			set => hashAlgId = value;
		}

		/// <summary>
		/// Gets/sets the <see cref="Version"/> or <c>null</c> if none specified
		/// </summary>
		public Version Version {
			get => version;
			set => version = value;
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes"/>
		/// </summary>
		public AssemblyAttributes Attributes {
			get => flags;
			set => flags = value;
		}

		/// <summary>
		/// Gets/sets the public key or token
		/// </summary>
		public PublicKeyBase PublicKeyOrToken {
			get => publicKeyOrToken;
			set => publicKeyOrToken = value;
		}

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}

		/// <summary>
		/// Gets/sets the culture or <c>null</c> if none specified
		/// </summary>
		public UTF8String Culture {
			get => culture;
			set => culture = value;
		}

		/// <summary>
		/// Gets the full name of the assembly
		/// </summary>
		public string FullName => FullNameToken;

		/// <summary>
		/// Gets the full name of the assembly but use a public key token
		/// </summary>
		public string FullNameToken {
			get {
				var pk = publicKeyOrToken;
				if (pk is PublicKey)
					pk = (pk as PublicKey).Token;
				return Utils.GetAssemblyNameString(name, version, culture, pk, flags);
			}
		}

		/// <summary>
		/// Modify <see cref="Attributes"/> property: <see cref="Attributes"/> =
		/// (<see cref="Attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(AssemblyAttributes andMask, AssemblyAttributes orMask) => Attributes = (Attributes & andMask) | orMask;

		/// <summary>
		/// Set or clear flags in <see cref="Attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, AssemblyAttributes flags) {
			if (set)
				Attributes |= flags;
			else
				Attributes &= ~flags;
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PublicKey"/> bit
		/// </summary>
		public bool HasPublicKey {
			get => (Attributes & AssemblyAttributes.PublicKey) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.PublicKey);
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitecture {
			get => Attributes & AssemblyAttributes.PA_Mask;
			set => ModifyAttributes(~AssemblyAttributes.PA_Mask, value & AssemblyAttributes.PA_Mask);
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitectureFull {
			get => Attributes & AssemblyAttributes.PA_FullMask;
			set => ModifyAttributes(~AssemblyAttributes.PA_FullMask, value & AssemblyAttributes.PA_FullMask);
		}

		/// <summary>
		/// <c>true</c> if unspecified processor architecture
		/// </summary>
		public bool IsProcessorArchitectureNone => (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_None;

		/// <summary>
		/// <c>true</c> if neutral (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureMSIL => (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_MSIL;

		/// <summary>
		/// <c>true</c> if x86 (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureX86 => (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_x86;

		/// <summary>
		/// <c>true</c> if IA-64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureIA64 => (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_IA64;

		/// <summary>
		/// <c>true</c> if x64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureX64 => (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_AMD64;

		/// <summary>
		/// <c>true</c> if ARM (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureARM => (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_ARM;

		/// <summary>
		/// <c>true</c> if eg. reference assembly (not runnable)
		/// </summary>
		public bool IsProcessorArchitectureNoPlatform => (Attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_NoPlatform;

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PA_Specified"/> bit
		/// </summary>
		public bool IsProcessorArchitectureSpecified {
			get => (Attributes & AssemblyAttributes.PA_Specified) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.PA_Specified);
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.EnableJITcompileTracking"/> bit
		/// </summary>
		public bool EnableJITcompileTracking {
			get => (Attributes & AssemblyAttributes.EnableJITcompileTracking) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.EnableJITcompileTracking);
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.DisableJITcompileOptimizer"/> bit
		/// </summary>
		public bool DisableJITcompileOptimizer {
			get => (Attributes & AssemblyAttributes.DisableJITcompileOptimizer) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.DisableJITcompileOptimizer);
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.Retargetable"/> bit
		/// </summary>
		public bool IsRetargetable {
			get => (Attributes & AssemblyAttributes.Retargetable) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.Retargetable);
		}

		/// <summary>
		/// Gets/sets the content type
		/// </summary>
		public AssemblyAttributes ContentType {
			get => Attributes & AssemblyAttributes.ContentType_Mask;
			set => ModifyAttributes(~AssemblyAttributes.ContentType_Mask, value & AssemblyAttributes.ContentType_Mask);
		}

		/// <summary>
		/// <c>true</c> if content type is <c>Default</c>
		/// </summary>
		public bool IsContentTypeDefault => (Attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_Default;

		/// <summary>
		/// <c>true</c> if content type is <c>WindowsRuntime</c>
		/// </summary>
		public bool IsContentTypeWindowsRuntime => (Attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_WindowsRuntime;

		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyNameInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmFullName">An assembly name</param>
		public AssemblyNameInfo(string asmFullName)
			: this(ReflectionTypeNameParser.ParseAssemblyRef(asmFullName)) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asm">The assembly</param>
		public AssemblyNameInfo(IAssembly asm) {
			if (asm is null)
				return;
			var asmDef = asm as AssemblyDef;
			hashAlgId = asmDef is null ? 0 : asmDef.HashAlgorithm;
			version = asm.Version ?? new Version(0, 0, 0, 0);
			flags = asm.Attributes;
			publicKeyOrToken = asm.PublicKeyOrToken;
			name = UTF8String.IsNullOrEmpty(asm.Name) ? UTF8String.Empty : asm.Name;
			culture = UTF8String.IsNullOrEmpty(asm.Culture) ? UTF8String.Empty : asm.Culture;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmName">Assembly name info</param>
		public AssemblyNameInfo(AssemblyName asmName) {
			if (asmName is null)
				return;
			hashAlgId = (AssemblyHashAlgorithm)asmName.HashAlgorithm;
			version = asmName.Version ?? new Version(0, 0, 0, 0);
			flags = (AssemblyAttributes)asmName.Flags;
			publicKeyOrToken = (PublicKeyBase)PublicKeyBase.CreatePublicKey(asmName.GetPublicKey()) ??
							PublicKeyBase.CreatePublicKeyToken(asmName.GetPublicKeyToken());
			name = asmName.Name ?? string.Empty;
			culture = asmName.CultureInfo is not null && asmName.CultureInfo.Name is not null ? asmName.CultureInfo.Name : string.Empty;
		}

		/// <inhertidoc/>
		public override string ToString() => FullName;
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the AssemblyRef table
	/// </summary>
	public abstract class AssemblyRef : IHasCustomAttribute, IImplementation, IResolutionScope, IHasCustomDebugInformation, IAssembly, IScope {
		/// <summary>
		/// An assembly ref that can be used to indicate that it references the current assembly
		/// when the current assembly is not known (eg. a type string without any assembly info
		/// when it references a type in the current assembly).
		/// </summary>
		public static readonly AssemblyRef CurrentAssembly = new AssemblyRefUser("<<<CURRENT_ASSEMBLY>>>");

		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.AssemblyRef, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 15;

		/// <inheritdoc/>
		public int ImplementationTag => 1;

		/// <inheritdoc/>
		public int ResolutionScopeTag => 2;

		/// <inheritdoc/>
		public ScopeType ScopeType => ScopeType.AssemblyRef;

		/// <inheritdoc/>
		public string ScopeName => FullName;

		/// <summary>
		/// From columns AssemblyRef.MajorVersion, AssemblyRef.MinorVersion,
		/// AssemblyRef.BuildNumber, AssemblyRef.RevisionNumber
		/// </summary>
		/// <exception cref="ArgumentNullException">If <paramref name="value"/> is <c>null</c></exception>
		public Version Version {
			get => version;
			set => version = value ?? throw new ArgumentNullException(nameof(value));
		}
		/// <summary/>
		protected Version version;

		/// <summary>
		/// From column AssemblyRef.Flags
		/// </summary>
		public AssemblyAttributes Attributes {
			get => (AssemblyAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column AssemblyRef.PublicKeyOrToken
		/// </summary>
		/// <exception cref="ArgumentNullException">If <paramref name="value"/> is <c>null</c></exception>
		public PublicKeyBase PublicKeyOrToken {
			get => publicKeyOrToken;
			set => publicKeyOrToken = value ?? throw new ArgumentNullException(nameof(value));
		}
		/// <summary/>
		protected PublicKeyBase publicKeyOrToken;

		/// <summary>
		/// From column AssemblyRef.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column AssemblyRef.Locale
		/// </summary>
		public UTF8String Culture {
			get => culture;
			set => culture = value;
		}
		/// <summary>Culture</summary>
		protected UTF8String culture;

		/// <summary>
		/// From column AssemblyRef.HashValue
		/// </summary>
		public byte[] Hash {
			get => hashValue;
			set => hashValue = value;
		}
		/// <summary/>
		protected byte[] hashValue;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 15;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <inheritdoc/>
		public string FullName => FullNameToken;

		/// <summary>
		/// Same as <see cref="FullName"/>, except that it uses the <c>PublicKey</c> if available.
		/// </summary>
		public string RealFullName => Utils.GetAssemblyNameString(name, version, culture, publicKeyOrToken, Attributes);

		/// <summary>
		/// Gets the full name of the assembly but use a public key token
		/// </summary>
		public string FullNameToken => Utils.GetAssemblyNameString(name, version, culture, PublicKeyBase.ToPublicKeyToken(publicKeyOrToken), Attributes);

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(AssemblyAttributes andMask, AssemblyAttributes orMask) =>
			attributes = (attributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, AssemblyAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PublicKey"/> bit
		/// </summary>
		public bool HasPublicKey {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.PublicKey) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.PublicKey);
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitecture {
			get => (AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask;
			set => ModifyAttributes(~AssemblyAttributes.PA_Mask, value & AssemblyAttributes.PA_Mask);
		}

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		public AssemblyAttributes ProcessorArchitectureFull {
			get => (AssemblyAttributes)attributes & AssemblyAttributes.PA_FullMask;
			set => ModifyAttributes(~AssemblyAttributes.PA_FullMask, value & AssemblyAttributes.PA_FullMask);
		}

		/// <summary>
		/// <c>true</c> if unspecified processor architecture
		/// </summary>
		public bool IsProcessorArchitectureNone => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_None;

		/// <summary>
		/// <c>true</c> if neutral (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureMSIL => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_MSIL;

		/// <summary>
		/// <c>true</c> if x86 (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureX86 => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_x86;

		/// <summary>
		/// <c>true</c> if IA-64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureIA64 => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_IA64;

		/// <summary>
		/// <c>true</c> if x64 (PE32+) architecture
		/// </summary>
		public bool IsProcessorArchitectureX64 => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_AMD64;

		/// <summary>
		/// <c>true</c> if ARM (PE32) architecture
		/// </summary>
		public bool IsProcessorArchitectureARM => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_ARM;

		/// <summary>
		/// <c>true</c> if eg. reference assembly (not runnable)
		/// </summary>
		public bool IsProcessorArchitectureNoPlatform => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Mask) == AssemblyAttributes.PA_NoPlatform;

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PA_Specified"/> bit
		/// </summary>
		public bool IsProcessorArchitectureSpecified {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.PA_Specified) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.PA_Specified);
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.EnableJITcompileTracking"/> bit
		/// </summary>
		public bool EnableJITcompileTracking {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.EnableJITcompileTracking) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.EnableJITcompileTracking);
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.DisableJITcompileOptimizer"/> bit
		/// </summary>
		public bool DisableJITcompileOptimizer {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.DisableJITcompileOptimizer) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.DisableJITcompileOptimizer);
		}

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.Retargetable"/> bit
		/// </summary>
		public bool IsRetargetable {
			get => ((AssemblyAttributes)attributes & AssemblyAttributes.Retargetable) != 0;
			set => ModifyAttributes(value, AssemblyAttributes.Retargetable);
		}

		/// <summary>
		/// Gets/sets the content type
		/// </summary>
		public AssemblyAttributes ContentType {
			get => (AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask;
			set => ModifyAttributes(~AssemblyAttributes.ContentType_Mask, value & AssemblyAttributes.ContentType_Mask);
		}

		/// <summary>
		/// <c>true</c> if content type is <c>Default</c>
		/// </summary>
		public bool IsContentTypeDefault => ((AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_Default;

		/// <summary>
		/// <c>true</c> if content type is <c>WindowsRuntime</c>
		/// </summary>
		public bool IsContentTypeWindowsRuntime => ((AssemblyAttributes)attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_WindowsRuntime;

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// An AssemblyRef row created by the user and not present in the original .NET file
	/// </summary>
	public class AssemblyRefUser : AssemblyRef {
		/// <summary>
		/// Creates a reference to CLR 1.0's mscorlib
		/// </summary>
		public static AssemblyRefUser CreateMscorlibReferenceCLR10() => new AssemblyRefUser("mscorlib", new Version(1, 0, 3300, 0), new PublicKeyToken("b77a5c561934e089"));

		/// <summary>
		/// Creates a reference to CLR 1.1's mscorlib
		/// </summary>
		public static AssemblyRefUser CreateMscorlibReferenceCLR11() => new AssemblyRefUser("mscorlib", new Version(1, 0, 5000, 0), new PublicKeyToken("b77a5c561934e089"));

		/// <summary>
		/// Creates a reference to CLR 2.0's mscorlib
		/// </summary>
		public static AssemblyRefUser CreateMscorlibReferenceCLR20() => new AssemblyRefUser("mscorlib", new Version(2, 0, 0, 0), new PublicKeyToken("b77a5c561934e089"));

		/// <summary>
		/// Creates a reference to CLR 4.0's mscorlib
		/// </summary>
		public static AssemblyRefUser CreateMscorlibReferenceCLR40() => new AssemblyRefUser("mscorlib", new Version(4, 0, 0, 0), new PublicKeyToken("b77a5c561934e089"));

		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyRefUser()
			: this(UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyRefUser(UTF8String name)
			: this(name, new Version(0, 0, 0, 0)) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyRefUser(UTF8String name, Version version)
			: this(name, version, new PublicKey()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <param name="publicKey">Public key or public key token</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyRefUser(UTF8String name, Version version, PublicKeyBase publicKey)
			: this(name, version, publicKey, UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Simple name</param>
		/// <param name="version">Version</param>
		/// <param name="publicKey">Public key or public key token</param>
		/// <param name="locale">Locale</param>
		/// <exception cref="ArgumentNullException">If any of the args is invalid</exception>
		public AssemblyRefUser(UTF8String name, Version version, PublicKeyBase publicKey, UTF8String locale) {
			if (name is null)
				throw new ArgumentNullException(nameof(name));
			if (locale is null)
				throw new ArgumentNullException(nameof(locale));
			this.name = name;
			this.version = version ?? throw new ArgumentNullException(nameof(version));
			publicKeyOrToken = publicKey;
			culture = locale;
			attributes = (int)(publicKey is PublicKey ? AssemblyAttributes.PublicKey : AssemblyAttributes.None);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="asmName">Assembly name info</param>
		/// <exception cref="ArgumentNullException">If <paramref name="asmName"/> is <c>null</c></exception>
		public AssemblyRefUser(AssemblyName asmName)
			: this(new AssemblyNameInfo(asmName)) => attributes = (int)asmName.Flags;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="assembly">Assembly</param>
		public AssemblyRefUser(IAssembly assembly) {
			if (assembly is null)
				throw new ArgumentNullException("asmName");

			version = assembly.Version ?? new Version(0, 0, 0, 0);
			publicKeyOrToken = assembly.PublicKeyOrToken;
			name = UTF8String.IsNullOrEmpty(assembly.Name) ? UTF8String.Empty : assembly.Name;
			culture = assembly.Culture;
			attributes = (int)((publicKeyOrToken is PublicKey ? AssemblyAttributes.PublicKey : AssemblyAttributes.None) | assembly.ContentType);
		}
	}

	/// <summary>
	/// Created from a row in the AssemblyRef table
	/// </summary>
	sealed class AssemblyRefMD : AssemblyRef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.AssemblyRef, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>AssemblyRef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public AssemblyRefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.AssemblyRefTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"AssemblyRef rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadAssemblyRefRow(origRid, out var row);
			Debug.Assert(b);
			version = new Version(row.MajorVersion, row.MinorVersion, row.BuildNumber, row.RevisionNumber);
			attributes = (int)row.Flags;
			var pkData = readerModule.BlobStream.Read(row.PublicKeyOrToken);
			if ((attributes & (uint)AssemblyAttributes.PublicKey) != 0)
				publicKeyOrToken = new PublicKey(pkData);
			else
				publicKeyOrToken = new PublicKeyToken(pkData);
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			culture = readerModule.StringsStream.ReadNoNull(row.Locale);
			hashValue = readerModule.BlobStream.Read(row.HashValue);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Resolves assemblies
	/// </summary>
	public class AssemblyResolver : IAssemblyResolver {
		static readonly ModuleDef nullModule = new ModuleDefUser();

		// DLL files are searched before EXE files
		static readonly string[] assemblyExtensions = new string[] { ".dll", ".exe" };
		static readonly string[] winMDAssemblyExtensions = new string[] { ".winmd" };

		static readonly List<GacInfo> gacInfos;
		static readonly string[] extraMonoPaths;
		static readonly string[] monoVerDirs = new string[] {
			// The "-api" dirs are reference assembly dirs.
			"4.5", @"4.5\Facades", "4.5-api", @"4.5-api\Facades", "4.0", "4.0-api",
			"3.5", "3.5-api", "3.0", "3.0-api", "2.0", "2.0-api",
			"1.1", "1.0",
		};

		ModuleContext defaultModuleContext;
		readonly Dictionary<ModuleDef, List<string>> moduleSearchPaths = new Dictionary<ModuleDef, List<string>>();
		readonly Dictionary<string, AssemblyDef> cachedAssemblies = new Dictionary<string, AssemblyDef>(StringComparer.OrdinalIgnoreCase);
		readonly List<string> preSearchPaths = new List<string>();
		readonly List<string> postSearchPaths = new List<string>();
		bool findExactMatch;
		bool enableFrameworkRedirect;
		bool enableTypeDefCache = true;
		bool useGac = true;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		sealed class GacInfo {
			public readonly int Version;
			public readonly string Path;
			public readonly string Prefix;
			public readonly string[] SubDirs;

			public GacInfo(int version, string prefix, string path, string[] subDirs) {
				Version = version;
				Prefix = prefix;
				Path = path;
				SubDirs = subDirs;
			}
		}

		static AssemblyResolver() {
			gacInfos = new List<GacInfo>();

			if (Type.GetType("Mono.Runtime") is not null) {
				var dirs = new Dictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
				var extraMonoPathsList = new List<string>();
				foreach (var prefix in FindMonoPrefixes()) {
					var dir = Path.Combine(Path.Combine(Path.Combine(prefix, "lib"), "mono"), "gac");
					if (dirs.ContainsKey(dir))
						continue;
					dirs[dir] = true;

					if (Directory.Exists(dir)) {
						gacInfos.Add(new GacInfo(-1, "", Path.GetDirectoryName(dir), new string[] {
							Path.GetFileName(dir)
						}));
					}

					dir = Path.GetDirectoryName(dir);
					foreach (var verDir in monoVerDirs) {
						var dir2 = dir;
						foreach (var d in verDir.Split(new char[] { '\\' }))
							dir2 = Path.Combine(dir2, d);
						if (Directory.Exists(dir2))
							extraMonoPathsList.Add(dir2);
					}
				}

				var paths = Environment.GetEnvironmentVariable("MONO_PATH");
				if (paths is not null) {
					foreach (var tmp in paths.Split(Path.PathSeparator)) {
						var path = tmp.Trim();
						if (path != string.Empty && Directory.Exists(path))
							extraMonoPathsList.Add(path);
					}
				}
				extraMonoPaths = extraMonoPathsList.ToArray();
			}
			else {
				var windir = Environment.GetEnvironmentVariable("WINDIR");
				if (!string.IsNullOrEmpty(windir)) {
					string path;

					// .NET Framework 1.x and 2.x
					path = Path.Combine(windir, "assembly");
					if (Directory.Exists(path)) {
						gacInfos.Add(new GacInfo(2, "", path, new string[] {
							"GAC_32", "GAC_64", "GAC_MSIL", "GAC"
						}));
					}

					// .NET Framework 4.x
					path = Path.Combine(Path.Combine(windir, "Microsoft.NET"), "assembly");
					if (Directory.Exists(path)) {
						gacInfos.Add(new GacInfo(4, "v4.0_", path, new string[] {
							"GAC_32", "GAC_64", "GAC_MSIL"
						}));
					}
				}
			}
		}

		static string GetCurrentMonoPrefix() {
			var path = typeof(object).Module.FullyQualifiedName;
			for (int i = 0; i < 4; i++)
				path = Path.GetDirectoryName(path);
			return path;
		}

		static IEnumerable<string> FindMonoPrefixes() {
			yield return GetCurrentMonoPrefix();

			var prefixes = Environment.GetEnvironmentVariable("MONO_GAC_PREFIX");
			if (!string.IsNullOrEmpty(prefixes)) {
				foreach (var tmp in prefixes.Split(Path.PathSeparator)) {
					var prefix = tmp.Trim();
					if (prefix != string.Empty)
						yield return prefix;
				}
			}
		}

		/// <summary>
		/// Gets/sets the default <see cref="ModuleContext"/>
		/// </summary>
		public ModuleContext DefaultModuleContext {
			get => defaultModuleContext;
			set => defaultModuleContext = value;
		}

		/// <summary>
		/// <c>true</c> if <see cref="Resolve"/> should find an assembly that matches exactly.
		/// <c>false</c> if it first tries to match exactly, and if that fails, it picks an
		/// assembly that is closest to the requested assembly.
		/// </summary>
		public bool FindExactMatch {
			get => findExactMatch;
			set => findExactMatch = value;
		}

		/// <summary>
		/// <c>true</c> if resolved .NET framework assemblies can be redirected to the source
		/// module's framework assembly version. Eg. if a resolved .NET Framework 3.5 assembly can be
		/// redirected to a .NET Framework 4.0 assembly if the source module is a .NET Framework 4.0 assembly. This is
		/// ignored if <see cref="FindExactMatch"/> is <c>true</c>.
		/// </summary>
		public bool EnableFrameworkRedirect {
			get => enableFrameworkRedirect;
			set => enableFrameworkRedirect = value;
		}

		/// <summary>
		/// If <c>true</c>, all modules in newly resolved assemblies will have their
		/// <see cref="ModuleDef.EnableTypeDefFindCache"/> property set to <c>true</c>. This is
		/// enabled by default since these modules shouldn't be modified by the user.
		/// </summary>
		public bool EnableTypeDefCache {
			get => enableTypeDefCache;
			set => enableTypeDefCache = value;
		}

		/// <summary>
		/// true to search the Global Assembly Cache. Default value is true.
		/// </summary>
		public bool UseGAC {
			get => useGac;
			set => useGac = value;
		}

		/// <summary>
		/// Gets paths searched before trying the standard locations
		/// </summary>
		public IList<string> PreSearchPaths => preSearchPaths;

		/// <summary>
		/// Gets paths searched after trying the standard locations
		/// </summary>
		public IList<string> PostSearchPaths => postSearchPaths;

		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyResolver()
			: this(null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="defaultModuleContext">Module context for all resolved assemblies</param>
		public AssemblyResolver(ModuleContext defaultModuleContext) {
			this.defaultModuleContext = defaultModuleContext;
			enableFrameworkRedirect = true;
		}

		/// <inheritdoc/>
		public AssemblyDef Resolve(IAssembly assembly, ModuleDef sourceModule) {
			if (assembly is null)
				return null;

			if (EnableFrameworkRedirect && !FindExactMatch)
				FrameworkRedirect.ApplyFrameworkRedirect(ref assembly, sourceModule);

#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var resolvedAssembly = Resolve2(assembly, sourceModule);
			if (resolvedAssembly is null) {
				string asmName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
				string asmNameTrimmed = asmName.Trim();
				if (asmName != asmNameTrimmed) {
					assembly = new AssemblyNameInfo {
						Name = asmNameTrimmed,
						Version = assembly.Version,
						PublicKeyOrToken = assembly.PublicKeyOrToken,
						Culture = assembly.Culture,
					};
					resolvedAssembly = Resolve2(assembly, sourceModule);
				}
			}

			if (resolvedAssembly is null) {
				// Make sure we don't search for this assembly again. This speeds up callers who
				// keep asking for this assembly when trying to resolve many different TypeRefs
				cachedAssemblies[GetAssemblyNameKey(assembly)] = null;
				return null;
			}

			var key1 = GetAssemblyNameKey(resolvedAssembly);
			var key2 = GetAssemblyNameKey(assembly);
			cachedAssemblies.TryGetValue(key1, out var asm1);
			cachedAssemblies.TryGetValue(key2, out var asm2);

			if (asm1 != resolvedAssembly && asm2 != resolvedAssembly) {
				// This assembly was just resolved
				if (enableTypeDefCache) {
					var modules = resolvedAssembly.Modules;
					int count = modules.Count;
					for (int i = 0; i < count; i++) {
						var module = modules[i];
						if (module is not null)
							module.EnableTypeDefFindCache = true;
					}
				}
			}

			bool inserted = false;
			if (!cachedAssemblies.ContainsKey(key1)) {
				cachedAssemblies.Add(key1, resolvedAssembly);
				inserted = true;
			}
			if (!cachedAssemblies.ContainsKey(key2)) {
				cachedAssemblies.Add(key2, resolvedAssembly);
				inserted = true;
			}
			if (inserted || asm1 == resolvedAssembly || asm2 == resolvedAssembly)
				return resolvedAssembly;

			// Dupe assembly. Don't insert it.
			var dupeModule = resolvedAssembly.ManifestModule;
			if (dupeModule is not null)
				dupeModule.Dispose();
			return asm1 ?? asm2;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Add a module's assembly to the assembly cache
		/// </summary>
		/// <param name="module">The module whose assembly should be cached</param>
		/// <returns><c>true</c> if <paramref name="module"/>'s assembly is cached, <c>false</c>
		/// if it's not cached because some other assembly with the exact same full name has
		/// already been cached or if <paramref name="module"/> or its assembly is <c>null</c>.</returns>
		public bool AddToCache(ModuleDef module) => module is not null && AddToCache(module.Assembly);

		/// <summary>
		/// Add an assembly to the assembly cache
		/// </summary>
		/// <param name="asm">The assembly</param>
		/// <returns><c>true</c> if <paramref name="asm"/> is cached, <c>false</c> if it's not
		/// cached because some other assembly with the exact same full name has already been
		/// cached or if <paramref name="asm"/> is <c>null</c>.</returns>
		public bool AddToCache(AssemblyDef asm) {
			if (asm is null)
				return false;
			var asmKey = GetAssemblyNameKey(asm);
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (cachedAssemblies.TryGetValue(asmKey, out var cachedAsm) && cachedAsm is not null)
				return asm == cachedAsm;
			cachedAssemblies[asmKey] = asm;
			return true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Removes a module's assembly from the cache
		/// </summary>
		/// <param name="module">The module</param>
		/// <returns><c>true</c> if its assembly was removed, <c>false</c> if it wasn't removed
		/// since it wasn't in the cache, it has no assembly, or <paramref name="module"/> was
		/// <c>null</c></returns>
		public bool Remove(ModuleDef module) => module is not null && Remove(module.Assembly);

		/// <summary>
		/// Removes the assembly from the cache
		/// </summary>
		/// <param name="asm">The assembly</param>
		/// <returns><c>true</c> if it was removed, <c>false</c> if it wasn't removed since it
		/// wasn't in the cache or if <paramref name="asm"/> was <c>null</c></returns>
		public bool Remove(AssemblyDef asm) {
			if (asm is null)
				return false;
			var asmKey = GetAssemblyNameKey(asm);
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return cachedAssemblies.Remove(asmKey);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Clears the cache and calls <see cref="IDisposable.Dispose()"/> on each cached module.
		/// Use <see cref="Remove(AssemblyDef)"/> to remove any assemblies you added yourself
		/// using <see cref="AddToCache(AssemblyDef)"/> before calling this method if you don't want
		/// them disposed.
		/// </summary>
		public void Clear() {
			List<AssemblyDef> asms;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			asms = new List<AssemblyDef>(cachedAssemblies.Values);
			cachedAssemblies.Clear();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
			foreach (var asm in asms) {
				if (asm is null)
					continue;
				foreach (var mod in asm.Modules)
					mod.Dispose();
			}
		}

		/// <summary>
		/// Gets the cached assemblies in this resolver.
		/// </summary>
		/// <returns>The cached assemblies.</returns>
		public IEnumerable<AssemblyDef> GetCachedAssemblies() {
			AssemblyDef[] assemblies;
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			assemblies = cachedAssemblies.Values.ToArray();
#if THREAD_SAFE
			} finally { theLock.ExitReadLock(); }
#endif
			return assemblies;
		}

		static string GetAssemblyNameKey(IAssembly asmName) {
			// Make sure the name contains PublicKeyToken= and not PublicKey=
			return asmName.FullNameToken;
		}

		AssemblyDef Resolve2(IAssembly assembly, ModuleDef sourceModule) {
			if (cachedAssemblies.TryGetValue(GetAssemblyNameKey(assembly), out var resolvedAssembly))
				return resolvedAssembly;

			var moduleContext = defaultModuleContext;
			if (moduleContext is null && sourceModule is not null)
				moduleContext = sourceModule.Context;

			resolvedAssembly = FindExactAssembly(assembly, PreFindAssemblies(assembly, sourceModule, true), moduleContext) ??
					FindExactAssembly(assembly, FindAssemblies(assembly, sourceModule, true), moduleContext) ??
					FindExactAssembly(assembly, PostFindAssemblies(assembly, sourceModule, true), moduleContext);
			if (resolvedAssembly is not null)
				return resolvedAssembly;

			if (!findExactMatch) {
				resolvedAssembly = FindClosestAssembly(assembly);
				resolvedAssembly = FindClosestAssembly(assembly, resolvedAssembly, PreFindAssemblies(assembly, sourceModule, false), moduleContext);
				resolvedAssembly = FindClosestAssembly(assembly, resolvedAssembly, FindAssemblies(assembly, sourceModule, false), moduleContext);
				resolvedAssembly = FindClosestAssembly(assembly, resolvedAssembly, PostFindAssemblies(assembly, sourceModule, false), moduleContext);
			}

			return resolvedAssembly;
		}

		/// <summary>
		/// Finds an assembly that exactly matches the requested assembly
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <param name="paths">Search paths or <c>null</c> if none</param>
		/// <param name="moduleContext">Module context</param>
		/// <returns>An <see cref="AssemblyDef"/> instance or <c>null</c> if an exact match
		/// couldn't be found.</returns>
		AssemblyDef FindExactAssembly(IAssembly assembly, IEnumerable<string> paths, ModuleContext moduleContext) {
			if (paths is null)
				return null;
			var asmComparer = AssemblyNameComparer.CompareAll;
			foreach (var path in paths) {
				ModuleDefMD mod = null;
				try {
					mod = ModuleDefMD.Load(path, moduleContext);
					var asm = mod.Assembly;
					if (asm is not null && asmComparer.Equals(assembly, asm)) {
						mod = null;
						return asm;
					}
				}
				catch {
				}
				finally {
					if (mod is not null)
						mod.Dispose();
				}
			}
			return null;
		}

		/// <summary>
		/// Finds the closest assembly from the already cached assemblies
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <returns>The closest <see cref="AssemblyDef"/> or <c>null</c> if none found</returns>
		AssemblyDef FindClosestAssembly(IAssembly assembly) {
			AssemblyDef closest = null;
			var asmComparer = AssemblyNameComparer.CompareAll;
			foreach (var kv in cachedAssemblies) {
				var asm = kv.Value;
				if (asm is null)
					continue;
				if (asmComparer.CompareClosest(assembly, closest, asm) == 1)
					closest = asm;
			}
			return closest;
		}

		AssemblyDef FindClosestAssembly(IAssembly assembly, AssemblyDef closest, IEnumerable<string> paths, ModuleContext moduleContext) {
			if (paths is null)
				return closest;
			var asmComparer = AssemblyNameComparer.CompareAll;
			foreach (var path in paths) {
				ModuleDefMD mod = null;
				try {
					mod = ModuleDefMD.Load(path, moduleContext);
					var asm = mod.Assembly;
					if (asm is not null && asmComparer.CompareClosest(assembly, closest, asm) == 1) {
						if (!IsCached(closest) && closest is not null) {
							var closeMod = closest.ManifestModule;
							if (closeMod is not null)
								closeMod.Dispose();
						}
						closest = asm;
						mod = null;
					}
				}
				catch {
				}
				finally {
					if (mod is not null)
						mod.Dispose();
				}
			}

			return closest;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="asm"/> is inserted in <see cref="cachedAssemblies"/>
		/// </summary>
		/// <param name="asm">Assembly to check</param>
		bool IsCached(AssemblyDef asm) {
			if (asm is null)
				return false;
			return cachedAssemblies.TryGetValue(GetAssemblyNameKey(asm), out var cachedAsm) &&
					cachedAsm == asm;
		}

		IEnumerable<string> FindAssemblies2(IAssembly assembly, IEnumerable<string> paths) {
			if (paths is not null) {
				var asmSimpleName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
				var exts = assembly.IsContentTypeWindowsRuntime ? winMDAssemblyExtensions : assemblyExtensions;
				foreach (var ext in exts) {
					foreach (var path in paths) {
						string fullPath;
						try {
							fullPath = Path.Combine(path, asmSimpleName + ext);
						}
						catch (ArgumentException) {
							// Invalid path chars
							yield break;
						}
						if (File.Exists(fullPath))
							yield return fullPath;
					}
				}
			}
		}

		/// <summary>
		/// Called before <see cref="FindAssemblies"/>
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <param name="matchExactly">We're trying to find an exact match</param>
		/// <returns><c>null</c> or an enumerable of full paths to try</returns>
		protected virtual IEnumerable<string> PreFindAssemblies(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			foreach (var path in FindAssemblies2(assembly, preSearchPaths))
				yield return path;
		}

		/// <summary>
		/// Called after <see cref="FindAssemblies"/> (if it fails)
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <param name="matchExactly">We're trying to find an exact match</param>
		/// <returns><c>null</c> or an enumerable of full paths to try</returns>
		protected virtual IEnumerable<string> PostFindAssemblies(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			foreach (var path in FindAssemblies2(assembly, postSearchPaths))
				yield return path;
		}

		/// <summary>
		/// Called after <see cref="PreFindAssemblies"/> (if it fails)
		/// </summary>
		/// <param name="assembly">Assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <param name="matchExactly">We're trying to find an exact match</param>
		/// <returns><c>null</c> or an enumerable of full paths to try</returns>
		protected virtual IEnumerable<string> FindAssemblies(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			if (assembly.IsContentTypeWindowsRuntime) {
				string path;
				try {
					path = Path.Combine(Path.Combine(Environment.SystemDirectory, "WinMetadata"), assembly.Name + ".winmd");
				}
				catch (ArgumentException) {
					// Invalid path chars
					path = null;
				}
				if (File.Exists(path))
					yield return path;
			}
			else {
				if (UseGAC) {
					foreach (var path in FindAssembliesGac(assembly, sourceModule, matchExactly))
						yield return path;
				}
			}
			foreach (var path in FindAssembliesModuleSearchPaths(assembly, sourceModule, matchExactly))
				yield return path;
		}

		IEnumerable<string> FindAssembliesGac(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			if (matchExactly)
				return FindAssembliesGacExactly(assembly, sourceModule);
			return FindAssembliesGacAny(assembly, sourceModule);
		}

		IEnumerable<GacInfo> GetGacInfos(ModuleDef sourceModule) {
			int version = sourceModule is null ? int.MinValue : sourceModule.IsClr40 ? 4 : 2;
			// Try the correct GAC first (eg. GAC4 if it's a .NET Framework 4 assembly)
			foreach (var gacInfo in gacInfos) {
				if (gacInfo.Version == version)
					yield return gacInfo;
			}
			foreach (var gacInfo in gacInfos) {
				if (gacInfo.Version != version)
					yield return gacInfo;
			}
		}

		IEnumerable<string> FindAssembliesGacExactly(IAssembly assembly, ModuleDef sourceModule) {
			foreach (var gacInfo in GetGacInfos(sourceModule)) {
				foreach (var path in FindAssembliesGacExactly(gacInfo, assembly, sourceModule))
					yield return path;
			}
			if (extraMonoPaths is not null) {
				foreach (var path in GetExtraMonoPaths(assembly, sourceModule))
					yield return path;
			}
		}

		static IEnumerable<string> GetExtraMonoPaths(IAssembly assembly, ModuleDef sourceModule) {
			if (extraMonoPaths is not null) {
				foreach (var dir in extraMonoPaths) {
					string file;
					try {
						file = Path.Combine(dir, assembly.Name + ".dll");
					}
					catch (ArgumentException) {
						// Invalid path chars
						break;
					}
					if (File.Exists(file))
						yield return file;
				}
			}
		}

		IEnumerable<string> FindAssembliesGacExactly(GacInfo gacInfo, IAssembly assembly, ModuleDef sourceModule) {
			var pkt = PublicKeyBase.ToPublicKeyToken(assembly.PublicKeyOrToken);
			if (gacInfo is not null && pkt is not null) {
				string pktString = pkt.ToString();
				string verString = Utils.CreateVersionWithNoUndefinedValues(assembly.Version).ToString();
				var cultureString = UTF8String.ToSystemStringOrEmpty(assembly.Culture);
				if (cultureString.Equals("neutral", StringComparison.OrdinalIgnoreCase))
					cultureString = string.Empty;
				var asmSimpleName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
				foreach (var subDir in gacInfo.SubDirs) {
					var baseDir = Path.Combine(gacInfo.Path, subDir);
					try {
						baseDir = Path.Combine(baseDir, asmSimpleName);
					}
					catch (ArgumentException) {
						// Invalid path chars
						break;
					}
					baseDir = Path.Combine(baseDir, $"{gacInfo.Prefix}{verString}_{cultureString}_{pktString}");
					var pathName = Path.Combine(baseDir, asmSimpleName + ".dll");
					if (File.Exists(pathName))
						yield return pathName;
				}
			}
		}

		IEnumerable<string> FindAssembliesGacAny(IAssembly assembly, ModuleDef sourceModule) {
			foreach (var gacInfo in GetGacInfos(sourceModule)) {
				foreach (var path in FindAssembliesGacAny(gacInfo, assembly, sourceModule))
					yield return path;
			}
			if (extraMonoPaths is not null) {
				foreach (var path in GetExtraMonoPaths(assembly, sourceModule))
					yield return path;
			}
		}

		IEnumerable<string> FindAssembliesGacAny(GacInfo gacInfo, IAssembly assembly, ModuleDef sourceModule) {
			if (gacInfo is not null) {
				var asmSimpleName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
				foreach (var subDir in gacInfo.SubDirs) {
					var baseDir = Path.Combine(gacInfo.Path, subDir);
					try {
						baseDir = Path.Combine(baseDir, asmSimpleName);
					}
					catch (ArgumentException) {
						// Invalid path chars
						break;
					}
					foreach (var dir in GetDirs(baseDir)) {
						var pathName = Path.Combine(dir, asmSimpleName + ".dll");
						if (File.Exists(pathName))
							yield return pathName;
					}
				}
			}
		}

		IEnumerable<string> GetDirs(string baseDir) {
			if (!Directory.Exists(baseDir))
				return Array2.Empty<string>();
			var dirs = new List<string>();
			try {
				foreach (var di in new DirectoryInfo(baseDir).GetDirectories())
					dirs.Add(di.FullName);
			}
			catch {
			}
			return dirs;
		}

		IEnumerable<string> FindAssembliesModuleSearchPaths(IAssembly assembly, ModuleDef sourceModule, bool matchExactly) {
			string asmSimpleName = UTF8String.ToSystemStringOrEmpty(assembly.Name);
			var searchPaths = GetSearchPaths(sourceModule);
			var exts = assembly.IsContentTypeWindowsRuntime ? winMDAssemblyExtensions : assemblyExtensions;
			foreach (var ext in exts) {
				foreach (var path in searchPaths) {
					for (int i = 0; i < 2; i++) {
						string path2;
						try {
							if (i == 0)
								path2 = Path.Combine(path, asmSimpleName + ext);
							else
								path2 = Path.Combine(Path.Combine(path, asmSimpleName), asmSimpleName + ext);
						}
						catch (ArgumentException) {
							// Invalid path chars
							yield break;
						}
						if (File.Exists(path2))
							yield return path2;
					}
				}
			}
		}

		/// <summary>
		/// Gets all search paths to use for this module
		/// </summary>
		/// <param name="module">The module or <c>null</c> if unknown</param>
		/// <returns>A list of all search paths to use for this module</returns>
		IEnumerable<string> GetSearchPaths(ModuleDef module) {
			var keyModule = module;
			if (keyModule is null)
				keyModule = nullModule;
			if (moduleSearchPaths.TryGetValue(keyModule, out var searchPaths))
				return searchPaths;
			moduleSearchPaths[keyModule] = searchPaths = new List<string>(GetModuleSearchPaths(module));
			return searchPaths;
		}

		/// <summary>
		/// Gets all module search paths. This is usually empty unless its assembly has
		/// a <c>.config</c> file specifying any additional private search paths in a
		/// &lt;probing/&gt; element.
		/// </summary>
		/// <param name="module">The module or <c>null</c> if unknown</param>
		/// <returns>A list of search paths</returns>
		protected virtual IEnumerable<string> GetModuleSearchPaths(ModuleDef module) => GetModulePrivateSearchPaths(module);

		/// <summary>
		/// Gets all private assembly search paths as found in the module's <c>.config</c> file.
		/// </summary>
		/// <param name="module">The module or <c>null</c> if unknown</param>
		/// <returns>A list of search paths</returns>
		protected IEnumerable<string> GetModulePrivateSearchPaths(ModuleDef module) {
			if (module is null)
				return Array2.Empty<string>();
			var asm = module.Assembly;
			if (asm is null)
				return Array2.Empty<string>();
			module = asm.ManifestModule;
			if (module is null)
				return Array2.Empty<string>();  // Should never happen

			string baseDir = null;
			try {
				var imageName = module.Location;
				if (imageName != string.Empty) {
					baseDir = Directory.GetParent(imageName).FullName;
					var configName = imageName + ".config";
					if (File.Exists(configName))
						return GetPrivatePaths(baseDir, configName);
				}
			}
			catch {
			}
			if (baseDir is not null)
				return new List<string> { baseDir };
			return Array2.Empty<string>();
		}

		IEnumerable<string> GetPrivatePaths(string baseDir, string configFileName) {
			var searchPaths = new List<string>();

			try {
				var dirName = Path.GetDirectoryName(Path.GetFullPath(configFileName));
				searchPaths.Add(dirName);

				using (var xmlStream = new FileStream(configFileName, FileMode.Open, FileAccess.Read, FileShare.Read)) {
					var doc = new XmlDocument();
					doc.Load(XmlReader.Create(xmlStream));
					foreach (var tmp in doc.GetElementsByTagName("probing")) {
						var probingElem = tmp as XmlElement;
						if (probingElem is null)
							continue;
						var privatePath = probingElem.GetAttribute("privatePath");
						if (string.IsNullOrEmpty(privatePath))
							continue;
						foreach (var tmp2 in privatePath.Split(';')) {
							var path = tmp2.Trim();
							if (path == "")
								continue;
							var newPath = Path.GetFullPath(Path.Combine(dirName, path.Replace('\\', Path.DirectorySeparatorChar)));
							if (Directory.Exists(newPath) && newPath.StartsWith(baseDir + Path.DirectorySeparatorChar))
								searchPaths.Add(newPath);
						}
					}
				}
			}
			catch (ArgumentException) {
			}
			catch (IOException) {
			}
			catch (XmlException) {
			}

			return searchPaths;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// See CorHdr.h/CorCallingConvention
	/// </summary>
	[Flags]
	public enum CallingConvention : byte {
		/// <summary>The managed calling convention</summary>
		Default			= 0x0,
		/// <summary/>
		C				= 0x1,
		/// <summary/>
		StdCall			= 0x2,
		/// <summary/>
		ThisCall		= 0x3,
		/// <summary/>
		FastCall		= 0x4,
		/// <summary/>
		VarArg			= 0x5,
		/// <summary/>
		Field			= 0x6,
		/// <summary/>
		LocalSig		= 0x7,
		/// <summary/>
		Property		= 0x8,
		/// <summary>Unmanaged calling convention encoded as modopts</summary>
		Unmanaged		= 0x9,
		/// <summary>generic method instantiation</summary>
		GenericInst		= 0xA,
		/// <summary>used ONLY for 64bit vararg PInvoke calls</summary>
		NativeVarArg	= 0xB,

		/// <summary>Calling convention is bottom 4 bits</summary>
		Mask			= 0x0F,

		/// <summary>Generic method</summary>
		Generic			= 0x10,
		/// <summary>Method needs a 'this' parameter</summary>
		HasThis			= 0x20,
		/// <summary>'this' parameter is the first arg if set (else it's hidden)</summary>
		ExplicitThis	= 0x40,
		/// <summary>Used internally by the CLR</summary>
		ReservedByCLR	= 0x80,
	}
}





/*
All signature classes:

CallingConventionSig
	FieldSig
	MethodBaseSig
		MethodSig
		PropertySig
	LocalSig
	GenericInstMethodSig
*/

namespace dnlib.DotNet {
	/// <summary>
	/// Base class for sigs with a calling convention
	/// </summary>
	public abstract class CallingConventionSig : IContainsGenericParameter {
		/// <summary>
		/// The calling convention
		/// </summary>
		protected CallingConvention callingConvention;

		byte[] extraData;

		/// <summary>
		/// Gets/sets the extra data found after the signature
		/// </summary>
		public byte[] ExtraData {
			get => extraData;
			set => extraData = value;
		}

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.Default"/> is set
		/// </summary>
		public bool IsDefault => (callingConvention & CallingConvention.Mask) == CallingConvention.Default;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.C"/> is set
		/// </summary>
		public bool IsC => (callingConvention & CallingConvention.Mask) == CallingConvention.C;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.StdCall"/> is set
		/// </summary>
		public bool IsStdCall => (callingConvention & CallingConvention.Mask) == CallingConvention.StdCall;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.ThisCall"/> is set
		/// </summary>
		public bool IsThisCall => (callingConvention & CallingConvention.Mask) == CallingConvention.ThisCall;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.FastCall"/> is set
		/// </summary>
		public bool IsFastCall => (callingConvention & CallingConvention.Mask) == CallingConvention.FastCall;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.VarArg"/> is set
		/// </summary>
		public bool IsVarArg => (callingConvention & CallingConvention.Mask) == CallingConvention.VarArg;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.Field"/> is set
		/// </summary>
		public bool IsField => (callingConvention & CallingConvention.Mask) == CallingConvention.Field;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.LocalSig"/> is set
		/// </summary>
		public bool IsLocalSig => (callingConvention & CallingConvention.Mask) == CallingConvention.LocalSig;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.Property"/> is set
		/// </summary>
		public bool IsProperty => (callingConvention & CallingConvention.Mask) == CallingConvention.Property;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.Unmanaged"/> is set
		/// </summary>
		public bool IsUnmanaged => (callingConvention & CallingConvention.Mask) == CallingConvention.Unmanaged;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.GenericInst"/> is set
		/// </summary>
		public bool IsGenericInst => (callingConvention & CallingConvention.Mask) == CallingConvention.GenericInst;

		/// <summary>
		/// Returns <c>true</c> if <see cref="CallingConvention.NativeVarArg"/> is set
		/// </summary>
		public bool IsNativeVarArg => (callingConvention & CallingConvention.Mask) == CallingConvention.NativeVarArg;

		/// <summary>
		/// Gets/sets the <see cref="CallingConvention.Generic"/> bit
		/// </summary>
		public bool Generic {
			get => (callingConvention & CallingConvention.Generic) != 0;
			set {
				if (value)
					callingConvention |= CallingConvention.Generic;
				else
					callingConvention &= ~CallingConvention.Generic;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="CallingConvention.HasThis"/> bit
		/// </summary>
		public bool HasThis {
			get => (callingConvention & CallingConvention.HasThis) != 0;
			set {
				if (value)
					callingConvention |= CallingConvention.HasThis;
				else
					callingConvention &= ~CallingConvention.HasThis;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="CallingConvention.ExplicitThis"/> bit
		/// </summary>
		public bool ExplicitThis {
			get => (callingConvention & CallingConvention.ExplicitThis) != 0;
			set {
				if (value)
					callingConvention |= CallingConvention.ExplicitThis;
				else
					callingConvention &= ~CallingConvention.ExplicitThis;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="CallingConvention.ReservedByCLR"/> bit
		/// </summary>
		public bool ReservedByCLR {
			get => (callingConvention & CallingConvention.ReservedByCLR) != 0;
			set {
				if (value)
					callingConvention |= CallingConvention.ReservedByCLR;
				else
					callingConvention &= ~CallingConvention.ReservedByCLR;
			}
		}

		/// <summary>
		/// <c>true</c> if there's an implicit <c>this</c> parameter
		/// </summary>
		public bool ImplicitThis => HasThis && !ExplicitThis;

		/// <summary>
		/// <c>true</c> if this <see cref="CallingConventionSig"/> contains a
		/// <see cref="GenericVar"/> or a <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);

		/// <summary>
		/// Default constructor
		/// </summary>
		protected CallingConventionSig() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">The calling convention</param>
		protected CallingConventionSig(CallingConvention callingConvention) => this.callingConvention = callingConvention;

		/// <summary>
		/// Gets the calling convention
		/// </summary>
		public CallingConvention GetCallingConvention() => callingConvention;
	}

	/// <summary>
	/// A field signature
	/// </summary>
	public sealed class FieldSig : CallingConventionSig {
		TypeSig type;

		/// <summary>
		/// Gets/sets the field type
		/// </summary>
		public TypeSig Type {
			get => type;
			set => type = value;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public FieldSig() => callingConvention = CallingConvention.Field;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Field type</param>
		public FieldSig(TypeSig type) {
			callingConvention = CallingConvention.Field;
			this.type = type;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Field type</param>
		/// <param name="callingConvention">The calling convention (must have Field set)</param>
		internal FieldSig(CallingConvention callingConvention, TypeSig type) {
			this.callingConvention = callingConvention;
			this.type = type;
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public FieldSig Clone() => new FieldSig(callingConvention, type);

		/// <inheritdoc/>
		public override string ToString() => FullNameFactory.FullName(type, false, null, null, null, null);
	}

	/// <summary>
	/// Method sig base class
	/// </summary>
	public abstract class MethodBaseSig : CallingConventionSig {
		/// <summary/>
		protected TypeSig retType;
		/// <summary/>
		protected IList<TypeSig> parameters;
		/// <summary/>
		protected uint genParamCount;
		/// <summary/>
		protected IList<TypeSig> paramsAfterSentinel;

		/// <summary>
		/// Gets/sets the calling convention
		/// </summary>
		public CallingConvention CallingConvention {
			get => callingConvention;
			set => callingConvention = value;
		}

		/// <summary>
		/// Gets/sets the return type
		/// </summary>
		public TypeSig RetType {
			get => retType;
			set => retType = value;
		}

		/// <summary>
		/// Gets the parameters. This is never <c>null</c>
		/// </summary>
		public IList<TypeSig> Params => parameters;

		/// <summary>
		/// Gets/sets the generic param count
		/// </summary>
		public uint GenParamCount {
			get => genParamCount;
			set => genParamCount = value;
		}

		/// <summary>
		/// Gets the parameters that are present after the sentinel. Note that this is <c>null</c>
		/// if there's no sentinel. It can still be empty even if it's not <c>null</c>.
		/// </summary>
		public IList<TypeSig> ParamsAfterSentinel {
			get => paramsAfterSentinel;
			set => paramsAfterSentinel = value;
		}
	}

	/// <summary>
	/// A method signature
	/// </summary>
	public sealed class MethodSig : MethodBaseSig {
		uint origToken;

		/// <summary>
		/// Gets/sets the original token. It's set when reading calli instruction operands
		/// and it's a hint to the module writer if it tries to re-use the same token.
		/// </summary>
		public uint OriginalToken {
			get => origToken;
			set => origToken = value;
		}

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		public static MethodSig CreateStatic(TypeSig retType) => new MethodSig(CallingConvention.Default, 0, retType);

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static MethodSig CreateStatic(TypeSig retType, TypeSig argType1) => new MethodSig(CallingConvention.Default, 0, retType, argType1);

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static MethodSig CreateStatic(TypeSig retType, TypeSig argType1, TypeSig argType2) => new MethodSig(CallingConvention.Default, 0, retType, argType1, argType2);

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static MethodSig CreateStatic(TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) => new MethodSig(CallingConvention.Default, 0, retType, argType1, argType2, argType3);

		/// <summary>
		/// Creates a static MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static MethodSig CreateStatic(TypeSig retType, params TypeSig[] argTypes) => new MethodSig(CallingConvention.Default, 0, retType, argTypes);

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		public static MethodSig CreateInstance(TypeSig retType) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType);

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static MethodSig CreateInstance(TypeSig retType, TypeSig argType1) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType, argType1);

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static MethodSig CreateInstance(TypeSig retType, TypeSig argType1, TypeSig argType2) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType, argType1, argType2);

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static MethodSig CreateInstance(TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType, argType1, argType2, argType3);

		/// <summary>
		/// Creates an instance MethodSig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static MethodSig CreateInstance(TypeSig retType, params TypeSig[] argTypes) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis, 0, retType, argTypes);

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType) => new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType);

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType, TypeSig argType1) => new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType, argType1);

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2) => new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType, argType1, argType2);

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) => new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType, argType1, argType2, argType3);

		/// <summary>
		/// Creates a static generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static MethodSig CreateStaticGeneric(uint genParamCount, TypeSig retType, params TypeSig[] argTypes) => new MethodSig(CallingConvention.Default | CallingConvention.Generic, genParamCount, retType, argTypes);

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType);

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType, TypeSig argType1) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType, argType1);

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType, argType1, argType2);

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType, argType1, argType2, argType3);

		/// <summary>
		/// Creates an instance generic MethodSig
		/// </summary>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static MethodSig CreateInstanceGeneric(uint genParamCount, TypeSig retType, params TypeSig[] argTypes) => new MethodSig(CallingConvention.Default | CallingConvention.HasThis | CallingConvention.Generic, genParamCount, retType, argTypes);

		/// <summary>
		/// Default constructor
		/// </summary>
		public MethodSig() => parameters = new List<TypeSig>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		public MethodSig(CallingConvention callingConvention) {
			this.callingConvention = callingConvention;
			parameters = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			parameters = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			parameters = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, TypeSig argType1) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			parameters = new List<TypeSig> { argType1 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			parameters = new List<TypeSig> { argType1, argType2 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			parameters = new List<TypeSig> { argType1, argType2, argType3 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, params TypeSig[] argTypes) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			parameters = new List<TypeSig>(argTypes);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, IList<TypeSig> argTypes) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			parameters = new List<TypeSig>(argTypes);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		/// <param name="paramsAfterSentinel">Parameters after sentinel</param>
		public MethodSig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, IList<TypeSig> argTypes, IList<TypeSig> paramsAfterSentinel) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			parameters = new List<TypeSig>(argTypes);
			this.paramsAfterSentinel = paramsAfterSentinel is null ? null : new List<TypeSig>(paramsAfterSentinel);
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public MethodSig Clone() => new MethodSig(callingConvention, genParamCount, retType, parameters, paramsAfterSentinel);

		/// <inheritdoc/>
		public override string ToString() => FullNameFactory.MethodBaseSigFullName(this, null);
	}

	/// <summary>
	/// A property signature
	/// </summary>
	public sealed class PropertySig : MethodBaseSig {
		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		public static PropertySig CreateStatic(TypeSig retType) => new PropertySig(false, retType);

		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static PropertySig CreateStatic(TypeSig retType, TypeSig argType1) => new PropertySig(false, retType, argType1);

		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static PropertySig CreateStatic(TypeSig retType, TypeSig argType1, TypeSig argType2) => new PropertySig(false, retType, argType1, argType2);

		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static PropertySig CreateStatic(TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) => new PropertySig(false, retType, argType1, argType2, argType3);

		/// <summary>
		/// Creates a static PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static PropertySig CreateStatic(TypeSig retType, params TypeSig[] argTypes) => new PropertySig(false, retType, argTypes);

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		public static PropertySig CreateInstance(TypeSig retType) => new PropertySig(true, retType);

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public static PropertySig CreateInstance(TypeSig retType, TypeSig argType1) => new PropertySig(true, retType, argType1);

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public static PropertySig CreateInstance(TypeSig retType, TypeSig argType1, TypeSig argType2) => new PropertySig(true, retType, argType1, argType2);

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public static PropertySig CreateInstance(TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) => new PropertySig(true, retType, argType1, argType2, argType3);

		/// <summary>
		/// Creates an instance PropertySig
		/// </summary>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public static PropertySig CreateInstance(TypeSig retType, params TypeSig[] argTypes) => new PropertySig(true, retType, argTypes);

		/// <summary>
		/// Default constructor
		/// </summary>
		public PropertySig() {
			callingConvention = CallingConvention.Property;
			parameters = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention (must have Property set)</param>
		internal PropertySig(CallingConvention callingConvention) {
			this.callingConvention = callingConvention;
			parameters = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		public PropertySig(bool hasThis) {
			callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			parameters = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		public PropertySig(bool hasThis, TypeSig retType) {
			callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			parameters = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		public PropertySig(bool hasThis, TypeSig retType, TypeSig argType1) {
			callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			parameters = new List<TypeSig> { argType1 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		public PropertySig(bool hasThis, TypeSig retType, TypeSig argType1, TypeSig argType2) {
			callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			parameters = new List<TypeSig> { argType1, argType2 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		/// <param name="argType1">Arg type #1</param>
		/// <param name="argType2">Arg type #2</param>
		/// <param name="argType3">Arg type #3</param>
		public PropertySig(bool hasThis, TypeSig retType, TypeSig argType1, TypeSig argType2, TypeSig argType3) {
			callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			parameters = new List<TypeSig> { argType1, argType2, argType3 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hasThis"><c>true</c> if instance, <c>false</c> if static</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		public PropertySig(bool hasThis, TypeSig retType, params TypeSig[] argTypes) {
			callingConvention = CallingConvention.Property | (hasThis ? CallingConvention.HasThis : 0);
			this.retType = retType;
			parameters = new List<TypeSig>(argTypes);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention</param>
		/// <param name="genParamCount">Number of generic parameters</param>
		/// <param name="retType">Return type</param>
		/// <param name="argTypes">Argument types</param>
		/// <param name="paramsAfterSentinel">Parameters after sentinel</param>
		internal PropertySig(CallingConvention callingConvention, uint genParamCount, TypeSig retType, IList<TypeSig> argTypes, IList<TypeSig> paramsAfterSentinel) {
			this.callingConvention = callingConvention;
			this.genParamCount = genParamCount;
			this.retType = retType;
			parameters = new List<TypeSig>(argTypes);
			this.paramsAfterSentinel = paramsAfterSentinel is null ? null : new List<TypeSig>(paramsAfterSentinel);
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public PropertySig Clone() => new PropertySig(callingConvention, genParamCount, retType, parameters, paramsAfterSentinel);

		/// <inheritdoc/>
		public override string ToString() => FullNameFactory.MethodBaseSigFullName(this, null);
	}

	/// <summary>
	/// A local variables signature
	/// </summary>
	public sealed class LocalSig : CallingConventionSig {
		readonly IList<TypeSig> locals;

		/// <summary>
		/// All local types. This is never <c>null</c>.
		/// </summary>
		public IList<TypeSig> Locals => locals;

		/// <summary>
		/// Default constructor
		/// </summary>
		public LocalSig() {
			callingConvention = CallingConvention.LocalSig;
			locals = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention (must have LocalSig set)</param>
		/// <param name="count">Number of locals</param>
		internal LocalSig(CallingConvention callingConvention, uint count) {
			this.callingConvention = callingConvention;
			locals = new List<TypeSig>((int)count);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="local1">Local type #1</param>
		public LocalSig(TypeSig local1) {
			callingConvention = CallingConvention.LocalSig;
			locals = new List<TypeSig> { local1 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="local1">Local type #1</param>
		/// <param name="local2">Local type #2</param>
		public LocalSig(TypeSig local1, TypeSig local2) {
			callingConvention = CallingConvention.LocalSig;
			locals = new List<TypeSig> { local1, local2 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="local1">Local type #1</param>
		/// <param name="local2">Local type #2</param>
		/// <param name="local3">Local type #3</param>
		public LocalSig(TypeSig local1, TypeSig local2, TypeSig local3) {
			callingConvention = CallingConvention.LocalSig;
			locals = new List<TypeSig> { local1, local2, local3 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="locals">All locals</param>
		public LocalSig(params TypeSig[] locals) {
			callingConvention = CallingConvention.LocalSig;
			this.locals = new List<TypeSig>(locals);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="locals">All locals</param>
		public LocalSig(IList<TypeSig> locals) {
			callingConvention = CallingConvention.LocalSig;
			this.locals = new List<TypeSig>(locals);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="locals">All locals (this instance now owns it)</param>
		/// <param name="dummy">Dummy</param>
		internal LocalSig(IList<TypeSig> locals, bool dummy) {
			callingConvention = CallingConvention.LocalSig;
			this.locals = locals;
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public LocalSig Clone() => new LocalSig(locals);
	}

	/// <summary>
	/// An instantiated generic method signature
	/// </summary>
	public sealed class GenericInstMethodSig : CallingConventionSig {
		readonly IList<TypeSig> genericArgs;

		/// <summary>
		/// Gets the generic arguments (must be instantiated types, i.e., closed types)
		/// </summary>
		public IList<TypeSig> GenericArguments => genericArgs;

		/// <summary>
		/// Default constructor
		/// </summary>
		public GenericInstMethodSig() {
			callingConvention = CallingConvention.GenericInst;
			genericArgs = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="callingConvention">Calling convention (must have GenericInst set)</param>
		/// <param name="size">Number of generic args</param>
		internal GenericInstMethodSig(CallingConvention callingConvention, uint size) {
			this.callingConvention = callingConvention;
			genericArgs = new List<TypeSig>((int)size);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arg1">Generic arg #1</param>
		public GenericInstMethodSig(TypeSig arg1) {
			callingConvention = CallingConvention.GenericInst;
			genericArgs = new List<TypeSig> { arg1 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arg1">Generic arg #1</param>
		/// <param name="arg2">Generic arg #2</param>
		public GenericInstMethodSig(TypeSig arg1, TypeSig arg2) {
			callingConvention = CallingConvention.GenericInst;
			genericArgs = new List<TypeSig> { arg1, arg2 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arg1">Generic arg #1</param>
		/// <param name="arg2">Generic arg #2</param>
		/// <param name="arg3">Generic arg #3</param>
		public GenericInstMethodSig(TypeSig arg1, TypeSig arg2, TypeSig arg3) {
			callingConvention = CallingConvention.GenericInst;
			genericArgs = new List<TypeSig> { arg1, arg2, arg3 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="args">Generic args</param>
		public GenericInstMethodSig(params TypeSig[] args) {
			callingConvention = CallingConvention.GenericInst;
			genericArgs = new List<TypeSig>(args);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="args">Generic args</param>
		public GenericInstMethodSig(IList<TypeSig> args) {
			callingConvention = CallingConvention.GenericInst;
			genericArgs = new List<TypeSig>(args);
		}

		/// <summary>
		/// Clone this
		/// </summary>
		public GenericInstMethodSig Clone() => new GenericInstMethodSig(genericArgs);
	}

	public static partial class Extensions {
		/// <summary>
		/// Gets the field type
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Field type or <c>null</c> if none</returns>
		public static TypeSig GetFieldType(this FieldSig sig) => sig?.Type;

		/// <summary>
		/// Gets the return type
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Return type or <c>null</c> if none</returns>
		public static TypeSig GetRetType(this MethodBaseSig sig) => sig?.RetType;

		/// <summary>
		/// Gets the parameters
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>The parameters</returns>
		public static IList<TypeSig> GetParams(this MethodBaseSig sig) => sig?.Params ?? new List<TypeSig>();

		/// <summary>
		/// Gets the parameter count
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Parameter count</returns>
		public static int GetParamCount(this MethodBaseSig sig) => sig?.Params.Count ?? 0;

		/// <summary>
		/// Gets the generic parameter count
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Generic parameter count</returns>
		public static uint GetGenParamCount(this MethodBaseSig sig) => sig?.GenParamCount ?? 0;

		/// <summary>
		/// Gets the parameters after the sentinel
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>Parameters after sentinel or <c>null</c> if none</returns>
		public static IList<TypeSig> GetParamsAfterSentinel(this MethodBaseSig sig) => sig?.ParamsAfterSentinel;

		/// <summary>
		/// Gets the locals
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>All locals</returns>
		public static IList<TypeSig> GetLocals(this LocalSig sig) => sig?.Locals ?? new List<TypeSig>();

		/// <summary>
		/// Gets the generic arguments
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>All generic arguments</returns>
		public static IList<TypeSig> GetGenericArguments(this GenericInstMethodSig sig) => sig?.GenericArguments ?? new List<TypeSig>();

		/// <summary>
		/// Gets the <see cref="CallingConventionSig.IsDefault"/> property
		/// </summary>
		/// <param name="sig">this</param>
		/// <returns>The type's <see cref="CallingConventionSig.IsDefault"/> property or
		/// <c>false</c> if input is<c>null</c></returns>
		public static bool GetIsDefault(this CallingConventionSig sig) => sig?.IsDefault ?? false;
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ClassLayout table
	/// </summary>
	public abstract class ClassLayout : IMDTokenProvider {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.ClassLayout, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <summary>
		/// From column ClassLayout.PackingSize
		/// </summary>
		public ushort PackingSize {
			get => packingSize;
			set => packingSize = value;
		}
		/// <summary/>
		protected ushort packingSize;

		/// <summary>
		/// From column ClassLayout.ClassSize
		/// </summary>
		public uint ClassSize {
			get => classSize;
			set => classSize = value;
		}
		/// <summary/>
		protected uint classSize;
	}

	/// <summary>
	/// A ClassLayout row created by the user and not present in the original .NET file
	/// </summary>
	public class ClassLayoutUser : ClassLayout {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ClassLayoutUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="packingSize">PackingSize</param>
		/// <param name="classSize">ClassSize</param>
		public ClassLayoutUser(ushort packingSize, uint classSize) {
			this.packingSize = packingSize;
			this.classSize = classSize;
		}
	}

	/// <summary>
	/// Created from a row in the ClassLayout table
	/// </summary>
	sealed class ClassLayoutMD : ClassLayout, IMDTokenProviderMD {
		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ClassLayout</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ClassLayoutMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ClassLayoutTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"ClassLayout rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			bool b = readerModule.TablesStream.TryReadClassLayoutRow(origRid, out var row);
			Debug.Assert(b);
			classSize = row.ClassSize;
			packingSize = row.PackingSize;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Constant table
	/// </summary>
	public abstract class Constant : IMDTokenProvider {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.Constant, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <summary>
		/// From column Constant.Type
		/// </summary>
		public ElementType Type {
			get => type;
			set => type = value;
		}
		/// <summary/>
		protected ElementType type;

		/// <summary>
		/// From column Constant.Value
		/// </summary>
		public object Value {
			get => value;
			set => this.value = value;
		}
		/// <summary/>
		protected object value;
	}

	/// <summary>
	/// A Constant row created by the user and not present in the original .NET file
	/// </summary>
	public class ConstantUser : Constant {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ConstantUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="value">Value</param>
		public ConstantUser(object value) {
			type = GetElementType(value);
			this.value = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="type">Type</param>
		public ConstantUser(object value, ElementType type) {
			this.type = type;
			this.value = value;
		}

		static ElementType GetElementType(object value) {
			if (value is null)
				return ElementType.Class;
			return System.Type.GetTypeCode(value.GetType()) switch {
				TypeCode.Boolean => ElementType.Boolean,
				TypeCode.Char => ElementType.Char,
				TypeCode.SByte => ElementType.I1,
				TypeCode.Byte => ElementType.U1,
				TypeCode.Int16 => ElementType.I2,
				TypeCode.UInt16 => ElementType.U2,
				TypeCode.Int32 => ElementType.I4,
				TypeCode.UInt32 => ElementType.U4,
				TypeCode.Int64 => ElementType.I8,
				TypeCode.UInt64 => ElementType.U8,
				TypeCode.Single => ElementType.R4,
				TypeCode.Double => ElementType.R8,
				TypeCode.String => ElementType.String,
				_ => ElementType.Void,
			};
		}
	}

	/// <summary>
	/// Created from a row in the Constant table
	/// </summary>
	sealed class ConstantMD : Constant, IMDTokenProviderMD {
		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Constant</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ConstantMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ConstantTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"Constant rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			bool b = readerModule.TablesStream.TryReadConstantRow(origRid, out var row);
			Debug.Assert(b);
			type = (ElementType)row.Type;
			var reader = readerModule.BlobStream.CreateReader(row.Value);
			value = GetValue(type, ref reader);
		}

		static object GetValue(ElementType etype, ref DataReader reader) {
			switch (etype) {
			case ElementType.Boolean:
				if (reader.Length < 1)
					return false;
				return reader.ReadBoolean();

			case ElementType.Char:
				if (reader.Length < 2)
					return (char)0;
				return reader.ReadChar();

			case ElementType.I1:
				if (reader.Length < 1)
					return (sbyte)0;
				return reader.ReadSByte();

			case ElementType.U1:
				if (reader.Length < 1)
					return (byte)0;
				return reader.ReadByte();

			case ElementType.I2:
				if (reader.Length < 2)
					return (short)0;
				return reader.ReadInt16();

			case ElementType.U2:
				if (reader.Length < 2)
					return (ushort)0;
				return reader.ReadUInt16();

			case ElementType.I4:
				if (reader.Length < 4)
					return (int)0;
				return reader.ReadInt32();

			case ElementType.U4:
				if (reader.Length < 4)
					return (uint)0;
				return reader.ReadUInt32();

			case ElementType.I8:
				if (reader.Length < 8)
					return (long)0;
				return reader.ReadInt64();

			case ElementType.U8:
				if (reader.Length < 8)
					return (ulong)0;
				return reader.ReadUInt64();

			case ElementType.R4:
				if (reader.Length < 4)
					return (float)0;
				return reader.ReadSingle();

			case ElementType.R8:
				if (reader.Length < 8)
					return (double)0;
				return reader.ReadDouble();

			case ElementType.String:
				return reader.ReadUtf16String((int)(reader.BytesLeft / 2));

			case ElementType.Class:
				return null;

			default:
				return null;
			}
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Default implementation of <see cref="ICorLibTypes"/>
	/// </summary>
	public sealed class CorLibTypes : ICorLibTypes {
		readonly ModuleDef module;
		CorLibTypeSig typeVoid;
		CorLibTypeSig typeBoolean;
		CorLibTypeSig typeChar;
		CorLibTypeSig typeSByte;
		CorLibTypeSig typeByte;
		CorLibTypeSig typeInt16;
		CorLibTypeSig typeUInt16;
		CorLibTypeSig typeInt32;
		CorLibTypeSig typeUInt32;
		CorLibTypeSig typeInt64;
		CorLibTypeSig typeUInt64;
		CorLibTypeSig typeSingle;
		CorLibTypeSig typeDouble;
		CorLibTypeSig typeString;
		CorLibTypeSig typeTypedReference;
		CorLibTypeSig typeIntPtr;
		CorLibTypeSig typeUIntPtr;
		CorLibTypeSig typeObject;
		readonly AssemblyRef corLibAssemblyRef;

		/// <inheritdoc/>
		public CorLibTypeSig Void => typeVoid;

		/// <inheritdoc/>
		public CorLibTypeSig Boolean => typeBoolean;

		/// <inheritdoc/>
		public CorLibTypeSig Char => typeChar;

		/// <inheritdoc/>
		public CorLibTypeSig SByte => typeSByte;

		/// <inheritdoc/>
		public CorLibTypeSig Byte => typeByte;

		/// <inheritdoc/>
		public CorLibTypeSig Int16 => typeInt16;

		/// <inheritdoc/>
		public CorLibTypeSig UInt16 => typeUInt16;

		/// <inheritdoc/>
		public CorLibTypeSig Int32 => typeInt32;

		/// <inheritdoc/>
		public CorLibTypeSig UInt32 => typeUInt32;

		/// <inheritdoc/>
		public CorLibTypeSig Int64 => typeInt64;

		/// <inheritdoc/>
		public CorLibTypeSig UInt64 => typeUInt64;

		/// <inheritdoc/>
		public CorLibTypeSig Single => typeSingle;

		/// <inheritdoc/>
		public CorLibTypeSig Double => typeDouble;

		/// <inheritdoc/>
		public CorLibTypeSig String => typeString;

		/// <inheritdoc/>
		public CorLibTypeSig TypedReference => typeTypedReference;

		/// <inheritdoc/>
		public CorLibTypeSig IntPtr => typeIntPtr;

		/// <inheritdoc/>
		public CorLibTypeSig UIntPtr => typeUIntPtr;

		/// <inheritdoc/>
		public CorLibTypeSig Object => typeObject;

		/// <inheritdoc/>
		public AssemblyRef AssemblyRef => corLibAssemblyRef;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The owner module</param>
		public CorLibTypes(ModuleDef module)
			: this(module, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The owner module</param>
		/// <param name="corLibAssemblyRef">Corlib assembly reference or <c>null</c> if a default
		/// assembly reference should be created</param>
		public CorLibTypes(ModuleDef module, AssemblyRef corLibAssemblyRef) {
			this.module = module;
			this.corLibAssemblyRef = corLibAssemblyRef ?? CreateCorLibAssemblyRef();
			Initialize();
		}

		AssemblyRef CreateCorLibAssemblyRef() => module.UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR20());

		void Initialize() {
			bool isCorLib = module.Assembly.IsCorLib();
			typeVoid	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Void"),		ElementType.Void);
			typeBoolean	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Boolean"),	ElementType.Boolean);
			typeChar	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Char"),		ElementType.Char);
			typeSByte	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "SByte"),		ElementType.I1);
			typeByte	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Byte"),		ElementType.U1);
			typeInt16	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Int16"),		ElementType.I2);
			typeUInt16	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "UInt16"),	ElementType.U2);
			typeInt32	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Int32"),		ElementType.I4);
			typeUInt32	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "UInt32"),	ElementType.U4);
			typeInt64	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Int64"),		ElementType.I8);
			typeUInt64	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "UInt64"),	ElementType.U8);
			typeSingle	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Single"),	ElementType.R4);
			typeDouble	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Double"),	ElementType.R8);
			typeString	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "String"),	ElementType.String);
			typeTypedReference = new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "TypedReference"), ElementType.TypedByRef);
			typeIntPtr	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "IntPtr"),	ElementType.I);
			typeUIntPtr	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "UIntPtr"),	ElementType.U);
			typeObject	= new CorLibTypeSig(CreateCorLibTypeRef(isCorLib, "Object"),	ElementType.Object);
		}

		ITypeDefOrRef CreateCorLibTypeRef(bool isCorLib, string name) {
			var tr = new TypeRefUser(module, "System", name, corLibAssemblyRef);
			if (isCorLib) {
				var td = module.Find(tr);
				if (td is not null)
					return td;
			}
			return module.UpdateRowId(tr);
		}

		/// <inheritdoc/>
		public TypeRef GetTypeRef(string @namespace, string name) => module.UpdateRowId(new TypeRefUser(module, @namespace, name, corLibAssemblyRef));
	}
}





namespace dnlib.DotNet {
	enum StubType {
		Export,
		EntryPoint,
	}

	abstract class CpuArch {
		// To support a new CPU arch, the easiest way is to check coreclr/src/ilasm/writer.cpp or
		// coreclr/src/dlls/mscorpe/stubs.h, eg. ExportStubAMD64Template, ExportStubX86Template,
		// ExportStubARMTemplate, ExportStubIA64Template, or use ilasm to generate a file with
		// exports and check the stub
		static readonly X86CpuArch x86CpuArch = new X86CpuArch();
		static readonly X64CpuArch x64CpuArch = new X64CpuArch();
		static readonly ItaniumCpuArch itaniumCpuArch = new ItaniumCpuArch();
		static readonly ArmCpuArch armCpuArch = new ArmCpuArch();

		/// <summary>
		/// Gets the required alignment for the stubs, must be a power of 2
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <returns></returns>
		public abstract uint GetStubAlignment(StubType stubType);

		/// <summary>
		/// Gets the size of a stub, it doesn't have to be a multiple of <see cref="GetStubAlignment(StubType)"/>
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <returns></returns>
		public abstract uint GetStubSize(StubType stubType);

		/// <summary>
		/// Gets the offset of the code (entry point) relative to the start of the stub
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <returns></returns>
		public abstract uint GetStubCodeOffset(StubType stubType);

		public static bool TryGetCpuArch(Machine machine, out CpuArch cpuArch) {
			switch (machine) {
			case Machine.I386:
			case Machine.I386_Native_Apple:
			case Machine.I386_Native_FreeBSD:
			case Machine.I386_Native_Linux:
			case Machine.I386_Native_NetBSD:
			case Machine.I386_Native_Sun:
				cpuArch = x86CpuArch;
				return true;

			case Machine.AMD64:
			case Machine.AMD64_Native_Apple:
			case Machine.AMD64_Native_FreeBSD:
			case Machine.AMD64_Native_Linux:
			case Machine.AMD64_Native_NetBSD:
			case Machine.AMD64_Native_Sun:
				cpuArch = x64CpuArch;
				return true;

			case Machine.IA64:
				cpuArch = itaniumCpuArch;
				return true;

			case Machine.ARMNT:
			case Machine.ARMNT_Native_Apple:
			case Machine.ARMNT_Native_FreeBSD:
			case Machine.ARMNT_Native_Linux:
			case Machine.ARMNT_Native_NetBSD:
			case Machine.ARMNT_Native_Sun:
				cpuArch = armCpuArch;
				return true;

			case Machine.ARM64:
			case Machine.ARM64_Native_Apple:
			case Machine.ARM64_Native_FreeBSD:
			case Machine.ARM64_Native_Linux:
			case Machine.ARM64_Native_NetBSD:
			case Machine.ARM64_Native_Sun:
				//TODO: Support ARM64
				goto default;

			default:
				cpuArch = null;
				return false;
			}
		}

		/// <summary>
		/// Gets the RVA of the func field that the stub jumps to
		/// </summary>
		/// <param name="reader">Reader, positioned at the stub func</param>
		/// <param name="peImage">PE image</param>
		/// <param name="funcRva">Updated with RVA of func field</param>
		/// <returns></returns>
		public bool TryGetExportedRvaFromStub(ref DataReader reader, IPEImage peImage, out uint funcRva) =>
			TryGetExportedRvaFromStubCore(ref reader, peImage, out funcRva);

		protected abstract bool TryGetExportedRvaFromStubCore(ref DataReader reader, IPEImage peImage, out uint funcRva);

		/// <summary>
		/// Writes stub relocs, if needed
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <param name="relocDirectory">Reloc directory</param>
		/// <param name="chunk">The chunk where this stub will be written to</param>
		/// <param name="stubOffset">Offset of this stub in <paramref name="chunk"/></param>
		public abstract void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset);

		/// <summary>
		/// Writes the stub that jumps to the managed function
		/// </summary>
		/// <param name="stubType">Stub type</param>
		/// <param name="writer">Writer</param>
		/// <param name="imageBase">Image base</param>
		/// <param name="stubRva">RVA of this stub</param>
		/// <param name="managedFuncRva">RVA of a pointer-sized field that contains the absolute address of the managed function</param>
		public abstract void WriteStub(StubType stubType, DataWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva);
	}

	sealed class X86CpuArch : CpuArch {
		public override uint GetStubAlignment(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 4;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubSize(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 2/*padding*/ + 6;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubCodeOffset(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 2/*padding*/;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		protected override bool TryGetExportedRvaFromStubCore(ref DataReader reader, IPEImage peImage, out uint funcRva) {
			funcRva = 0;

			// FF25xxxxxxxx		jmp DWORD PTR [xxxxxxxx]
			if (reader.ReadUInt16() != 0x25FF)
				return false;
			funcRva = reader.ReadUInt32() - (uint)peImage.ImageNTHeaders.OptionalHeader.ImageBase;
			return true;
		}

		public override void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				relocDirectory.Add(chunk, stubOffset + 4);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override void WriteStub(StubType stubType, DataWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				writer.WriteUInt16(0);// padding
				writer.WriteUInt16(0x25FF);
				writer.WriteUInt32((uint)imageBase + managedFuncRva);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}

	sealed class X64CpuArch : CpuArch {
		public override uint GetStubAlignment(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 4;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubSize(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 2/*padding*/ + 12;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubCodeOffset(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 2/*padding*/;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		protected override bool TryGetExportedRvaFromStubCore(ref DataReader reader, IPEImage peImage, out uint funcRva) {
			funcRva = 0;

			// 48A1xxxxxxxxxxxxxxxx		movabs	rax,[xxxxxxxxxxxxxxxx]
			// FFE0						jmp		rax
			if (reader.ReadUInt16() != 0xA148)
				return false;
			ulong absAddr = reader.ReadUInt64();
			if (reader.ReadUInt16() != 0xE0FF)
				return false;
			ulong rva = absAddr - peImage.ImageNTHeaders.OptionalHeader.ImageBase;
			if (rva > uint.MaxValue)
				return false;
			funcRva = (uint)rva;
			return true;
		}

		public override void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				relocDirectory.Add(chunk, stubOffset + 4);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override void WriteStub(StubType stubType, DataWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				writer.WriteUInt16(0);// padding
				writer.WriteUInt16(0xA148);
				writer.WriteUInt64(imageBase + managedFuncRva);
				writer.WriteUInt16(0xE0FF);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}

	sealed class ItaniumCpuArch : CpuArch {
		public override uint GetStubAlignment(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 16;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubSize(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 0x30;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubCodeOffset(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 0x20;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		protected override bool TryGetExportedRvaFromStubCore(ref DataReader reader, IPEImage peImage, out uint funcRva) {
			funcRva = 0;

			// From ExportStubIA64Template in coreclr/src/ilasm/writer.cpp
			//
			// ld8    r9  = [gp]    ;;
			// ld8    r10 = [r9],8
			// nop.i                ;;
			// ld8    gp  = [r9]
			// mov    b6  = r10
			// br.cond.sptk.few  b6
			//
			// 0x0B, 0x48, 0x00, 0x02, 0x18, 0x10, 0xA0, 0x40, 
			// 0x24, 0x30, 0x28, 0x00, 0x00, 0x00, 0x04, 0x00, 
			// 0x10, 0x08, 0x00, 0x12, 0x18, 0x10, 0x60, 0x50, 
			// 0x04, 0x80, 0x03, 0x00, 0x60, 0x00, 0x80, 0x00,
			// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,//address of the template
			// 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 //address of VTFixup slot
			ulong addrTemplate = reader.ReadUInt64();
			ulong absAddr = reader.ReadUInt64();
			reader.Position = (uint)peImage.ToFileOffset((RVA)(addrTemplate - peImage.ImageNTHeaders.OptionalHeader.ImageBase));
			if (reader.ReadUInt64() != 0x40A010180200480BUL)
				return false;
			if (reader.ReadUInt64() != 0x0004000000283024UL)
				return false;
			if (reader.ReadUInt64() != 0x5060101812000810UL)
				return false;
			if (reader.ReadUInt64() != 0x0080006000038004UL)
				return false;

			ulong rva = absAddr - peImage.ImageNTHeaders.OptionalHeader.ImageBase;
			if (rva > uint.MaxValue)
				return false;
			funcRva = (uint)rva;
			return true;
		}

		public override void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				relocDirectory.Add(chunk, stubOffset + 0x20);
				relocDirectory.Add(chunk, stubOffset + 0x28);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override void WriteStub(StubType stubType, DataWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				writer.WriteUInt64(0x40A010180200480BUL);
				writer.WriteUInt64(0x0004000000283024UL);
				writer.WriteUInt64(0x5060101812000810UL);
				writer.WriteUInt64(0x0080006000038004UL);
				writer.WriteUInt64(imageBase + stubRva);
				writer.WriteUInt64(imageBase + managedFuncRva);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}

	sealed class ArmCpuArch : CpuArch {
		public override uint GetStubAlignment(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 4;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubSize(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 8;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override uint GetStubCodeOffset(StubType stubType) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				return 0;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		protected override bool TryGetExportedRvaFromStubCore(ref DataReader reader, IPEImage peImage, out uint funcRva) {
			funcRva = 0;

			// DFF800F0		ldr.w	pc,[pc]
			// xxxxxxxx
			if (reader.ReadUInt32() != 0xF000F8DF)
				return false;
			funcRva = reader.ReadUInt32() - (uint)peImage.ImageNTHeaders.OptionalHeader.ImageBase;
			return true;
		}

		public override void WriteStubRelocs(StubType stubType, RelocDirectory relocDirectory, IChunk chunk, uint stubOffset) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				relocDirectory.Add(chunk, stubOffset + 4);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		public override void WriteStub(StubType stubType, DataWriter writer, ulong imageBase, uint stubRva, uint managedFuncRva) {
			switch (stubType) {
			case StubType.Export:
			case StubType.EntryPoint:
				writer.WriteUInt32(0xF000F8DF);
				writer.WriteUInt32((uint)imageBase + managedFuncRva);
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A custom attribute
	/// </summary>
	public sealed class CustomAttribute : ICustomAttribute {
		ICustomAttributeType ctor;
		byte[] rawData;
		readonly IList<CAArgument> arguments;
		readonly IList<CANamedArgument> namedArguments;
		uint caBlobOffset;

		/// <summary>
		/// Gets/sets the custom attribute constructor
		/// </summary>
		public ICustomAttributeType Constructor {
			get => ctor;
			set => ctor = value;
		}

		/// <summary>
		/// Gets the attribute type
		/// </summary>
		public ITypeDefOrRef AttributeType => ctor?.DeclaringType;

		/// <summary>
		/// Gets the full name of the attribute type
		/// </summary>
		public string TypeFullName {
			get {
				if (ctor is MemberRef mrCtor)
					return mrCtor.GetDeclaringTypeFullName() ?? string.Empty;

				if (ctor is MethodDef mdCtor) {
					var declType = mdCtor.DeclaringType;
					if (declType is not null)
						return declType.FullName;
				}

				return string.Empty;
			}
		}

		/// <summary>
		/// <c>true</c> if the raw custom attribute blob hasn't been parsed
		/// </summary>
		public bool IsRawBlob => rawData is not null;

		/// <summary>
		/// Gets the raw custom attribute blob or <c>null</c> if the CA was successfully parsed.
		/// </summary>
		public byte[] RawData => rawData;

		/// <summary>
		/// Gets all constructor arguments
		/// </summary>
		public IList<CAArgument> ConstructorArguments => arguments;

		/// <summary>
		/// <c>true</c> if <see cref="ConstructorArguments"/> is not empty
		/// </summary>
		public bool HasConstructorArguments => arguments.Count > 0;

		/// <summary>
		/// Gets all named arguments (field and property values)
		/// </summary>
		public IList<CANamedArgument> NamedArguments => namedArguments;

		/// <summary>
		/// <c>true</c> if <see cref="NamedArguments"/> is not empty
		/// </summary>
		public bool HasNamedArguments => namedArguments.Count > 0;

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are field arguments
		/// </summary>
		public IEnumerable<CANamedArgument> Fields {
			get {
				var namedArguments = this.namedArguments;
				int count = namedArguments.Count;
				for (int i = 0; i < count; i++) {
					var namedArg = namedArguments[i];
					if (namedArg.IsField)
						yield return namedArg;
				}
			}
		}

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are property arguments
		/// </summary>
		public IEnumerable<CANamedArgument> Properties {
			get {
				var namedArguments = this.namedArguments;
				int count = namedArguments.Count;
				for (int i = 0; i < count; i++) {
					var namedArg = namedArguments[i];
					if (namedArg.IsProperty)
						yield return namedArg;
				}
			}
		}

		/// <summary>
		/// Gets the #Blob offset or 0 if unknown
		/// </summary>
		public uint BlobOffset => caBlobOffset;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="rawData">Raw custom attribute blob</param>
		public CustomAttribute(ICustomAttributeType ctor, byte[] rawData)
			: this(ctor, null, null, 0) => this.rawData = rawData;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		public CustomAttribute(ICustomAttributeType ctor)
			: this(ctor, null, null, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="arguments">Constructor arguments or <c>null</c> if none</param>
		public CustomAttribute(ICustomAttributeType ctor, IEnumerable<CAArgument> arguments)
			: this(ctor, arguments, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="namedArguments">Named arguments or <c>null</c> if none</param>
		public CustomAttribute(ICustomAttributeType ctor, IEnumerable<CANamedArgument> namedArguments)
			: this(ctor, null, namedArguments) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="arguments">Constructor arguments or <c>null</c> if none</param>
		/// <param name="namedArguments">Named arguments or <c>null</c> if none</param>
		public CustomAttribute(ICustomAttributeType ctor, IEnumerable<CAArgument> arguments, IEnumerable<CANamedArgument> namedArguments)
			: this(ctor, arguments, namedArguments, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="arguments">Constructor arguments or <c>null</c> if none</param>
		/// <param name="namedArguments">Named arguments or <c>null</c> if none</param>
		/// <param name="caBlobOffset">Original custom attribute #Blob offset or 0</param>
		public CustomAttribute(ICustomAttributeType ctor, IEnumerable<CAArgument> arguments, IEnumerable<CANamedArgument> namedArguments, uint caBlobOffset) {
			this.ctor = ctor;
			this.arguments = arguments is null ? new List<CAArgument>() : new List<CAArgument>(arguments);
			this.namedArguments = namedArguments is null ? new List<CANamedArgument>() : new List<CANamedArgument>(namedArguments);
			this.caBlobOffset = caBlobOffset;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="arguments">Constructor arguments. The list is now owned by this instance.</param>
		/// <param name="namedArguments">Named arguments. The list is now owned by this instance.</param>
		/// <param name="caBlobOffset">Original custom attribute #Blob offset or 0</param>
		internal CustomAttribute(ICustomAttributeType ctor, List<CAArgument> arguments, List<CANamedArgument> namedArguments, uint caBlobOffset) {
			this.ctor = ctor;
			this.arguments = arguments ?? new List<CAArgument>();
			this.namedArguments = namedArguments ?? new List<CANamedArgument>();
			this.caBlobOffset = caBlobOffset;
		}

		/// <summary>
		/// Gets the field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of field</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetField(string name) => GetNamedArgument(name, true);

		/// <summary>
		/// Gets the field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of field</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetField(UTF8String name) => GetNamedArgument(name, true);

		/// <summary>
		/// Gets the property named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetProperty(string name) => GetNamedArgument(name, false);

		/// <summary>
		/// Gets the property named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetProperty(UTF8String name) => GetNamedArgument(name, false);

		/// <summary>
		/// Gets the property/field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of property/field</param>
		/// <param name="isField"><c>true</c> if it's a field, <c>false</c> if it's a property</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetNamedArgument(string name, bool isField) {
			var namedArguments = this.namedArguments;
			int count = namedArguments.Count;
			for (int i = 0; i < count; i++) {
				var namedArg = namedArguments[i];
				if (namedArg.IsField == isField && UTF8String.ToSystemStringOrEmpty(namedArg.Name) == name)
					return namedArg;
			}
			return null;
		}

		/// <summary>
		/// Gets the property/field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Name of property/field</param>
		/// <param name="isField"><c>true</c> if it's a field, <c>false</c> if it's a property</param>
		/// <returns>A <see cref="CANamedArgument"/> instance or <c>null</c> if not found</returns>
		public CANamedArgument GetNamedArgument(UTF8String name, bool isField) {
			var namedArguments = this.namedArguments;
			int count = namedArguments.Count;
			for (int i = 0; i < count; i++) {
				var namedArg = namedArguments[i];
				if (namedArg.IsField == isField && UTF8String.Equals(namedArg.Name, name))
					return namedArg;
			}
			return null;
		}

		/// <inheritdoc/>
		public override string ToString() => TypeFullName;
	}

	/// <summary>
	/// A custom attribute constructor argument
	/// </summary>
	public struct CAArgument : ICloneable {
		TypeSig type;
		object value;

		/// <summary>
		/// Gets/sets the argument type
		/// </summary>
		public TypeSig Type {
			readonly get => type;
			set => type = value;
		}

		/// <summary>
		/// Gets/sets the argument value
		/// </summary>
		public object Value {
			readonly get => value;
			set => this.value = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Argument type</param>
		public CAArgument(TypeSig type) {
			this.type = type;
			value = null;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Argument type</param>
		/// <param name="value">Argument value</param>
		public CAArgument(TypeSig type, object value) {
			this.type = type;
			this.value = value;
		}

		readonly object ICloneable.Clone() => Clone();

		/// <summary>
		/// Clones this instance and any <see cref="CAArgument"/>s and <see cref="CANamedArgument"/>s
		/// referenced from this instance.
		/// </summary>
		/// <returns></returns>
		public readonly CAArgument Clone() {
			var value = this.value;
			if (value is CAArgument)
				value = ((CAArgument)value).Clone();
			else if (value is IList<CAArgument> args) {
				var newArgs = new List<CAArgument>(args.Count);
				int count = args.Count;
				for (int i = 0; i < count; i++) {
					var arg = args[i];
					newArgs.Add(arg.Clone());
				}
				value = newArgs;
			}
			return new CAArgument(type, value);
		}

		/// <inheritdoc/>
		public override readonly string ToString() => $"{value ?? "null"} ({type})";
	}

	/// <summary>
	/// A custom attribute field/property argument
	/// </summary>
	public sealed class CANamedArgument : ICloneable {
		bool isField;
		TypeSig type;
		UTF8String name;
		CAArgument argument;

		/// <summary>
		/// <c>true</c> if it's a field
		/// </summary>
		public bool IsField {
			get => isField;
			set => isField = value;
		}

		/// <summary>
		/// <c>true</c> if it's a property
		/// </summary>
		public bool IsProperty {
			get => !isField;
			set => isField = !value;
		}

		/// <summary>
		/// Gets/sets the field/property type
		/// </summary>
		public TypeSig Type {
			get => type;
			set => type = value;
		}

		/// <summary>
		/// Gets/sets the property/field name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}

		/// <summary>
		/// Gets/sets the argument
		/// </summary>
		public CAArgument Argument {
			get => argument;
			set => argument = value;
		}

		/// <summary>
		/// Gets/sets the argument type
		/// </summary>
		public TypeSig ArgumentType {
			get => argument.Type;
			set => argument.Type = value;
		}

		/// <summary>
		/// Gets/sets the argument value
		/// </summary>
		public object Value {
			get => argument.Value;
			set => argument.Value = value;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public CANamedArgument() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
		public CANamedArgument(bool isField) => this.isField = isField;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
		/// <param name="type">Field/property type</param>
		public CANamedArgument(bool isField, TypeSig type) {
			this.isField = isField;
			this.type = type;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
		/// <param name="type">Field/property type</param>
		/// <param name="name">Name of field/property</param>
		public CANamedArgument(bool isField, TypeSig type, UTF8String name) {
			this.isField = isField;
			this.type = type;
			this.name = name;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isField"><c>true</c> if field, <c>false</c> if property</param>
		/// <param name="type">Field/property type</param>
		/// <param name="name">Name of field/property</param>
		/// <param name="argument">Field/property argument</param>
		public CANamedArgument(bool isField, TypeSig type, UTF8String name, CAArgument argument) {
			this.isField = isField;
			this.type = type;
			this.name = name;
			this.argument = argument;
		}

		object ICloneable.Clone() => Clone();

		/// <summary>
		/// Clones this instance and any <see cref="CAArgument"/>s referenced from this instance.
		/// </summary>
		/// <returns></returns>
		public CANamedArgument Clone() => new CANamedArgument(isField, type, name, argument.Clone());

		/// <inheritdoc/>
		public override string ToString() => $"({(isField ? "field" : "property")}) {type} {name} = {Value ?? "null"} ({ArgumentType})";
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Stores <see cref="CustomAttribute"/>s
	/// </summary>
	public class CustomAttributeCollection : LazyList<CustomAttribute, object> {
		/// <summary>
		/// Default constructor
		/// </summary>
		public CustomAttributeCollection() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Initial length of the list</param>
		/// <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
		/// <param name="readOriginalValue">Delegate instance that returns original values</param>
		public CustomAttributeCollection(int length, object context, Func<object, int, CustomAttribute> readOriginalValue)
			: base(length, context, readOriginalValue) {
		}

		/// <summary>
		/// Checks whether a custom attribute is present
		/// </summary>
		/// <param name="fullName">Full name of custom attribute type</param>
		/// <returns><c>true</c> if the custom attribute type is present, <c>false</c> otherwise</returns>
		public bool IsDefined(string fullName) => Find(fullName) is not null;

		/// <summary>
		/// Removes all custom attributes of a certain type
		/// </summary>
		/// <param name="fullName">Full name of custom attribute type that should be removed</param>
		public void RemoveAll(string fullName) {
			for (int i = Count - 1; i >= 0; i--) {
				if (this[i].TypeFullName == fullName)
					RemoveAt(i);
			}
		}

		/// <summary>
		/// Finds a custom attribute
		/// </summary>
		/// <param name="fullName">Full name of custom attribute type</param>
		/// <returns>A <see cref="CustomAttribute"/> or <c>null</c> if it wasn't found</returns>
		public CustomAttribute Find(string fullName) {
			foreach (var ca in this) {
				if (ca is not null && ca.TypeFullName == fullName)
					return ca;
			}

			return null;
		}

		/// <summary>
		/// Finds all custom attributes of a certain type
		/// </summary>
		/// <param name="fullName">Full name of custom attribute type</param>
		/// <returns>All <see cref="CustomAttribute"/>s of the requested type</returns>
		public IEnumerable<CustomAttribute> FindAll(string fullName) {
			foreach (var ca in this) {
				if (ca is not null && ca.TypeFullName == fullName)
					yield return ca;
			}
		}

		/// <summary>
		/// Finds a custom attribute
		/// </summary>
		/// <param name="attrType">Custom attribute type</param>
		/// <returns>The first <see cref="CustomAttribute"/> found or <c>null</c> if none found</returns>
		public CustomAttribute Find(IType attrType) => Find(attrType, 0);

		/// <summary>
		/// Finds a custom attribute
		/// </summary>
		/// <param name="attrType">Custom attribute type</param>
		/// <param name="options">Attribute type comparison flags</param>
		/// <returns>The first <see cref="CustomAttribute"/> found or <c>null</c> if none found</returns>
		public CustomAttribute Find(IType attrType, SigComparerOptions options) {
			var comparer = new SigComparer(options);
			foreach (var ca in this) {
				if (comparer.Equals(ca.AttributeType, attrType))
					return ca;
			}
			return null;
		}

		/// <summary>
		/// Finds all custom attributes of a certain type
		/// </summary>
		/// <param name="attrType">Custom attribute type</param>
		/// <returns>All <see cref="CustomAttribute"/>s of the requested type</returns>
		public IEnumerable<CustomAttribute> FindAll(IType attrType) => FindAll(attrType, 0);

		/// <summary>
		/// Finds all custom attributes of a certain type
		/// </summary>
		/// <param name="attrType">Custom attribute type</param>
		/// <param name="options">Attribute type comparison flags</param>
		/// <returns>All <see cref="CustomAttribute"/>s of the requested type</returns>
		public IEnumerable<CustomAttribute> FindAll(IType attrType, SigComparerOptions options) {
			var comparer = new SigComparer(options);
			foreach (var ca in this) {
				if (comparer.Equals(ca.AttributeType, attrType))
					yield return ca;
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Searches for a type according to custom attribute search rules: first try the
	/// current assembly, and if that fails, try mscorlib
	/// </summary>
	sealed class CAAssemblyRefFinder : IAssemblyRefFinder {
		readonly ModuleDef module;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module to search first</param>
		public CAAssemblyRefFinder(ModuleDef module) => this.module = module;

		/// <inheritdoc/>
		public AssemblyRef FindAssemblyRef(TypeRef nonNestedTypeRef) {
			var modAsm = module.Assembly;
			if (modAsm is not null) {
				var type = modAsm.Find(nonNestedTypeRef);
				// If the user added a new type with the same name as a corelib type, don't return it,
				// only return the type if it is this module's original type.
				if (type is TypeDefMD td && td.ReaderModule == module)
					return module.UpdateRowId(new AssemblyRefUser(modAsm));
			}
			else if (module.Find(nonNestedTypeRef) is not null)
				return AssemblyRef.CurrentAssembly;

			var corLibAsm = module.Context.AssemblyResolver.Resolve(module.CorLibTypes.AssemblyRef, module);
			if (corLibAsm is not null) {
				var type = corLibAsm.Find(nonNestedTypeRef);
				if (type is not null)
					return module.CorLibTypes.AssemblyRef;
			}

			if (modAsm is not null)
				return module.UpdateRowId(new AssemblyRefUser(modAsm));
			return AssemblyRef.CurrentAssembly;
		}
	}

	/// <summary>
	/// Thrown by CustomAttributeReader when it fails to parse a custom attribute blob
	/// </summary>
	[Serializable]
	public class CABlobParserException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public CABlobParserException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		public CABlobParserException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		/// <param name="innerException">Other exception</param>
		public CABlobParserException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected CABlobParserException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Reads custom attributes from the #Blob stream
	/// </summary>
	public struct CustomAttributeReader {
		readonly ModuleDef module;
		DataReader reader;
		readonly uint caBlobOffset;
		readonly GenericParamContext gpContext;
		GenericArguments genericArguments;
		RecursionCounter recursionCounter;
		bool verifyReadAllBytes;

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="offset">Offset of custom attribute in the #Blob stream</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDefMD readerModule, ICustomAttributeType ctor, uint offset) => Read(readerModule, ctor, offset, new GenericParamContext());

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="offset">Offset of custom attribute in the #Blob stream</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDefMD readerModule, ICustomAttributeType ctor, uint offset, GenericParamContext gpContext) {
			var caReader = new CustomAttributeReader(readerModule, offset, gpContext);
			try {
				if (ctor is null)
					return caReader.CreateRaw(ctor);
				return caReader.Read(ctor);
			}
			catch (CABlobParserException) {
				return caReader.CreateRaw(ctor);
			}
			catch (IOException) {
				return caReader.CreateRaw(ctor);
			}
		}

		CustomAttribute CreateRaw(ICustomAttributeType ctor) => new CustomAttribute(ctor, GetRawBlob());

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="caBlob">CA blob</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDef module, byte[] caBlob, ICustomAttributeType ctor) =>
			Read(module, ByteArrayDataReaderFactory.CreateReader(caBlob), ctor, new GenericParamContext());

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">A reader positioned at the the first byte of the CA blob</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDef module, DataReader reader, ICustomAttributeType ctor) =>
			Read(module, ref reader, ctor, new GenericParamContext());

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="caBlob">CA blob</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDef module, byte[] caBlob, ICustomAttributeType ctor, GenericParamContext gpContext) =>
			Read(module, ByteArrayDataReaderFactory.CreateReader(caBlob), ctor, gpContext);

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">A stream positioned at the the first byte of the CA blob</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		public static CustomAttribute Read(ModuleDef module, DataReader reader, ICustomAttributeType ctor, GenericParamContext gpContext) =>
			Read(module, ref reader, ctor, gpContext);

		/// <summary>
		/// Reads a custom attribute
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">A stream positioned at the the first byte of the CA blob</param>
		/// <param name="ctor">Custom attribute constructor</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance</returns>
		static CustomAttribute Read(ModuleDef module, ref DataReader reader, ICustomAttributeType ctor, GenericParamContext gpContext) {
			var caReader = new CustomAttributeReader(module, ref reader, gpContext);
			CustomAttribute ca;
			try {
				if (ctor is null)
					ca = caReader.CreateRaw(ctor);
				else
					ca = caReader.Read(ctor);
			}
			catch (CABlobParserException) {
				ca = caReader.CreateRaw(ctor);
			}
			catch (IOException) {
				ca = caReader.CreateRaw(ctor);
			}
			return ca;
		}

		/// <summary>
		/// Reads custom attribute named arguments
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">A reader positioned at the the first byte of the CA blob</param>
		/// <param name="numNamedArgs">Number of named arguments to read from <paramref name="reader"/></param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A list of <see cref="CANamedArgument"/>s or <c>null</c> if some error
		/// occurred.</returns>
		internal static List<CANamedArgument> ReadNamedArguments(ModuleDef module, ref DataReader reader, int numNamedArgs, GenericParamContext gpContext) {
			try {
				var caReader = new CustomAttributeReader(module, ref reader, gpContext);
				var namedArgs = caReader.ReadNamedArguments(numNamedArgs);
				reader.CurrentOffset = caReader.reader.CurrentOffset;
				return namedArgs;
			}
			catch (CABlobParserException) {
				return null;
			}
			catch (IOException) {
				return null;
			}
		}

		CustomAttributeReader(ModuleDefMD readerModule, uint offset, GenericParamContext gpContext) {
			module = readerModule;
			caBlobOffset = offset;
			reader = readerModule.BlobStream.CreateReader(offset);
			genericArguments = null;
			recursionCounter = new RecursionCounter();
			verifyReadAllBytes = false;
			this.gpContext = gpContext;
		}

		CustomAttributeReader(ModuleDef module, ref DataReader reader, GenericParamContext gpContext) {
			this.module = module;
			caBlobOffset = 0;
			this.reader = reader;
			genericArguments = null;
			recursionCounter = new RecursionCounter();
			verifyReadAllBytes = false;
			this.gpContext = gpContext;
		}

		byte[] GetRawBlob() => reader.ToArray();

		CustomAttribute Read(ICustomAttributeType ctor) {
			var methodSig = ctor?.MethodSig;
			if (methodSig is null)
				throw new CABlobParserException("ctor is null or not a method");

			if (ctor is MemberRef mrCtor && mrCtor.Class is TypeSpec owner && owner.TypeSig is GenericInstSig gis) {
				genericArguments = new GenericArguments();
				genericArguments.PushTypeArgs(gis.GenericArguments);
			}

			var methodSigParams = methodSig.Params;
			bool isEmpty = methodSigParams.Count == 0 && reader.Position == reader.Length;
			if (!isEmpty && reader.ReadUInt16() != 1)
				throw new CABlobParserException("Invalid CA blob prolog");

			var ctorArgs = new List<CAArgument>(methodSigParams.Count);
			int count = methodSigParams.Count;
			for (int i = 0; i < count; i++)
				ctorArgs.Add(ReadFixedArg(FixTypeSig(methodSigParams[i])));

			// Some tools don't write the next ushort if there are no named arguments.
			int numNamedArgs = reader.Position == reader.Length ? 0 : reader.ReadUInt16();
			var namedArgs = ReadNamedArguments(numNamedArgs);

			// verifyReadAllBytes will be set when we guess the underlying type of an enum.
			// To make sure we guessed right, verify that we read all bytes.
			if (verifyReadAllBytes && reader.Position != reader.Length)
				throw new CABlobParserException("Not all CA blob bytes were read");

			return new CustomAttribute(ctor, ctorArgs, namedArgs, caBlobOffset);
		}

		List<CANamedArgument> ReadNamedArguments(int numNamedArgs) {
			var namedArgs = new List<CANamedArgument>(numNamedArgs);
			for (int i = 0; i < numNamedArgs; i++) {
				if (reader.Position == reader.Length)
					break;
				namedArgs.Add(ReadNamedArgument());
			}
			return namedArgs;
		}

		TypeSig FixTypeSig(TypeSig type) => SubstituteGenericParameter(type.RemoveModifiers()).RemoveModifiers();

		TypeSig SubstituteGenericParameter(TypeSig type) {
			if (genericArguments is null)
				return type;
			return genericArguments.Resolve(type);
		}

		CAArgument ReadFixedArg(TypeSig argType) {
			if (!recursionCounter.Increment())
				throw new CABlobParserException("Too much recursion");
			if (argType is null)
				throw new CABlobParserException("null argType");
			CAArgument result;

			if (argType is SZArraySig arrayType)
				result = ReadArrayArgument(arrayType);
			else
				result = ReadElem(argType);

			recursionCounter.Decrement();
			return result;
		}

		CAArgument ReadElem(TypeSig argType) {
			if (argType is null)
				throw new CABlobParserException("null argType");
			var value = ReadValue((SerializationType)argType.ElementType, argType, out var realArgType);
			if (realArgType is null)
				throw new CABlobParserException("Invalid arg type");

			// One example when this is true is when prop/field type is object and
			// value type is string[]
			if (value is CAArgument)
				return (CAArgument)value;

			return new CAArgument(realArgType, value);
		}

		object ReadValue(SerializationType etype, TypeSig argType, out TypeSig realArgType) {
			if (!recursionCounter.Increment())
				throw new CABlobParserException("Too much recursion");

			object result;
			switch (etype) {
			case SerializationType.Boolean:
				realArgType = module.CorLibTypes.Boolean;
				result = reader.ReadByte() != 0;
				break;

			case SerializationType.Char:
				realArgType = module.CorLibTypes.Char;
				result = reader.ReadChar();
				break;

			case SerializationType.I1:
				realArgType = module.CorLibTypes.SByte;
				result = reader.ReadSByte();
				break;

			case SerializationType.U1:
				realArgType = module.CorLibTypes.Byte;
				result = reader.ReadByte();
				break;

			case SerializationType.I2:
				realArgType = module.CorLibTypes.Int16;
				result = reader.ReadInt16();
				break;

			case SerializationType.U2:
				realArgType = module.CorLibTypes.UInt16;
				result = reader.ReadUInt16();
				break;

			case SerializationType.I4:
				realArgType = module.CorLibTypes.Int32;
				result = reader.ReadInt32();
				break;

			case SerializationType.U4:
				realArgType = module.CorLibTypes.UInt32;
				result = reader.ReadUInt32();
				break;

			case SerializationType.I8:
				realArgType = module.CorLibTypes.Int64;
				result = reader.ReadInt64();
				break;

			case SerializationType.U8:
				realArgType = module.CorLibTypes.UInt64;
				result = reader.ReadUInt64();
				break;

			case SerializationType.R4:
				realArgType = module.CorLibTypes.Single;
				result = reader.ReadSingle();
				break;

			case SerializationType.R8:
				realArgType = module.CorLibTypes.Double;
				result = reader.ReadDouble();
				break;

			case SerializationType.String:
				realArgType = module.CorLibTypes.String;
				result = ReadUTF8String();
				break;

			// It's ET.ValueType if it's eg. a ctor enum arg type
			case (SerializationType)ElementType.ValueType:
				if (argType is null)
					throw new CABlobParserException("Invalid element type");
				realArgType = argType;
				result = ReadEnumValue(GetEnumUnderlyingType(argType));
				break;

			// It's ET.Object if it's a ctor object arg type
			case (SerializationType)ElementType.Object:
			case SerializationType.TaggedObject:
				realArgType = ReadFieldOrPropType();
				var arraySig = realArgType as SZArraySig;
				if (arraySig is not null)
					result = ReadArrayArgument(arraySig);
				else
					result = ReadValue((SerializationType)realArgType.ElementType, realArgType, out var tmpType);
				break;

			// It's ET.Class if it's eg. a ctor System.Type arg type
			case (SerializationType)ElementType.Class:
				var tdr = argType as TypeDefOrRefSig;
				if (tdr is not null && tdr.DefinitionAssembly.IsCorLib() && tdr.Namespace == "System") {
					if (tdr.TypeName == "Type") {
						result = ReadValue(SerializationType.Type, tdr, out realArgType);
						break;
					}
					if (tdr.TypeName == "String") {
						result = ReadValue(SerializationType.String, tdr, out realArgType);
						break;
					}
					if (tdr.TypeName == "Object") {
						result = ReadValue(SerializationType.TaggedObject, tdr, out realArgType);
						break;
					}
				}

				// Assume it's an enum that couldn't be resolved
				realArgType = argType;
				result = ReadEnumValue(null);
				break;

			case SerializationType.Type:
				realArgType = argType;
				result = ReadType(true);
				break;

			case SerializationType.Enum:
				realArgType = ReadType(false);
				result = ReadEnumValue(GetEnumUnderlyingType(realArgType));
				break;

			default:
				throw new CABlobParserException("Invalid element type");
			}

			recursionCounter.Decrement();
			return result;
		}

		object ReadEnumValue(TypeSig underlyingType) {
			if (underlyingType is not null) {
				if (underlyingType.ElementType < ElementType.Boolean || underlyingType.ElementType > ElementType.U8)
					throw new CABlobParserException("Invalid enum underlying type");
				return ReadValue((SerializationType)underlyingType.ElementType, underlyingType, out var realArgType);
			}

			// We couldn't resolve the type ref. It should be an enum, but we don't know for sure.
			// Most enums use Int32 as the underlying type. Assume that's true also in this case.
			// Since we're guessing, verify that we've read all CA blob bytes. If we haven't, then
			// we probably guessed wrong.
			verifyReadAllBytes = true;
			return reader.ReadInt32();
		}

		TypeSig ReadType(bool canReturnNull) {
			var name = ReadUTF8String();
			if (canReturnNull && name is null)
				return null;
			var asmRefFinder = new CAAssemblyRefFinder(module);
			var type = TypeNameParser.ParseAsTypeSigReflection(module, UTF8String.ToSystemStringOrEmpty(name), asmRefFinder, gpContext);
			if (type is null)
				throw new CABlobParserException("Could not parse type");
			return type;
		}

		/// <summary>
		/// Gets the enum's underlying type
		/// </summary>
		/// <param name="type">An enum type</param>
		/// <returns>The underlying type or <c>null</c> if we couldn't resolve the type ref</returns>
		/// <exception cref="CABlobParserException">If <paramref name="type"/> is not an enum or <c>null</c></exception>
		static TypeSig GetEnumUnderlyingType(TypeSig type) {
			if (type is null)
				throw new CABlobParserException("null enum type");
			var td = GetTypeDef(type);
			if (td is null)
				return null;
			if (!td.IsEnum)
				throw new CABlobParserException("Not an enum");
			return td.GetEnumUnderlyingType().RemoveModifiers();
		}

		/// <summary>
		/// Converts <paramref name="type"/> to a <see cref="TypeDef"/>, possibly resolving
		/// a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if we couldn't resolve the
		/// <see cref="TypeRef"/> or if <paramref name="type"/> is a type spec</returns>
		static TypeDef GetTypeDef(TypeSig type) {
			if (type is TypeDefOrRefSig tdr) {
				var td = tdr.TypeDef;
				if (td is not null)
					return td;

				var tr = tdr.TypeRef;
				if (tr is not null)
					return tr.Resolve();
			}

			return null;
		}

		CAArgument ReadArrayArgument(SZArraySig arrayType) {
			if (!recursionCounter.Increment())
				throw new CABlobParserException("Too much recursion");
			var arg = new CAArgument(arrayType);

			int arrayCount = reader.ReadInt32();
			if (arrayCount == -1) {	// -1 if it's null
			}
			else if (arrayCount < 0)
				throw new CABlobParserException("Array is too big");
			else {
				var array = new List<CAArgument>(arrayCount);
				arg.Value = array;
				for (int i = 0; i < arrayCount; i++)
					array.Add(ReadFixedArg(FixTypeSig(arrayType.Next)));
			}

			recursionCounter.Decrement();
			return arg;
		}

		CANamedArgument ReadNamedArgument() {
			var isField = (SerializationType)reader.ReadByte() switch {
				SerializationType.Property => false,
				SerializationType.Field => true,
				_ => throw new CABlobParserException("Named argument is not a field/property"),
			};
			var fieldPropType = ReadFieldOrPropType();
			var name = ReadUTF8String();
			var argument = ReadFixedArg(fieldPropType);

			return new CANamedArgument(isField, fieldPropType, name, argument);
		}

		TypeSig ReadFieldOrPropType() {
			if (!recursionCounter.Increment())
				throw new CABlobParserException("Too much recursion");
			var result = (SerializationType)reader.ReadByte() switch {
				SerializationType.Boolean => module.CorLibTypes.Boolean,
				SerializationType.Char => module.CorLibTypes.Char,
				SerializationType.I1 => module.CorLibTypes.SByte,
				SerializationType.U1 => module.CorLibTypes.Byte,
				SerializationType.I2 => module.CorLibTypes.Int16,
				SerializationType.U2 => module.CorLibTypes.UInt16,
				SerializationType.I4 => module.CorLibTypes.Int32,
				SerializationType.U4 => module.CorLibTypes.UInt32,
				SerializationType.I8 => module.CorLibTypes.Int64,
				SerializationType.U8 => module.CorLibTypes.UInt64,
				SerializationType.R4 => module.CorLibTypes.Single,
				SerializationType.R8 => module.CorLibTypes.Double,
				SerializationType.String => module.CorLibTypes.String,
				SerializationType.SZArray => new SZArraySig(ReadFieldOrPropType()),
				SerializationType.Type => new ClassSig(module.CorLibTypes.GetTypeRef("System", "Type")),
				SerializationType.TaggedObject => module.CorLibTypes.Object,
				SerializationType.Enum => ReadType(false),
				_ => throw new CABlobParserException("Invalid type"),
			};
			recursionCounter.Decrement();
			return result;
		}

		UTF8String ReadUTF8String() {
			if (reader.ReadByte() == 0xFF)
				return null;
			reader.Position--;
			if (!reader.TryReadCompressedUInt32(out uint len))
				throw new CABlobParserException("Could not read compressed UInt32");
			if (len == 0)
				return UTF8String.Empty;
			return new UTF8String(reader.ReadBytes((int)len));
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the DeclSecurity table
	/// </summary>
	[DebuggerDisplay("{Action} Count={SecurityAttributes.Count}")]
	public abstract class DeclSecurity : IHasCustomAttribute, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.DeclSecurity, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 8;

		/// <summary>
		/// From column DeclSecurity.Action
		/// </summary>
		public SecurityAction Action {
			get => action;
			set => action = value;
		}
		/// <summary/>
		protected SecurityAction action;

		/// <summary>
		/// From column DeclSecurity.PermissionSet
		/// </summary>
		public IList<SecurityAttribute> SecurityAttributes {
			get {
				if (securityAttributes is null)
					InitializeSecurityAttributes();
				return securityAttributes;
			}
		}
		/// <summary/>
		protected IList<SecurityAttribute> securityAttributes;
		/// <summary>Initializes <see cref="securityAttributes"/></summary>
		protected virtual void InitializeSecurityAttributes() =>
			Interlocked.CompareExchange(ref securityAttributes, new List<SecurityAttribute>(), null);

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 8;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// <c>true</c> if <see cref="SecurityAttributes"/> is not empty
		/// </summary>
		public bool HasSecurityAttributes => SecurityAttributes.Count > 0;

		/// <summary>
		/// Gets the blob data or <c>null</c> if there's none
		/// </summary>
		/// <returns>Blob data or <c>null</c></returns>
		public abstract byte[] GetBlob();

		/// <summary>
		/// Returns the .NET Framework 1.x XML string or null if it's not a .NET Framework 1.x format
		/// </summary>
		/// <returns></returns>
		public string GetNet1xXmlString() => GetNet1xXmlStringInternal(SecurityAttributes);

		internal static string GetNet1xXmlStringInternal(IList<SecurityAttribute> secAttrs) {
			if (secAttrs is null || secAttrs.Count != 1)
				return null;
			var sa = secAttrs[0];
			if (sa is null || sa.TypeFullName != "System.Security.Permissions.PermissionSetAttribute")
				return null;
			if (sa.NamedArguments.Count != 1)
				return null;
			var na = sa.NamedArguments[0];
			if (na is null || !na.IsProperty || na.Name != "XML")
				return null;
			if (na.ArgumentType.GetElementType() != ElementType.String)
				return null;
			var arg = na.Argument;
			if (arg.Type.GetElementType() != ElementType.String)
				return null;
			var utf8 = arg.Value as UTF8String;
			if (utf8 is not null)
				return utf8;
			if (arg.Value is string s)
				return s;
			return null;
		}
	}

	/// <summary>
	/// A DeclSecurity row created by the user and not present in the original .NET file
	/// </summary>
	public class DeclSecurityUser : DeclSecurity {
		/// <summary>
		/// Default constructor
		/// </summary>
		public DeclSecurityUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="action">The security action</param>
		/// <param name="securityAttrs">The security attributes (now owned by this)</param>
		public DeclSecurityUser(SecurityAction action, IList<SecurityAttribute> securityAttrs) {
			this.action = action;
			securityAttributes = securityAttrs;
		}

		/// <inheritdoc/>
		public override byte[] GetBlob() => null;
	}

	/// <summary>
	/// Created from a row in the DeclSecurity table
	/// </summary>
	sealed class DeclSecurityMD : DeclSecurity, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly uint permissionSet;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeSecurityAttributes() {
			var gpContext = new GenericParamContext();
			var tmp = DeclSecurityReader.Read(readerModule, permissionSet, gpContext);
			Interlocked.CompareExchange(ref securityAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.DeclSecurity, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			var gpContext = new GenericParamContext();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>DeclSecurity</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public DeclSecurityMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.DeclSecurityTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"DeclSecurity rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadDeclSecurityRow(origRid, out var row);
			Debug.Assert(b);
			permissionSet = row.PermissionSet;
			action = (SecurityAction)row.Action;
		}

		/// <inheritdoc/>
		public override byte[] GetBlob() => readerModule.BlobStream.Read(permissionSet);
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Reads <c>DeclSecurity</c> blobs
	/// </summary>
	public struct DeclSecurityReader {
		DataReader reader;
		readonly ModuleDef module;
		readonly GenericParamContext gpContext;

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="sig"><c>#Blob</c> offset of <c>DeclSecurity</c> signature</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static IList<SecurityAttribute> Read(ModuleDefMD module, uint sig) => Read(module, module.BlobStream.CreateReader(sig), new GenericParamContext());

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="sig"><c>#Blob</c> offset of <c>DeclSecurity</c> signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static IList<SecurityAttribute> Read(ModuleDefMD module, uint sig, GenericParamContext gpContext) => Read(module, module.BlobStream.CreateReader(sig), gpContext);

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="blob"><c>DeclSecurity</c> blob</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static IList<SecurityAttribute> Read(ModuleDef module, byte[] blob) => Read(module, ByteArrayDataReaderFactory.CreateReader(blob), new GenericParamContext());

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="blob"><c>DeclSecurity</c> blob</param>
		/// <param name="gpContext">Generic parameter context</param>/// 
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static IList<SecurityAttribute> Read(ModuleDef module, byte[] blob, GenericParamContext gpContext) => Read(module, ByteArrayDataReaderFactory.CreateReader(blob), gpContext);

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="signature"><c>DeclSecurity</c> stream that will be owned by us</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static IList<SecurityAttribute> Read(ModuleDef module, DataReader signature) => Read(module, signature, new GenericParamContext());

		/// <summary>
		/// Reads a <c>DeclSecurity</c> blob
		/// </summary>
		/// <param name="module">Module that will own the returned list</param>
		/// <param name="signature"><c>DeclSecurity</c> stream that will be owned by us</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A list of <see cref="SecurityAttribute"/>s</returns>
		public static IList<SecurityAttribute> Read(ModuleDef module, DataReader signature, GenericParamContext gpContext) {
			var reader = new DeclSecurityReader(module, signature, gpContext);
			return reader.Read();
		}

		DeclSecurityReader(ModuleDef module, DataReader reader, GenericParamContext gpContext) {
			this.reader = reader;
			this.module = module;
			this.gpContext = gpContext;
		}

		IList<SecurityAttribute> Read() {
			try {
				if (reader.Position >= reader.Length)
					return new List<SecurityAttribute>();

				if (reader.ReadByte() == '.')
					return ReadBinaryFormat();
				reader.Position--;
				return ReadXmlFormat();
			}
			catch {
				return new List<SecurityAttribute>();
			}
		}

		/// <summary>
		/// Reads the new (.NET Framework 2.0+) DeclSecurity blob format
		/// </summary>
		/// <returns></returns>
		IList<SecurityAttribute> ReadBinaryFormat() {
			int numAttrs = (int)reader.ReadCompressedUInt32();
			var list = new List<SecurityAttribute>(numAttrs);

			for (int i = 0; i < numAttrs; i++) {
				var name = ReadUTF8String();
				// Use CA search rules. Some tools don't write the fully qualified name.
				var attrRef = TypeNameParser.ParseReflection(module, UTF8String.ToSystemStringOrEmpty(name), new CAAssemblyRefFinder(module), gpContext);
				/*int blobLength = (int)*/reader.ReadCompressedUInt32();
				int numNamedArgs = (int)reader.ReadCompressedUInt32();
				var namedArgs = CustomAttributeReader.ReadNamedArguments(module, ref reader, numNamedArgs, gpContext);
				if (namedArgs is null)
					throw new ApplicationException("Could not read named arguments");
				list.Add(new SecurityAttribute(attrRef, namedArgs));
			}

			return list;
		}

		/// <summary>
		/// Reads the old (.NET Framework 1.x) DeclSecurity blob format
		/// </summary>
		/// <returns></returns>
		IList<SecurityAttribute> ReadXmlFormat() {
			var xml = reader.ReadUtf16String((int)reader.Length / 2);
			var sa = SecurityAttribute.CreateFromXml(module, xml);
			return new List<SecurityAttribute> { sa };
		}

		UTF8String ReadUTF8String() {
			uint len = reader.ReadCompressedUInt32();
			return len == 0 ? UTF8String.Empty : new UTF8String(reader.ReadBytes((int)len));
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// See CorHdr.h/CorElementType
	/// </summary>
	public enum ElementType : byte {
		/// <summary/>
		End			= 0x00,
		/// <summary>System.Void</summary>
		Void		= 0x01,
		/// <summary>System.Boolean</summary>
		Boolean		= 0x02,
		/// <summary>System.Char</summary>
		Char		= 0x03,
		/// <summary>System.SByte</summary>
		I1			= 0x04,
		/// <summary>System.Byte</summary>
		U1 			= 0x05,
		/// <summary>System.Int16</summary>
		I2 			= 0x06,
		/// <summary>System.UInt16</summary>
		U2 			= 0x07,
		/// <summary>System.Int32</summary>
		I4 			= 0x08,
		/// <summary>System.UInt32</summary>
		U4			= 0x09,
		/// <summary>System.Int64</summary>
		I8			= 0x0A,
		/// <summary>System.UInt64</summary>
		U8			= 0x0B,
		/// <summary>System.Single</summary>
		R4			= 0x0C,
		/// <summary>System.Double</summary>
		R8			= 0x0D,
		/// <summary>System.String</summary>
		String		= 0x0E,
		/// <summary>Pointer type (*)</summary>
		Ptr			= 0x0F,
		/// <summary>ByRef type (&amp;)</summary>
		ByRef		= 0x10,
		/// <summary>Value type</summary>
		ValueType	= 0x11,
		/// <summary>Reference type</summary>
		Class		= 0x12,
		/// <summary>Type generic parameter</summary>
		Var			= 0x13,
		/// <summary>Multidimensional array ([*], [,], [,,], ...)</summary>
		Array		= 0x14,
		/// <summary>Generic instance type</summary>
		GenericInst	= 0x15,
		/// <summary>Typed byref</summary>
		TypedByRef	= 0x16,
		/// <summary>Value array (don't use)</summary>
		ValueArray	= 0x17,
		/// <summary>System.IntPtr</summary>
		I			= 0x18,
		/// <summary>System.UIntPtr</summary>
		U			= 0x19,
		/// <summary>native real (don't use)</summary>
		R			= 0x1A,
		/// <summary>Function pointer</summary>
		FnPtr		= 0x1B,
		/// <summary>System.Object</summary>
		Object		= 0x1C,
		/// <summary>Single-dimension, zero lower bound array ([])</summary>
		SZArray		= 0x1D,
		/// <summary>Method generic parameter</summary>
		MVar		= 0x1E,
		/// <summary>Required C modifier</summary>
		CModReqd	= 0x1F,
		/// <summary>Optional C modifier</summary>
		CModOpt		= 0x20,
		/// <summary>Used internally by the CLR (don't use)</summary>
		Internal	= 0x21,
		/// <summary>Module (don't use)</summary>
		Module		= 0x3F,
		/// <summary>Sentinel (method sigs only)</summary>
		Sentinel	= 0x41,
		/// <summary>Pinned type (locals only)</summary>
		Pinned		= 0x45,
	}

	public static partial class Extensions {
		/// <summary>
		/// Returns <c>true</c> if it's an integer or a floating point type
		/// </summary>
		/// <param name="etype">Element type</param>
		/// <returns></returns>
		public static bool IsPrimitive(this ElementType etype) {
			switch (etype) {
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.I:
			case ElementType.U:
			case ElementType.R:
				return true;

			default:
				return false;
			}
		}

		/// <summary>
		/// Returns the size of the element type in bytes or <c>-1</c> if it's unknown
		/// </summary>
		/// <param name="etype">Element type</param>
		/// <param name="ptrSize">Size of a pointer</param>
		/// <returns></returns>
		public static int GetPrimitiveSize(this ElementType etype, int ptrSize = -1) {
			switch (etype) {
			case ElementType.Boolean:
			case ElementType.I1:
			case ElementType.U1:
				return 1;

			case ElementType.Char:
			case ElementType.I2:
			case ElementType.U2:
				return 2;

			case ElementType.I4:
			case ElementType.U4:
			case ElementType.R4:
				return 4;

			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R8:
				return 8;

			case ElementType.Ptr:
			case ElementType.FnPtr:
			case ElementType.I:
			case ElementType.U:
				return ptrSize;

			default:
				return -1;
			}
		}

		/// <summary>
		/// Checks whether it's a value type
		/// </summary>
		/// <param name="etype">this</param>
		/// <returns><c>true</c> if it's a value type, <c>false</c> if it's not a value type or
		/// if we couldn't determine whether it's a value type. Eg., it could be a generic
		/// instance type.</returns>
		public static bool IsValueType(this ElementType etype) {
			switch (etype) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.ValueType:
			case ElementType.TypedByRef:
			case ElementType.ValueArray:
			case ElementType.I:
			case ElementType.U:
			case ElementType.R:
				return true;

			case ElementType.GenericInst:
				// We don't have enough info to determine whether this is a value type
				return false;

			case ElementType.End:
			case ElementType.String:
			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Class:
			case ElementType.Var:
			case ElementType.Array:
			case ElementType.FnPtr:
			case ElementType.Object:
			case ElementType.SZArray:
			case ElementType.MVar:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Internal:
			case ElementType.Module:
			case ElementType.Sentinel:
			case ElementType.Pinned:
			default:
				return false;
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Event attributes, see CorHdr.h/CorEventAttr
	/// </summary>
	[Flags]
	public enum EventAttributes : ushort {
		/// <summary>event is special.  Name describes how.</summary>
		SpecialName			= 0x0200,
		/// <summary>Runtime(metadata internal APIs) should check name encoding.</summary>
		RTSpecialName		= 0x0400,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Event table
	/// </summary>
	public abstract class EventDef : IHasCustomAttribute, IHasSemantic, IHasCustomDebugInformation, IFullName, IMemberDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.Event, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 10;

		/// <inheritdoc/>
		public int HasSemanticTag => 0;

		/// <summary>
		/// From column Event.EventFlags
		/// </summary>
		public EventAttributes Attributes {
			get => (EventAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary/>
		protected int attributes;

		/// <summary>
		/// From column Event.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Event.EventType
		/// </summary>
		public ITypeDefOrRef EventType {
			get => eventType;
			set => eventType = value;
		}
		/// <summary/>
		protected ITypeDefOrRef eventType;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 10;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// Gets/sets the adder method
		/// </summary>
		public MethodDef AddMethod {
			get {
				if (otherMethods is null)
					InitializeEventMethods();
				return addMethod;
			}
			set {
				if (otherMethods is null)
					InitializeEventMethods();
				addMethod = value;
			}
		}

		/// <summary>
		/// Gets/sets the invoker method
		/// </summary>
		public MethodDef InvokeMethod {
			get {
				if (otherMethods is null)
					InitializeEventMethods();
				return invokeMethod;
			}
			set {
				if (otherMethods is null)
					InitializeEventMethods();
				invokeMethod = value;
			}
		}

		/// <summary>
		/// Gets/sets the remover method
		/// </summary>
		public MethodDef RemoveMethod {
			get {
				if (otherMethods is null)
					InitializeEventMethods();
				return removeMethod;
			}
			set {
				if (otherMethods is null)
					InitializeEventMethods();
				removeMethod = value;
			}
		}

		/// <summary>
		/// Gets the other methods
		/// </summary>
		public IList<MethodDef> OtherMethods {
			get {
				if (otherMethods is null)
					InitializeEventMethods();
				return otherMethods;
			}
		}

		void InitializeEventMethods() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (otherMethods is null)
				InitializeEventMethods_NoLock();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Initializes <see cref="otherMethods"/>, <see cref="addMethod"/>,
		/// <see cref="invokeMethod"/> and <see cref="removeMethod"/>.
		/// </summary>
		protected virtual void InitializeEventMethods_NoLock() =>
			otherMethods = new List<MethodDef>();

		/// <summary/>
		protected MethodDef addMethod;
		/// <summary/>
		protected MethodDef invokeMethod;
		/// <summary/>
		protected MethodDef removeMethod;
		/// <summary/>
		protected IList<MethodDef> otherMethods;

		/// <summary>Reset <see cref="AddMethod"/>, <see cref="InvokeMethod"/>, <see cref="RemoveMethod"/>, <see cref="OtherMethods"/></summary>
		protected void ResetMethods() => otherMethods = null;

		/// <summary>
		/// <c>true</c> if there are no methods attached to this event
		/// </summary>
		public bool IsEmpty =>
			// The first property access initializes the other fields we access here
			AddMethod is null &&
			removeMethod is null &&
			invokeMethod is null &&
			otherMethods.Count == 0;

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <summary>
		/// <c>true</c> if <see cref="OtherMethods"/> is not empty
		/// </summary>
		public bool HasOtherMethods => OtherMethods.Count > 0;

		/// <summary>
		/// Gets/sets the declaring type (owner type)
		/// </summary>
		public TypeDef DeclaringType {
			get => declaringType2;
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType is not null)
					currentDeclaringType.Events.Remove(this);	// Will set DeclaringType2 = null
				if (value is not null)
					value.Events.Add(this);	// Will set DeclaringType2 = value
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType => declaringType2;

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get => declaringType2;
			set => declaringType2 = value;
		}
		/// <summary/>
		protected TypeDef declaringType2;

		/// <inheritdoc/>
		public ModuleDef Module => declaringType2?.Module;

		/// <summary>
		/// Gets the full name of the event
		/// </summary>
		public string FullName => FullNameFactory.EventFullName(declaringType2?.FullName, name, eventType, null, null);

		bool IIsTypeOrMethod.IsType => false;
		bool IIsTypeOrMethod.IsMethod => false;
		bool IMemberRef.IsField => false;
		bool IMemberRef.IsTypeSpec => false;
		bool IMemberRef.IsTypeRef => false;
		bool IMemberRef.IsTypeDef => false;
		bool IMemberRef.IsMethodSpec => false;
		bool IMemberRef.IsMethodDef => false;
		bool IMemberRef.IsMemberRef => false;
		bool IMemberRef.IsFieldDef => false;
		bool IMemberRef.IsPropertyDef => false;
		bool IMemberRef.IsEventDef => true;
		bool IMemberRef.IsGenericParam => false;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, EventAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the <see cref="EventAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get => ((EventAttributes)attributes & EventAttributes.SpecialName) != 0;
			set => ModifyAttributes(value, EventAttributes.SpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="EventAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get => ((EventAttributes)attributes & EventAttributes.RTSpecialName) != 0;
			set => ModifyAttributes(value, EventAttributes.RTSpecialName);
		}

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// An Event row created by the user and not present in the original .NET file
	/// </summary>
	public class EventDefUser : EventDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public EventDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public EventDefUser(UTF8String name)
			: this(name, null, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="type">Type</param>
		public EventDefUser(UTF8String name, ITypeDefOrRef type)
			: this(name, type, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="type">Type</param>
		/// <param name="flags">Flags</param>
		public EventDefUser(UTF8String name, ITypeDefOrRef type, EventAttributes flags) {
			this.name = name;
			eventType = type;
			attributes = (int)flags;
		}
	}

	/// <summary>
	/// Created from a row in the Event table
	/// </summary>
	sealed class EventDefMD : EventDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.Event, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(declaringType2), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Event</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public EventDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.EventTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"Event rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadEventRow(origRid, out var row);
			Debug.Assert(b);
			attributes = row.EventFlags;
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			declaringType2 = readerModule.GetOwnerType(this);
			eventType = readerModule.ResolveTypeDefOrRef(row.EventType, new GenericParamContext(declaringType2));
		}

		internal EventDefMD InitializeAll() {
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(EventType);
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(AddMethod);
			MemberMDInitializer.Initialize(InvokeMethod);
			MemberMDInitializer.Initialize(RemoveMethod);
			MemberMDInitializer.Initialize(OtherMethods);
			MemberMDInitializer.Initialize(DeclaringType);
			return this;
		}

		/// <inheritdoc/>
		protected override void InitializeEventMethods_NoLock() {
			IList<MethodDef> newOtherMethods;
			var dt = declaringType2 as TypeDefMD;
			if (dt is null)
				newOtherMethods = new List<MethodDef>();
			else
				dt.InitializeEvent(this, out addMethod, out invokeMethod, out removeMethod, out newOtherMethods);
			otherMethods = newOtherMethods;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ExportedType table
	/// </summary>
	public abstract class ExportedType : IHasCustomAttribute, IImplementation, IHasCustomDebugInformation, IType {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// The owner module
		/// </summary>
		protected ModuleDef module;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.ExportedType, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 17;

		/// <inheritdoc/>
		public int ImplementationTag => 2;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 17;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				var td = Resolve();
				return td is not null && td.IsValueType;
			}
		}

		/// <inheritdoc/>
		public bool IsPrimitive => this.IsPrimitive();

		/// <inheritdoc/>
		string IType.TypeName => FullNameFactory.Name(this, false, null);

		/// <inheritdoc/>
		public UTF8String Name {
			get => typeName;
			set => typeName = value;
		}

		/// <inheritdoc/>
		public string ReflectionName => FullNameFactory.Name(this, true, null);

		/// <inheritdoc/>
		public string Namespace => FullNameFactory.Namespace(this, false, null);

		/// <inheritdoc/>
		public string ReflectionNamespace => FullNameFactory.Namespace(this, true, null);

		/// <inheritdoc/>
		public string FullName => FullNameFactory.FullName(this, false, null, null);

		/// <inheritdoc/>
		public string ReflectionFullName => FullNameFactory.FullName(this, true, null, null);

		/// <inheritdoc/>
		public string AssemblyQualifiedName => FullNameFactory.AssemblyQualifiedName(this, null, null);

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly => FullNameFactory.DefinitionAssembly(this);

		/// <inheritdoc/>
		public IScope Scope => FullNameFactory.Scope(this);

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType => FullNameFactory.ScopeType(this);

		/// <summary>
		/// Always returns <c>false</c> since a <see cref="ExportedType"/> does not contain any
		/// <see cref="GenericVar"/> or <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter => false;

		/// <inheritdoc/>
		public ModuleDef Module => module;

		/// <inheritdoc/>
		bool IIsTypeOrMethod.IsMethod => false;

		/// <inheritdoc/>
		bool IIsTypeOrMethod.IsType => true;

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters => 0;

		/// <summary>
		/// From column ExportedType.Flags
		/// </summary>
		public TypeAttributes Attributes {
			get => (TypeAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column ExportedType.TypeDefId
		/// </summary>
		public uint TypeDefId {
			get => typeDefId;
			set => typeDefId = value;
		}
		/// <summary/>
		protected uint typeDefId;

		/// <summary>
		/// From column ExportedType.TypeName
		/// </summary>
		public UTF8String TypeName {
			get => typeName;
			set => typeName = value;
		}
		/// <summary/>
		protected UTF8String typeName;

		/// <summary>
		/// From column ExportedType.TypeNamespace
		/// </summary>
		public UTF8String TypeNamespace {
			get => typeNamespace;
			set => typeNamespace = value;
		}
		/// <summary/>
		protected UTF8String typeNamespace;

		/// <summary>
		/// From column ExportedType.Implementation
		/// </summary>
		public IImplementation Implementation {
			get {
				if (!implementation_isInitialized)
					InitializeImplementation();
				return implementation;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				implementation = value;
				implementation_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected IImplementation implementation;
		/// <summary/>
		protected bool implementation_isInitialized;

		void InitializeImplementation() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (implementation_isInitialized)
				return;
			implementation = GetImplementation_NoLock();
			implementation_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="implementation"/></summary>
		protected virtual IImplementation GetImplementation_NoLock() => null;

		/// <summary>
		/// <c>true</c> if it's nested within another <see cref="ExportedType"/>
		/// </summary>
		public bool IsNested => DeclaringType is not null;

		/// <summary>
		/// Gets the declaring type, if any
		/// </summary>
		public ExportedType DeclaringType {
			get {
				if (!implementation_isInitialized)
					InitializeImplementation();
				return implementation as ExportedType;
			}
		}

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(TypeAttributes andMask, TypeAttributes orMask) =>
			attributes = (attributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, TypeAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the visibility
		/// </summary>
		public TypeAttributes Visibility {
			get => (TypeAttributes)attributes & TypeAttributes.VisibilityMask;
			set => ModifyAttributes(~TypeAttributes.VisibilityMask, value & TypeAttributes.VisibilityMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NotPublic"/> is set
		/// </summary>
		public bool IsNotPublic => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NotPublic;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.Public;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedPublic"/> is set
		/// </summary>
		public bool IsNestedPublic => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPublic;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedPrivate"/> is set
		/// </summary>
		public bool IsNestedPrivate => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamily"/> is set
		/// </summary>
		public bool IsNestedFamily => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamily;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedAssembly"/> is set
		/// </summary>
		public bool IsNestedAssembly => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedAssembly;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamANDAssem"/> is set
		/// </summary>
		public bool IsNestedFamilyAndAssembly => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamANDAssem;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamORAssem"/> is set
		/// </summary>
		public bool IsNestedFamilyOrAssembly => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamORAssem;

		/// <summary>
		/// Gets/sets the layout
		/// </summary>
		public TypeAttributes Layout {
			get => (TypeAttributes)attributes & TypeAttributes.LayoutMask;
			set => ModifyAttributes(~TypeAttributes.LayoutMask, value & TypeAttributes.LayoutMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AutoLayout"/> is set
		/// </summary>
		public bool IsAutoLayout => ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.AutoLayout;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.SequentialLayout"/> is set
		/// </summary>
		public bool IsSequentialLayout => ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.SequentialLayout;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.ExplicitLayout"/> is set
		/// </summary>
		public bool IsExplicitLayout => ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.ExplicitLayout;

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Interface"/> bit
		/// </summary>
		public bool IsInterface {
			get => ((TypeAttributes)attributes & TypeAttributes.Interface) != 0;
			set => ModifyAttributes(value, TypeAttributes.Interface);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Class"/> bit
		/// </summary>
		public bool IsClass {
			get => ((TypeAttributes)attributes & TypeAttributes.Interface) == 0;
			set => ModifyAttributes(!value, TypeAttributes.Interface);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Abstract"/> bit
		/// </summary>
		public bool IsAbstract {
			get => ((TypeAttributes)attributes & TypeAttributes.Abstract) != 0;
			set => ModifyAttributes(value, TypeAttributes.Abstract);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Sealed"/> bit
		/// </summary>
		public bool IsSealed {
			get => ((TypeAttributes)attributes & TypeAttributes.Sealed) != 0;
			set => ModifyAttributes(value, TypeAttributes.Sealed);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get => ((TypeAttributes)attributes & TypeAttributes.SpecialName) != 0;
			set => ModifyAttributes(value, TypeAttributes.SpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Import"/> bit
		/// </summary>
		public bool IsImport {
			get => ((TypeAttributes)attributes & TypeAttributes.Import) != 0;
			set => ModifyAttributes(value, TypeAttributes.Import);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Serializable"/> bit
		/// </summary>
		public bool IsSerializable {
			get => ((TypeAttributes)attributes & TypeAttributes.Serializable) != 0;
			set => ModifyAttributes(value, TypeAttributes.Serializable);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.WindowsRuntime"/> bit
		/// </summary>
		public bool IsWindowsRuntime {
			get => ((TypeAttributes)attributes & TypeAttributes.WindowsRuntime) != 0;
			set => ModifyAttributes(value, TypeAttributes.WindowsRuntime);
		}

		/// <summary>
		/// Gets/sets the string format
		/// </summary>
		public TypeAttributes StringFormat {
			get => (TypeAttributes)attributes & TypeAttributes.StringFormatMask;
			set => ModifyAttributes(~TypeAttributes.StringFormatMask, value & TypeAttributes.StringFormatMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AnsiClass"/> is set
		/// </summary>
		public bool IsAnsiClass => ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.AnsiClass;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.UnicodeClass"/> is set
		/// </summary>
		public bool IsUnicodeClass => ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.UnicodeClass;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AutoClass"/> is set
		/// </summary>
		public bool IsAutoClass => ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.AutoClass;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.CustomFormatClass"/> is set
		/// </summary>
		public bool IsCustomFormatClass => ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.CustomFormatClass;

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.BeforeFieldInit"/> bit
		/// </summary>
		public bool IsBeforeFieldInit {
			get => ((TypeAttributes)attributes & TypeAttributes.BeforeFieldInit) != 0;
			set => ModifyAttributes(value, TypeAttributes.BeforeFieldInit);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Forwarder"/> bit. See also <see cref="MovedToAnotherAssembly"/>
		/// </summary>
		public bool IsForwarder {
			get => ((TypeAttributes)attributes & TypeAttributes.Forwarder) != 0;
			set => ModifyAttributes(value, TypeAttributes.Forwarder);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get => ((TypeAttributes)attributes & TypeAttributes.RTSpecialName) != 0;
			set => ModifyAttributes(value, TypeAttributes.RTSpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.HasSecurity"/> bit
		/// </summary>
		public bool HasSecurity {
			get => ((TypeAttributes)attributes & TypeAttributes.HasSecurity) != 0;
			set => ModifyAttributes(value, TypeAttributes.HasSecurity);
		}

		const int MAX_LOOP_ITERS = 50;

		/// <summary>
		/// <c>true</c> if this type has been moved to another assembly
		/// </summary>
		public bool MovedToAnotherAssembly {
			get {
				var et = this;
				for (int i = 0; i < MAX_LOOP_ITERS; i++) {
					var impl = et.Implementation;
					if (impl is AssemblyRef)
						return et.IsForwarder;

					et = impl as ExportedType;
					if (et is null)
						break;
				}
				return false;
			}
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public TypeDef Resolve() => Resolve(null);

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <param name="sourceModule">Source module or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public TypeDef Resolve(ModuleDef sourceModule) {
			if (module is null)
				return null;

			return Resolve(sourceModule, this);
		}

		static TypeDef Resolve(ModuleDef sourceModule, ExportedType et) {
			for (int i = 0; i < MAX_LOOP_ITERS; i++) {
				if (et is null || et.module is null)
					break;
				var resolver = et.module.Context.AssemblyResolver;
				var etAsm = resolver.Resolve(et.DefinitionAssembly, sourceModule ?? et.module);
				if (etAsm is null)
					break;

				var td = etAsm.Find(et.FullName, false);
				if (td is not null)
					return td;

				et = FindExportedType(etAsm, et);
			}

			return null;
		}

		static ExportedType FindExportedType(AssemblyDef asm, ExportedType et) {
			var modules = asm.Modules;
			int count = modules.Count;
			for (int i = 0; i < count; i++) {
				var mod = modules[i];
				var exportedTypes = mod.ExportedTypes;
				int count2 = exportedTypes.Count;
				for (int j = 0; j < count2; j++) {
					var et2 = exportedTypes[j];
					if (new SigComparer(SigComparerOptions.DontCompareTypeScope).Equals(et, et2))
						return et2;
				}
			}
			return null;
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public TypeDef ResolveThrow() {
			var type = Resolve();
			if (type is not null)
				return type;
			throw new TypeResolveException($"Could not resolve type: {this} ({DefinitionAssembly})");
		}

		/// <summary>
		/// Converts this instance to a <see cref="TypeRef"/>
		/// </summary>
		/// <returns>A new <see cref="TypeRef"/> instance</returns>
		public TypeRef ToTypeRef() {
			TypeRef result = null, prev = null;
			var mod = module;
			IImplementation impl = this;
			for (int i = 0; i < MAX_LOOP_ITERS && impl is not null; i++) {
				if (impl is ExportedType et) {
					var newTr = mod.UpdateRowId(new TypeRefUser(mod, et.TypeNamespace, et.TypeName));
					if (result is null)
						result = newTr;
					if (prev is not null)
						prev.ResolutionScope = newTr;

					prev = newTr;
					impl = et.Implementation;
					continue;
				}

				if (impl is AssemblyRef asmRef) {
					// prev is never null when we're here
					prev.ResolutionScope = asmRef;
					return result;
				}

				if (impl is FileDef file) {
					// prev is never null when we're here
					prev.ResolutionScope = FindModule(mod, file);
					return result;
				}

				break;
			}
			return result;
		}

		static ModuleDef FindModule(ModuleDef module, FileDef file) {
			if (module is null || file is null)
				return null;
			if (UTF8String.CaseInsensitiveEquals(module.Name, file.Name))
				return module;
			var asm = module.Assembly;
			if (asm is null)
				return null;
			return asm.FindModule(file.Name);
		}

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// An ExportedType row created by the user and not present in the original .NET file
	/// </summary>
	public class ExportedTypeUser : ExportedType {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		public ExportedTypeUser(ModuleDef module) => this.module = module;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="typeDefId">TypeDef ID</param>
		/// <param name="typeName">Type name</param>
		/// <param name="typeNamespace">Type namespace</param>
		/// <param name="flags">Flags</param>
		/// <param name="implementation">Implementation</param>
		public ExportedTypeUser(ModuleDef module, uint typeDefId, UTF8String typeNamespace, UTF8String typeName, TypeAttributes flags, IImplementation implementation) {
			this.module = module;
			this.typeDefId = typeDefId;
			this.typeName = typeName;
			this.typeNamespace = typeNamespace;
			attributes = (int)flags;
			this.implementation = implementation;
			implementation_isInitialized = true;
		}
	}

	/// <summary>
	/// Created from a row in the ExportedType table
	/// </summary>
	sealed class ExportedTypeMD : ExportedType, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly uint implementationRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.ExportedType, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override IImplementation GetImplementation_NoLock() =>
			readerModule.ResolveImplementation(implementationRid);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ExportedType</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ExportedTypeMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ExportedTypeTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"ExportedType rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			module = readerModule;
			bool b = readerModule.TablesStream.TryReadExportedTypeRow(origRid, out var row);
			implementationRid = row.Implementation;
			attributes = (int)row.Flags;
			typeDefId = row.TypeDefId;
			typeName = readerModule.StringsStream.ReadNoNull(row.TypeName);
			typeNamespace = readerModule.StringsStream.ReadNoNull(row.TypeNamespace);
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class Extensions {
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Field flags, see CorHdr.h/CorFieldAttr
	/// </summary>
	[Flags]
	public enum FieldAttributes : ushort {
		/// <summary>member access mask - Use this mask to retrieve accessibility information.</summary>
		FieldAccessMask		= 0x0007,
		/// <summary>Member not referenceable.</summary>
		PrivateScope		= 0x0000,
		/// <summary>Member not referenceable.</summary>
		CompilerControlled	= PrivateScope,
		/// <summary>Accessible only by the parent type.</summary>
		Private				= 0x0001,
		/// <summary>Accessible by sub-types only in this Assembly.</summary>
		FamANDAssem			= 0x0002,
		/// <summary>Accessibly by anyone in the Assembly.</summary>
		Assembly			= 0x0003,
		/// <summary>Accessible only by type and sub-types.</summary>
		Family				= 0x0004,
		/// <summary>Accessibly by sub-types anywhere, plus anyone in assembly.</summary>
		FamORAssem			= 0x0005,
		/// <summary>Accessibly by anyone who has visibility to this scope.</summary>
		Public				= 0x0006,

		/// <summary>Defined on type, else per instance.</summary>
		Static				= 0x0010,
		/// <summary>Field may only be initialized, not written to after init.</summary>
		InitOnly			= 0x0020,
		/// <summary>Value is compile time constant.</summary>
		Literal				= 0x0040,
		/// <summary>Field does not have to be serialized when type is remoted.</summary>
		NotSerialized		= 0x0080,

		/// <summary>field is special.  Name describes how.</summary>
		SpecialName			= 0x0200,

		/// <summary>Implementation is forwarded through pinvoke.</summary>
		PinvokeImpl			= 0x2000,

		/// <summary>Runtime(metadata internal APIs) should check name encoding.</summary>
		RTSpecialName		= 0x0400,
		/// <summary>Field has marshalling information.</summary>
		HasFieldMarshal		= 0x1000,
		/// <summary>Field has default.</summary>
		HasDefault			= 0x8000,
		/// <summary>Field has RVA.</summary>
		HasFieldRVA			= 0x0100,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Field table
	/// </summary>
	public abstract class FieldDef : IHasConstant, IHasCustomAttribute, IHasFieldMarshal, IMemberForwarded, IHasCustomDebugInformation, IField, ITokenOperand, IMemberDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.Field, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasConstantTag => 0;

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 1;

		/// <inheritdoc/>
		public int HasFieldMarshalTag => 0;

		/// <inheritdoc/>
		public int MemberForwardedTag => 0;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 1;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// From column Field.Flags
		/// </summary>
		public FieldAttributes Attributes {
			get => (FieldAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Field.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Field.Signature
		/// </summary>
		public CallingConventionSig Signature {
			get => signature;
			set => signature = value;
		}
		/// <summary/>
		protected CallingConventionSig signature;

		/// <summary>
		/// Gets/sets the field layout offset
		/// </summary>
		public uint? FieldOffset {
			get {
				if (!fieldOffset_isInitialized)
					InitializeFieldOffset();
				return fieldOffset;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				fieldOffset = value;
				fieldOffset_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected uint? fieldOffset;
		/// <summary/>
		protected bool fieldOffset_isInitialized;

		void InitializeFieldOffset() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (fieldOffset_isInitialized)
				return;
			fieldOffset = GetFieldOffset_NoLock();
			fieldOffset_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="fieldOffset"/></summary>
		protected virtual uint? GetFieldOffset_NoLock() => null;

		/// <inheritdoc/>
		public MarshalType MarshalType {
			get {
				if (!marshalType_isInitialized)
					InitializeMarshalType();
				return marshalType;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				marshalType = value;
				marshalType_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected MarshalType marshalType;
		/// <summary/>
		protected bool marshalType_isInitialized;

		void InitializeMarshalType() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (marshalType_isInitialized)
				return;
			marshalType = GetMarshalType_NoLock();
			marshalType_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="marshalType"/></summary>
		protected virtual MarshalType GetMarshalType_NoLock() => null;

		/// <summary>Reset <see cref="MarshalType"/></summary>
		protected void ResetMarshalType() =>
			marshalType_isInitialized = false;

		/// <summary>
		/// Gets/sets the field RVA
		/// </summary>
		public RVA RVA {
			get {
				if (!rva_isInitialized)
					InitializeRVA();
				return rva;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				rva = value;
				rva_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected RVA rva;
		/// <summary/>
		protected bool rva_isInitialized;

		void InitializeRVA() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (rva_isInitialized)
				return;
			rva = GetRVA_NoLock();
			rva_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="rva"/></summary>
		protected virtual RVA GetRVA_NoLock() => 0;

		/// <summary>Reset <see cref="RVA"/></summary>
		protected void ResetRVA() => rva_isInitialized = false;

		/// <summary>
		/// Gets/sets the initial value. Be sure to set <see cref="HasFieldRVA"/> to <c>true</c> if
		/// you write to this field.
		/// </summary>
		public byte[] InitialValue {
			get {
				if (!initialValue_isInitialized)
					InitializeInitialValue();
				return initialValue;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				initialValue = value;
				initialValue_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected byte[] initialValue;
		/// <summary/>
		protected bool initialValue_isInitialized;

		void InitializeInitialValue() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (initialValue_isInitialized)
				return;
			initialValue = GetInitialValue_NoLock();
			initialValue_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="initialValue"/></summary>
		protected virtual byte[] GetInitialValue_NoLock() => null;

		/// <summary>Reset <see cref="InitialValue"/></summary>
		protected void ResetInitialValue() => initialValue_isInitialized = false;

		/// <inheritdoc/>
		public ImplMap ImplMap {
			get {
				if (!implMap_isInitialized)
					InitializeImplMap();
				return implMap;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				implMap = value;
				implMap_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ImplMap implMap;
		/// <summary/>
		protected bool implMap_isInitialized;

		void InitializeImplMap() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (implMap_isInitialized)
				return;
			implMap = GetImplMap_NoLock();
			implMap_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="implMap"/></summary>
		protected virtual ImplMap GetImplMap_NoLock() => null;

		/// <inheritdoc/>
		public Constant Constant {
			get {
				if (!constant_isInitialized)
					InitializeConstant();
				return constant;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				constant = value;
				constant_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected Constant constant;
		/// <summary/>
		protected bool constant_isInitialized;

		void InitializeConstant() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (constant_isInitialized)
				return;
			constant = GetConstant_NoLock();
			constant_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="constant"/></summary>
		protected virtual Constant GetConstant_NoLock() => null;

		/// <summary>Reset <see cref="Constant"/></summary>
		protected void ResetConstant() => constant_isInitialized = false;

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public bool HasImplMap => ImplMap is not null;

		/// <summary>
		/// Gets/sets the declaring type (owner type)
		/// </summary>
		public TypeDef DeclaringType {
			get => declaringType2;
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType is not null)
					currentDeclaringType.Fields.Remove(this);	// Will set DeclaringType2 = null
				if (value is not null)
					value.Fields.Add(this);		// Will set DeclaringType2 = value
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType => declaringType2;

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get => declaringType2;
			set => declaringType2 = value;
		}
		/// <summary/>
		protected TypeDef declaringType2;

		/// <summary>
		/// Gets/sets the <see cref="FieldSig"/>
		/// </summary>
		public FieldSig FieldSig {
			get => signature as FieldSig;
			set => signature = value;
		}

		/// <inheritdoc/>
		public ModuleDef Module => declaringType2?.Module;

		bool IIsTypeOrMethod.IsType => false;
		bool IIsTypeOrMethod.IsMethod => false;
		bool IMemberRef.IsField => true;
		bool IMemberRef.IsTypeSpec => false;
		bool IMemberRef.IsTypeRef => false;
		bool IMemberRef.IsTypeDef => false;
		bool IMemberRef.IsMethodSpec => false;
		bool IMemberRef.IsMethodDef => false;
		bool IMemberRef.IsMemberRef => false;
		bool IMemberRef.IsFieldDef => true;
		bool IMemberRef.IsPropertyDef => false;
		bool IMemberRef.IsEventDef => false;
		bool IMemberRef.IsGenericParam => false;

		/// <summary>
		/// <c>true</c> if <see cref="FieldOffset"/> is not <c>null</c>
		/// </summary>
		public bool HasLayoutInfo => FieldOffset is not null;

		/// <summary>
		/// <c>true</c> if <see cref="Constant"/> is not <c>null</c>
		/// </summary>
		public bool HasConstant => Constant is not null;

		/// <summary>
		/// Gets the constant element type or <see cref="dnlib.DotNet.ElementType.End"/> if there's no constant
		/// </summary>
		public ElementType ElementType {
			get {
				var c = Constant;
				return c is null ? ElementType.End : c.Type;
			}
		}

		/// <summary>
		/// <c>true</c> if <see cref="MarshalType"/> is not <c>null</c>
		/// </summary>
		public bool HasMarshalType => MarshalType is not null;

		/// <summary>
		/// Gets/sets the field type
		/// </summary>
		public TypeSig FieldType {
			get => FieldSig.GetFieldType();
			set {
				var sig = FieldSig;
				if (sig is not null)
					sig.Type = value;
			}
		}

		/// <summary>
		/// Modify <see cref="attributes"/> field: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(FieldAttributes andMask, FieldAttributes orMask) =>
			attributes = (attributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, FieldAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the field access
		/// </summary>
		public FieldAttributes Access {
			get => (FieldAttributes)attributes & FieldAttributes.FieldAccessMask;
			set => ModifyAttributes(~FieldAttributes.FieldAccessMask, value & FieldAttributes.FieldAccessMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.PrivateScope"/> is set
		/// </summary>
		public bool IsCompilerControlled => IsPrivateScope;

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.PrivateScope"/> is set
		/// </summary>
		public bool IsPrivateScope => ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.PrivateScope;

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.Private"/> is set
		/// </summary>
		public bool IsPrivate => ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Private;

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.FamANDAssem"/> is set
		/// </summary>
		public bool IsFamilyAndAssembly => ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.FamANDAssem;

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.Assembly"/> is set
		/// </summary>
		public bool IsAssembly => ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Assembly;

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.Family"/> is set
		/// </summary>
		public bool IsFamily => ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Family;

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.FamORAssem"/> is set
		/// </summary>
		public bool IsFamilyOrAssembly => ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.FamORAssem;

		/// <summary>
		/// <c>true</c> if <see cref="FieldAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic => ((FieldAttributes)attributes & FieldAttributes.FieldAccessMask) == FieldAttributes.Public;

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.Static"/> bit
		/// </summary>
		public bool IsStatic {
			get => ((FieldAttributes)attributes & FieldAttributes.Static) != 0;
			set => ModifyAttributes(value, FieldAttributes.Static);
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.InitOnly"/> bit
		/// </summary>
		public bool IsInitOnly {
			get => ((FieldAttributes)attributes & FieldAttributes.InitOnly) != 0;
			set => ModifyAttributes(value, FieldAttributes.InitOnly);
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.Literal"/> bit
		/// </summary>
		public bool IsLiteral {
			get => ((FieldAttributes)attributes & FieldAttributes.Literal) != 0;
			set => ModifyAttributes(value, FieldAttributes.Literal);
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.NotSerialized"/> bit
		/// </summary>
		public bool IsNotSerialized {
			get => ((FieldAttributes)attributes & FieldAttributes.NotSerialized) != 0;
			set => ModifyAttributes(value, FieldAttributes.NotSerialized);
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get => ((FieldAttributes)attributes & FieldAttributes.SpecialName) != 0;
			set => ModifyAttributes(value, FieldAttributes.SpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.PinvokeImpl"/> bit
		/// </summary>
		public bool IsPinvokeImpl {
			get => ((FieldAttributes)attributes & FieldAttributes.PinvokeImpl) != 0;
			set => ModifyAttributes(value, FieldAttributes.PinvokeImpl);
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get => ((FieldAttributes)attributes & FieldAttributes.RTSpecialName) != 0;
			set => ModifyAttributes(value, FieldAttributes.RTSpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.HasFieldMarshal"/> bit
		/// </summary>
		public bool HasFieldMarshal {
			get => ((FieldAttributes)attributes & FieldAttributes.HasFieldMarshal) != 0;
			set => ModifyAttributes(value, FieldAttributes.HasFieldMarshal);
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.HasDefault"/> bit
		/// </summary>
		public bool HasDefault {
			get => ((FieldAttributes)attributes & FieldAttributes.HasDefault) != 0;
			set => ModifyAttributes(value, FieldAttributes.HasDefault);
		}

		/// <summary>
		/// Gets/sets the <see cref="FieldAttributes.HasFieldRVA"/> bit
		/// </summary>
		public bool HasFieldRVA {
			get => ((FieldAttributes)attributes & FieldAttributes.HasFieldRVA) != 0;
			set => ModifyAttributes(value, FieldAttributes.HasFieldRVA);
		}

		/// <summary>
		/// Returns the full name of this field
		/// </summary>
		public string FullName => FullNameFactory.FieldFullName(declaringType2?.FullName, name, FieldSig, null, null);

		/// <summary>
		/// Gets the size of this field in bytes or <c>0</c> if unknown.
		/// </summary>
		public uint GetFieldSize() {
			if (!GetFieldSize(out uint size))
				return 0;
			return size;
		}

		/// <summary>
		/// Gets the size of this field in bytes or <c>0</c> if unknown.
		/// </summary>
		/// <param name="size">Updated with size</param>
		/// <returns><c>true</c> if <paramref name="size"/> is valid, <c>false</c> otherwise</returns>
		public bool GetFieldSize(out uint size) => GetFieldSize(declaringType2, FieldSig, out size);

		/// <summary>
		/// Gets the size of this field in bytes or <c>0</c> if unknown.
		/// </summary>
		/// <param name="declaringType">The declaring type of <c>this</c></param>
		/// <param name="fieldSig">The field signature of <c>this</c></param>
		/// <param name="size">Updated with size</param>
		/// <returns><c>true</c> if <paramref name="size"/> is valid, <c>false</c> otherwise</returns>
		protected bool GetFieldSize(TypeDef declaringType, FieldSig fieldSig, out uint size) => GetFieldSize(declaringType, fieldSig, GetPointerSize(declaringType), out size);

		/// <summary>
		/// Gets the size of this field in bytes or <c>0</c> if unknown.
		/// </summary>
		/// <param name="declaringType">The declaring type of <c>this</c></param>
		/// <param name="fieldSig">The field signature of <c>this</c></param>
		/// <param name="ptrSize">Size of a pointer</param>
		/// <param name="size">Updated with size</param>
		/// <returns><c>true</c> if <paramref name="size"/> is valid, <c>false</c> otherwise</returns>
		protected bool GetFieldSize(TypeDef declaringType, FieldSig fieldSig, int ptrSize, out uint size) {
			size = 0;
			if (fieldSig is null)
				return false;
			return GetClassSize(declaringType, fieldSig.Type, ptrSize, out size);
		}

		bool GetClassSize(TypeDef declaringType, TypeSig ts, int ptrSize, out uint size) {
			size = 0;
			ts = ts.RemovePinnedAndModifiers();
			if (ts is null)
				return false;

			int size2 = ts.ElementType.GetPrimitiveSize(ptrSize);
			if (size2 >= 0) {
				size = (uint)size2;
				return true;
			}

			var tdrs = ts as TypeDefOrRefSig;
			if (tdrs is null)
				return false;

			var td = tdrs.TypeDef;
			if (td is not null)
				return TypeDef.GetClassSize(td, out size);

			var tr = tdrs.TypeRef;
			if (tr is not null)
				return TypeDef.GetClassSize(tr.Resolve(), out size);

			return false;
		}

		int GetPointerSize(TypeDef declaringType) {
			if (declaringType is null)
				return 4;
			var module = declaringType.Module;
			if (module is null)
				return 4;
			return module.GetPointerSize();
		}

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A Field row created by the user and not present in the original .NET file
	/// </summary>
	public class FieldDefUser : FieldDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public FieldDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public FieldDefUser(UTF8String name)
			: this(name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="signature">Signature</param>
		public FieldDefUser(UTF8String name, FieldSig signature)
			: this(name, signature, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="signature">Signature</param>
		/// <param name="attributes">Flags</param>
		public FieldDefUser(UTF8String name, FieldSig signature, FieldAttributes attributes) {
			this.name = name;
			this.signature = signature;
			this.attributes = (int)attributes;
		}
	}

	/// <summary>
	/// Created from a row in the Field table
	/// </summary>
	sealed class FieldDefMD : FieldDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly FieldAttributes origAttributes;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.Field, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(declaringType2), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override uint? GetFieldOffset_NoLock() {
			if (readerModule.TablesStream.TryReadFieldLayoutRow(readerModule.Metadata.GetFieldLayoutRid(origRid), out var row))
				return row.OffSet;
			return null;
		}

		/// <inheritdoc/>
		protected override MarshalType GetMarshalType_NoLock() =>
			readerModule.ReadMarshalType(Table.Field, origRid, new GenericParamContext(declaringType2));

		/// <inheritdoc/>
		protected override RVA GetRVA_NoLock() {
			GetFieldRVA_NoLock(out var rva2);
			return rva2;
		}

		/// <inheritdoc/>
		protected override byte[] GetInitialValue_NoLock() {
			if (!GetFieldRVA_NoLock(out var rva2))
				return null;
			return ReadInitialValue_NoLock(rva2);
		}

		/// <inheritdoc/>
		protected override ImplMap GetImplMap_NoLock() =>
			readerModule.ResolveImplMap(readerModule.Metadata.GetImplMapRid(Table.Field, origRid));

		/// <inheritdoc/>
		protected override Constant GetConstant_NoLock() =>
			readerModule.ResolveConstant(readerModule.Metadata.GetConstantRid(Table.Field, origRid));

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Field</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public FieldDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.FieldTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"Field rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadFieldRow(origRid, out var row);
			Debug.Assert(b);
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			attributes = row.Flags;
			origAttributes = (FieldAttributes)attributes;
			declaringType2 = readerModule.GetOwnerType(this);
			signature = readerModule.ReadSignature(row.Signature, new GenericParamContext(declaringType2));
		}

		internal FieldDefMD InitializeAll() {
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(Signature);
			MemberMDInitializer.Initialize(FieldOffset);
			MemberMDInitializer.Initialize(MarshalType);
			MemberMDInitializer.Initialize(RVA);
			MemberMDInitializer.Initialize(InitialValue);
			MemberMDInitializer.Initialize(ImplMap);
			MemberMDInitializer.Initialize(Constant);
			MemberMDInitializer.Initialize(DeclaringType);
			return this;
		}

		bool GetFieldRVA_NoLock(out RVA rva) {
			if ((origAttributes & FieldAttributes.HasFieldRVA) == 0) {
				rva = 0;
				return false;
			}
			if (!readerModule.TablesStream.TryReadFieldRVARow(readerModule.Metadata.GetFieldRVARid(origRid), out var row)) {
				rva = 0;
				return false;
			}
			rva = (RVA)row.RVA;
			return true;
		}

		byte[] ReadInitialValue_NoLock(RVA rva) {
			if (!GetFieldSize(declaringType2, signature as FieldSig, out uint size))
				return null;
			if (size >= int.MaxValue)
				return null;
			return readerModule.ReadDataAt(rva, (int)size);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// File row flags. See CorHdr.h/CorFileFlags
	/// </summary>
	[Flags]
	public enum FileAttributes : uint {
		/// <summary>This is not a resource file</summary>
		ContainsMetadata	= 0x0000,
		/// <summary>This is a resource file or other non-metadata-containing file</summary>
		ContainsNoMetadata	= 0x0001,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the File table
	/// </summary>
	public abstract class FileDef : IHasCustomAttribute, IImplementation, IHasCustomDebugInformation, IManagedEntryPoint {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.File, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 16;

		/// <inheritdoc/>
		public int ImplementationTag => 0;

		/// <summary>
		/// From column File.Flags
		/// </summary>
		public FileAttributes Flags {
			get => (FileAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column File.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column File.HashValue
		/// </summary>
		public byte[] HashValue {
			get => hashValue;
			set => hashValue = value;
		}
		/// <summary/>
		protected byte[] hashValue;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 16;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, FileAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the <see cref="FileAttributes.ContainsMetadata"/> bit
		/// </summary>
		public bool ContainsMetadata {
			get => ((FileAttributes)attributes & FileAttributes.ContainsNoMetadata) == 0;
			set => ModifyAttributes(!value, FileAttributes.ContainsNoMetadata);
		}

		/// <summary>
		/// Gets/sets the <see cref="FileAttributes.ContainsNoMetadata"/> bit
		/// </summary>
		public bool ContainsNoMetadata {
			get => ((FileAttributes)attributes & FileAttributes.ContainsNoMetadata) != 0;
			set => ModifyAttributes(value, FileAttributes.ContainsNoMetadata);
		}

		/// <inheritdoc/>
		public string FullName => UTF8String.ToSystemStringOrEmpty(name);

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A File row created by the user and not present in the original .NET file
	/// </summary>
	public class FileDefUser : FileDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public FileDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of file</param>
		/// <param name="flags">Flags</param>
		/// <param name="hashValue">File hash</param>
		public FileDefUser(UTF8String name, FileAttributes flags, byte[] hashValue) {
			this.name = name;
			attributes = (int)flags;
			this.hashValue = hashValue;
		}
	}

	/// <summary>
	/// Created from a row in the File table
	/// </summary>
	sealed class FileDefMD : FileDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.File, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>File</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public FileDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.FileTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"File rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadFileRow(origRid, out var row);
			Debug.Assert(b);
			attributes = (int)row.Flags;
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			hashValue = readerModule.BlobStream.Read(row.HashValue);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Redirects .NET framework assembly references from older to newer versions
	/// </summary>
	public static class FrameworkRedirect {
		static readonly Dictionary<string, FrameworkRedirectInfo> frmRedir2;
		static readonly Dictionary<string, FrameworkRedirectInfo> frmRedir4;

		readonly struct FrameworkRedirectInfo {
			public readonly PublicKeyToken publicKeyToken;
			public readonly Version redirectVersion;

			public FrameworkRedirectInfo(string publicKeyToken, string redirectVersion) {
				this.publicKeyToken = new PublicKeyToken(publicKeyToken);
				this.redirectVersion = new Version(redirectVersion);
			}
		}

		static FrameworkRedirect() {
			frmRedir2 = new Dictionary<string, FrameworkRedirectInfo>(StringComparer.OrdinalIgnoreCase);
			frmRedir4 = new Dictionary<string, FrameworkRedirectInfo>(StringComparer.OrdinalIgnoreCase);
			InitFrameworkRedirectV2();
			InitFrameworkRedirectV4();
		}

		static void InitFrameworkRedirectV2() {
			frmRedir2["Accessibility"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["cscompmgd"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["CustomMarshalers"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["IEExecRemote"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["IEHost"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["IIEHost"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["ISymWrapper"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["Microsoft.JScript"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualBasic"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualBasic.Compatibility"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualBasic.Compatibility.Data"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualBasic.Vsa"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.VisualC"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.Vsa"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft.Vsa.Vb.CodeDOMProcessor"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["Microsoft_VsaVb"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "8.0.0.0");
			frmRedir2["mscorcfg"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["mscorlib"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Configuration"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Configuration.Install"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Data"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Data.OracleClient"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Data.SqlXml"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Deployment"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Design"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.DirectoryServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.DirectoryServices.Protocols"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Drawing"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Drawing.Design"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.EnterpriseServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Management"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Messaging"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Runtime.Remoting"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Runtime.Serialization.Formatters.Soap"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Security"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.ServiceProcess"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Transactions"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Web"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Web.Mobile"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Web.RegularExpressions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Web.Services"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["System.Windows.Forms"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["System.Xml"] = new FrameworkRedirectInfo("b77a5c561934e089", "2.0.0.0");
			frmRedir2["vjscor"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["VJSharpCodeProvider"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjsJBC"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjslib"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjslibcw"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["Vjssupuilib"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjsvwaux"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjswfc"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["VJSWfcBrowserStubLib"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjswfccw"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir2["vjswfchtml"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
		}

		static void InitFrameworkRedirectV4() {
			frmRedir4["Accessibility"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["CustomMarshalers"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["ISymWrapper"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.JScript"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualBasic"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualBasic.Compatibility"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualBasic.Compatibility.Data"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualC"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["mscorlib"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Configuration"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Configuration.Install"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Data"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.OracleClient"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.SqlXml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Deployment"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Design"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.DirectoryServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.DirectoryServices.Protocols"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Drawing"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Drawing.Design"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.EnterpriseServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Management"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Messaging"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Remoting"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization.Formatters.Soap"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Security"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceProcess"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Transactions"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Web.Mobile"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Web.RegularExpressions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Web.Services"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Windows.Forms"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Xml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["AspNetMMCExt"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["sysglobl"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Build.Engine"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Build.Framework"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["PresentationCFFRasterizer"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationCore"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Aero"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Classic"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Luna"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Royale"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationUI"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["ReachFramework"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Printing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Speech"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["UIAutomationClient"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["UIAutomationClientsideProviders"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["UIAutomationProvider"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["UIAutomationTypes"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["WindowsBase"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["WindowsFormsIntegration"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["SMDiagnostics"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IdentityModel"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IdentityModel.Selectors"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IO.Log"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.ServiceModel"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.ServiceModel.Install"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.ServiceModel.WasHosting"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Workflow.Activities"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Workflow.ComponentModel"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Workflow.Runtime"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["Microsoft.Transactions.Bridge"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Transactions.Bridge.Dtc"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.AddIn"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.AddIn.Contract"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ComponentModel.Composition"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Core"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.DataSetExtensions"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Linq"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Xml.Linq"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.DirectoryServices.AccountManagement"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Management.Instrumentation"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Net"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Web"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.Extensions"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.Extensions.Design"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Windows.Presentation"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.WorkflowServices"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ComponentModel.DataAnnotations"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Data.Entity"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Entity.Design"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Services"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Services.Client"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Data.Services.Design"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web.Abstractions"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.DynamicData"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.DynamicData.Design"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.Entity"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web.Entity.Design"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web.Routing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["Microsoft.Build"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.CSharp"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Dynamic"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Numerics"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Xaml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["Microsoft.Workflow.Compiler"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["Microsoft.Activities.Build"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["Microsoft.Build.Conversion.v4.0"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Build.Tasks.v4.0"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Build.Utilities.v4.0"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["Microsoft.Internal.Tasks.Dataflow"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["Microsoft.VisualBasic.Activities.Compiler"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "10.0.0.0");
			frmRedir4["Microsoft.VisualC.STLCLR"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "2.0.0.0");
			frmRedir4["Microsoft.Windows.ApplicationServer.Applications"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationBuildTasks"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.Aero2"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework.AeroLite"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemCore"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemData"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemDrawing"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemXml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["PresentationFramework-SystemXmlLinq"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Activities"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Activities.Core.Presentation"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Activities.DurableInstancing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Activities.Presentation"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ComponentModel.Composition.Registration"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Device"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IdentityModel.Services"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IO.Compression"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.IO.Compression.FileSystem"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Net.Http"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.Http.WebRequest"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Context"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Runtime.Caching"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.DurableInstancing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Runtime.WindowsRuntime"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Runtime.WindowsRuntime.UI.Xaml"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.ServiceModel.Activation"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Activities"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Channels"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Discovery"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Internals"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.Routing"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.ServiceModel.ServiceMoniker40"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Web.ApplicationServices"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.DataVisualization"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Web.DataVisualization.Design"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Windows.Controls.Ribbon"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Windows.Forms.DataVisualization"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Windows.Forms.DataVisualization.Design"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Windows.Input.Manipulations"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
			frmRedir4["System.Xaml.Hosting"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["XamlBuildTask"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["XsdBuildTask"] = new FrameworkRedirectInfo("31bf3856ad364e35", "4.0.0.0");
			frmRedir4["System.Collections"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Collections.Concurrent"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ComponentModel"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ComponentModel.Annotations"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ComponentModel.EventBasedAsync"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Diagnostics.Contracts"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Diagnostics.Debug"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Diagnostics.Tools"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Diagnostics.Tracing"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Dynamic.Runtime"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Globalization"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.IO"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Linq"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Linq.Expressions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Linq.Parallel"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Linq.Queryable"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.NetworkInformation"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.Primitives"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.Requests"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ObjectModel"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Emit"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Emit.ILGeneration"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Emit.Lightweight"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Extensions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Reflection.Primitives"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Resources.ResourceManager"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Extensions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.InteropServices"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.InteropServices.WindowsRuntime"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Numerics"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization.Json"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization.Primitives"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Runtime.Serialization.Xml"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Security.Principal"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Duplex"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Http"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.NetTcp"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Primitives"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.ServiceModel.Security"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Text.Encoding"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Text.Encoding.Extensions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Text.RegularExpressions"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Threading"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Threading.Timer"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Threading.Tasks"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Threading.Tasks.Parallel"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Xml.ReaderWriter"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Xml.XDocument"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Xml.XmlSerializer"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Net.Http.Rtc"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Windows"] = new FrameworkRedirectInfo("b03f5f7f11d50a3a", "4.0.0.0");
			frmRedir4["System.Xml.Serialization"] = new FrameworkRedirectInfo("b77a5c561934e089", "4.0.0.0");
		}

		/// <summary>
		/// Redirects a .NET Framework assembly from an older version to the correct version
		/// loaded at runtime.
		/// </summary>
		/// <param name="assembly">Current assembly reference that might get updated</param>
		/// <param name="sourceModule">Module using the assembly reference</param>
		public static void ApplyFrameworkRedirect(ref IAssembly assembly, ModuleDef sourceModule) {
			if (TryApplyFrameworkRedirectCore(assembly, sourceModule, out var redirectedAssembly))
				assembly = redirectedAssembly;
		}

		/// <summary>
		/// Tries to redirect a .NET Framework assembly from an older version to the correct version
		/// loaded at runtime.
		/// </summary>
		/// <param name="assembly">Assembly reference</param>
		/// <param name="sourceModule">Module using the assembly reference</param>
		/// <param name="redirectedAssembly">Updated with the redirected assembly if successful</param>
		/// <returns></returns>
		public static bool TryApplyFrameworkRedirect(IAssembly assembly, ModuleDef sourceModule, out IAssembly redirectedAssembly) =>
			TryApplyFrameworkRedirectCore(assembly, sourceModule, out redirectedAssembly);

		static bool TryApplyFrameworkRedirectCore(IAssembly assembly, ModuleDef sourceModule, out IAssembly redirectedAssembly) {
			if (sourceModule is not null) {
				if (sourceModule.IsClr40)
					return TryApplyFrameworkRedirect(assembly, frmRedir4, out redirectedAssembly);
				if (sourceModule.IsClr20)
					return TryApplyFrameworkRedirect(assembly, frmRedir2, out redirectedAssembly);
			}

			redirectedAssembly = null;
			return false;
		}

		/// <summary>
		/// Redirects a .NET Framework 2.0-3.5 assembly from an older version to the correct version
		/// loaded at runtime.
		/// </summary>
		/// <param name="assembly">Current assembly reference that might get updated</param>
		public static void ApplyFrameworkRedirectV2(ref IAssembly assembly) {
			if (TryApplyFrameworkRedirect(assembly, frmRedir2, out var redirectedAssembly))
				assembly = redirectedAssembly;
		}

		/// <summary>
		/// Redirects a .NET Framework 4.0+ assembly from an older version to the correct version
		/// loaded at runtime.
		/// </summary>
		/// <param name="assembly">Current assembly reference that might get updated</param>
		public static void ApplyFrameworkRedirectV4(ref IAssembly assembly) {
			if (TryApplyFrameworkRedirect(assembly, frmRedir4, out var redirectedAssembly))
				assembly = redirectedAssembly;
		}

		/// <summary>
		/// Tries to redirect a .NET Framework 2.0-3.5 assembly from an older version to the correct version
		/// loaded at runtime.
		/// </summary>
		/// <param name="assembly">Assembly reference</param>
		/// <param name="redirectedAssembly">Updated with the redirected assembly if successful</param>
		/// <returns></returns>
		public static bool TryApplyFrameworkRedirectV2(IAssembly assembly, out IAssembly redirectedAssembly) =>
			TryApplyFrameworkRedirect(assembly, frmRedir2, out redirectedAssembly);

		/// <summary>
		/// Tries to redirect a .NET Framework 4.0+ assembly from an older version to the correct version
		/// loaded at runtime.
		/// </summary>
		/// <param name="assembly">Assembly reference</param>
		/// <param name="redirectedAssembly">Updated with the redirected assembly if successful</param>
		/// <returns></returns>
		public static bool TryApplyFrameworkRedirectV4(IAssembly assembly, out IAssembly redirectedAssembly) =>
			TryApplyFrameworkRedirect(assembly, frmRedir4, out redirectedAssembly);

		static bool TryApplyFrameworkRedirect(IAssembly assembly, Dictionary<string, FrameworkRedirectInfo> frmRedir, out IAssembly redirectedAssembly) {
			redirectedAssembly = null;
			if (!Utils.LocaleEquals(assembly.Culture, ""))
				return false;
			if (!frmRedir.TryGetValue(assembly.Name, out var redirect))
				return false;
			if (PublicKeyBase.TokenCompareTo(assembly.PublicKeyOrToken, redirect.publicKeyToken) != 0)
				return false;

			if (Utils.CompareTo(assembly.Version, redirect.redirectVersion) == 0)
				redirectedAssembly = assembly;
			else {
				redirectedAssembly = new AssemblyNameInfo(assembly);
				redirectedAssembly.Version = redirect.redirectVersion;
			}
			return true;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Helps <see cref="FullNameFactory"/> create a name
	/// </summary>
	public interface IFullNameFactoryHelper {
		/// <summary>
		/// Checks whether the assembly name should be included when printing
		/// the full type name. The assembly name isn't required in custom attributes
		/// when the type already exists in the same module as the CA, or if the type
		/// exists in mscorlib.
		/// </summary>
		/// <param name="type">The type (<c>TypeDef</c>, <c>TypeRef</c> or <c>ExportedType</c>)
		/// or <c>null</c></param>
		/// <returns><c>true</c> if the assembly name must be included, <c>false</c> otherwise</returns>
		bool MustUseAssemblyName(IType type);
	}

	/// <summary>
	/// Creates type names, method names, etc.
	/// </summary>
	public struct FullNameFactory {
		const uint MaxArrayRank = 100;
		const uint MaxMethodGenParamCount = 200;
		const string RECURSION_ERROR_RESULT_STRING = "<<<INFRECURSION>>>";
		const string NULLVALUE = "<<<NULL>>>";
		readonly StringBuilder sb;
		readonly bool isReflection;
		readonly IFullNameFactoryHelper helper;
		GenericArguments genericArguments;
		RecursionCounter recursionCounter;

		/// <summary>
		/// Checks whether the assembly name should be included when printing the full name.
		/// See <see cref="IFullNameFactoryHelper.MustUseAssemblyName"/> for more info.
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="type">The type (<c>TypeDef</c>, <c>TypeRef</c> or <c>ExportedType</c>)
		/// or <c>null</c></param>
		/// <returns><c>true</c> if the assembly name must be included, <c>false</c> otherwise</returns>
		public static bool MustUseAssemblyName(ModuleDef module, IType type) => MustUseAssemblyName(module, type, true);

		/// <summary>
		/// Checks whether the assembly name should be included when printing the full name.
		/// See <see cref="IFullNameFactoryHelper.MustUseAssemblyName"/> for more info.
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="type">The type (<c>TypeDef</c>, <c>TypeRef</c> or <c>ExportedType</c>)
		/// or <c>null</c></param>
		/// <param name="allowCorlib">If false, don't add an assembly name if it's a type in <paramref name="module"/>,
		/// if true, don't add an assembly name if it's a type in <paramref name="module"/> or the corlib.</param>
		/// <returns><c>true</c> if the assembly name must be included, <c>false</c> otherwise</returns>
		public static bool MustUseAssemblyName(ModuleDef module, IType type, bool allowCorlib) {
			if (type is TypeDef td)
				return td.Module != module;

			var tr = type as TypeRef;
			if (tr is null)
				return true;
			if (tr.ResolutionScope == AssemblyRef.CurrentAssembly)
				return false;
			if (allowCorlib) {
				if (!tr.DefinitionAssembly.IsCorLib())
					return true;
				// If it's present in this module, but it's a corlib type, then we will need the
				// assembly name.
				return module.Find(tr) is not null;
			}
			else
				return true;
		}

		/// <summary>
		/// Returns the full name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(IType type, bool isReflection, IFullNameFactoryHelper helper, StringBuilder sb) =>
			FullNameSB(type, isReflection, helper, sb).ToString();

		/// <summary>
		/// Returns the full name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(IType type, bool isReflection, IFullNameFactoryHelper helper, StringBuilder sb) {
			if (type is TypeDef td)
				return FullNameSB(td, isReflection, helper, sb);
			if (type is TypeRef tr)
				return FullNameSB(tr, isReflection, helper, sb);
			if (type is TypeSpec ts)
				return FullNameSB(ts, isReflection, helper, sb);
			if (type is TypeSig sig)
				return FullNameSB(sig, isReflection, helper, null, null, sb);
			if (type is ExportedType et)
				return FullNameSB(et, isReflection, helper, sb);
			return sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string Name(IType type, bool isReflection, StringBuilder sb) =>
			NameSB(type, isReflection, sb).ToString();

		/// <summary>
		/// Returns the name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder NameSB(IType type, bool isReflection, StringBuilder sb) {
			if (type is TypeDef td)
				return NameSB(td, isReflection, sb);
			if (type is TypeRef tr)
				return NameSB(tr, isReflection, sb);
			if (type is TypeSpec ts)
				return NameSB(ts, isReflection, sb);
			if (type is TypeSig sig)
				return NameSB(sig, isReflection, sb);
			if (type is ExportedType et)
				return NameSB(et, isReflection, sb);
			return sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string Namespace(IType type, bool isReflection, StringBuilder sb) =>
			NamespaceSB(type, isReflection, sb).ToString();

		/// <summary>
		/// Returns the namespace of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder NamespaceSB(IType type, bool isReflection, StringBuilder sb) {
			if (type is TypeDef td)
				return NamespaceSB(td, isReflection, sb);
			if (type is TypeRef tr)
				return NamespaceSB(tr, isReflection, sb);
			if (type is TypeSpec ts)
				return NamespaceSB(ts, isReflection, sb);
			if (type is TypeSig sig)
				return NamespaceSB(sig, isReflection, sb);
			if (type is ExportedType et)
				return NamespaceSB(et, isReflection, sb);
			return sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>IType</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(IType type, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			AssemblyQualifiedNameSB(type, helper, sb).ToString();

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The <c>IType</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(IType type, IFullNameFactoryHelper helper, StringBuilder sb) {
			if (type is TypeDef td)
				return AssemblyQualifiedNameSB(td, helper, sb);

			if (type is TypeRef tr)
				return AssemblyQualifiedNameSB(tr, helper, sb);

			if (type is TypeSpec ts)
				return AssemblyQualifiedNameSB(ts, helper, sb);

			if (type is TypeSig sig)
				return AssemblyQualifiedNameSB(sig, helper, sb);

			if (type is ExportedType et)
				return AssemblyQualifiedNameSB(et, helper, sb);

			return sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a property
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of property</param>
		/// <param name="propertySig">Property signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property full name</returns>
		public static string PropertyFullName(string declaringType, UTF8String name, CallingConventionSig propertySig, IList<TypeSig> typeGenArgs = null, StringBuilder sb = null) =>
			PropertyFullNameSB(declaringType, name, propertySig, typeGenArgs, sb).ToString();

		/// <summary>
		/// Returns the full name of a property
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of property</param>
		/// <param name="propertySig">Property signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property full name</returns>
		public static StringBuilder PropertyFullNameSB(string declaringType, UTF8String name, CallingConventionSig propertySig, IList<TypeSig> typeGenArgs, StringBuilder sb) {
			var fnc = new FullNameFactory(false, null, sb);
			if (typeGenArgs is not null) {
				fnc.genericArguments = new GenericArguments();
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			}

			fnc.CreatePropertyFullName(declaringType, name, propertySig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a property
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of property</param>
		/// <param name="typeDefOrRef">Event type</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property full name</returns>
		public static string EventFullName(string declaringType, UTF8String name, ITypeDefOrRef typeDefOrRef, IList<TypeSig> typeGenArgs = null, StringBuilder sb = null) =>
			EventFullNameSB(declaringType, name, typeDefOrRef, typeGenArgs, sb).ToString();

		/// <summary>
		/// Returns the full name of a property
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of property</param>
		/// <param name="typeDefOrRef">Event type</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property full name</returns>
		public static StringBuilder EventFullNameSB(string declaringType, UTF8String name, ITypeDefOrRef typeDefOrRef, IList<TypeSig> typeGenArgs, StringBuilder sb) {
			var fnc = new FullNameFactory(false, null, sb);
			if (typeGenArgs is not null) {
				fnc.genericArguments = new GenericArguments();
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			}

			fnc.CreateEventFullName(declaringType, name, typeDefOrRef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a field
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of field</param>
		/// <param name="fieldSig">Field signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Field full name</returns>
		public static string FieldFullName(string declaringType, string name, FieldSig fieldSig, IList<TypeSig> typeGenArgs = null, StringBuilder sb = null) =>
			FieldFullNameSB(declaringType, name, fieldSig, typeGenArgs, sb).ToString();

		/// <summary>
		/// Returns the full name of a field
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of field</param>
		/// <param name="fieldSig">Field signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Field full name</returns>
		public static StringBuilder FieldFullNameSB(string declaringType, string name, FieldSig fieldSig, IList<TypeSig> typeGenArgs, StringBuilder sb) {
			var fnc = new FullNameFactory(false, null, sb);
			if (typeGenArgs is not null) {
				fnc.genericArguments = new GenericArguments();
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			}

			fnc.CreateFieldFullName(declaringType, name, fieldSig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a method
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of method or <c>null</c> if none</param>
		/// <param name="methodSig">Method signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="methodGenArgs">Method generic arguments or <c>null</c> if none</param>
		/// <param name="gppMethod">Generic parameter owner method or <c>null</c></param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Method full name</returns>
		public static string MethodFullName(string declaringType, string name, MethodSig methodSig, IList<TypeSig> typeGenArgs = null, IList<TypeSig> methodGenArgs = null, MethodDef gppMethod = null, StringBuilder sb = null) =>
			MethodFullNameSB(declaringType, name, methodSig, typeGenArgs, methodGenArgs, gppMethod, sb).ToString();

		/// <summary>
		/// Returns the full name of a method
		/// </summary>
		/// <param name="declaringType">Declaring type full name or <c>null</c> if none</param>
		/// <param name="name">Name of method or <c>null</c> if none</param>
		/// <param name="methodSig">Method signature</param>
		/// <param name="typeGenArgs">Type generic arguments or <c>null</c> if none</param>
		/// <param name="methodGenArgs">Method generic arguments or <c>null</c> if none</param>
		/// <param name="gppMethod">Generic parameter owner method or <c>null</c></param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Method full name</returns>
		public static StringBuilder MethodFullNameSB(string declaringType, string name, MethodSig methodSig, IList<TypeSig> typeGenArgs, IList<TypeSig> methodGenArgs, MethodDef gppMethod, StringBuilder sb) {
			var fnc = new FullNameFactory(false, null, sb);
			if (typeGenArgs is not null || methodGenArgs is not null)
				fnc.genericArguments = new GenericArguments();
			if (typeGenArgs is not null)
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			if (methodGenArgs is not null)
				fnc.genericArguments.PushMethodArgs(methodGenArgs);
			fnc.CreateMethodFullName(declaringType, name, methodSig, gppMethod);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a property sig
		/// </summary>
		/// <param name="sig">Property sig</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property sig full name</returns>
		public static string MethodBaseSigFullName(MethodBaseSig sig, StringBuilder sb = null) =>
			MethodBaseSigFullNameSB(sig, sb).ToString();

		/// <summary>
		/// Returns the full name of a property sig
		/// </summary>
		/// <param name="sig">Property sig</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Property sig full name</returns>
		public static StringBuilder MethodBaseSigFullNameSB(MethodBaseSig sig, StringBuilder sb) {
			var fnc = new FullNameFactory(false, null, sb);
			fnc.CreateMethodFullName(null, null, sig, null);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a sig
		/// </summary>
		/// <param name="declType">Declaring type or null</param>
		/// <param name="name">Name or null</param>
		/// <param name="sig">Method sig</param>
		/// <param name="gppMethod">Owner method or null</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Sig full name</returns>
		public static string MethodBaseSigFullName(string declType, string name, MethodBaseSig sig, MethodDef gppMethod, StringBuilder sb = null) =>
			MethodBaseSigFullNameSB(declType, name, sig, gppMethod, sb).ToString();

		/// <summary>
		/// Returns the full name of a sig
		/// </summary>
		/// <param name="declType">Declaring type or null</param>
		/// <param name="name">Name or null</param>
		/// <param name="sig">Method sig</param>
		/// <param name="gppMethod">Owner method or null</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>Sig full name</returns>
		public static StringBuilder MethodBaseSigFullNameSB(string declType, string name, MethodBaseSig sig, MethodDef gppMethod, StringBuilder sb) {
			var fnc = new FullNameFactory(false, null, sb);
			fnc.CreateMethodFullName(declType, name, sig, gppMethod);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the namespace of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(TypeRef typeRef, bool isReflection, StringBuilder sb = null) =>
			NamespaceSB(typeRef, isReflection, sb).ToString();

		/// <summary>
		/// Returns the namespace of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(TypeRef typeRef, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateNamespace(typeRef, true);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(TypeRef typeRef, bool isReflection, StringBuilder sb = null) =>
			NameSB(typeRef, isReflection, sb).ToString();

		/// <summary>
		/// Returns the name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(TypeRef typeRef, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateName(typeRef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(TypeRef typeRef, bool isReflection, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			FullNameSB(typeRef, isReflection, helper, sb).ToString();

		/// <summary>
		/// Returns the full name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(TypeRef typeRef, bool isReflection, IFullNameFactoryHelper helper, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, helper, sb);
			fnc.CreateFullName(typeRef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(TypeRef typeRef, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			AssemblyQualifiedNameSB(typeRef, helper, sb).ToString();

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(TypeRef typeRef, IFullNameFactoryHelper helper, StringBuilder sb) {
			var fnc = new FullNameFactory(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(typeRef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(TypeRef typeRef) =>
			new FullNameFactory().GetDefinitionAssembly(typeRef);

		/// <summary>
		/// Gets the scope
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <returns>The <see cref="IScope"/> or <c>null</c> if none found</returns>
		public static IScope Scope(TypeRef typeRef) =>
			new FullNameFactory().GetScope(typeRef);

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="typeRef">The <c>TypeRef</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(TypeRef typeRef) =>
			new FullNameFactory().GetOwnerModule(typeRef);

		/// <summary>
		/// Returns the namespace of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(TypeDef typeDef, bool isReflection, StringBuilder sb = null) =>
			NamespaceSB(typeDef, isReflection, sb).ToString();

		/// <summary>
		/// Returns the namespace of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(TypeDef typeDef, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateNamespace(typeDef, true);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(TypeDef typeDef, bool isReflection, StringBuilder sb = null) =>
			NameSB(typeDef, isReflection, sb).ToString();

		/// <summary>
		/// Returns the name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(TypeDef typeDef, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateName(typeDef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(TypeDef typeDef, bool isReflection, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			FullNameSB(typeDef, isReflection, helper, sb).ToString();

		/// <summary>
		/// Returns the full name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(TypeDef typeDef, bool isReflection, IFullNameFactoryHelper helper, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, helper, sb);
			fnc.CreateFullName(typeDef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(TypeDef typeDef, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			AssemblyQualifiedNameSB(typeDef, helper, sb).ToString();

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(TypeDef typeDef, IFullNameFactoryHelper helper, StringBuilder sb) {
			var fnc = new FullNameFactory(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(typeDef);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(TypeDef typeDef) =>
			new FullNameFactory().GetDefinitionAssembly(typeDef);

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="typeDef">The <c>TypeDef</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(TypeDef typeDef) =>
			new FullNameFactory().GetOwnerModule(typeDef);

		/// <summary>
		/// Returns the namespace of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(TypeSpec typeSpec, bool isReflection, StringBuilder sb = null) =>
			NamespaceSB(typeSpec, isReflection, sb).ToString();

		/// <summary>
		/// Returns the namespace of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(TypeSpec typeSpec, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateNamespace(typeSpec, true);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(TypeSpec typeSpec, bool isReflection, StringBuilder sb = null) =>
			NameSB(typeSpec, isReflection, sb).ToString();

		/// <summary>
		/// Returns the name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(TypeSpec typeSpec, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateName(typeSpec);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(TypeSpec typeSpec, bool isReflection, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			FullNameSB(typeSpec, isReflection, helper, sb).ToString();

		/// <summary>
		/// Returns the full name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(TypeSpec typeSpec, bool isReflection, IFullNameFactoryHelper helper, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, helper, sb);
			fnc.CreateFullName(typeSpec);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(TypeSpec typeSpec, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			AssemblyQualifiedNameSB(typeSpec, helper, sb).ToString();

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(TypeSpec typeSpec, IFullNameFactoryHelper helper, StringBuilder sb) {
			var fnc = new FullNameFactory(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(typeSpec);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(TypeSpec typeSpec) =>
			new FullNameFactory().GetDefinitionAssembly(typeSpec);

		/// <summary>
		/// Gets the scope type
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <returns>The scope type or <c>null</c> if none found</returns>
		public static ITypeDefOrRef ScopeType(TypeSpec typeSpec) =>
			new FullNameFactory().GetScopeType(typeSpec);

		/// <summary>
		/// Gets the scope
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <returns>The <see cref="IScope"/> or <c>null</c> if none found</returns>
		public static IScope Scope(TypeSpec typeSpec) =>
			new FullNameFactory().GetScope(typeSpec);

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="typeSpec">The <c>TypeSpec</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(TypeSpec typeSpec) =>
			new FullNameFactory().GetOwnerModule(typeSpec);

		/// <summary>
		/// Returns the namespace of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(TypeSig typeSig, bool isReflection, StringBuilder sb = null) =>
			NamespaceSB(typeSig, isReflection, sb).ToString();

		/// <summary>
		/// Returns the namespace of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(TypeSig typeSig, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateNamespace(typeSig, true);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(TypeSig typeSig, bool isReflection, StringBuilder sb = null) =>
			NameSB(typeSig, isReflection, sb).ToString();

		/// <summary>
		/// Returns the name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(TypeSig typeSig, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateName(typeSig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="typeGenArgs">Type generic args or <c>null</c> if none</param>
		/// <param name="methodGenArgs">Method generic args or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(TypeSig typeSig, bool isReflection, IFullNameFactoryHelper helper = null, IList<TypeSig> typeGenArgs = null, IList<TypeSig> methodGenArgs = null, StringBuilder sb = null) =>
			FullNameSB(typeSig, isReflection, helper, typeGenArgs, methodGenArgs, sb).ToString();

		/// <summary>
		/// Returns the full name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The type sig</param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="typeGenArgs">Type generic args or <c>null</c> if none</param>
		/// <param name="methodGenArgs">Method generic args or <c>null</c> if none</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(TypeSig typeSig, bool isReflection, IFullNameFactoryHelper helper, IList<TypeSig> typeGenArgs, IList<TypeSig> methodGenArgs, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, helper, sb);
			if (typeGenArgs is not null || methodGenArgs is not null)
				fnc.genericArguments = new GenericArguments();
			if (typeGenArgs is not null)
				fnc.genericArguments.PushTypeArgs(typeGenArgs);
			if (methodGenArgs is not null)
				fnc.genericArguments.PushMethodArgs(methodGenArgs);
			fnc.CreateFullName(typeSig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(TypeSig typeSig, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			AssemblyQualifiedNameSB(typeSig, helper, sb).ToString();

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(TypeSig typeSig, IFullNameFactoryHelper helper, StringBuilder sb) {
			var fnc = new FullNameFactory(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(typeSig);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(TypeSig typeSig) =>
			new FullNameFactory().GetDefinitionAssembly(typeSig);

		/// <summary>
		/// Gets the scope
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <returns>The <see cref="IScope"/> or <c>null</c> if none found</returns>
		public static IScope Scope(TypeSig typeSig) =>
			new FullNameFactory().GetScope(typeSig);

		/// <summary>
		/// Gets the scope type
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <returns>The scope type or <c>null</c> if none found</returns>
		public static ITypeDefOrRef ScopeType(TypeSig typeSig) =>
			new FullNameFactory().GetScopeType(typeSig);

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="typeSig">The <c>TypeSig</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(TypeSig typeSig) =>
			new FullNameFactory().GetOwnerModule(typeSig);

		/// <summary>
		/// Returns the namespace of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static string Namespace(ExportedType exportedType, bool isReflection, StringBuilder sb = null) =>
			NamespaceSB(exportedType, isReflection, sb).ToString();

		/// <summary>
		/// Returns the namespace of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The namespace</returns>
		public static StringBuilder NamespaceSB(ExportedType exportedType, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateNamespace(exportedType, true);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static string Name(ExportedType exportedType, bool isReflection, StringBuilder sb = null) =>
			NameSB(exportedType, isReflection, sb).ToString();

		/// <summary>
		/// Returns the name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The name</returns>
		public static StringBuilder NameSB(ExportedType exportedType, bool isReflection, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, null, sb);
			fnc.CreateName(exportedType);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the full name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static string FullName(ExportedType exportedType, bool isReflection, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			FullNameSB(exportedType, isReflection, helper, sb).ToString();

		/// <summary>
		/// Returns the full name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="isReflection">Set if output should be compatible with reflection</param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The full name</returns>
		public static StringBuilder FullNameSB(ExportedType exportedType, bool isReflection, IFullNameFactoryHelper helper, StringBuilder sb) {
			var fnc = new FullNameFactory(isReflection, helper, sb);
			fnc.CreateFullName(exportedType);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static string AssemblyQualifiedName(ExportedType exportedType, IFullNameFactoryHelper helper = null, StringBuilder sb = null) =>
			AssemblyQualifiedNameSB(exportedType, helper, sb).ToString();

		/// <summary>
		/// Returns the assembly qualified full name of a <see cref="ExportedType"/>
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <param name="helper">Helps print the name</param>
		/// <param name="sb">String builder to use or null</param>
		/// <returns>The assembly qualified full name</returns>
		public static StringBuilder AssemblyQualifiedNameSB(ExportedType exportedType, IFullNameFactoryHelper helper, StringBuilder sb) {
			var fnc = new FullNameFactory(true, helper, sb);
			fnc.CreateAssemblyQualifiedName(exportedType);
			return fnc.sb ?? new StringBuilder();
		}

		/// <summary>
		/// Returns the assembly where this type is defined
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <returns>A <see cref="IAssembly"/> or <c>null</c> if none found</returns>
		public static IAssembly DefinitionAssembly(ExportedType exportedType) =>
			new FullNameFactory().GetDefinitionAssembly(exportedType);

		/// <summary>
		/// Gets the scope type
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <returns>The scope type or <c>null</c> if none found</returns>
		public static ITypeDefOrRef ScopeType(ExportedType exportedType) =>
			new FullNameFactory().GetScopeType(exportedType);

		/// <summary>
		/// Gets the scope
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <returns>The <see cref="IScope"/> or <c>null</c> if none found</returns>
		public static IScope Scope(ExportedType exportedType) =>
			new FullNameFactory().GetScope(exportedType);

		/// <summary>
		/// Returns the owner module. The type was created from metadata in this module.
		/// </summary>
		/// <param name="exportedType">The <c>ExportedType</c></param>
		/// <returns>A <see cref="ModuleDef"/> or <c>null</c> if none found</returns>
		public static ModuleDef OwnerModule(ExportedType exportedType) =>
			new FullNameFactory().GetOwnerModule(exportedType);

		string Result => sb?.ToString();

		FullNameFactory(bool isReflection, IFullNameFactoryHelper helper, StringBuilder sb) {
			this.sb = sb ?? new StringBuilder();
			this.isReflection = isReflection;
			this.helper = helper;
			genericArguments = null;
			recursionCounter = new RecursionCounter();
		}

		bool MustUseAssemblyName(IType type) {
			if (helper is null)
				return true;
			return helper.MustUseAssemblyName(GetDefinitionType(type));
		}

		IType GetDefinitionType(IType type) {
			if (!recursionCounter.Increment())
				return type;

			if (type is TypeSpec ts)
				type = ts.TypeSig;

			if (type is TypeSig sig) {
				GenericInstSig gis;
				if (sig is TypeDefOrRefSig tdr)
					type = GetDefinitionType(tdr.TypeDefOrRef);
				else if ((gis = sig as GenericInstSig) is not null)
					type = GetDefinitionType(gis.GenericType);
				else
					type = GetDefinitionType(sig.Next);
			}

			recursionCounter.Decrement();
			return type;
		}

		void CreateFullName(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef)
				CreateFullName((TypeRef)typeDefOrRef);
			else if (typeDefOrRef is TypeDef)
				CreateFullName((TypeDef)typeDefOrRef);
			else if (typeDefOrRef is TypeSpec)
				CreateFullName((TypeSpec)typeDefOrRef);
			else
				sb.Append(NULLVALUE);
		}

		void CreateNamespace(ITypeDefOrRef typeDefOrRef, bool onlyNamespace) {
			if (typeDefOrRef is TypeRef)
				CreateNamespace((TypeRef)typeDefOrRef, onlyNamespace);
			else if (typeDefOrRef is TypeDef)
				CreateNamespace((TypeDef)typeDefOrRef, onlyNamespace);
			else if (typeDefOrRef is TypeSpec)
				CreateNamespace((TypeSpec)typeDefOrRef, onlyNamespace);
			else
				sb.Append(NULLVALUE);
		}

		void CreateName(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef)
				CreateName((TypeRef)typeDefOrRef);
			else if (typeDefOrRef is TypeDef)
				CreateName((TypeDef)typeDefOrRef);
			else if (typeDefOrRef is TypeSpec)
				CreateName((TypeSpec)typeDefOrRef);
			else
				sb.Append(NULLVALUE);
		}

		void CreateAssemblyQualifiedName(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef)
				CreateAssemblyQualifiedName((TypeRef)typeDefOrRef);
			else if (typeDefOrRef is TypeDef)
				CreateAssemblyQualifiedName((TypeDef)typeDefOrRef);
			else if (typeDefOrRef is TypeSpec)
				CreateAssemblyQualifiedName((TypeSpec)typeDefOrRef);
			else
				sb.Append(NULLVALUE);
		}

		void CreateAssemblyQualifiedName(TypeRef typeRef) {
			if (typeRef is null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			CreateFullName(typeRef);
			if (MustUseAssemblyName(typeRef))
				AddAssemblyName(GetDefinitionAssembly(typeRef));

			recursionCounter.Decrement();
		}

		void CreateFullName(TypeRef typeRef) {
			if (typeRef is null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			if (typeRef.ResolutionScope is TypeRef declaringTypeRef) {
				CreateFullName(declaringTypeRef);
				AddNestedTypeSeparator();
			}

			if (AddNamespace(typeRef.Namespace, false))
				sb.Append('.');
			AddName(typeRef.Name);

			recursionCounter.Decrement();
		}

		void CreateNamespace(TypeRef typeRef, bool onlyNamespace) {
			if (typeRef is null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddNamespace(typeRef.Namespace, onlyNamespace);
		}

		void CreateName(TypeRef typeRef) {
			if (typeRef is null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddName(typeRef.Name);
		}

		void CreateAssemblyQualifiedName(TypeDef typeDef) {
			if (typeDef is null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			CreateFullName(typeDef);
			if (MustUseAssemblyName(typeDef))
				AddAssemblyName(GetDefinitionAssembly(typeDef));

			recursionCounter.Decrement();
		}

		void CreateFullName(TypeDef typeDef) {
			if (typeDef is null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			var declaringTypeDef = typeDef.DeclaringType;
			if (declaringTypeDef is not null) {
				CreateFullName(declaringTypeDef);
				AddNestedTypeSeparator();
			}

			if (AddNamespace(typeDef.Namespace, false))
				sb.Append('.');
			AddName(typeDef.Name);

			recursionCounter.Decrement();
		}

		void CreateNamespace(TypeDef typeDef, bool onlyNamespace) {
			if (typeDef is null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddNamespace(typeDef.Namespace, onlyNamespace);
		}

		void CreateName(TypeDef typeDef) {
			if (typeDef is null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddName(typeDef.Name);
		}

		void CreateAssemblyQualifiedName(TypeSpec typeSpec) {
			if (typeSpec is null) {
				sb.Append(NULLVALUE);
				return;
			}
			CreateAssemblyQualifiedName(typeSpec.TypeSig);
		}

		void CreateFullName(TypeSpec typeSpec) {
			if (typeSpec is null) {
				sb.Append(NULLVALUE);
				return;
			}
			CreateFullName(typeSpec.TypeSig);
		}

		void CreateNamespace(TypeSpec typeSpec, bool onlyNamespace) {
			if (typeSpec is null) {
				sb.Append(NULLVALUE);
				return;
			}
			CreateNamespace(typeSpec.TypeSig, onlyNamespace);
		}

		void CreateName(TypeSpec typeSpec) {
			if (typeSpec is null) {
				sb.Append(NULLVALUE);
				return;
			}
			CreateName(typeSpec.TypeSig);
		}


		void CreateAssemblyQualifiedName(TypeSig typeSig) {
			if (typeSig is null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			CreateFullName(typeSig);
			if (MustUseAssemblyName(typeSig))
				AddAssemblyName(GetDefinitionAssembly(typeSig));

			recursionCounter.Decrement();
		}

		void CreateFullName(TypeSig typeSig) => CreateTypeSigName(typeSig, TYPESIG_NAMESPACE | TYPESIG_NAME);
		void CreateNamespace(TypeSig typeSig, bool onlyNamespace) => CreateTypeSigName(typeSig, TYPESIG_NAMESPACE | (onlyNamespace ? TYPESIG_ONLY_NAMESPACE : 0));
		void CreateName(TypeSig typeSig) => CreateTypeSigName(typeSig, TYPESIG_NAME);

		TypeSig ReplaceGenericArg(TypeSig typeSig) {
			if (genericArguments is null)
				return typeSig;
			var newTypeSig = genericArguments.Resolve(typeSig);
			if (newTypeSig != typeSig)
				genericArguments = null;
			return newTypeSig;
		}

		const int TYPESIG_NAMESPACE = 1;
		const int TYPESIG_NAME = 2;
		const int TYPESIG_ONLY_NAMESPACE = 4;
		void CreateTypeSigName(TypeSig typeSig, int flags) {
			if (typeSig is null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			bool createNamespace = (flags & TYPESIG_NAMESPACE) != 0;
			bool createName = (flags & TYPESIG_NAME) != 0;
			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				if (createNamespace && createName)
					CreateFullName(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				else if (createNamespace)
					CreateNamespace(((TypeDefOrRefSig)typeSig).TypeDefOrRef, (flags & TYPESIG_ONLY_NAMESPACE) != 0);
				else if (createName)
					CreateName(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName)
					sb.Append('*');
				break;

			case ElementType.ByRef:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName)
					sb.Append('&');
				break;

			case ElementType.Array:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName) {
					var arraySig = (ArraySig)typeSig;
					sb.Append('[');
					uint rank = arraySig.Rank;
					if (rank > MaxArrayRank)
						rank = MaxArrayRank;
					if (rank == 0)
						sb.Append("<RANK0>");	// Not allowed
					else if (rank == 1)
						sb.Append('*');
					else for (int i = 0; i < (int)rank; i++) {
						if (i != 0)
							sb.Append(',');
						if (!isReflection) {
							const int NO_LOWER = int.MinValue;
							const uint NO_SIZE = uint.MaxValue;
							int lower = i < arraySig.LowerBounds.Count ? arraySig.LowerBounds[i] : NO_LOWER;
							uint size = i < arraySig.Sizes.Count ? arraySig.Sizes[i] : NO_SIZE;
							if (lower != NO_LOWER) {
								sb.Append(lower);
								sb.Append("..");
								if (size != NO_SIZE)
									sb.Append(lower + (int)size - 1);
								else
									sb.Append('.');
							}
						}
					}
					sb.Append(']');
				}
				break;

			case ElementType.SZArray:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName)
					sb.Append("[]");
				break;

			case ElementType.CModReqd:
				CreateTypeSigName(typeSig.Next, flags);
				if (!isReflection && createName) {
					sb.Append(" modreq(");
					if (createNamespace)
						CreateFullName(((ModifierSig)typeSig).Modifier);
					else
						CreateName(((ModifierSig)typeSig).Modifier);
					sb.Append(")");
				}
				break;

			case ElementType.CModOpt:
				CreateTypeSigName(typeSig.Next, flags);
				if (!isReflection && createName) {
					sb.Append(" modopt(");
					if (createNamespace)
						CreateFullName(((ModifierSig)typeSig).Modifier);
					else
						CreateName(((ModifierSig)typeSig).Modifier);
					sb.Append(")");
				}
				break;

			case ElementType.Pinned:
				CreateTypeSigName(typeSig.Next, flags);
				break;

			case ElementType.ValueArray:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName) {
					var valueArraySig = (ValueArraySig)typeSig;
					sb.Append(" ValueArray(");
					sb.Append(valueArraySig.Size);
					sb.Append(')');
				}
				break;

			case ElementType.Module:
				CreateTypeSigName(typeSig.Next, flags);
				if (createName) {
					var moduleSig = (ModuleSig)typeSig;
					sb.Append(" Module(");
					sb.Append(moduleSig.Index);
					sb.Append(')');
				}
				break;

			case ElementType.GenericInst:
				var genericInstSig = (GenericInstSig)typeSig;
				var typeGenArgs = genericInstSig.GenericArguments;
				CreateTypeSigName(genericInstSig.GenericType, flags);
				if (createNamespace && createName) {
					if (isReflection) {
						sb.Append('[');
						int i = -1;
						int count = typeGenArgs.Count;
						for (int j = 0; j < count; j++) {
							var genArg = typeGenArgs[j];
							i++;
							if (i != 0)
								sb.Append(',');

							bool mustWriteAssembly = MustUseAssemblyName(genArg);
							if (mustWriteAssembly)
								sb.Append('[');

							CreateFullName(genArg);

							if (mustWriteAssembly) {
								sb.Append(", ");
								var asm = GetDefinitionAssembly(genArg);
								if (asm is null)
									sb.Append(NULLVALUE);
								else
									sb.Append(EscapeAssemblyName(GetAssemblyName(asm)));
								sb.Append(']');
							}
						}
						sb.Append(']');
					}
					else {
						sb.Append('<');
						int i = -1;
						int count = typeGenArgs.Count;
						for (int j = 0; j < count; j++) {
							var genArg = typeGenArgs[j];
							i++;
							if (i != 0)
								sb.Append(',');
							CreateFullName(genArg);
						}
						sb.Append('>');
					}
				}
				break;

			case ElementType.Var:
			case ElementType.MVar:
				if (createName) {
					var gs = (GenericSig)typeSig;
					var gp = gs.GenericParam;
					if (gp is null || !AddName(gp.Name)) {
						sb.Append(gs.IsMethodVar ? "!!" : "!");
						sb.Append(gs.Number);
					}
				}
				break;

			case ElementType.FnPtr:
				if (createName) {
					if (isReflection)
						sb.Append("(fnptr)");
					else
						CreateMethodFullName(null, null, ((FnPtrSig)typeSig).MethodSig, null);
				}
				break;

			case ElementType.Sentinel:
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
		}

		void CreateAssemblyQualifiedName(ExportedType exportedType) {
			if (exportedType is null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			CreateFullName(exportedType);
			if (MustUseAssemblyName(exportedType))
				AddAssemblyName(GetDefinitionAssembly(exportedType));

			recursionCounter.Decrement();
		}

		void CreateFullName(ExportedType exportedType) {
			if (exportedType is null) {
				sb.Append(NULLVALUE);
				return;
			}
			if (!recursionCounter.Increment()) {
				sb.Append(RECURSION_ERROR_RESULT_STRING);
				return;
			}

			if (exportedType.Implementation is ExportedType declaringExportedType) {
				CreateFullName(declaringExportedType);
				AddNestedTypeSeparator();
			}

			if (AddNamespace(exportedType.TypeNamespace, false))
				sb.Append('.');
			AddName(exportedType.TypeName);

			recursionCounter.Decrement();
		}

		void CreateNamespace(ExportedType exportedType, bool onlyNamespace) {
			if (exportedType is null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddNamespace(exportedType.TypeNamespace, onlyNamespace);
		}

		void CreateName(ExportedType exportedType) {
			if (exportedType is null) {
				sb.Append(NULLVALUE);
				return;
			}
			AddName(exportedType.TypeName);
		}

		static string GetAssemblyName(IAssembly assembly) {
			var pk = assembly.PublicKeyOrToken;
			if (pk is PublicKey)
				pk = ((PublicKey)pk).Token;
			return Utils.GetAssemblyNameString(EscapeAssemblyName(assembly.Name), assembly.Version, assembly.Culture, pk, assembly.Attributes);
		}

		static string EscapeAssemblyName(UTF8String asmSimpleName) =>
			EscapeAssemblyName(UTF8String.ToSystemString(asmSimpleName));

		static string EscapeAssemblyName(string asmSimpleName) {
			if (asmSimpleName.IndexOf(']') < 0)
				return asmSimpleName;
			var sb = new StringBuilder(asmSimpleName.Length);
			foreach (var c in asmSimpleName) {
				if (c == ']')
					sb.Append('\\');
				sb.Append(c);
			}
			return sb.ToString();
		}

		void AddNestedTypeSeparator() {
			if (isReflection)
				sb.Append('+');
			else
				sb.Append('/');
		}

		bool AddNamespace(UTF8String @namespace, bool onlyNamespace) {
			if (UTF8String.IsNullOrEmpty(@namespace))
				return false;
			// If it's reflection and only namespace (instead of full name), it's not escaped
			if (onlyNamespace && isReflection)
				sb.Append(@namespace.String);
			else
				AddIdentifier(@namespace.String);
			return true;
		}

		bool AddName(UTF8String name) {
			if (UTF8String.IsNullOrEmpty(name))
				return false;
			AddIdentifier(name.String);
			return true;
		}

		void AddAssemblyName(IAssembly assembly) {
			sb.Append(", ");
			if (assembly is null)
				sb.Append(NULLVALUE);
			else {
				var pkt = assembly.PublicKeyOrToken;
				if (pkt is PublicKey)
					pkt = ((PublicKey)pkt).Token;
				sb.Append(Utils.GetAssemblyNameString(assembly.Name, assembly.Version, assembly.Culture, pkt, assembly.Attributes));
			}
		}

		void AddIdentifier(string id) {
			if (isReflection) {
				// Periods are not escaped by Reflection, even if they're part of a type name.
				foreach (var c in id) {
					switch (c) {
					case ',':
					case '+':
					case '&':
					case '*':
					case '[':
					case ']':
					case '\\':
						sb.Append('\\');
						break;
					}
					sb.Append(c);
				}
			}
			else
				sb.Append(id);
		}

		IAssembly GetDefinitionAssembly(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef tr)
				return GetDefinitionAssembly(tr);

			if (typeDefOrRef is TypeDef td)
				return GetDefinitionAssembly(td);

			if (typeDefOrRef is TypeSpec ts)
				return GetDefinitionAssembly(ts);

			return null;
		}

		IScope GetScope(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef tr)
				return GetScope(tr);

			if (typeDefOrRef is TypeDef td)
				return td.Scope;

			if (typeDefOrRef is TypeSpec ts)
				return GetScope(ts);

			return null;
		}

		ITypeDefOrRef GetScopeType(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef tr)
				return tr;

			if (typeDefOrRef is TypeDef td)
				return td;

			if (typeDefOrRef is TypeSpec ts)
				return GetScopeType(ts);

			return null;
		}

		ModuleDef GetOwnerModule(ITypeDefOrRef typeDefOrRef) {
			if (typeDefOrRef is TypeRef tr)
				return GetOwnerModule(tr);

			if (typeDefOrRef is TypeDef td)
				return GetOwnerModule(td);

			if (typeDefOrRef is TypeSpec ts)
				return GetOwnerModule(ts);

			return null;
		}

		IAssembly GetDefinitionAssembly(TypeRef typeRef) {
			if (typeRef is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IAssembly result;

			var scope = typeRef.ResolutionScope;
			if (scope is null)
				result = null;	//TODO: Check ownerModule's ExportedType table
			else if (scope is TypeRef)
				result = GetDefinitionAssembly((TypeRef)scope);
			else if (scope is AssemblyRef)
				result = (AssemblyRef)scope;
			else if (scope is ModuleRef) {
				var ownerModule = GetOwnerModule(typeRef);
				result = ownerModule?.Assembly;
			}
			else if (scope is ModuleDef)
				result = ((ModuleDef)scope).Assembly;
			else
				result = null;	// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		IScope GetScope(TypeRef typeRef) {
			if (typeRef is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IScope result;
			TypeRef tr;
			AssemblyRef asmRef;
			ModuleRef modRef;
			ModuleDef modDef;

			var scope = typeRef.ResolutionScope;
			if (scope is null)
				result = null;	//TODO: Check ownerModule's ExportedType table
			else if ((tr = scope as TypeRef) is not null)
				result = GetScope(tr);
			else if ((asmRef = scope as AssemblyRef) is not null)
				result = asmRef;
			else if ((modRef = scope as ModuleRef) is not null)
				result = modRef;
			else if ((modDef = scope as ModuleDef) is not null)
				result = modDef;
			else
				result = null;	// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		ModuleDef GetOwnerModule(TypeRef typeRef) {
			if (typeRef is null)
				return null;
			return typeRef.Module;
		}

		IAssembly GetDefinitionAssembly(TypeDef typeDef) => GetOwnerModule(typeDef)?.Assembly;

		ModuleDef GetOwnerModule(TypeDef typeDef) {
			if (typeDef is null)
				return null;

			ModuleDef result = null;
			for (int i = recursionCounter.Counter; i < RecursionCounter.MAX_RECURSION_COUNT; i++) {
				var declaringType = typeDef.DeclaringType;
				if (declaringType is null) {
					result = typeDef.Module2;
					break;
				}
				typeDef = declaringType;
			}

			return result;
		}

		IAssembly GetDefinitionAssembly(TypeSpec typeSpec) {
			if (typeSpec is null)
				return null;
			return GetDefinitionAssembly(typeSpec.TypeSig);
		}

		IScope GetScope(TypeSpec typeSpec) {
			if (typeSpec is null)
				return null;
			return GetScope(typeSpec.TypeSig);
		}

		ITypeDefOrRef GetScopeType(TypeSpec typeSpec) {
			if (typeSpec is null)
				return null;
			return GetScopeType(typeSpec.TypeSig);
		}

		ModuleDef GetOwnerModule(TypeSpec typeSpec) {
			if (typeSpec is null)
				return null;
			return GetOwnerModule(typeSpec.TypeSig);
		}

		IAssembly GetDefinitionAssembly(TypeSig typeSig) {
			if (typeSig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IAssembly result;

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				result = GetDefinitionAssembly(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				result = GetDefinitionAssembly(typeSig.Next);
				break;

			case ElementType.GenericInst:
				var genericInstSig = (GenericInstSig)typeSig;
				var genericType = genericInstSig.GenericType;
				result = GetDefinitionAssembly(genericType?.TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
			case ElementType.FnPtr:
			case ElementType.Sentinel:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
			return result;
		}

		ITypeDefOrRef GetScopeType(TypeSig typeSig) {
			if (typeSig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			ITypeDefOrRef result;

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				result = GetScopeType(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				result = GetScopeType(typeSig.Next);
				break;

			case ElementType.GenericInst:
				result = GetScopeType(((GenericInstSig)typeSig).GenericType?.TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
			case ElementType.FnPtr:
			case ElementType.Sentinel:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
			return result;
		}

		IScope GetScope(TypeSig typeSig) {
			if (typeSig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IScope result;

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				result = GetScope(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				result = GetScope(typeSig.Next);
				break;

			case ElementType.GenericInst:
				result = GetScope(((GenericInstSig)typeSig).GenericType?.TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
			case ElementType.FnPtr:
			case ElementType.Sentinel:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
			return result;
		}

		ModuleDef GetOwnerModule(TypeSig typeSig) {
			if (typeSig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			ModuleDef result;

			var old = genericArguments;
			typeSig = ReplaceGenericArg(typeSig);

			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				result = GetOwnerModule(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				result = GetOwnerModule(typeSig.Next);
				break;

			case ElementType.GenericInst:
				result = GetOwnerModule(((GenericInstSig)typeSig).GenericType?.TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
			case ElementType.FnPtr:
			case ElementType.Sentinel:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			genericArguments = old;
			recursionCounter.Decrement();
			return result;
		}

		IAssembly GetDefinitionAssembly(ExportedType exportedType) {
			if (exportedType is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IAssembly result;
			AssemblyRef asmRef;

			var scope = exportedType.Implementation;
			if (scope is ExportedType et)
				result = GetDefinitionAssembly(et);
			else if ((asmRef = scope as AssemblyRef) is not null)
				result = asmRef;
			else if (scope is FileDef) {
				var ownerModule = GetOwnerModule(exportedType);
				result = ownerModule?.Assembly;
			}
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		ITypeDefOrRef GetScopeType(ExportedType exportedType) => null;

		IScope GetScope(ExportedType exportedType) {
			if (exportedType is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			IScope result;
			AssemblyRef asmRef;
			FileDef file;

			var scope = exportedType.Implementation;
			if (scope is ExportedType et)
				result = GetScope(et);
			else if ((asmRef = scope as AssemblyRef) is not null)
				result = asmRef;
			else if ((file = scope as FileDef) is not null) {
				var ownerModule = GetOwnerModule(exportedType);
				//TODO: Not all modules' names are equal to the name in FileDef.Name
				var modRef = new ModuleRefUser(ownerModule, file.Name);
				if (ownerModule is not null)
					ownerModule.UpdateRowId(modRef);
				result = modRef;
			}
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		ModuleDef GetOwnerModule(ExportedType exportedType) {
			if (exportedType is null)
				return null;
			return exportedType.Module;
		}

		void CreateFieldFullName(string declaringType, string name, FieldSig fieldSig) {
			CreateFullName(fieldSig?.Type);
			sb.Append(' ');

			if (declaringType is not null) {
				sb.Append(declaringType);
				sb.Append("::");
			}
			if (name is not null)
				sb.Append(name);
		}

		void CreateMethodFullName(string declaringType, string name, MethodBaseSig methodSig, MethodDef gppMethod) {
			if (methodSig is null) {
				sb.Append(NULLVALUE);
				return;
			}

			CreateFullName(methodSig.RetType);
			sb.Append(' ');
			if (declaringType is not null) {
				sb.Append(declaringType);
				sb.Append("::");
			}
			if (name is not null)
				sb.Append(name);

			if (methodSig.Generic) {
				sb.Append('<');
				uint genParamCount = methodSig.GenParamCount;
				if (genParamCount > MaxMethodGenParamCount)
					genParamCount = MaxMethodGenParamCount;
				for (uint i = 0; i < genParamCount; i++) {
					if (i != 0)
						sb.Append(',');
					CreateFullName(new GenericMVar(i, gppMethod));
				}
				sb.Append('>');
			}
			sb.Append('(');
			int count = PrintMethodArgList(methodSig.Params, false, false);
			PrintMethodArgList(methodSig.ParamsAfterSentinel, count > 0, true);
			sb.Append(')');
		}

		int PrintMethodArgList(IList<TypeSig> args, bool hasPrintedArgs, bool isAfterSentinel) {
			if (args is null)
				return 0;
			if (isAfterSentinel) {
				if (hasPrintedArgs)
					sb.Append(',');
				sb.Append("...");
				hasPrintedArgs = true;
			}
			int count = 0;
			int argsCount = args.Count;
			for (int i = 0; i < argsCount; i++) {
				var arg = args[i];
				count++;
				if (hasPrintedArgs)
					sb.Append(',');
				CreateFullName(arg);
				hasPrintedArgs = true;
			}
			return count;
		}

		void CreatePropertyFullName(string declaringType, UTF8String name, CallingConventionSig propertySig) =>
			CreateMethodFullName(declaringType, UTF8String.ToSystemString(name), propertySig as MethodBaseSig, null);

		void CreateEventFullName(string declaringType, UTF8String name, ITypeDefOrRef typeDefOrRef) {
			CreateFullName(typeDefOrRef);
			sb.Append(' ');
			if (declaringType is not null) {
				sb.Append(declaringType);
				sb.Append("::");
			}
			if (!UTF8String.IsNull(name))
				sb.Append(UTF8String.ToSystemString(name));
		}

		/// <inheritdoc/>
		public override string ToString() => Result;
	}
}





namespace dnlib.DotNet {
	readonly struct GenericArgumentsStack {
		readonly List<IList<TypeSig>> argsStack;
		readonly bool isTypeVar;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isTypeVar"><c>true</c> if it's for generic types, <c>false</c> if generic methods</param>
		public GenericArgumentsStack(bool isTypeVar) {
			argsStack = new List<IList<TypeSig>>();
			this.isTypeVar = isTypeVar;
		}

		/// <summary>
		/// Pushes generic arguments
		/// </summary>
		/// <param name="args">The generic arguments</param>
		public void Push(IList<TypeSig> args) => argsStack.Add(args);

		/// <summary>
		/// Pops generic arguments
		/// </summary>
		/// <returns>The popped generic arguments</returns>
		public IList<TypeSig> Pop() {
			int index = argsStack.Count - 1;
			var result = argsStack[index];
			argsStack.RemoveAt(index);
			return result;
		}

		/// <summary>
		/// Resolves a generic argument
		/// </summary>
		/// <param name="number">Generic variable number</param>
		/// <returns>A <see cref="TypeSig"/> or <c>null</c> if none was found</returns>
		public TypeSig Resolve(uint number) {
			TypeSig result = null;
			for (int i = argsStack.Count - 1; i >= 0; i--) {
				var args = argsStack[i];
				if (number >= args.Count)
					return null;
				var typeSig = args[(int)number];
				var gvar = typeSig as GenericSig;
				if (gvar is null || gvar.IsTypeVar != isTypeVar)
					return typeSig;
				result = gvar;
				number = gvar.Number;
			}
			return result;
		}
	}

	/// <summary>
	/// Replaces generic type/method var with its generic argument
	/// </summary>
	sealed class GenericArguments {
		GenericArgumentsStack typeArgsStack = new GenericArgumentsStack(true);
		GenericArgumentsStack methodArgsStack = new GenericArgumentsStack(false);

		/// <summary>
		/// Pushes generic arguments
		/// </summary>
		/// <param name="typeArgs">The generic arguments</param>
		public void PushTypeArgs(IList<TypeSig> typeArgs) => typeArgsStack.Push(typeArgs);

		/// <summary>
		/// Pops generic arguments
		/// </summary>
		/// <returns>The popped generic arguments</returns>
		public IList<TypeSig> PopTypeArgs() => typeArgsStack.Pop();

		/// <summary>
		/// Pushes generic arguments
		/// </summary>
		/// <param name="methodArgs">The generic arguments</param>
		public void PushMethodArgs(IList<TypeSig> methodArgs) => methodArgsStack.Push(methodArgs);

		/// <summary>
		/// Pops generic arguments
		/// </summary>
		/// <returns>The popped generic arguments</returns>
		public IList<TypeSig> PopMethodArgs() => methodArgsStack.Pop();

		/// <summary>
		/// Replaces a generic type/method var with its generic argument (if any). If
		/// <paramref name="typeSig"/> isn't a generic type/method var or if it can't
		/// be resolved, it itself is returned. Else the resolved type is returned.
		/// </summary>
		/// <param name="typeSig">Type signature</param>
		/// <returns>New <see cref="TypeSig"/> which is never <c>null</c> unless
		/// <paramref name="typeSig"/> is <c>null</c></returns>
		public TypeSig Resolve(TypeSig typeSig) {
			if (typeSig is null)
				return null;

			var sig = typeSig;

			if (sig is GenericMVar genericMVar) {
				var newSig = methodArgsStack.Resolve(genericMVar.Number);
				if (newSig is null || newSig == sig)
					return sig;
				return newSig;
			}

			if (sig is GenericVar genericVar) {
				var newSig = typeArgsStack.Resolve(genericVar.Number);
				if (newSig is null || newSig == sig)
					return sig;
				return newSig;
			}

			return sig;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the GenericParam table
	/// </summary>
	[DebuggerDisplay("{Name.String}")]
	public abstract class GenericParam : IHasCustomAttribute, IHasCustomDebugInformation, IMemberDef, IListListener<GenericParamConstraint> {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.GenericParam, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 19;

		/// <summary>
		/// Gets the owner type/method
		/// </summary>
		public ITypeOrMethodDef Owner {
			get => owner;
			internal set => owner = value;
		}
		/// <summary/>
		protected ITypeOrMethodDef owner;

		/// <summary>
		/// Gets the declaring type or <c>null</c> if none or if <see cref="Owner"/> is
		/// not a <see cref="TypeDef"/>
		/// </summary>
		public TypeDef DeclaringType => owner as TypeDef;

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType => owner as TypeDef;

		/// <summary>
		/// Gets the declaring method or <c>null</c> if none or if <see cref="Owner"/> is
		/// not a <see cref="MethodDef"/>
		/// </summary>
		public MethodDef DeclaringMethod => owner as MethodDef;

		/// <summary>
		/// From column GenericParam.Number
		/// </summary>
		public ushort Number {
			get => number;
			set => number = value;
		}
		/// <summary/>
		protected ushort number;

		/// <summary>
		/// From column GenericParam.Flags
		/// </summary>
		public GenericParamAttributes Flags {
			get => (GenericParamAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column GenericParam.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column GenericParam.Kind (v1.1 only)
		/// </summary>
		public ITypeDefOrRef Kind {
			get => kind;
			set => kind = value;
		}
		/// <summary/>
		protected ITypeDefOrRef kind;

		/// <summary>
		/// Gets the generic param constraints
		/// </summary>
		public IList<GenericParamConstraint> GenericParamConstraints {
			get {
				if (genericParamConstraints is null)
					InitializeGenericParamConstraints();
				return genericParamConstraints;
			}
		}
		/// <summary/>
		protected LazyList<GenericParamConstraint> genericParamConstraints;
		/// <summary>Initializes <see cref="genericParamConstraints"/></summary>
		protected virtual void InitializeGenericParamConstraints() =>
			Interlocked.CompareExchange(ref genericParamConstraints, new LazyList<GenericParamConstraint>(this), null);

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 19;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// <c>true</c> if <see cref="GenericParamConstraints"/> is not empty
		/// </summary>
		public bool HasGenericParamConstraints => GenericParamConstraints.Count > 0;

		/// <inheritdoc/>
		public ModuleDef Module => owner?.Module;

		/// <inheritdoc/>
		public string FullName => UTF8String.ToSystemStringOrEmpty(name);

		bool IIsTypeOrMethod.IsType => false;
		bool IIsTypeOrMethod.IsMethod => false;
		bool IMemberRef.IsField => false;
		bool IMemberRef.IsTypeSpec => false;
		bool IMemberRef.IsTypeRef => false;
		bool IMemberRef.IsTypeDef => false;
		bool IMemberRef.IsMethodSpec => false;
		bool IMemberRef.IsMethodDef => false;
		bool IMemberRef.IsMemberRef => false;
		bool IMemberRef.IsFieldDef => false;
		bool IMemberRef.IsPropertyDef => false;
		bool IMemberRef.IsEventDef => false;
		bool IMemberRef.IsGenericParam => true;

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(GenericParamAttributes andMask, GenericParamAttributes orMask) =>
			attributes = (attributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, GenericParamAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets variance (non, contra, co)
		/// </summary>
		public GenericParamAttributes Variance {
			get => (GenericParamAttributes)attributes & GenericParamAttributes.VarianceMask;
			set => ModifyAttributes(~GenericParamAttributes.VarianceMask, value & GenericParamAttributes.VarianceMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="GenericParamAttributes.NonVariant"/> is set
		/// </summary>
		public bool IsNonVariant => Variance == GenericParamAttributes.NonVariant;

		/// <summary>
		/// <c>true</c> if <see cref="GenericParamAttributes.Covariant"/> is set
		/// </summary>
		public bool IsCovariant => Variance == GenericParamAttributes.Covariant;

		/// <summary>
		/// <c>true</c> if <see cref="GenericParamAttributes.Contravariant"/> is set
		/// </summary>
		public bool IsContravariant => Variance == GenericParamAttributes.Contravariant;

		/// <summary>
		/// Gets/sets the special constraint
		/// </summary>
		public GenericParamAttributes SpecialConstraint {
			get => (GenericParamAttributes)attributes & GenericParamAttributes.SpecialConstraintMask;
			set => ModifyAttributes(~GenericParamAttributes.SpecialConstraintMask, value & GenericParamAttributes.SpecialConstraintMask);
		}

		/// <summary>
		/// <c>true</c> if there are no special constraints
		/// </summary>
		public bool HasNoSpecialConstraint => ((GenericParamAttributes)attributes & GenericParamAttributes.SpecialConstraintMask) == GenericParamAttributes.NoSpecialConstraint;

		/// <summary>
		/// Gets/sets the <see cref="GenericParamAttributes.ReferenceTypeConstraint"/> bit
		/// </summary>
		public bool HasReferenceTypeConstraint {
			get => ((GenericParamAttributes)attributes & GenericParamAttributes.ReferenceTypeConstraint) != 0;
			set => ModifyAttributes(value, GenericParamAttributes.ReferenceTypeConstraint);
		}

		/// <summary>
		/// Gets/sets the <see cref="GenericParamAttributes.NotNullableValueTypeConstraint"/> bit
		/// </summary>
		public bool HasNotNullableValueTypeConstraint {
			get => ((GenericParamAttributes)attributes & GenericParamAttributes.NotNullableValueTypeConstraint) != 0;
			set => ModifyAttributes(value, GenericParamAttributes.NotNullableValueTypeConstraint);
		}

		/// <summary>
		/// Gets/sets the <see cref="GenericParamAttributes.DefaultConstructorConstraint"/> bit
		/// </summary>
		public bool HasDefaultConstructorConstraint {
			get => ((GenericParamAttributes)attributes & GenericParamAttributes.DefaultConstructorConstraint) != 0;
			set => ModifyAttributes(value, GenericParamAttributes.DefaultConstructorConstraint);
		}

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnLazyAdd(int index, ref GenericParamConstraint value) => OnLazyAdd2(index, ref value);

		internal virtual void OnLazyAdd2(int index, ref GenericParamConstraint value) {
#if DEBUG
			if (value.Owner != this)
				throw new InvalidOperationException("Added generic param constraint's Owner != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnAdd(int index, GenericParamConstraint value) {
			if (value.Owner is not null)
				throw new InvalidOperationException("Generic param constraint is already owned by another generic param. Set Owner to null first.");
			value.Owner = this;
		}

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnRemove(int index, GenericParamConstraint value) => value.Owner = null;

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<GenericParamConstraint>.OnClear() {
			foreach (var gpc in genericParamConstraints.GetEnumerable_NoLock())
				gpc.Owner = null;
		}

		/// <inheritdoc/>
		public override string ToString() {
			var o = owner;
			if (o is TypeDef)
				return $"!{number}";
			if (o is MethodDef)
				return $"!!{number}";
			return $"??{number}";
		}
	}

	/// <summary>
	/// A GenericParam row created by the user and not present in the original .NET file
	/// </summary>
	public class GenericParamUser : GenericParam {
		/// <summary>
		/// Default constructor
		/// </summary>
		public GenericParamUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">The generic param number</param>
		public GenericParamUser(ushort number)
			: this(number, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">The generic param number</param>
		/// <param name="flags">Flags</param>
		public GenericParamUser(ushort number, GenericParamAttributes flags)
			: this(number, flags, UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">The generic param number</param>
		/// <param name="flags">Flags</param>
		/// <param name="name">Name</param>
		public GenericParamUser(ushort number, GenericParamAttributes flags, UTF8String name) {
			genericParamConstraints = new LazyList<GenericParamConstraint>(this);
			this.number = number;
			attributes = (int)flags;
			this.name = name;
		}
	}

	/// <summary>
	/// Created from a row in the GenericParam table
	/// </summary>
	sealed class GenericParamMD : GenericParam, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.GenericParam, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), GetGenericParamContext(owner), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override void InitializeGenericParamConstraints() {
			var list = readerModule.Metadata.GetGenericParamConstraintRidList(origRid);
			var tmp = new LazyList<GenericParamConstraint, RidList>(list.Count, this, list, (list2, index) => readerModule.ResolveGenericParamConstraint(list2[index], GetGenericParamContext(owner)));
			Interlocked.CompareExchange(ref genericParamConstraints, tmp, null);
		}

		static GenericParamContext GetGenericParamContext(ITypeOrMethodDef tmOwner) {
			if (tmOwner is MethodDef md)
				return GenericParamContext.Create(md);
			return new GenericParamContext(tmOwner as TypeDef);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>GenericParam</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public GenericParamMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.GenericParamTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"GenericParam rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadGenericParamRow(origRid, out var row);
			Debug.Assert(b);
			number = row.Number;
			attributes = row.Flags;
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			owner = readerModule.GetOwner(this);
			if (row.Kind != 0)
				kind = readerModule.ResolveTypeDefOrRef(row.Kind, GetGenericParamContext(owner));
		}

		internal GenericParamMD InitializeAll() {
			MemberMDInitializer.Initialize(Owner);
			MemberMDInitializer.Initialize(Number);
			MemberMDInitializer.Initialize(Flags);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(Kind);
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(GenericParamConstraints);
			return this;
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref GenericParamConstraint value) {
			if (value.Owner != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadGenericParamConstraint(value.Rid, GetGenericParamContext(owner)).InitializeAll());
				value.Owner = this;
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Generic parameter flags. See CorHdr.h/CorGenericParamAttr
	/// </summary>
	[Flags]
	public enum GenericParamAttributes : ushort {
		/// <summary/>
		VarianceMask			= 0x0003,
		/// <summary/>
		NonVariant				= 0x0000,
		/// <summary/>
		Covariant				= 0x0001,
		/// <summary/>
		Contravariant			= 0x0002,

		/// <summary/>
		SpecialConstraintMask	= 0x001C,
		/// <summary/>
		NoSpecialConstraint		= 0x0000,
		/// <summary>type argument must be a reference type</summary>
		ReferenceTypeConstraint = 0x0004,
		/// <summary>type argument must be a value type but not Nullable</summary>
		NotNullableValueTypeConstraint = 0x0008,
		/// <summary>type argument must have a public default constructor</summary>
		DefaultConstructorConstraint = 0x0010,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the GenericParamConstraint table
	/// </summary>
	public abstract class GenericParamConstraint : IHasCustomAttribute, IHasCustomDebugInformation, IContainsGenericParameter {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.GenericParamConstraint, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 20;

		/// <summary>
		/// Gets the owner generic param
		/// </summary>
		public GenericParam Owner {
			get => owner;
			internal set => owner = value;
		}
		/// <summary/>
		protected GenericParam owner;

		/// <summary>
		/// From column GenericParamConstraint.Constraint
		/// </summary>
		public ITypeDefOrRef Constraint {
			get => constraint;
			set => constraint = value;
		}
		/// <summary/>
		protected ITypeDefOrRef constraint;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 20;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		bool IContainsGenericParameter.ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);
	}

	/// <summary>
	/// A GenericParamConstraintAssembly row created by the user and not present in the original .NET file
	/// </summary>
	public class GenericParamConstraintUser : GenericParamConstraint {
		/// <summary>
		/// Default constructor
		/// </summary>
		public GenericParamConstraintUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="constraint">The constraint</param>
		public GenericParamConstraintUser(ITypeDefOrRef constraint) => this.constraint = constraint;
	}

	/// <summary>
	/// Created from a row in the GenericParamConstraint table
	/// </summary>
	sealed class GenericParamConstraintMD : GenericParamConstraint, IMDTokenProviderMD, IContainsGenericParameter2 {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		bool IContainsGenericParameter2.ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.GenericParamConstraint, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>GenericParamConstraint</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public GenericParamConstraintMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.GenericParamConstraintTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"GenericParamConstraint rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			bool b = readerModule.TablesStream.TryReadGenericParamConstraintRow(origRid, out var row);
			Debug.Assert(b);
			constraint = readerModule.ResolveTypeDefOrRef(row.Constraint, gpContext);
			owner = readerModule.GetOwner(this);
		}

		internal GenericParamConstraintMD InitializeAll() {
			MemberMDInitializer.Initialize(Owner);
			MemberMDInitializer.Initialize(Constraint);
			MemberMDInitializer.Initialize(CustomAttributes);
			return this;
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Generic parameter context
	/// </summary>
	public readonly struct GenericParamContext {
		/// <summary>
		/// Type context
		/// </summary>
		public readonly TypeDef Type;

		/// <summary>
		/// Method context
		/// </summary>
		public readonly MethodDef Method;

		/// <summary>
		/// true if <see cref="Type"/> and <see cref="Method"/> are both <c>null</c>
		/// </summary>
		public bool IsEmpty => Type is null && Method is null;

		/// <summary>
		/// Creates a new <see cref="GenericParamContext"/> instance and initializes the
		/// <see cref="Type"/> field to <paramref name="method"/>'s <see cref="MethodDef.DeclaringType"/>
		/// and the <see cref="Method"/> field to <paramref name="method"/>.
		/// </summary>
		/// <param name="method">Method</param>
		/// <returns>A new <see cref="GenericParamContext"/> instance</returns>
		public static GenericParamContext Create(MethodDef method) {
			if (method is null)
				return new GenericParamContext();
			return new GenericParamContext(method.DeclaringType, method);
		}

		/// <summary>
		/// Creates a new <see cref="GenericParamContext"/> instance and initializes the
		/// <see cref="Type"/> field to <paramref name="type"/> and the <see cref="Method"/> field
		/// to <c>null</c>
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns>A new <see cref="GenericParamContext"/> instance</returns>
		public static GenericParamContext Create(TypeDef type) => new GenericParamContext(type);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Type context</param>
		public GenericParamContext(TypeDef type) {
			Type = type;
			Method = null;
		}

		/// <summary>
		/// Constructor. The <see cref="Type"/> field is set to <c>null</c> and <c>NOT</c> to
		/// <paramref name="method"/>'s <see cref="MethodDef.DeclaringType"/>. Use
		/// <see cref="Create(MethodDef)"/> if you want that behavior.
		/// </summary>
		/// <param name="method">Method context</param>
		public GenericParamContext(MethodDef method) {
			Type = null;
			Method = method;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">Type context</param>
		/// <param name="method">Method context</param>
		public GenericParamContext(TypeDef type, MethodDef method) {
			Type = type;
			Method = method;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Resolves assemblies
	/// </summary>
	public interface IAssemblyResolver {
		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="assembly">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver or
		/// <c>null</c> if the assembly couldn't be found.</returns>
		AssemblyDef Resolve(IAssembly assembly, ModuleDef sourceModule);
	}

	public static partial class Extensions {
		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="assembly">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver or
		/// <c>null</c> if the assembly couldn't be found.</returns>
		public static AssemblyDef Resolve(this IAssemblyResolver self, AssemblyName assembly, ModuleDef sourceModule) {
			if (assembly is null)
				return null;
			return self.Resolve(new AssemblyNameInfo(assembly), sourceModule);
		}

		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="asmFullName">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver or
		/// <c>null</c> if the assembly couldn't be found.</returns>
		public static AssemblyDef Resolve(this IAssemblyResolver self, string asmFullName, ModuleDef sourceModule) {
			if (asmFullName is null)
				return null;
			return self.Resolve(new AssemblyNameInfo(asmFullName), sourceModule);
		}

		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="assembly">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver</returns>
		/// <exception cref="AssemblyResolveException">If the assembly couldn't be found.</exception>
		public static AssemblyDef ResolveThrow(this IAssemblyResolver self, IAssembly assembly, ModuleDef sourceModule) {
			if (assembly is null)
				return null;
			var asm = self.Resolve(assembly, sourceModule);
			if (asm is not null)
				return asm;
			throw new AssemblyResolveException($"Could not resolve assembly: {assembly}");
		}

		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="assembly">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver</returns>
		/// <exception cref="AssemblyResolveException">If the assembly couldn't be found.</exception>
		public static AssemblyDef ResolveThrow(this IAssemblyResolver self, AssemblyName assembly, ModuleDef sourceModule) {
			if (assembly is null)
				return null;
			var asm = self.Resolve(new AssemblyNameInfo(assembly), sourceModule);
			if (asm is not null)
				return asm;
			throw new AssemblyResolveException($"Could not resolve assembly: {assembly}");
		}

		/// <summary>
		/// Finds and returns an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="asmFullName">The assembly to find</param>
		/// <param name="sourceModule">The module that needs to resolve an assembly or <c>null</c></param>
		/// <returns>An <see cref="AssemblyDef"/> instance owned by the assembly resolver</returns>
		/// <exception cref="AssemblyResolveException">If the assembly couldn't be found.</exception>
		public static AssemblyDef ResolveThrow(this IAssemblyResolver self, string asmFullName, ModuleDef sourceModule) {
			if (asmFullName is null)
				return null;
			var asm = self.Resolve(new AssemblyNameInfo(asmFullName), sourceModule);
			if (asm is not null)
				return asm;
			throw new AssemblyResolveException($"Could not resolve assembly: {asmFullName}");
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// The table row can be referenced by a MD token
	/// </summary>
	public interface IMDTokenProvider {
		/// <summary>
		/// Returns the metadata token
		/// </summary>
		MDToken MDToken { get; }

		/// <summary>
		/// Gets/sets the row ID
		/// </summary>
		uint Rid { get; set; }
	}

	/// <summary>
	/// All <c>*MD</c> classes implement this interface.
	/// </summary>
	public interface IMDTokenProviderMD : IMDTokenProvider {
		/// <summary>
		/// Gets the original row ID
		/// </summary>
		uint OrigRid { get; }
	}

	/// <summary>
	/// An assembly. Implemented by <see cref="AssemblyRef"/>, <see cref="AssemblyDef"/> and
	/// <see cref="AssemblyNameInfo"/>.
	/// </summary>
	public interface IAssembly : IFullName {
		/// <summary>
		/// The assembly version
		/// </summary>
		Version Version { get; set; }

		/// <summary>
		/// Assembly flags
		/// </summary>
		AssemblyAttributes Attributes { get; set; }

		/// <summary>
		/// Public key or public key token
		/// </summary>
		PublicKeyBase PublicKeyOrToken { get; }

		/// <summary>
		/// Locale, aka culture
		/// </summary>
		UTF8String Culture { get; set; }

		/// <summary>
		/// Gets the full name of the assembly but use a public key token
		/// </summary>
		string FullNameToken { get; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PublicKey"/> bit
		/// </summary>
		bool HasPublicKey { get; set; }

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		AssemblyAttributes ProcessorArchitecture { get; set; }

		/// <summary>
		/// Gets/sets the processor architecture
		/// </summary>
		AssemblyAttributes ProcessorArchitectureFull { get; set; }

		/// <summary>
		/// <c>true</c> if unspecified processor architecture
		/// </summary>
		bool IsProcessorArchitectureNone { get; }

		/// <summary>
		/// <c>true</c> if neutral (PE32) architecture
		/// </summary>
		bool IsProcessorArchitectureMSIL { get; }

		/// <summary>
		/// <c>true</c> if x86 (PE32) architecture
		/// </summary>
		bool IsProcessorArchitectureX86 { get; }

		/// <summary>
		/// <c>true</c> if IA-64 (PE32+) architecture
		/// </summary>
		bool IsProcessorArchitectureIA64 { get; }

		/// <summary>
		/// <c>true</c> if x64 (PE32+) architecture
		/// </summary>
		bool IsProcessorArchitectureX64 { get; }

		/// <summary>
		/// <c>true</c> if ARM (PE32) architecture
		/// </summary>
		bool IsProcessorArchitectureARM { get; }

		/// <summary>
		/// <c>true</c> if eg. reference assembly (not runnable)
		/// </summary>
		bool IsProcessorArchitectureNoPlatform { get; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.PA_Specified"/> bit
		/// </summary>
		bool IsProcessorArchitectureSpecified { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.EnableJITcompileTracking"/> bit
		/// </summary>
		bool EnableJITcompileTracking { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.DisableJITcompileOptimizer"/> bit
		/// </summary>
		bool DisableJITcompileOptimizer { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="AssemblyAttributes.Retargetable"/> bit
		/// </summary>
		bool IsRetargetable { get; set; }

		/// <summary>
		/// Gets/sets the content type
		/// </summary>
		AssemblyAttributes ContentType { get; set; }

		/// <summary>
		/// <c>true</c> if content type is <c>Default</c>
		/// </summary>
		bool IsContentTypeDefault { get; }

		/// <summary>
		/// <c>true</c> if content type is <c>WindowsRuntime</c>
		/// </summary>
		bool IsContentTypeWindowsRuntime { get; }
	}

	public static partial class Extensions {
		/// <summary>
		/// Checks whether <paramref name="asm"/> appears to be the core library (eg.
		/// mscorlib, System.Runtime or corefx).
		/// 
		/// If <paramref name="asm"/> is a reference to a private corlib (eg. System.Private.CoreLib),
		/// this method returns false unless <paramref name="asm"/> is an <see cref="AssemblyDef"/>
		/// whose manifest (first) module defines <c>System.Object</c>. This check is performed in
		/// the constructor and the result can be found in <see cref="ModuleDef.IsCoreLibraryModule"/>.
		/// 
		/// Note that this method also returns true if it appears to be a 'public' corlib,
		/// eg. mscorlib, etc, even if it internally possibly references a private corlib.
		/// </summary>
		/// <param name="asm">The assembly</param>
		public static bool IsCorLib(this IAssembly asm) {
			if (asm is AssemblyDef asmDef) {
				var manifestModule = asmDef.ManifestModule;
				if (manifestModule is not null) {
					var isCorModule = manifestModule.IsCoreLibraryModule;
					if (isCorModule is not null)
						return isCorModule.Value;
				}
			}

			string asmName;
			return asm is not null &&
				UTF8String.IsNullOrEmpty(asm.Culture) &&
				((asmName = UTF8String.ToSystemStringOrEmpty(asm.Name)).Equals("mscorlib", StringComparison.OrdinalIgnoreCase) ||
				asmName.Equals("System.Runtime", StringComparison.OrdinalIgnoreCase) ||
				// This name could change but since CoreCLR is used a lot, it's worth supporting
				asmName.Equals("System.Private.CoreLib", StringComparison.OrdinalIgnoreCase) ||
				asmName.Equals("netstandard", StringComparison.OrdinalIgnoreCase) ||
				asmName.Equals("corefx", StringComparison.OrdinalIgnoreCase));
		}

		/// <summary>
		/// Converts <paramref name="asm"/> to a <see cref="AssemblyRef"/> instance
		/// </summary>
		/// <param name="asm">The assembly</param>
		/// <returns>A new <see cref="AssemblyRef"/> instance</returns>
		public static AssemblyRef ToAssemblyRef(this IAssembly asm) {
			if (asm is null)
				return null;
			// Always create a new one, even if it happens to be an AssemblyRef
			return new AssemblyRefUser(asm.Name, asm.Version, asm.PublicKeyOrToken, asm.Culture) { Attributes = asm.Attributes };
		}

		/// <summary>
		/// Converts <paramref name="type"/> to a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <param name="checkValueType"><c>true</c> if we should try to figure out whether
		/// <paramref name="type"/> is a <see cref="ValueType"/></param>
		/// <returns>A <see cref="TypeSig"/> instance or <c>null</c> if <paramref name="type"/>
		/// is invalid</returns>
		public static TypeSig ToTypeSig(this ITypeDefOrRef type, bool checkValueType = true) {
			if (type is null)
				return null;

			var module = type.Module;
			if (module is not null) {
				var corLibType = module.CorLibTypes.GetCorLibTypeSig(type);
				if (corLibType is not null)
					return corLibType;
			}

			var td = type as TypeDef;
			if (td is not null)
				return CreateClassOrValueType(type, checkValueType ? td.IsValueType : false);

			if (type is TypeRef tr) {
				if (checkValueType)
					td = tr.Resolve();
				return CreateClassOrValueType(type, td is null ? false : td.IsValueType);
			}

			if (type is TypeSpec ts)
				return ts.TypeSig;

			return null;
		}

		static TypeSig CreateClassOrValueType(ITypeDefOrRef type, bool isValueType) {
			if (isValueType)
				return new ValueTypeSig(type);
			return new ClassSig(type);
		}

		/// <summary>
		/// Returns a <see cref="TypeDefOrRefSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="TypeDefOrRefSig"/> or <c>null</c> if it's not a
		/// <see cref="TypeDefOrRefSig"/></returns>
		public static TypeDefOrRefSig TryGetTypeDefOrRefSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as TypeDefOrRefSig;
		}

		/// <summary>
		/// Returns a <see cref="ClassOrValueTypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ClassOrValueTypeSig"/> or <c>null</c> if it's not a
		/// <see cref="ClassOrValueTypeSig"/></returns>
		public static ClassOrValueTypeSig TryGetClassOrValueTypeSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ClassOrValueTypeSig;
		}

		/// <summary>
		/// Returns a <see cref="ValueTypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ValueTypeSig"/> or <c>null</c> if it's not a
		/// <see cref="ValueTypeSig"/></returns>
		public static ValueTypeSig TryGetValueTypeSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ValueTypeSig;
		}

		/// <summary>
		/// Returns a <see cref="ClassSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ClassSig"/> or <c>null</c> if it's not a
		/// <see cref="ClassSig"/></returns>
		public static ClassSig TryGetClassSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ClassSig;
		}

		/// <summary>
		/// Returns a <see cref="GenericSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericSig"/> or <c>null</c> if it's not a
		/// <see cref="GenericSig"/></returns>
		public static GenericSig TryGetGenericSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as GenericSig;
		}

		/// <summary>
		/// Returns a <see cref="GenericVar"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericVar"/> or <c>null</c> if it's not a
		/// <see cref="GenericVar"/></returns>
		public static GenericVar TryGetGenericVar(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as GenericVar;
		}

		/// <summary>
		/// Returns a <see cref="GenericMVar"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericMVar"/> or <c>null</c> if it's not a
		/// <see cref="GenericMVar"/></returns>
		public static GenericMVar TryGetGenericMVar(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as GenericMVar;
		}

		/// <summary>
		/// Returns a <see cref="GenericInstSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericInstSig"/> or <c>null</c> if it's not a
		/// <see cref="GenericInstSig"/></returns>
		public static GenericInstSig TryGetGenericInstSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as GenericInstSig;
		}

		/// <summary>
		/// Returns a <see cref="PtrSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="PtrSig"/> or <c>null</c> if it's not a
		/// <see cref="PtrSig"/></returns>
		public static PtrSig TryGetPtrSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as PtrSig;
		}

		/// <summary>
		/// Returns a <see cref="ByRefSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ByRefSig"/> or <c>null</c> if it's not a
		/// <see cref="ByRefSig"/></returns>
		public static ByRefSig TryGetByRefSig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ByRefSig;
		}

		/// <summary>
		/// Returns a <see cref="ArraySig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ArraySig"/> or <c>null</c> if it's not a
		/// <see cref="ArraySig"/></returns>
		public static ArraySig TryGetArraySig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as ArraySig;
		}

		/// <summary>
		/// Returns a <see cref="SZArraySig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="SZArraySig"/> or <c>null</c> if it's not a
		/// <see cref="SZArraySig"/></returns>
		public static SZArraySig TryGetSZArraySig(this ITypeDefOrRef type) {
			var ts = type as TypeSpec;
			return ts is null ? null : ts.TypeSig.RemovePinnedAndModifiers() as SZArraySig;
		}

		/// <summary>
		/// Returns the base type of <paramref name="tdr"/>. Throws if we can't resolve
		/// a <see cref="TypeRef"/>.
		/// </summary>
		/// <param name="tdr">The type</param>
		/// <returns>The base type or <c>null</c> if there's no base type</returns>
		public static ITypeDefOrRef GetBaseTypeThrow(this ITypeDefOrRef tdr) => tdr.GetBaseType(true);

		/// <summary>
		/// Returns the base type of <paramref name="tdr"/>
		/// </summary>
		/// <param name="tdr">The type</param>
		/// <param name="throwOnResolveFailure"><c>true</c> if we should throw if we can't
		/// resolve a <see cref="TypeRef"/>. <c>false</c> if we should ignore the error and
		/// just return <c>null</c>.</param>
		/// <returns>The base type or <c>null</c> if there's no base type, or if
		/// <paramref name="throwOnResolveFailure"/> is <c>true</c> and we couldn't resolve
		/// a <see cref="TypeRef"/></returns>
		public static ITypeDefOrRef GetBaseType(this ITypeDefOrRef tdr, bool throwOnResolveFailure = false) {
			if (tdr is TypeDef td)
				return td.BaseType;

			if (tdr is TypeRef tr) {
				td = throwOnResolveFailure ? tr.ResolveThrow() : tr.Resolve();
				return td?.BaseType;
			}

			var ts = tdr as TypeSpec;
			if (ts is null)
				return null;

			var git = ts.TypeSig.ToGenericInstSig();
			if (git is not null)
				tdr = git.GenericType?.TypeDefOrRef;
			else
				tdr = ts.TypeSig.ToTypeDefOrRefSig()?.TypeDefOrRef;

			td = tdr as TypeDef;
			if (td is not null)
				return td.BaseType;

			tr = tdr as TypeRef;
			if (tr is not null) {
				td = throwOnResolveFailure ? tr.ResolveThrow() : tr.Resolve();
				return td?.BaseType;
			}

			return null;
		}

		/// <summary>
		/// Gets the scope type, resolves it, and returns the <see cref="TypeDef"/>
		/// </summary>
		/// <param name="tdr">Type</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if input was <c>null</c> or if we
		/// couldn't resolve the reference.</returns>
		public static TypeDef ResolveTypeDef(this ITypeDefOrRef tdr) {
			if (tdr is TypeDef td)
				return td;

			if (tdr is TypeRef tr)
				return tr.Resolve();

			if (tdr is null)
				return null;
			tdr = tdr.ScopeType;

			td = tdr as TypeDef;
			if (td is not null)
				return td;

			tr = tdr as TypeRef;
			if (tr is not null)
				return tr.Resolve();

			return null;
		}

		/// <summary>
		/// Gets the scope type, resolves it, and returns the <see cref="TypeDef"/>
		/// </summary>
		/// <param name="tdr">Type</param>
		/// <returns>A <see cref="TypeDef"/> instance.</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public static TypeDef ResolveTypeDefThrow(this ITypeDefOrRef tdr) {
			if (tdr is TypeDef td)
				return td;

			if (tdr is TypeRef tr)
				return tr.ResolveThrow();

			if (tdr is null)
				throw new TypeResolveException("Can't resolve a null pointer");
			tdr = tdr.ScopeType;

			td = tdr as TypeDef;
			if (td is not null)
				return td;

			tr = tdr as TypeRef;
			if (tr is not null)
				return tr.ResolveThrow();

			throw new TypeResolveException($"Could not resolve type: {tdr} ({tdr?.DefinitionAssembly})");
		}

		/// <summary>
		/// Resolves an <see cref="IField"/> to a <see cref="FieldDef"/>. Returns <c>null</c> if it
		/// was not possible to resolve it. See also <see cref="ResolveFieldDefThrow"/>
		/// </summary>
		/// <param name="field">Field to resolve</param>
		/// <returns>The <see cref="FieldDef"/> or <c>null</c> if <paramref name="field"/> is
		/// <c>null</c> or if it wasn't possible to resolve it (the field doesn't exist or its
		/// assembly couldn't be loaded)</returns>
		public static FieldDef ResolveFieldDef(this IField field) {
			if (field is FieldDef fd)
				return fd;

			if (field is MemberRef mr)
				return mr.ResolveField();

			return null;
		}

		/// <summary>
		/// Resolves an <see cref="IField"/> to a <see cref="FieldDef"/> and throws an exception if
		/// it was not possible to resolve it. See also <see cref="ResolveFieldDef"/>
		/// </summary>
		/// <param name="field">Field to resolve</param>
		/// <returns>The <see cref="FieldDef"/></returns>
		public static FieldDef ResolveFieldDefThrow(this IField field) {
			if (field is FieldDef fd)
				return fd;

			if (field is MemberRef mr)
				return mr.ResolveFieldThrow();

			throw new MemberRefResolveException($"Could not resolve field: {field}");
		}

		/// <summary>
		/// Resolves an <see cref="IMethod"/> to a <see cref="MethodDef"/>. Returns <c>null</c> if it
		/// was not possible to resolve it. See also <see cref="ResolveMethodDefThrow"/>. If
		/// <paramref name="method"/> is a <see cref="MethodSpec"/>, then the
		/// <see cref="MethodSpec.Method"/> property is resolved and returned.
		/// </summary>
		/// <param name="method">Method to resolve</param>
		/// <returns>The <see cref="MethodDef"/> or <c>null</c> if <paramref name="method"/> is
		/// <c>null</c> or if it wasn't possible to resolve it (the method doesn't exist or its
		/// assembly couldn't be loaded)</returns>
		public static MethodDef ResolveMethodDef(this IMethod method) {
			if (method is MethodDef md)
				return md;

			if (method is MemberRef mr)
				return mr.ResolveMethod();

			if (method is MethodSpec ms) {
				md = ms.Method as MethodDef;
				if (md is not null)
					return md;

				mr = ms.Method as MemberRef;
				if (mr is not null)
					return mr.ResolveMethod();
			}

			return null;
		}

		/// <summary>
		/// Resolves an <see cref="IMethod"/> to a <see cref="MethodDef"/> and throws an exception
		/// if it was not possible to resolve it. See also <see cref="ResolveMethodDef"/>. If
		/// <paramref name="method"/> is a <see cref="MethodSpec"/>, then the
		/// <see cref="MethodSpec.Method"/> property is resolved and returned.
		/// </summary>
		/// <param name="method">Method to resolve</param>
		/// <returns>The <see cref="MethodDef"/></returns>
		public static MethodDef ResolveMethodDefThrow(this IMethod method) {
			if (method is MethodDef md)
				return md;

			if (method is MemberRef mr)
				return mr.ResolveMethodThrow();

			if (method is MethodSpec ms) {
				md = ms.Method as MethodDef;
				if (md is not null)
					return md;

				mr = ms.Method as MemberRef;
				if (mr is not null)
					return mr.ResolveMethodThrow();
			}

			throw new MemberRefResolveException($"Could not resolve method: {method}");
		}

		/// <summary>
		/// Returns the definition assembly of a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="mr">Member reference</param>
		/// <returns></returns>
		static internal IAssembly GetDefinitionAssembly(this MemberRef mr) {
			if (mr is null)
				return null;
			var parent = mr.Class;

			if (parent is ITypeDefOrRef tdr)
				return tdr.DefinitionAssembly;

			if (parent is ModuleRef)
				return mr.Module?.Assembly;

			if (parent is MethodDef md)
				return md.DeclaringType?.DefinitionAssembly;

			return null;
		}

		/// <summary>
		/// Gets the normal visible parameters, doesn't include the hidden 'this' parameter
		/// </summary>
		/// <param name="method">this</param>
		/// <returns>The normal visible parameters</returns>
		public static IList<TypeSig> GetParams(this IMethod method) => method?.MethodSig.GetParams();

		/// <summary>
		/// Gets the normal visible parameter count, doesn't include the hidden 'this' parameter
		/// </summary>
		/// <param name="method">this</param>
		/// <returns>Normal visible parameter count</returns>
		public static int GetParamCount(this IMethod method) => method?.MethodSig.GetParamCount() ?? 0;

		/// <summary>
		/// Checks whether any normal visible parameter exists, doesn't include the hidden 'this' parameter
		/// </summary>
		/// <param name="method">this</param>
		/// <returns><c>true</c> if there's at least one normal visible parameter</returns>
		public static bool HasParams(this IMethod method) => method.GetParamCount() > 0;

		/// <summary>
		/// Gets a normal visible parameter, doesn't include the hidden 'this' parameter
		/// </summary>
		/// <param name="method">this</param>
		/// <param name="index">Normal visible parameter index</param>
		/// <returns></returns>
		public static TypeSig GetParam(this IMethod method, int index) => method?.MethodSig?.Params[index];
	}

	/// <summary>
	/// Implemented by <see cref="MethodDef"/> and <see cref="FileDef"/>, which are the only
	/// valid managed entry point tokens.
	/// </summary>
	public interface IManagedEntryPoint : ICodedToken {
	}

	/// <summary>
	/// Interface to access a module def/ref
	/// </summary>
	public interface IModule : IScope, IFullName {
	}

	/// <summary>
	/// Type of scope
	/// </summary>
	public enum ScopeType {
		/// <summary>
		/// It's an <see cref="dnlib.DotNet.AssemblyRef"/> instance
		/// </summary>
		AssemblyRef,

		/// <summary>
		/// It's a <see cref="dnlib.DotNet.ModuleRef"/> instance
		/// </summary>
		ModuleRef,

		/// <summary>
		/// It's a <see cref="dnlib.DotNet.ModuleDef"/> instance
		/// </summary>
		ModuleDef,
	}

	/// <summary>
	/// Implemented by modules and assemblies
	/// </summary>
	public interface IScope {
		/// <summary>
		/// Gets the scope type
		/// </summary>
		ScopeType ScopeType { get; }

		/// <summary>
		/// Gets the scope name
		/// </summary>
		string ScopeName { get; }
	}

	/// <summary>
	/// Interface to get the full name of a type, field, or method
	/// </summary>
	public interface IFullName {
		/// <summary>
		/// Gets the full name
		/// </summary>
		string FullName { get; }

		/// <summary>
		/// Simple name of implementer
		/// </summary>
		UTF8String Name { get; set; }
	}

	/// <summary>
	/// Implemented by all member refs and types
	/// </summary>
	public interface IOwnerModule {
		/// <summary>
		/// Gets the owner module
		/// </summary>
		ModuleDef Module { get; }
	}

	/// <summary>
	/// Methods to check whether the implementer is a type or a method.
	/// </summary>
	public interface IIsTypeOrMethod {
		/// <summary>
		/// <c>true</c> if it's a type
		/// </summary>
		bool IsType { get; }

		/// <summary>
		/// <c>true</c> if it's a method
		/// </summary>
		bool IsMethod { get; }
	}

	/// <summary>
	/// Implemented by types, fields, methods, properties, events
	/// </summary>
	public interface IMemberRef : ICodedToken, IFullName, IOwnerModule, IIsTypeOrMethod {
		/// <summary>
		/// Gets the declaring type
		/// </summary>
		ITypeDefOrRef DeclaringType { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="FieldDef"/> or a <see cref="MemberRef"/> that's
		/// referencing a field.
		/// </summary>
		bool IsField { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="TypeSpec"/>
		/// </summary>
		bool IsTypeSpec { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="TypeRef"/>
		/// </summary>
		bool IsTypeRef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="TypeDef"/>
		/// </summary>
		bool IsTypeDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="MethodSpec"/>
		/// </summary>
		bool IsMethodSpec { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="MethodDef"/>
		/// </summary>
		bool IsMethodDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="MemberRef"/>
		/// </summary>
		bool IsMemberRef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="FieldDef"/>
		/// </summary>
		bool IsFieldDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="PropertyDef"/>
		/// </summary>
		bool IsPropertyDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="EventDef"/>
		/// </summary>
		bool IsEventDef { get; }

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericParam"/>
		/// </summary>
		bool IsGenericParam { get; }
	}

	/// <summary>
	/// All member definitions implement this interface: <see cref="TypeDef"/>,
	/// <see cref="FieldDef"/>, <see cref="MethodDef"/>, <see cref="EventDef"/>,
	/// <see cref="PropertyDef"/>, and <see cref="GenericParam"/>.
	/// </summary>
	public interface IMemberDef : IDnlibDef, IMemberRef {
		/// <summary>
		/// Gets the declaring type
		/// </summary>
		new TypeDef DeclaringType { get; }
	}

	/// <summary>
	/// Implemented by the following classes: <see cref="TypeDef"/>,
	/// <see cref="FieldDef"/>, <see cref="MethodDef"/>, <see cref="EventDef"/>,
	/// <see cref="PropertyDef"/>, <see cref="GenericParam"/>, <see cref="AssemblyDef"/>,
	/// and <see cref="ModuleDef"/>
	/// </summary>
	public interface IDnlibDef : ICodedToken, IFullName, IHasCustomAttribute {
	}

	/// <summary>
	/// Implemented by types and methods
	/// </summary>
	public interface IGenericParameterProvider : ICodedToken, IIsTypeOrMethod {
		/// <summary>
		/// Gets the number of generic parameters / arguments
		/// </summary>
		int NumberOfGenericParameters { get; }
	}

	/// <summary>
	/// Implemented by fields (<see cref="FieldDef"/> and <see cref="MemberRef"/>)
	/// </summary>
	public interface IField : ICodedToken, ITokenOperand, IFullName, IMemberRef {
		/// <summary>
		/// Gets/sets the field signature
		/// </summary>
		FieldSig FieldSig { get; set; }
	}

	/// <summary>
	/// Implemented by methods (<see cref="MethodDef"/>, <see cref="MemberRef"/> and <see cref="MethodSpec"/>)
	/// </summary>
	public interface IMethod : ICodedToken, ITokenOperand, IFullName, IGenericParameterProvider, IMemberRef {
		/// <summary>
		/// Method signature
		/// </summary>
		MethodSig MethodSig { get; set; }
	}

	/// <summary>
	/// Implemented by tables that can be a token in the <c>ldtoken</c> instruction
	/// </summary>
	public interface ITokenOperand : ICodedToken {
	}

	/// <summary>
	/// The table row can be referenced by a coded token
	/// </summary>
	public interface ICodedToken : IMDTokenProvider {
	}

	/// <summary>
	/// TypeDefOrRef coded token interface
	/// </summary>
	public interface ITypeDefOrRef : ICodedToken, IHasCustomAttribute, IMemberRefParent, IType, ITokenOperand, IMemberRef {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int TypeDefOrRefTag { get; }
	}

	/// <summary>
	/// HasConstant coded token interface
	/// </summary>
	public interface IHasConstant : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasConstantTag { get; }

		/// <summary>
		/// Gets/sets the constant value
		/// </summary>
		Constant Constant { get; set; }
	}

	/// <summary>
	/// HasCustomAttribute coded token interface
	/// </summary>
	public interface IHasCustomAttribute : ICodedToken {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasCustomAttributeTag { get; }

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		CustomAttributeCollection CustomAttributes { get; }

		/// <summary>
		/// <c>true</c> if <see cref="CustomAttributes"/> is not empty
		/// </summary>
		bool HasCustomAttributes { get; }
	}

	/// <summary>
	/// HasFieldMarshal coded token interface
	/// </summary>
	public interface IHasFieldMarshal : ICodedToken, IHasCustomAttribute, IHasConstant, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasFieldMarshalTag { get; }

		/// <summary>
		/// Gets/sets the marshal type
		/// </summary>
		MarshalType MarshalType { get; set; }

		/// <summary>
		/// <c>true</c> if <see cref="MarshalType"/> is not <c>null</c>
		/// </summary>
		bool HasMarshalType { get; }
	}

	/// <summary>
	/// HasDeclSecurity coded token interface
	/// </summary>
	public interface IHasDeclSecurity : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasDeclSecurityTag { get; }

		/// <summary>
		/// Gets the permission sets
		/// </summary>
		IList<DeclSecurity> DeclSecurities { get; }

		/// <summary>
		/// <c>true</c> if <see cref="DeclSecurities"/> is not empty
		/// </summary>
		bool HasDeclSecurities { get; }
	}

	/// <summary>
	/// MemberRefParent coded token interface
	/// </summary>
	public interface IMemberRefParent : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int MemberRefParentTag { get; }
	}

	/// <summary>
	/// HasSemantic coded token interface
	/// </summary>
	public interface IHasSemantic : ICodedToken, IHasCustomAttribute, IFullName, IMemberRef {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int HasSemanticTag { get; }
	}

	/// <summary>
	/// MethodDefOrRef coded token interface
	/// </summary>
	public interface IMethodDefOrRef : ICodedToken, IHasCustomAttribute, ICustomAttributeType, IMethod {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int MethodDefOrRefTag { get; }
	}

	/// <summary>
	/// MemberForwarded coded token interface
	/// </summary>
	public interface IMemberForwarded : ICodedToken, IHasCustomAttribute, IFullName, IMemberRef {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int MemberForwardedTag { get; }

		/// <summary>
		/// Gets/sets the impl map
		/// </summary>
		ImplMap ImplMap { get; set; }

		/// <summary>
		/// <c>true</c> if <see cref="ImplMap"/> is not <c>null</c>
		/// </summary>
		bool HasImplMap { get; }
	}

	/// <summary>
	/// Implementation coded token interface
	/// </summary>
	public interface IImplementation : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int ImplementationTag { get; }
	}

	/// <summary>
	/// CustomAttributeType coded token interface
	/// </summary>
	public interface ICustomAttributeType : ICodedToken, IHasCustomAttribute, IMethod {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int CustomAttributeTypeTag { get; }
	}

	/// <summary>
	/// ResolutionScope coded token interface
	/// </summary>
	public interface IResolutionScope : ICodedToken, IHasCustomAttribute, IFullName {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int ResolutionScopeTag { get; }
	}

	/// <summary>
	/// TypeOrMethodDef coded token interface
	/// </summary>
	public interface ITypeOrMethodDef : ICodedToken, IHasCustomAttribute, IHasDeclSecurity, IMemberRefParent, IFullName, IMemberRef, IGenericParameterProvider {
		/// <summary>
		/// The coded token tag
		/// </summary>
		int TypeOrMethodDefTag { get; }

		/// <summary>
		/// Gets the generic parameters
		/// </summary>
		IList<GenericParam> GenericParameters { get; }

		/// <summary>
		/// <c>true</c> if <see cref="GenericParameters"/> is not empty
		/// </summary>
		bool HasGenericParameters { get; }
	}

	/// <summary>
	/// HasCustomDebugInformation interface
	/// </summary>
	public interface IHasCustomDebugInformation {
		/// <summary>
		/// The custom debug information tag
		/// </summary>
		int HasCustomDebugInformationTag { get; }

		/// <summary>
		/// Gets the custom debug infos
		/// </summary>
		IList<PdbCustomDebugInfo> CustomDebugInfos { get; }

		/// <summary>
		/// <c>true</c> if <see cref="CustomDebugInfos"/> is not empty
		/// </summary>
		bool HasCustomDebugInfos { get; }
	}

	public static partial class Extensions {
		/// <summary>
		/// Converts a <see cref="TypeSig"/> to a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		public static ITypeDefOrRef ToTypeDefOrRef(this TypeSig sig) {
			if (sig is null)
				return null;
			if (sig is TypeDefOrRefSig tdrSig)
				return tdrSig.TypeDefOrRef;
			var module = sig.Module;
			if (module is null)
				return new TypeSpecUser(sig);
			return module.UpdateRowId(new TypeSpecUser(sig));
		}

		/// <summary>
		/// Returns <c>true</c> if it's an integer or a floating point type
		/// </summary>
		/// <param name="tdr">Type</param>
		/// <returns></returns>
		internal static bool IsPrimitive(this IType tdr) {
			if (tdr is null)
				return false;
			if (!tdr.DefinitionAssembly.IsCorLib())
				return false;

			switch (tdr.FullName) {
			case "System.Boolean":
			case "System.Char":
			case "System.SByte":
			case "System.Byte":
			case "System.Int16":
			case "System.UInt16":
			case "System.Int32":
			case "System.UInt32":
			case "System.Int64":
			case "System.UInt64":
			case "System.Single":
			case "System.Double":
			case "System.IntPtr":
			case "System.UIntPtr":
				return true;
			default:
				return false;
			}
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Access to .NET core library's simple types
	/// </summary>
	public interface ICorLibTypes {
		/// <summary>
		/// Gets a <c>System.Void</c>
		/// </summary>
		CorLibTypeSig Void { get; }

		/// <summary>
		/// Gets a <c>System.Boolean</c>
		/// </summary>
		CorLibTypeSig Boolean { get; }

		/// <summary>
		/// Gets a <c>System.Char</c>
		/// </summary>
		CorLibTypeSig Char { get; }

		/// <summary>
		/// Gets a <c>System.SByte</c>
		/// </summary>
		CorLibTypeSig SByte { get; }

		/// <summary>
		/// Gets a <c>System.Byte</c>
		/// </summary>
		CorLibTypeSig Byte { get; }

		/// <summary>
		/// Gets a <c>System.Int16</c>
		/// </summary>
		CorLibTypeSig Int16 { get; }

		/// <summary>
		/// Gets a <c>System.UInt16</c>
		/// </summary>
		CorLibTypeSig UInt16 { get; }

		/// <summary>
		/// Gets a <c>System.Int32</c>
		/// </summary>
		CorLibTypeSig Int32 { get; }

		/// <summary>
		/// Gets a <c>System.UInt32</c>
		/// </summary>
		CorLibTypeSig UInt32 { get; }

		/// <summary>
		/// Gets a <c>System.Int64</c>
		/// </summary>
		CorLibTypeSig Int64 { get; }

		/// <summary>
		/// Gets a <c>System.UInt64</c>
		/// </summary>
		CorLibTypeSig UInt64 { get; }

		/// <summary>
		/// Gets a <c>System.Single</c>
		/// </summary>
		CorLibTypeSig Single { get; }

		/// <summary>
		/// Gets a <c>System.Double</c>
		/// </summary>
		CorLibTypeSig Double { get; }

		/// <summary>
		/// Gets a <c>System.String</c>
		/// </summary>
		CorLibTypeSig String { get; }

		/// <summary>
		/// Gets a <c>System.TypedReference</c>
		/// </summary>
		CorLibTypeSig TypedReference { get; }

		/// <summary>
		/// Gets a <c>System.IntPtr</c>
		/// </summary>
		CorLibTypeSig IntPtr { get; }

		/// <summary>
		/// Gets a <c>System.UIntPtr</c>
		/// </summary>
		CorLibTypeSig UIntPtr { get; }

		/// <summary>
		/// Gets a <c>System.Object</c>
		/// </summary>
		CorLibTypeSig Object { get; }

		/// <summary>
		/// Gets the assembly reference to the core library
		/// </summary>
		AssemblyRef AssemblyRef { get; }

		/// <summary>
		/// Gets a <see cref="TypeRef"/> that references a type in the core library assembly
		/// </summary>
		/// <param name="namespace">Namespace of type (eg. "System")</param>
		/// <param name="name">Name of type</param>
		/// <returns>A <see cref="TypeRef"/> instance. This instance may be a cached instance.</returns>
		TypeRef GetTypeRef(string @namespace, string name);
	}

	public static partial class Extensions {
		/// <summary>
		/// Gets a <see cref="CorLibTypeSig"/> if <paramref name="type"/> matches a primitive type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="CorLibTypeSig"/> or <c>null</c> if it didn't match any primitive type</returns>
		public static CorLibTypeSig GetCorLibTypeSig(this ICorLibTypes self, ITypeDefOrRef type) {
			CorLibTypeSig corLibType;

			if (type is TypeDef td &&
				td.DeclaringType is null &&
				(corLibType = self.GetCorLibTypeSig(td.Namespace, td.Name, td.DefinitionAssembly)) is not null) {
				return corLibType;
			}

			if (type is TypeRef tr &&
				!(tr.ResolutionScope is TypeRef) &&
				(corLibType = self.GetCorLibTypeSig(tr.Namespace, tr.Name, tr.DefinitionAssembly)) is not null) {
				return corLibType;
			}

			return null;
		}

		/// <summary>
		/// Gets a <see cref="CorLibTypeSig"/> if <paramref name="namespace"/> and
		/// <paramref name="name"/> matches a primitive type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="namespace">Namespace</param>
		/// <param name="name">Name</param>
		/// <param name="defAsm">Definition assembly</param>
		/// <returns>A <see cref="CorLibTypeSig"/> or <c>null</c> if it didn't match any primitive type</returns>
		public static CorLibTypeSig GetCorLibTypeSig(this ICorLibTypes self, UTF8String @namespace, UTF8String name, IAssembly defAsm) =>
			self.GetCorLibTypeSig(UTF8String.ToSystemStringOrEmpty(@namespace), UTF8String.ToSystemStringOrEmpty(name), defAsm);

		/// <summary>
		/// Gets a <see cref="CorLibTypeSig"/> if <paramref name="namespace"/> and
		/// <paramref name="name"/> matches a primitive type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="namespace">Namespace</param>
		/// <param name="name">Name</param>
		/// <param name="defAsm">Definition assembly</param>
		/// <returns>A <see cref="CorLibTypeSig"/> or <c>null</c> if it didn't match any primitive type</returns>
		public static CorLibTypeSig GetCorLibTypeSig(this ICorLibTypes self, string @namespace, string name, IAssembly defAsm) {
			if (@namespace != "System")
				return null;
			if (defAsm is null || !defAsm.IsCorLib())
				return null;
			return name switch {
				"Void" => self.Void,
				"Boolean" => self.Boolean,
				"Char" => self.Char,
				"SByte" => self.SByte,
				"Byte" => self.Byte,
				"Int16" => self.Int16,
				"UInt16" => self.UInt16,
				"Int32" => self.Int32,
				"UInt32" => self.UInt32,
				"Int64" => self.Int64,
				"UInt64" => self.UInt64,
				"Single" => self.Single,
				"Double" => self.Double,
				"String" => self.String,
				"TypedReference" => self.TypedReference,
				"IntPtr" => self.IntPtr,
				"UIntPtr" => self.UIntPtr,
				"Object" => self.Object,
				_ => null,
			};
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Custom attribute interface. Implemented by <see cref="SecurityAttribute"/> and
	/// <see cref="CustomAttribute"/>
	/// </summary>
	public interface ICustomAttribute {
		/// <summary>
		/// Gets the attribute type
		/// </summary>
		ITypeDefOrRef AttributeType { get; }

		/// <summary>
		/// Gets the full name of the attribute type
		/// </summary>
		string TypeFullName { get; }

		/// <summary>
		/// Gets all named arguments (field and property values)
		/// </summary>
		IList<CANamedArgument> NamedArguments { get; }

		/// <summary>
		/// <c>true</c> if <see cref="NamedArguments"/> is not empty
		/// </summary>
		bool HasNamedArguments { get; }

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are field arguments
		/// </summary>
		IEnumerable<CANamedArgument> Fields { get; }

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are property arguments
		/// </summary>
		IEnumerable<CANamedArgument> Properties { get; }
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Interface to decrypt methods
	/// </summary>
	public interface IMethodDecrypter {
		/// <summary>
		/// Gets the method's body
		/// </summary>
		/// <param name="rid"><c>Method</c> rid</param>
		/// <param name="rva">The <see cref="RVA"/> found in the method's <c>Method</c> row</param>
		/// <param name="parameters">The method's parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="methodBody">Updated with the method's <see cref="MethodBody"/> if this
		/// method returns <c>true</c></param>
		/// <returns><c>true</c> if the method body was decrypted, <c>false</c> if the method isn't
		/// encrypted and the default <see cref="MethodDef"/> body reader code should be used.</returns>
		bool GetMethodBody(uint rid, RVA rva, IList<Parameter> parameters, GenericParamContext gpContext, out Emit.MethodBody methodBody);
	}

	/// <summary>
	/// Interface to decrypt strings
	/// </summary>
	public interface IStringDecrypter {
		/// <summary>
		/// Reads a string
		/// </summary>
		/// <param name="token">String token</param>
		/// <returns>A string or <c>null</c> if we should read it from the #US heap</returns>
		string ReadUserString(uint token);
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// <see cref="ILogger"/> events
	/// </summary>
	public enum LoggerEvent {
		/// <summary>
		/// An error was detected. An exception should normally be thrown but the error
		/// can be ignored.
		/// </summary>
		Error,

		/// <summary>
		/// Just a warning and can be ignored.
		/// </summary>
		Warning,

		/// <summary>
		/// A normal message
		/// </summary>
		Info,

		/// <summary>
		/// A verbose message
		/// </summary>
		Verbose,

		/// <summary>
		/// A very verbose message
		/// </summary>
		VeryVerbose,
	}

	/// <summary>
	/// Simple logger
	/// </summary>
	public interface ILogger {
		/// <summary>
		/// Log something
		/// </summary>
		/// <param name="sender">Caller or <c>null</c></param>
		/// <param name="loggerEvent">Logger event</param>
		/// <param name="format">Format</param>
		/// <param name="args">Arguments</param>
		void Log(object sender, LoggerEvent loggerEvent, string format, params object[] args);

		/// <summary>
		/// <c>true</c> if this event is ignored. If the event is ignored, the caller can
		/// choose not to call <see cref="Log"/>. This is useful if it can take time to
		/// prepare the message.
		/// </summary>
		/// <param name="loggerEvent">The logger event</param>
		bool IgnoresEvent(LoggerEvent loggerEvent);
	}

	public static partial class Extensions {
		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void Error(this ILogger logger, object sender, string message) =>
			logger.Log(sender, LoggerEvent.Error, "{0}", message);

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void Error(this ILogger logger, object sender, string message, object arg1) =>
			logger.Log(sender, LoggerEvent.Error, message, arg1);

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void Error(this ILogger logger, object sender, string message, object arg1, object arg2) =>
			logger.Log(sender, LoggerEvent.Error, message, arg1, arg2);

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void Error(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) =>
			logger.Log(sender, LoggerEvent.Error, message, arg1, arg2, arg3);

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void Error(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) =>
			logger.Log(sender, LoggerEvent.Error, message, arg1, arg2, arg3, arg4);

		/// <summary>
		/// Log an error message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void Error(this ILogger logger, object sender, string message, params object[] args) =>
			logger.Log(sender, LoggerEvent.Error, message, args);

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void Warning(this ILogger logger, object sender, string message) =>
			logger.Log(sender, LoggerEvent.Warning, "{0}", message);

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void Warning(this ILogger logger, object sender, string message, object arg1) =>
			logger.Log(sender, LoggerEvent.Warning, message, arg1);

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void Warning(this ILogger logger, object sender, string message, object arg1, object arg2) =>
			logger.Log(sender, LoggerEvent.Warning, message, arg1, arg2);

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void Warning(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) => logger.Log(sender, LoggerEvent.Warning, message, arg1, arg2, arg3);

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void Warning(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) =>
			logger.Log(sender, LoggerEvent.Warning, message, arg1, arg2, arg3, arg4);

		/// <summary>
		/// Log a warning message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void Warning(this ILogger logger, object sender, string message, params object[] args) =>
			logger.Log(sender, LoggerEvent.Warning, message, args);

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void Info(this ILogger logger, object sender, string message) =>
			logger.Log(sender, LoggerEvent.Info, "{0}", message);

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void Info(this ILogger logger, object sender, string message, object arg1) =>
			logger.Log(sender, LoggerEvent.Info, message, arg1);

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void Info(this ILogger logger, object sender, string message, object arg1, object arg2) =>
			logger.Log(sender, LoggerEvent.Info, message, arg1, arg2);

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void Info(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) =>
			logger.Log(sender, LoggerEvent.Info, message, arg1, arg2, arg3);

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void Info(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) =>
			logger.Log(sender, LoggerEvent.Info, message, arg1, arg2, arg3, arg4);

		/// <summary>
		/// Log an info message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void Info(this ILogger logger, object sender, string message, params object[] args) =>
			logger.Log(sender, LoggerEvent.Info, message, args);

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void Verbose(this ILogger logger, object sender, string message) =>
			logger.Log(sender, LoggerEvent.Verbose, "{0}", message);

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void Verbose(this ILogger logger, object sender, string message, object arg1) =>
			logger.Log(sender, LoggerEvent.Verbose, message, arg1);

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void Verbose(this ILogger logger, object sender, string message, object arg1, object arg2) =>
			logger.Log(sender, LoggerEvent.Verbose, message, arg1, arg2);

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void Verbose(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) =>
			logger.Log(sender, LoggerEvent.Verbose, message, arg1, arg2, arg3);

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void Verbose(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) =>
			logger.Log(sender, LoggerEvent.Verbose, message, arg1, arg2, arg3, arg4);

		/// <summary>
		/// Log a verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void Verbose(this ILogger logger, object sender, string message, params object[] args) =>
			logger.Log(sender, LoggerEvent.Verbose, message, args);

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message) =>
			logger.Log(sender, LoggerEvent.VeryVerbose, "{0}", message);

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, object arg1) =>
			logger.Log(sender, LoggerEvent.VeryVerbose, message, arg1);

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, object arg1, object arg2) =>
			logger.Log(sender, LoggerEvent.VeryVerbose, message, arg1, arg2);

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3) =>
			logger.Log(sender, LoggerEvent.VeryVerbose, message, arg1, arg2, arg3);

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="arg1">Message arg #1</param>
		/// <param name="arg2">Message arg #2</param>
		/// <param name="arg3">Message arg #3</param>
		/// <param name="arg4">Message arg #4</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, object arg1, object arg2, object arg3, object arg4) =>
			logger.Log(sender, LoggerEvent.VeryVerbose, message, arg1, arg2, arg3, arg4);

		/// <summary>
		/// Log a very verbose message
		/// </summary>
		/// <param name="logger">this</param>
		/// <param name="sender">Sender or <c>null</c></param>
		/// <param name="message">Message</param>
		/// <param name="args">Message arguments</param>
		public static void VeryVerbose(this ILogger logger, object sender, string message, params object[] args) =>
			logger.Log(sender, LoggerEvent.VeryVerbose, message, args);
	}

	/// <summary>
	/// Dummy logger which ignores all messages, but can optionally throw on errors.
	/// </summary>
	public sealed class DummyLogger : ILogger {
		ConstructorInfo ctor;

		/// <summary>
		/// It ignores everything and doesn't throw anything.
		/// </summary>
		public static readonly DummyLogger NoThrowInstance = new DummyLogger();

		/// <summary>
		/// Throws a <see cref="ModuleWriterException"/> on errors, but ignores anything else.
		/// </summary>
		public static readonly DummyLogger ThrowModuleWriterExceptionOnErrorInstance = new DummyLogger(typeof(ModuleWriterException));

		DummyLogger() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="exceptionToThrow">If non-<c>null</c>, this exception type is thrown on
		/// errors. It must have a public constructor that takes a <see cref="string"/> as the only
		/// argument.</param>
		public DummyLogger(Type exceptionToThrow) {
			if (exceptionToThrow is not null) {
				if (!exceptionToThrow.IsSubclassOf(typeof(Exception)))
					throw new ArgumentException($"Not a System.Exception sub class: {exceptionToThrow.GetType()}");
				ctor = exceptionToThrow.GetConstructor(new Type[] { typeof(string) });
				if (ctor is null)
					throw new ArgumentException($"Exception type {exceptionToThrow.GetType()} doesn't have a public constructor that takes a string as the only argument");
			}
		}

		/// <inheritdoc/>
		public void Log(object sender, LoggerEvent loggerEvent, string format, params object[] args) {
			if (loggerEvent == LoggerEvent.Error && ctor is not null)
				throw (Exception)ctor.Invoke(new object[] { string.Format(format, args) });
		}

		/// <inheritdoc/>
		public bool IgnoresEvent(LoggerEvent loggerEvent) {
			if (ctor is null)
				return true;
			return loggerEvent != LoggerEvent.Error;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ImplMap table
	/// </summary>
	[DebuggerDisplay("{Module} {Name}")]
	public abstract class ImplMap : IMDTokenProvider {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.ImplMap, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <summary>
		/// From column ImplMap.MappingFlags
		/// </summary>
		public PInvokeAttributes Attributes {
			get => (PInvokeAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column ImplMap.ImportName
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column ImplMap.ImportScope
		/// </summary>
		public ModuleRef Module {
			get => module;
			set => module = value;
		}
		/// <summary/>
		protected ModuleRef module;

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(PInvokeAttributes andMask, PInvokeAttributes orMask) =>
			attributes = (attributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, PInvokeAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the <see cref="PInvokeAttributes.NoMangle"/> bit
		/// </summary>
		public bool IsNoMangle {
			get => ((PInvokeAttributes)attributes & PInvokeAttributes.NoMangle) != 0;
			set => ModifyAttributes(value, PInvokeAttributes.NoMangle);
		}

		/// <summary>
		/// Gets/sets the char set
		/// </summary>
		public PInvokeAttributes CharSet {
			get => (PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask;
			set => ModifyAttributes(~PInvokeAttributes.CharSetMask, value & PInvokeAttributes.CharSetMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CharSetNotSpec"/> is set
		/// </summary>
		public bool IsCharSetNotSpec => ((PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask) == PInvokeAttributes.CharSetNotSpec;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CharSetAnsi"/> is set
		/// </summary>
		public bool IsCharSetAnsi => ((PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask) == PInvokeAttributes.CharSetAnsi;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CharSetUnicode"/> is set
		/// </summary>
		public bool IsCharSetUnicode => ((PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask) == PInvokeAttributes.CharSetUnicode;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CharSetAuto"/> is set
		/// </summary>
		public bool IsCharSetAuto => ((PInvokeAttributes)attributes & PInvokeAttributes.CharSetMask) == PInvokeAttributes.CharSetAuto;

		/// <summary>
		/// Gets/sets best fit
		/// </summary>
		public PInvokeAttributes BestFit {
			get => (PInvokeAttributes)attributes & PInvokeAttributes.BestFitMask;
			set => ModifyAttributes(~PInvokeAttributes.BestFitMask, value & PInvokeAttributes.BestFitMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.BestFitUseAssem"/> is set
		/// </summary>
		public bool IsBestFitUseAssem => ((PInvokeAttributes)attributes & PInvokeAttributes.BestFitMask) == PInvokeAttributes.BestFitUseAssem;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.BestFitEnabled"/> is set
		/// </summary>
		public bool IsBestFitEnabled => ((PInvokeAttributes)attributes & PInvokeAttributes.BestFitMask) == PInvokeAttributes.BestFitEnabled;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.BestFitDisabled"/> is set
		/// </summary>
		public bool IsBestFitDisabled => ((PInvokeAttributes)attributes & PInvokeAttributes.BestFitMask) == PInvokeAttributes.BestFitDisabled;

		/// <summary>
		/// Gets/sets throw on unmappable char
		/// </summary>
		public PInvokeAttributes ThrowOnUnmappableChar {
			get => (PInvokeAttributes)attributes & PInvokeAttributes.ThrowOnUnmappableCharMask;
			set => ModifyAttributes(~PInvokeAttributes.ThrowOnUnmappableCharMask, value & PInvokeAttributes.ThrowOnUnmappableCharMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.ThrowOnUnmappableCharUseAssem"/> is set
		/// </summary>
		public bool IsThrowOnUnmappableCharUseAssem => ((PInvokeAttributes)attributes & PInvokeAttributes.ThrowOnUnmappableCharMask) == PInvokeAttributes.ThrowOnUnmappableCharUseAssem;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.ThrowOnUnmappableCharEnabled"/> is set
		/// </summary>
		public bool IsThrowOnUnmappableCharEnabled => ((PInvokeAttributes)attributes & PInvokeAttributes.ThrowOnUnmappableCharMask) == PInvokeAttributes.ThrowOnUnmappableCharEnabled;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.ThrowOnUnmappableCharDisabled"/> is set
		/// </summary>
		public bool IsThrowOnUnmappableCharDisabled => ((PInvokeAttributes)attributes & PInvokeAttributes.ThrowOnUnmappableCharMask) == PInvokeAttributes.ThrowOnUnmappableCharDisabled;

		/// <summary>
		/// Gets/sets the <see cref="PInvokeAttributes.SupportsLastError"/> bit
		/// </summary>
		public bool SupportsLastError {
			get => ((PInvokeAttributes)attributes & PInvokeAttributes.SupportsLastError) != 0;
			set => ModifyAttributes(value, PInvokeAttributes.SupportsLastError);
		}

		/// <summary>
		/// Gets/sets calling convention
		/// </summary>
		public PInvokeAttributes CallConv {
			get => (PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask;
			set => ModifyAttributes(~PInvokeAttributes.CallConvMask, value & PInvokeAttributes.CallConvMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvWinapi"/> is set
		/// </summary>
		public bool IsCallConvWinapi => ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvWinapi;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvCdecl"/> is set
		/// </summary>
		public bool IsCallConvCdecl => ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvCdecl;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvStdcall"/> is set
		/// </summary>
		public bool IsCallConvStdcall => ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvStdcall;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvThiscall"/> is set
		/// </summary>
		public bool IsCallConvThiscall => ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvThiscall;

		/// <summary>
		/// <c>true</c> if <see cref="PInvokeAttributes.CallConvFastcall"/> is set
		/// </summary>
		public bool IsCallConvFastcall => ((PInvokeAttributes)attributes & PInvokeAttributes.CallConvMask) == PInvokeAttributes.CallConvFastcall;

		/// <summary>
		/// Checks whether this <see cref="ImplMap"/> is a certain P/Invoke method
		/// </summary>
		/// <param name="dllName">Name of the DLL</param>
		/// <param name="funcName">Name of the function within the DLL</param>
		/// <returns><c>true</c> if it's the specified P/Invoke method, else <c>false</c></returns>
		public bool IsPinvokeMethod(string dllName, string funcName) => IsPinvokeMethod(dllName, funcName, IsWindows());

		/// <summary>
		/// Checks whether this <see cref="ImplMap"/> is a certain P/Invoke method
		/// </summary>
		/// <param name="dllName">Name of the DLL</param>
		/// <param name="funcName">Name of the function within the DLL</param>
		/// <param name="treatAsWindows">Treat as Windows</param>
		/// <returns><c>true</c> if it's the specified P/Invoke method, else <c>false</c></returns>
		public bool IsPinvokeMethod(string dllName, string funcName, bool treatAsWindows) {
			if (name != funcName)
				return false;
			var mod = module;
			if (mod is null)
				return false;
			return GetDllName(dllName, treatAsWindows).Equals(GetDllName(mod.Name, treatAsWindows), StringComparison.OrdinalIgnoreCase);
		}

		static string GetDllName(string dllName, bool treatAsWindows) {
			if (treatAsWindows)
				dllName = dllName.TrimEnd(trimChars);
			if (dllName.EndsWith(".dll", StringComparison.OrdinalIgnoreCase))
				return dllName.Substring(0, dllName.Length - 4);
			return dllName;
		}

		static bool IsWindows() =>
#if NETSTANDARD
			RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
#else
			Path.DirectorySeparatorChar == '\\' || Path.AltDirectorySeparatorChar == '\\';
#endif

		static readonly char[] trimChars = { ' ' };
	}

	/// <summary>
	/// An ImplMap row created by the user and not present in the original .NET file
	/// </summary>
	public class ImplMapUser : ImplMap {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ImplMapUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="scope">Scope</param>
		/// <param name="name">Name</param>
		/// <param name="flags">Flags</param>
		public ImplMapUser(ModuleRef scope, UTF8String name, PInvokeAttributes flags) {
			module = scope;
			this.name = name;
			attributes = (int)flags;
		}
	}

	/// <summary>
	/// Created from a row in the ImplMap table
	/// </summary>
	sealed class ImplMapMD : ImplMap, IMDTokenProviderMD {
		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ImplMap</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ImplMapMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ImplMapTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"ImplMap rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			bool b = readerModule.TablesStream.TryReadImplMapRow(origRid, out var row);
			Debug.Assert(b);
			attributes = row.MappingFlags;
			name = readerModule.StringsStream.ReadNoNull(row.ImportName);
			module = readerModule.ResolveModuleRef(row.ImportScope);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// <see cref="Importer"/> options
	/// </summary>
	[Flags]
	public enum ImporterOptions {
		/// <summary>
		/// Use <see cref="TypeDef"/>s whenever possible if the <see cref="TypeDef"/> is located
		/// in this module.
		/// </summary>
		TryToUseTypeDefs = 1,

		/// <summary>
		/// Use <see cref="MethodDef"/>s whenever possible if the <see cref="MethodDef"/> is located
		/// in this module.
		/// </summary>
		TryToUseMethodDefs = 2,

		/// <summary>
		/// Use <see cref="FieldDef"/>s whenever possible if the <see cref="FieldDef"/> is located
		/// in this module.
		/// </summary>
		TryToUseFieldDefs = 4,

		/// <summary>
		/// Use <see cref="TypeDef"/>s, <see cref="MethodDef"/>s and <see cref="FieldDef"/>s
		/// whenever possible if the definition is located in this module.
		/// </summary>
		/// <seealso cref="TryToUseTypeDefs"/>
		/// <seealso cref="TryToUseMethodDefs"/>
		/// <seealso cref="TryToUseFieldDefs"/>
		TryToUseDefs = TryToUseTypeDefs | TryToUseMethodDefs | TryToUseFieldDefs,

		/// <summary>
		/// Use already existing <see cref="AssemblyRef"/>s whenever possible
		/// </summary>
		TryToUseExistingAssemblyRefs = 8,

		/// <summary>
		/// Don't set this flag. For internal use only.
		/// </summary>
		FixSignature = int.MinValue,
	}

	/// <summary>
	/// Re-maps entities that were renamed in the target module
	/// </summary>
	public abstract class ImportMapper {
		/// <summary>
		/// Matches source <see cref="ITypeDefOrRef"/> to the one that is already present in the target module under a different name.
		/// </summary>
		/// <param name="source"><see cref="ITypeDefOrRef"/> referenced by the entity that is being imported.</param>
		/// <returns>matching <see cref="ITypeDefOrRef"/> or <c>null</c> if there's no match.</returns>
		public virtual ITypeDefOrRef Map(ITypeDefOrRef source) => null;

		/// <summary>
		/// Matches source <see cref="FieldDef"/> to the one that is already present in the target module under a different name.
		/// </summary>
		/// <param name="source"><see cref="FieldDef"/> referenced by the entity that is being imported.</param>
		/// <returns>matching <see cref="IField"/> or <c>null</c> if there's no match.</returns>
		public virtual IField Map(FieldDef source) => null;

		/// <summary>
		/// Matches source <see cref="MethodDef"/> to the one that is already present in the target module under a different name.
		/// </summary>
		/// <param name="source"><see cref="MethodDef"/> referenced by the entity that is being imported.</param>
		/// <returns>matching <see cref="IMethod"/> or <c>null</c> if there's no match.</returns>
		public virtual IMethod Map(MethodDef source) => null;

		/// <summary>
		/// Matches source <see cref="MemberRef"/> to the one that is already present in the target module under a different name.
		/// </summary>
		/// <param name="source"><see cref="MemberRef"/> referenced by the entity that is being imported.</param>
		/// <returns>matching <see cref="MemberRef"/> or <c>null</c> if there's no match.</returns>
		public virtual MemberRef Map(MemberRef source) => null;

		/// <summary>
		/// Overrides default behavior of <see cref="Importer.Import(Type)"/>
		/// May be used to use reference assemblies for <see cref="Type"/> resolution, for example.
		/// </summary>
		/// <param name="source"><see cref="Type"/> to create <see cref="TypeRef"/> for. <paramref name="source"/> is non-generic type or generic type without generic arguments.</param>
		/// <returns><see cref="TypeRef"/> or null to use default <see cref="Importer"/>'s type resolution</returns>
		public virtual TypeRef Map(Type source) => null;
	}

	/// <summary>
	/// Imports <see cref="Type"/>s, <see cref="ConstructorInfo"/>s, <see cref="MethodInfo"/>s
	/// and <see cref="FieldInfo"/>s as references
	/// </summary>
	public struct Importer {
		readonly ModuleDef module;
		internal readonly GenericParamContext gpContext;
		readonly ImportMapper mapper;
		RecursionCounter recursionCounter;
		ImporterOptions options;

		bool TryToUseTypeDefs => (options & ImporterOptions.TryToUseTypeDefs) != 0;
		bool TryToUseMethodDefs => (options & ImporterOptions.TryToUseMethodDefs) != 0;
		bool TryToUseFieldDefs => (options & ImporterOptions.TryToUseFieldDefs) != 0;
		bool TryToUseExistingAssemblyRefs => (options & ImporterOptions.TryToUseExistingAssemblyRefs) != 0;

		bool FixSignature {
			get => (options & ImporterOptions.FixSignature) != 0;
			set {
				if (value)
					options |= ImporterOptions.FixSignature;
				else
					options &= ~ImporterOptions.FixSignature;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module that will own all references</param>
		public Importer(ModuleDef module)
			: this(module, 0, new GenericParamContext(), null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module that will own all references</param>
		/// <param name="gpContext">Generic parameter context</param>
		public Importer(ModuleDef module, GenericParamContext gpContext)
			: this(module, 0, gpContext, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module that will own all references</param>
		/// <param name="options">Importer options</param>
		public Importer(ModuleDef module, ImporterOptions options)
			: this(module, options, new GenericParamContext(), null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module that will own all references</param>
		/// <param name="options">Importer options</param>
		/// <param name="gpContext">Generic parameter context</param>
		public Importer(ModuleDef module, ImporterOptions options, GenericParamContext gpContext)
			: this(module, options, gpContext, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module that will own all references</param>
		/// <param name="options">Importer options</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="mapper">Mapper for renamed entities</param>
		public Importer(ModuleDef module, ImporterOptions options, GenericParamContext gpContext, ImportMapper mapper) {
			this.module = module;
			recursionCounter = new RecursionCounter();
			this.options = options;
			this.gpContext = gpContext;
			this.mapper = mapper;
		}

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="ITypeDefOrRef"/>. If it's a type that should be
		/// the declaring type of a field/method reference, call <see cref="ImportDeclaringType(Type)"/> instead.
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public ITypeDefOrRef Import(Type type) => module.UpdateRowId(ImportAsTypeSig(type).ToTypeDefOrRef());

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="ITypeDefOrRef"/>. Should be called if it's the
		/// declaring type of a method/field reference. See also <see cref="Import(Type)"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns></returns>
		public ITypeDefOrRef ImportDeclaringType(Type type) => module.UpdateRowId(ImportAsTypeSig(type, type.IsGenericTypeDefinition).ToTypeDefOrRef());

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <param name="requiredModifiers">A list of all required modifiers or <c>null</c></param>
		/// <param name="optionalModifiers">A list of all optional modifiers or <c>null</c></param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public ITypeDefOrRef Import(Type type, IList<Type> requiredModifiers, IList<Type> optionalModifiers) =>
			module.UpdateRowId(ImportAsTypeSig(type, requiredModifiers, optionalModifiers).ToTypeDefOrRef());

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public TypeSig ImportAsTypeSig(Type type) => ImportAsTypeSig(type, false);

		TypeSig ImportAsTypeSig(Type type, bool treatAsGenericInst) {
			if (type is null)
				return null;
			switch (treatAsGenericInst ? ElementType.GenericInst : type.GetElementType2()) {
			case ElementType.Void:		return module.CorLibTypes.Void;
			case ElementType.Boolean:	return module.CorLibTypes.Boolean;
			case ElementType.Char:		return module.CorLibTypes.Char;
			case ElementType.I1:		return module.CorLibTypes.SByte;
			case ElementType.U1:		return module.CorLibTypes.Byte;
			case ElementType.I2:		return module.CorLibTypes.Int16;
			case ElementType.U2:		return module.CorLibTypes.UInt16;
			case ElementType.I4:		return module.CorLibTypes.Int32;
			case ElementType.U4:		return module.CorLibTypes.UInt32;
			case ElementType.I8:		return module.CorLibTypes.Int64;
			case ElementType.U8:		return module.CorLibTypes.UInt64;
			case ElementType.R4:		return module.CorLibTypes.Single;
			case ElementType.R8:		return module.CorLibTypes.Double;
			case ElementType.String:	return module.CorLibTypes.String;
			case ElementType.TypedByRef:return module.CorLibTypes.TypedReference;
			case ElementType.U:			return module.CorLibTypes.UIntPtr;
			case ElementType.Object:	return module.CorLibTypes.Object;
			case ElementType.Ptr:		return new PtrSig(ImportAsTypeSig(type.GetElementType(), treatAsGenericInst));
			case ElementType.ByRef:		return new ByRefSig(ImportAsTypeSig(type.GetElementType(), treatAsGenericInst));
			case ElementType.SZArray:	return new SZArraySig(ImportAsTypeSig(type.GetElementType(), treatAsGenericInst));
			case ElementType.ValueType: return new ValueTypeSig(CreateTypeRef(type));
			case ElementType.Class:		return new ClassSig(CreateTypeRef(type));
			case ElementType.Var:		return new GenericVar((uint)type.GenericParameterPosition, gpContext.Type);
			case ElementType.MVar:		return new GenericMVar((uint)type.GenericParameterPosition, gpContext.Method);

			case ElementType.I:
				FixSignature = true;	// FnPtr is mapped to System.IntPtr
				return module.CorLibTypes.IntPtr;

			case ElementType.Array:
				// We don't know sizes and lower bounds. Assume it's `0..`
				var lowerBounds = new int[type.GetArrayRank()];
				var sizes = Array2.Empty<uint>();
				FixSignature = true;
				return new ArraySig(ImportAsTypeSig(type.GetElementType(), treatAsGenericInst), (uint)type.GetArrayRank(), sizes, lowerBounds);

			case ElementType.GenericInst:
				var typeGenArgs = type.GetGenericArguments();
				var git = new GenericInstSig(ImportAsTypeSig(type.GetGenericTypeDefinition()) as ClassOrValueTypeSig, (uint)typeGenArgs.Length);
				foreach (var ga in typeGenArgs)
					git.GenericArguments.Add(ImportAsTypeSig(ga));
				return git;

			case ElementType.Sentinel:
			case ElementType.Pinned:
			case ElementType.FnPtr:		// mapped to System.IntPtr
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.ValueArray:
			case ElementType.R:
			case ElementType.Internal:
			case ElementType.Module:
			case ElementType.End:
			default:
				return null;
			}
		}

		ITypeDefOrRef TryResolve(TypeRef tr) {
			if (!TryToUseTypeDefs || tr is null)
				return tr;
			if (!IsThisModule(tr))
				return tr;
			var td = tr.Resolve();
			if (td is null || td.Module != module)
				return tr;
			return td;
		}

		IMethodDefOrRef TryResolveMethod(IMethodDefOrRef mdr) {
			if (!TryToUseMethodDefs || mdr is null)
				return mdr;

			var mr = mdr as MemberRef;
			if (mr is null)
				return mdr;
			if (!mr.IsMethodRef)
				return mr;

			var declType = GetDeclaringType(mr);
			if (declType is null)
				return mr;
			if (declType.Module != module)
				return mr;
			return (IMethodDefOrRef)declType.ResolveMethod(mr) ?? mr;
		}

		IField TryResolveField(MemberRef mr) {
			if (!TryToUseFieldDefs || mr is null)
				return mr;

			if (!mr.IsFieldRef)
				return mr;

			var declType = GetDeclaringType(mr);
			if (declType is null)
				return mr;
			if (declType.Module != module)
				return mr;
			return (IField)declType.ResolveField(mr) ?? mr;
		}

		TypeDef GetDeclaringType(MemberRef mr) {
			if (mr is null)
				return null;

			if (mr.Class is TypeDef td)
				return td;

			td = TryResolve(mr.Class as TypeRef) as TypeDef;
			if (td is not null)
				return td;

			var modRef = mr.Class as ModuleRef;
			if (IsThisModule(modRef))
				return module.GlobalType;

			return null;
		}

		bool IsThisModule(TypeRef tr) {
			if (tr is null)
				return false;
			var scopeType = tr.GetNonNestedTypeRefScope() as TypeRef;
			if (scopeType is null)
				return false;

			if (module == scopeType.ResolutionScope)
				return true;

			if (scopeType.ResolutionScope is ModuleRef modRef)
				return IsThisModule(modRef);

			var asmRef = scopeType.ResolutionScope as AssemblyRef;
			return Equals(module.Assembly, asmRef);
		}

		bool IsThisModule(ModuleRef modRef) =>
			modRef is not null &&
			module.Name == modRef.Name &&
			Equals(module.Assembly, modRef.DefinitionAssembly);

		static bool Equals(IAssembly a, IAssembly b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			return Utils.Equals(a.Version, b.Version) &&
				PublicKeyBase.TokenEquals(a.PublicKeyOrToken, b.PublicKeyOrToken) &&
				UTF8String.Equals(a.Name, b.Name) &&
				UTF8String.CaseInsensitiveEquals(a.Culture, b.Culture);
		}

		ITypeDefOrRef CreateTypeRef(Type type) => TryResolve(mapper?.Map(type) ?? CreateTypeRef2(type));

		TypeRef CreateTypeRef2(Type type) {
			if (!type.IsNested)
				return module.UpdateRowId(new TypeRefUser(module, type.Namespace ?? string.Empty, ReflectionExtensions.Unescape(type.Name) ?? string.Empty, CreateScopeReference(type)));
			type.GetTypeNamespaceAndName_TypeDefOrRef(out var @namespace, out var name);
			return module.UpdateRowId(new TypeRefUser(module, @namespace ?? string.Empty, name ?? string.Empty, CreateTypeRef2(type.DeclaringType)));
		}

		IResolutionScope CreateScopeReference(Type type) {
			if (type is null)
				return null;
			var asmName = type.Assembly.GetName();
			var modAsm = module.Assembly;
			if (modAsm is not null) {
				if (UTF8String.ToSystemStringOrEmpty(modAsm.Name).Equals(asmName.Name, StringComparison.OrdinalIgnoreCase)) {
					if (UTF8String.ToSystemStringOrEmpty(module.Name).Equals(type.Module.ScopeName, StringComparison.OrdinalIgnoreCase))
						return module;
					return module.UpdateRowId(new ModuleRefUser(module, type.Module.ScopeName));
				}
			}
			var pkt = asmName.GetPublicKeyToken();
			if (pkt is null || pkt.Length == 0)
				pkt = null;
			if (TryToUseExistingAssemblyRefs && module.GetAssemblyRef(asmName.Name) is AssemblyRef asmRef)
				return asmRef;
			return module.UpdateRowId(new AssemblyRefUser(asmName.Name, asmName.Version, PublicKeyBase.CreatePublicKeyToken(pkt), asmName.CultureInfo.Name));
		}

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <param name="requiredModifiers">A list of all required modifiers or <c>null</c></param>
		/// <param name="optionalModifiers">A list of all optional modifiers or <c>null</c></param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public TypeSig ImportAsTypeSig(Type type, IList<Type> requiredModifiers, IList<Type> optionalModifiers) =>
			ImportAsTypeSig(type, requiredModifiers, optionalModifiers, false);

		TypeSig ImportAsTypeSig(Type type, IList<Type> requiredModifiers, IList<Type> optionalModifiers, bool treatAsGenericInst) {
			if (type is null)
				return null;
			if (IsEmpty(requiredModifiers) && IsEmpty(optionalModifiers))
				return ImportAsTypeSig(type, treatAsGenericInst);

			FixSignature = true;	// Order of modifiers is unknown
			var ts = ImportAsTypeSig(type, treatAsGenericInst);

			// We don't know the original order of the modifiers.
			// Assume all required modifiers are closer to the real type.
			// Assume all modifiers should be applied in the same order as in the lists.

			if (requiredModifiers is not null) {
				foreach (var modifier in requiredModifiers)
					ts = new CModReqdSig(Import(modifier), ts);
			}

			if (optionalModifiers is not null) {
				foreach (var modifier in optionalModifiers)
					ts = new CModOptSig(Import(modifier), ts);
			}

			return ts;
		}

		static bool IsEmpty<T>(IList<T> list) => list is null || list.Count == 0;

		/// <summary>
		/// Imports a <see cref="MethodBase"/> as a <see cref="IMethod"/>. This will be either
		/// a <see cref="MemberRef"/> or a <see cref="MethodSpec"/>.
		/// </summary>
		/// <param name="methodBase">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="methodBase"/> is invalid
		/// or if we failed to import the method</returns>
		public IMethod Import(MethodBase methodBase) => Import(methodBase, false);

		/// <summary>
		/// Imports a <see cref="MethodBase"/> as a <see cref="IMethod"/>. This will be either
		/// a <see cref="MemberRef"/> or a <see cref="MethodSpec"/>.
		/// </summary>
		/// <param name="methodBase">The method</param>
		/// <param name="forceFixSignature">Always verify method signature to make sure the
		/// returned reference matches the metadata in the source assembly</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="methodBase"/> is invalid
		/// or if we failed to import the method</returns>
		public IMethod Import(MethodBase methodBase, bool forceFixSignature) {
			FixSignature = false;
			return ImportInternal(methodBase, forceFixSignature);
		}

		IMethod ImportInternal(MethodBase methodBase) => ImportInternal(methodBase, false);

		IMethod ImportInternal(MethodBase methodBase, bool forceFixSignature) {
			if (methodBase is null)
				return null;

			if (forceFixSignature) {
				//TODO:
			}

			bool isMethodSpec = methodBase.IsGenericButNotGenericMethodDefinition();
			if (isMethodSpec) {
				IMethodDefOrRef method;
				var origMethod = methodBase.Module.ResolveMethod(methodBase.MetadataToken);
				if (methodBase.DeclaringType.GetElementType2() == ElementType.GenericInst)
					method = module.UpdateRowId(new MemberRefUser(module, methodBase.Name, CreateMethodSig(origMethod), ImportDeclaringType(methodBase.DeclaringType)));
				else
					method = ImportInternal(origMethod) as IMethodDefOrRef;

				method = TryResolveMethod(method);

				var gim = CreateGenericInstMethodSig(methodBase);
				var methodSpec = module.UpdateRowId(new MethodSpecUser(method, gim));
				if (FixSignature && !forceFixSignature) {
					//TODO:
				}
				return methodSpec;
			}
			else {
				IMemberRefParent parent;
				if (methodBase.DeclaringType is null) {
					// It's the global type. We can reference it with a ModuleRef token.
					parent = GetModuleParent(methodBase.Module);
				}
				else
					parent = ImportDeclaringType(methodBase.DeclaringType);
				if (parent is null)
					return null;

				MethodBase origMethod;
				try {
					// Get the original method def in case the declaring type is a generic
					// type instance and the method uses at least one generic type parameter.
					origMethod = methodBase.Module.ResolveMethod(methodBase.MetadataToken);
				}
				catch (ArgumentException) {
					// Here if eg. the method was created by the runtime (eg. a multi-dimensional
					// array getter/setter method). The method token is in that case 0x06000000,
					// which is invalid.
					origMethod = methodBase;
				}

				var methodSig = CreateMethodSig(origMethod);
				IMethodDefOrRef methodRef = module.UpdateRowId(new MemberRefUser(module, methodBase.Name, methodSig, parent));
				methodRef = TryResolveMethod(methodRef);
				if (FixSignature && !forceFixSignature) {
					//TODO:
				}
				return methodRef;
			}
		}

		MethodSig CreateMethodSig(MethodBase mb) {
			var sig = new MethodSig(GetCallingConvention(mb));

			if (mb is MethodInfo mi)
				sig.RetType = ImportAsTypeSig(mi.ReturnParameter, mb.DeclaringType);
			else
				sig.RetType = module.CorLibTypes.Void;

			foreach (var p in mb.GetParameters())
				sig.Params.Add(ImportAsTypeSig(p, mb.DeclaringType));

			if (mb.IsGenericMethodDefinition)
				sig.GenParamCount = (uint)mb.GetGenericArguments().Length;

			return sig;
		}

		TypeSig ImportAsTypeSig(ParameterInfo p, Type declaringType) =>
			ImportAsTypeSig(p.ParameterType, p.GetRequiredCustomModifiers(), p.GetOptionalCustomModifiers(), declaringType.MustTreatTypeAsGenericInstType(p.ParameterType));

		CallingConvention GetCallingConvention(MethodBase mb) {
			CallingConvention cc = 0;

			var mbcc = mb.CallingConvention;
			if (mb.IsGenericMethodDefinition)
				cc |= CallingConvention.Generic;
			if ((mbcc & CallingConventions.HasThis) != 0)
				cc |= CallingConvention.HasThis;
			if ((mbcc & CallingConventions.ExplicitThis) != 0)
				cc |= CallingConvention.ExplicitThis;

			switch (mbcc & CallingConventions.Any) {
			case CallingConventions.Standard:
				cc |= CallingConvention.Default;
				break;

			case CallingConventions.VarArgs:
				cc |= CallingConvention.VarArg;
				break;

			case CallingConventions.Any:
			default:
				FixSignature = true;
				cc |= CallingConvention.Default;
				break;
			}

			return cc;
		}

		GenericInstMethodSig CreateGenericInstMethodSig(MethodBase mb) {
			var genMethodArgs = mb.GetGenericArguments();
			var gim = new GenericInstMethodSig(CallingConvention.GenericInst, (uint)genMethodArgs.Length);
			foreach (var gma in genMethodArgs)
				gim.GenericArguments.Add(ImportAsTypeSig(gma));
			return gim;
		}

		IMemberRefParent GetModuleParent(Module module2) {
			// If we have no assembly, assume this is a netmodule in the same assembly as module
			var modAsm = module.Assembly;
			bool isSameAssembly = modAsm is null ||
				UTF8String.ToSystemStringOrEmpty(modAsm.Name).Equals(module2.Assembly.GetName().Name, StringComparison.OrdinalIgnoreCase);
			if (!isSameAssembly)
				return null;
			return module.UpdateRowId(new ModuleRefUser(module, module.Name));
		}

		/// <summary>
		/// Imports a <see cref="FieldInfo"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="fieldInfo">The field</param>
		/// <returns>The imported field or <c>null</c> if <paramref name="fieldInfo"/> is invalid
		/// or if we failed to import the field</returns>
		public IField Import(FieldInfo fieldInfo) => Import(fieldInfo, false);

		/// <summary>
		/// Imports a <see cref="FieldInfo"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="fieldInfo">The field</param>
		/// <param name="forceFixSignature">Always verify field signature to make sure the
		/// returned reference matches the metadata in the source assembly</param>
		/// <returns>The imported field or <c>null</c> if <paramref name="fieldInfo"/> is invalid
		/// or if we failed to import the field</returns>
		public IField Import(FieldInfo fieldInfo, bool forceFixSignature) {
			FixSignature = false;
			if (fieldInfo is null)
				return null;

			if (forceFixSignature) {
				//TODO:
			}

			IMemberRefParent parent;
			if (fieldInfo.DeclaringType is null) {
				// It's the global type. We can reference it with a ModuleRef token.
				parent = GetModuleParent(fieldInfo.Module);
			}
			else
				parent = ImportDeclaringType(fieldInfo.DeclaringType);
			if (parent is null)
				return null;

			FieldInfo origField;
			try {
				// Get the original field def in case the declaring type is a generic
				// type instance and the field uses a generic type parameter.
				origField = fieldInfo.Module.ResolveField(fieldInfo.MetadataToken);
			}
			catch (ArgumentException) {
				origField = fieldInfo;
			}

			MemberRef fieldRef;
			if (origField.FieldType.ContainsGenericParameters) {
				var origDeclType = origField.DeclaringType;
				var asm = module.Context.AssemblyResolver.Resolve(origDeclType.Module.Assembly.GetName(), module);
				if (asm is null || asm.FullName != origDeclType.Assembly.FullName)
					throw new Exception("Couldn't resolve the correct assembly");
				var mod = asm.FindModule(origDeclType.Module.ScopeName) as ModuleDefMD;
				if (mod is null)
					throw new Exception("Couldn't resolve the correct module");
				var fieldDef = mod.ResolveField((uint)(origField.MetadataToken & 0x00FFFFFF));
				if (fieldDef is null)
					throw new Exception("Couldn't resolve the correct field");

				var fieldSig = new FieldSig(Import(fieldDef.FieldSig.GetFieldType()));
				fieldRef = module.UpdateRowId(new MemberRefUser(module, fieldInfo.Name, fieldSig, parent));
			}
			else {
				var fieldSig = new FieldSig(ImportAsTypeSig(fieldInfo.FieldType, fieldInfo.GetRequiredCustomModifiers(), fieldInfo.GetOptionalCustomModifiers()));
				fieldRef = module.UpdateRowId(new MemberRefUser(module, fieldInfo.Name, fieldSig, parent));
			}
			var field = TryResolveField(fieldRef);
			if (FixSignature && !forceFixSignature) {
				//TODO:
			}
			return field;
		}

		/// <summary>
		/// Imports a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public IType Import(IType type) {
			if (type is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			IType result;
			TypeDef td;
			TypeRef tr;
			TypeSpec ts;
			TypeSig sig;

			if ((td = type as TypeDef) is not null)
				result = Import(td);
			else if ((tr = type as TypeRef) is not null)
				result = Import(tr);
			else if ((ts = type as TypeSpec) is not null)
				result = Import(ts);
			else if ((sig = type as TypeSig) is not null)
				result = Import(sig);
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="TypeDef"/> as a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public ITypeDefOrRef Import(TypeDef type) {
			if (type is null)
				return null;
			if (TryToUseTypeDefs && type.Module == module)
				return type;
			var mapped = mapper?.Map(type);
			if (mapped is not null)
				return mapped;
			return Import2(type);
		}

		TypeRef Import2(TypeDef type) {
			if (type is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			TypeRef result;

			var declType = type.DeclaringType;
			if (declType is not null)
				result = module.UpdateRowId(new TypeRefUser(module, type.Namespace, type.Name, Import2(declType)));
			else
				result = module.UpdateRowId(new TypeRefUser(module, type.Namespace, type.Name, CreateScopeReference(type.DefinitionAssembly, type.Module)));

			recursionCounter.Decrement();
			return result;
		}

		IResolutionScope CreateScopeReference(IAssembly defAsm, ModuleDef defMod) {
			if (defAsm is null)
				return null;
			var modAsm = module.Assembly;
			if (defMod is not null && defAsm is not null && modAsm is not null) {
				if (UTF8String.CaseInsensitiveEquals(modAsm.Name, defAsm.Name)) {
					if (UTF8String.CaseInsensitiveEquals(module.Name, defMod.Name))
						return module;
					return module.UpdateRowId(new ModuleRefUser(module, defMod.Name));
				}
			}
			var pkt = PublicKeyBase.ToPublicKeyToken(defAsm.PublicKeyOrToken);
			if (PublicKeyBase.IsNullOrEmpty2(pkt))
				pkt = null;
			if (TryToUseExistingAssemblyRefs && module.GetAssemblyRef(defAsm.Name) is AssemblyRef asmRef)
				return asmRef;
			return module.UpdateRowId(new AssemblyRefUser(defAsm.Name, defAsm.Version, pkt, defAsm.Culture) { Attributes = defAsm.Attributes & ~AssemblyAttributes.PublicKey });
		}

		/// <summary>
		/// Imports a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public ITypeDefOrRef Import(TypeRef type) {
			var mapped = mapper?.Map(type);
			if (mapped is not null)
				return mapped;

			return TryResolve(Import2(type));
		}

		TypeRef Import2(TypeRef type) {
			if (type is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			TypeRef result;

			var declaringType = type.DeclaringType;
			if (declaringType is not null)
				result = module.UpdateRowId(new TypeRefUser(module, type.Namespace, type.Name, Import2(declaringType)));
			else
				result = module.UpdateRowId(new TypeRefUser(module, type.Namespace, type.Name, CreateScopeReference(type.DefinitionAssembly, type.Module)));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeSpec Import(TypeSpec type) {
			if (type is null)
				return null;
			return module.UpdateRowId(new TypeSpecUser(Import(type.TypeSig)));
		}

		/// <summary>
		/// Imports a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeSig Import(TypeSig type) {
			if (type is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			TypeSig result;
			switch (type.ElementType) {
			case ElementType.Void:		result = module.CorLibTypes.Void; break;
			case ElementType.Boolean:	result = module.CorLibTypes.Boolean; break;
			case ElementType.Char:		result = module.CorLibTypes.Char; break;
			case ElementType.I1:		result = module.CorLibTypes.SByte; break;
			case ElementType.U1:		result = module.CorLibTypes.Byte; break;
			case ElementType.I2:		result = module.CorLibTypes.Int16; break;
			case ElementType.U2:		result = module.CorLibTypes.UInt16; break;
			case ElementType.I4:		result = module.CorLibTypes.Int32; break;
			case ElementType.U4:		result = module.CorLibTypes.UInt32; break;
			case ElementType.I8:		result = module.CorLibTypes.Int64; break;
			case ElementType.U8:		result = module.CorLibTypes.UInt64; break;
			case ElementType.R4:		result = module.CorLibTypes.Single; break;
			case ElementType.R8:		result = module.CorLibTypes.Double; break;
			case ElementType.String:	result = module.CorLibTypes.String; break;
			case ElementType.TypedByRef:result = module.CorLibTypes.TypedReference; break;
			case ElementType.I:			result = module.CorLibTypes.IntPtr; break;
			case ElementType.U:			result = module.CorLibTypes.UIntPtr; break;
			case ElementType.Object:	result = module.CorLibTypes.Object; break;
			case ElementType.Ptr:		result = new PtrSig(Import(type.Next)); break;
			case ElementType.ByRef:		result = new ByRefSig(Import(type.Next)); break;
			case ElementType.ValueType: result = CreateClassOrValueType((type as ClassOrValueTypeSig).TypeDefOrRef, true); break;
			case ElementType.Class:		result = CreateClassOrValueType((type as ClassOrValueTypeSig).TypeDefOrRef, false); break;
			case ElementType.Var:		result = new GenericVar((type as GenericVar).Number, gpContext.Type); break;
			case ElementType.ValueArray:result = new ValueArraySig(Import(type.Next), (type as ValueArraySig).Size); break;
			case ElementType.FnPtr:		result = new FnPtrSig(Import((type as FnPtrSig).Signature)); break;
			case ElementType.SZArray:	result = new SZArraySig(Import(type.Next)); break;
			case ElementType.MVar:		result = new GenericMVar((type as GenericMVar).Number, gpContext.Method); break;
			case ElementType.CModReqd:	result = new CModReqdSig(Import((type as ModifierSig).Modifier), Import(type.Next)); break;
			case ElementType.CModOpt:	result = new CModOptSig(Import((type as ModifierSig).Modifier), Import(type.Next)); break;
			case ElementType.Module:	result = new ModuleSig((type as ModuleSig).Index, Import(type.Next)); break;
			case ElementType.Sentinel:	result = new SentinelSig(); break;
			case ElementType.Pinned:	result = new PinnedSig(Import(type.Next)); break;

			case ElementType.Array:
				var arraySig = (ArraySig)type;
				var sizes = new List<uint>(arraySig.Sizes);
				var lbounds = new List<int>(arraySig.LowerBounds);
				result = new ArraySig(Import(type.Next), arraySig.Rank, sizes, lbounds);
				break;

			case ElementType.GenericInst:
				var gis = (GenericInstSig)type;
				var genArgs = new List<TypeSig>(gis.GenericArguments.Count);
				foreach (var ga in gis.GenericArguments)
					genArgs.Add(Import(ga));
				result = new GenericInstSig(Import(gis.GenericType) as ClassOrValueTypeSig, genArgs);
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = null;
				break;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public ITypeDefOrRef Import(ITypeDefOrRef type) => (ITypeDefOrRef)Import((IType)type);

		TypeSig CreateClassOrValueType(ITypeDefOrRef type, bool isValueType) {
			var corLibType = module.CorLibTypes.GetCorLibTypeSig(type);
			if (corLibType is not null)
				return corLibType;

			if (isValueType)
				return new ValueTypeSig(Import(type));
			return new ClassSig(Import(type));
		}

		/// <summary>
		/// Imports a <see cref="CallingConventionSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public CallingConventionSig Import(CallingConventionSig sig) {
			if (sig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			CallingConventionSig result;

			var sigType = sig.GetType();
			if (sigType == typeof(MethodSig))
				result = Import((MethodSig)sig);
			else if (sigType == typeof(FieldSig))
				result = Import((FieldSig)sig);
			else if (sigType == typeof(GenericInstMethodSig))
				result = Import((GenericInstMethodSig)sig);
			else if (sigType == typeof(PropertySig))
				result = Import((PropertySig)sig);
			else if (sigType == typeof(LocalSig))
				result = Import((LocalSig)sig);
			else
				result = null;	// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="FieldSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public FieldSig Import(FieldSig sig) {
			if (sig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			var result = new FieldSig(sig.GetCallingConvention(), Import(sig.Type));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="MethodSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public MethodSig Import(MethodSig sig) {
			if (sig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			var result = Import(new MethodSig(sig.GetCallingConvention()), sig);

			recursionCounter.Decrement();
			return result;
		}

		T Import<T>(T sig, T old) where T : MethodBaseSig {
			sig.RetType = Import(old.RetType);
			foreach (var p in old.Params)
				sig.Params.Add(Import(p));
			sig.GenParamCount = old.GenParamCount;
			var paramsAfterSentinel = sig.ParamsAfterSentinel;
			if (paramsAfterSentinel is not null) {
				foreach (var p in old.ParamsAfterSentinel)
					paramsAfterSentinel.Add(Import(p));
			}
			return sig;
		}

		/// <summary>
		/// Imports a <see cref="PropertySig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public PropertySig Import(PropertySig sig) {
			if (sig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			var result = Import(new PropertySig(sig.GetCallingConvention()), sig);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="LocalSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public LocalSig Import(LocalSig sig) {
			if (sig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			var result = new LocalSig(sig.GetCallingConvention(), (uint)sig.Locals.Count);
			foreach (var l in sig.Locals)
				result.Locals.Add(Import(l));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="GenericInstMethodSig"/>
		/// </summary>
		/// <param name="sig">The sig</param>
		/// <returns>The imported sig or <c>null</c> if input is invalid</returns>
		public GenericInstMethodSig Import(GenericInstMethodSig sig) {
			if (sig is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			var result = new GenericInstMethodSig(sig.GetCallingConvention(), (uint)sig.GenericArguments.Count);
			foreach (var l in sig.GenericArguments)
				result.GenericArguments.Add(Import(l));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="IField"/>
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
		public IField Import(IField field) {
			if (field is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			IField result;
			MemberRef mr;
			FieldDef fd;

			if ((fd = field as FieldDef) is not null)
				result = Import(fd);
			else if ((mr = field as MemberRef) is not null)
				result = Import(mr);
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="IMethod"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public IMethod Import(IMethod method) {
			if (method is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			IMethod result;
			MethodDef md;
			MethodSpec ms;
			MemberRef mr;

			if ((md = method as MethodDef) is not null)
				result = Import(md);
			else if ((ms = method as MethodSpec) is not null)
				result = Import(ms);
			else if ((mr = method as MemberRef) is not null)
				result = Import(mr);
			else
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="FieldDef"/> as an <see cref="IField"/>
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
		public IField Import(FieldDef field) {
			if (field is null)
				return null;
			if (TryToUseFieldDefs && field.Module == module)
				return field;
			if (!recursionCounter.Increment())
				return null;
			var mapped = mapper?.Map(field);
			if (mapped is not null) {
				recursionCounter.Decrement();
				return mapped;
			}

			MemberRef result = module.UpdateRowId(new MemberRefUser(module, field.Name));
			result.Signature = Import(field.Signature);
			result.Class = ImportParent(field.DeclaringType);

			recursionCounter.Decrement();
			return result;
		}

		IMemberRefParent ImportParent(TypeDef type) {
			if (type is null)
				return null;
			if (type.IsGlobalModuleType)
				return module.UpdateRowId(new ModuleRefUser(module, type.Module?.Name));
			return Import(type);
		}

		/// <summary>
		/// Imports a <see cref="MethodDef"/> as an <see cref="IMethod"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public IMethod Import(MethodDef method) {
			if (method is null)
				return null;
			if (TryToUseMethodDefs && method.Module == module)
				return method;
			if (!recursionCounter.Increment())
				return null;
			var mapped = mapper?.Map(method);
			if (mapped is not null) {
				recursionCounter.Decrement();
				return mapped;
			}

			MemberRef result = module.UpdateRowId(new MemberRefUser(module, method.Name));
			result.Signature = Import(method.Signature);
			result.Class = ImportParent(method.DeclaringType);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="MethodSpec"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public MethodSpec Import(MethodSpec method) {
			if (method is null)
				return null;
			if (!recursionCounter.Increment())
				return null;

			MethodSpec result = module.UpdateRowId(new MethodSpecUser((IMethodDefOrRef)Import(method.Method)));
			result.Instantiation = Import(method.Instantiation);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Imports a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="memberRef">The member ref</param>
		/// <returns>The imported member ref or <c>null</c> if <paramref name="memberRef"/> is invalid</returns>
		public MemberRef Import(MemberRef memberRef) {
			if (memberRef is null)
				return null;
			if (!recursionCounter.Increment())
				return null;
			var mapped = mapper?.Map(memberRef);
			if (mapped is not null) {
				recursionCounter.Decrement();
				return mapped;
			}

			MemberRef result = module.UpdateRowId(new MemberRefUser(module, memberRef.Name));
			result.Signature = Import(memberRef.Signature);
			result.Class = Import(memberRef.Class);
			if (result.Class is null)	// Will be null if memberRef.Class is null or a MethodDef
				result = null;

			recursionCounter.Decrement();
			return result;
		}

		IMemberRefParent Import(IMemberRefParent parent) {
			if (parent is ITypeDefOrRef tdr) {
				if (tdr is TypeDef td && td.IsGlobalModuleType)
					return module.UpdateRowId(new ModuleRefUser(module, td.Module?.Name));
				return Import(tdr);
			}

			if (parent is ModuleRef modRef)
				return module.UpdateRowId(new ModuleRefUser(module, modRef.Name));

			if (parent is MethodDef method) {
				var dt = method.DeclaringType;
				return dt is null || dt.Module != module ? null : method;
			}

			return null;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the InterfaceImpl table
	/// </summary>
	[DebuggerDisplay("{Interface}")]
	public abstract class InterfaceImpl : IHasCustomAttribute, IContainsGenericParameter, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.InterfaceImpl, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 5;

		/// <summary>
		/// From column InterfaceImpl.Interface
		/// </summary>
		public ITypeDefOrRef Interface {
			get => @interface;
			set => @interface = value;
		}
		/// <summary/>
		protected ITypeDefOrRef @interface;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 5;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		bool IContainsGenericParameter.ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);
	}

	/// <summary>
	/// An InterfaceImpl row created by the user and not present in the original .NET file
	/// </summary>
	public class InterfaceImplUser : InterfaceImpl {
		/// <summary>
		/// Default constructor
		/// </summary>
		public InterfaceImplUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="interface">The interface the type implements</param>
		public InterfaceImplUser(ITypeDefOrRef @interface) => this.@interface = @interface;
	}

	/// <summary>
	/// Created from a row in the InterfaceImpl table
	/// </summary>
	sealed class InterfaceImplMD : InterfaceImpl, IMDTokenProviderMD, IContainsGenericParameter2 {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		bool IContainsGenericParameter2.ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.InterfaceImpl, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>InterfaceImpl</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public InterfaceImplMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.InterfaceImplTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"InterfaceImpl rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			bool b = readerModule.TablesStream.TryReadInterfaceImplRow(origRid, out var row);
			Debug.Assert(b);
			@interface = readerModule.ResolveTypeDefOrRef(row.Interface, gpContext);
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Resolves types, methods, fields
	/// </summary>
	public interface IResolver : ITypeResolver, IMemberRefResolver {
	}

	/// <summary>
	/// Resolves types
	/// </summary>
	public interface ITypeResolver {
		/// <summary>
		/// Resolves a type
		/// </summary>
		/// <param name="typeRef">The type</param>
		/// <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		TypeDef Resolve(TypeRef typeRef, ModuleDef sourceModule);
	}

	/// <summary>
	/// Resolves fields and methods
	/// </summary>
	public interface IMemberRefResolver {
		/// <summary>
		/// Resolves a method or a field
		/// </summary>
		/// <param name="memberRef">A method/field reference</param>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance or <c>null</c>
		/// if it couldn't be resolved.</returns>
		IMemberForwarded Resolve(MemberRef memberRef);
	}

	public static partial class Extensions {
		/// <summary>
		/// Resolves a type
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type</param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public static TypeDef Resolve(this ITypeResolver self, TypeRef typeRef) => self.Resolve(typeRef, null);

		/// <summary>
		/// Resolves a type
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type</param>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public static TypeDef ResolveThrow(this ITypeResolver self, TypeRef typeRef) => self.ResolveThrow(typeRef, null);

		/// <summary>
		/// Resolves a type
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type</param>
		/// <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public static TypeDef ResolveThrow(this ITypeResolver self, TypeRef typeRef, ModuleDef sourceModule) {
			var type = self.Resolve(typeRef, sourceModule);
			if (type is not null)
				return type;
			throw new TypeResolveException($"Could not resolve type: {typeRef} ({typeRef?.DefinitionAssembly})");
		}

		/// <summary>
		/// Resolves a method or a field
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A method/field reference</param>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance</returns>
		/// <exception cref="MemberRefResolveException">If the method/field couldn't be resolved</exception>
		public static IMemberForwarded ResolveThrow(this IMemberRefResolver self, MemberRef memberRef) {
			var memberDef = self.Resolve(memberRef);
			if (memberDef is not null)
				return memberDef;
			throw new MemberRefResolveException($"Could not resolve method/field: {memberRef} ({memberRef?.GetDefinitionAssembly()})");
		}

		/// <summary>
		/// Resolves a field
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A field reference</param>
		/// <returns>A <see cref="FieldDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		public static FieldDef ResolveField(this IMemberRefResolver self, MemberRef memberRef) => self.Resolve(memberRef) as FieldDef;

		/// <summary>
		/// Resolves a field
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A field reference</param>
		/// <returns>A <see cref="FieldDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		/// <exception cref="MemberRefResolveException">If the field couldn't be resolved</exception>
		public static FieldDef ResolveFieldThrow(this IMemberRefResolver self, MemberRef memberRef) {
			if (self.Resolve(memberRef) is FieldDef field)
				return field;
			throw new MemberRefResolveException($"Could not resolve field: {memberRef} ({memberRef?.GetDefinitionAssembly()})");
		}

		/// <summary>
		/// Resolves a method
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A method reference</param>
		/// <returns>A <see cref="MethodDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		public static MethodDef ResolveMethod(this IMemberRefResolver self, MemberRef memberRef) => self.Resolve(memberRef) as MethodDef;

		/// <summary>
		/// Resolves a method
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="memberRef">A method reference</param>
		/// <returns>A <see cref="MethodDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		/// <exception cref="MemberRefResolveException">If the method couldn't be resolved</exception>
		public static MethodDef ResolveMethodThrow(this IMemberRefResolver self, MemberRef memberRef) {
			if (self.Resolve(memberRef) is MethodDef method)
				return method;
			throw new MemberRefResolveException($"Could not resolve method: {memberRef} ({memberRef?.GetDefinitionAssembly()})");
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Resolves tokens
	/// </summary>
	public interface ITokenResolver {
		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		IMDTokenProvider ResolveToken(uint token, GenericParamContext gpContext);
	}

	public static partial class Extensions {
		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="self">This</param>
		/// <param name="token">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public static IMDTokenProvider ResolveToken(this ITokenResolver self, uint token) => self.ResolveToken(token, new GenericParamContext());
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Interface to get the full name of a type
	/// </summary>
	public interface IType : IFullName, IOwnerModule, ICodedToken, IGenericParameterProvider, IContainsGenericParameter {
		/// <summary>
		/// <c>true</c> if it's a value type
		/// </summary>
		bool IsValueType { get; }

		/// <summary>
		/// Returns the name of this type
		/// </summary>
		string TypeName { get; }

		/// <summary>
		/// Returns the reflection name of this type
		/// </summary>
		string ReflectionName { get; }

		/// <summary>
		/// Returns the namespace of this type
		/// </summary>
		string Namespace { get; }

		/// <summary>
		/// Returns the reflection namespace of this type
		/// </summary>
		string ReflectionNamespace { get; }

		/// <summary>
		/// Returns the reflection name of this type. See also <see cref="AssemblyQualifiedName"/>.
		/// </summary>
		string ReflectionFullName { get; }

		/// <summary>
		/// Returns the reflection name of this type, and includes the assembly name where the
		/// type is located. It can be passed to <see cref="System.Type.GetType(string)"/> to
		/// load the type.
		/// </summary>
		string AssemblyQualifiedName { get; }

		/// <summary>
		/// Gets the assembly where this type is defined
		/// </summary>
		IAssembly DefinitionAssembly { get; }

		/// <summary>
		/// Gets the scope, which is different from <see cref="DefinitionAssembly"/> since it
		/// can differentiate between modules within the same assembly.
		/// </summary>
		IScope Scope { get; }

		/// <summary>
		/// Gets the type whose scope is returned by <see cref="Scope"/> and whose assembly
		/// is returned by <see cref="DefinitionAssembly"/>. This is always a
		/// <see cref="TypeDef"/>, <see cref="TypeRef"/> or <c>null</c>. It can also be a
		/// nested <see cref="TypeRef"/>.
		/// For example, if this type is a System.String&amp;, then this value is a System.String.
		/// If it's a generic instance type (eg. List&lt;int&gt;), then the generic type is
		/// returned (eg. List&lt;T&gt;). In other words, the first <see cref="TypeDef"/> or
		/// <see cref="TypeRef"/> that is found (without searching generic arguments) is returned.
		/// </summary>
		ITypeDefOrRef ScopeType { get; }

		/// <summary>
		/// <c>true</c> if it's an integer or a floating point type
		/// </summary>
		bool IsPrimitive { get; }
	}

	/// <summary>
	/// Implemented by types and calling convention signatures.
	/// </summary>
	public interface IContainsGenericParameter {
		/// <summary>
		/// <c>true</c> if this contains a <see cref="GenericVar"/> or a <see cref="GenericMVar"/>.
		/// </summary>
		bool ContainsGenericParameter { get; }
	}
	interface IContainsGenericParameter2 {
		bool ContainsGenericParameter { get; }
	}

	public static partial class Extensions {
		/// <summary>
		/// Returns <see cref="IType.ScopeType"/>, but if it's a nested <see cref="TypeRef"/>,
		/// return the non-nested <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">this</param>
		/// <returns>The scope type</returns>
		public static ITypeDefOrRef GetNonNestedTypeRefScope(this IType type) {
			if (type is null)
				return null;
			var scopeType = type.ScopeType;
			var tr = scopeType as TypeRef;
			if (tr is null)
				return scopeType;
			for (int i = 0; i < 100; i++) {
				var dt = tr.ResolutionScope as TypeRef;
				if (dt is null)
					return tr;
				tr = dt;
			}
			return tr;
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Finds <see cref="TypeDef"/>s
	/// </summary>
	public interface ITypeDefFinder {
		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		TypeDef Find(string fullName, bool isReflectionName);

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. <paramref name="typeRef"/>'s scope (i.e., module or
		/// assembly) is ignored when looking up the type.
		/// </summary>
		/// <param name="typeRef">The type ref</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		TypeDef Find(TypeRef typeRef);
	}

	public static partial class Extensions {
		/// <summary>
		/// Finds a <see cref="TypeDef"/>. Its scope (i.e., module or assembly) is ignored when
		/// looking up the type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type ref</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		/// <exception cref="TypeResolveException">If type couldn't be found</exception>
		public static TypeDef FindThrow(this ITypeDefFinder self, TypeRef typeRef) {
			var type = self.Find(typeRef);
			if (type is not null)
				return type;
			throw new TypeResolveException($"Could not find type: {typeRef}");
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns>An existing <see cref="TypeDef"/></returns>
		/// <exception cref="TypeResolveException">If type couldn't be found</exception>
		public static TypeDef FindThrow(this ITypeDefFinder self, string fullName, bool isReflectionName) {
			var type = self.Find(fullName, isReflectionName);
			if (type is not null)
				return type;
			throw new TypeResolveException($"Could not find type: {fullName}");
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>/</c></param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public static TypeDef FindNormal(this ITypeDefFinder self, string fullName) => self.Find(fullName, false);

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>/</c></param>
		/// <returns>An existing <see cref="TypeDef"/></returns>
		/// <exception cref="TypeResolveException">If type couldn't be found</exception>
		public static TypeDef FindNormalThrow(this ITypeDefFinder self, string fullName) {
			var type = self.Find(fullName, false);
			if (type is not null)
				return type;
			throw new TypeResolveException($"Could not find type: {fullName}");
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>+</c></param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public static TypeDef FindReflection(this ITypeDefFinder self, string fullName) => self.Find(fullName, true);

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>+</c></param>
		/// <returns>An existing <see cref="TypeDef"/></returns>
		/// <exception cref="TypeResolveException">If type couldn't be found</exception>
		public static TypeDef FindReflectionThrow(this ITypeDefFinder self, string fullName) {
			var type = self.Find(fullName, true);
			if (type is not null)
				return type;
			throw new TypeResolveException($"Could not find type: {fullName}");
		}

		/// <summary>
		/// Checks whether a <see cref="TypeDef"/> exists. <paramref name="typeRef"/>'s scope (i.e.,
		/// module or assembly) is ignored when looking up the type.
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="typeRef">The type ref</param>
		/// <returns><c>true</c> if the <see cref="TypeDef"/> exists, <c>false</c> otherwise</returns>
		public static bool TypeExists(this ITypeDefFinder self, TypeRef typeRef) => self.Find(typeRef) is not null;

		/// <summary>
		/// Checks whether a <see cref="TypeDef"/> exists
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns><c>true</c> if the <see cref="TypeDef"/> exists, <c>false</c> otherwise</returns>
		public static bool TypeExists(this ITypeDefFinder self, string fullName, bool isReflectionName) => self.Find(fullName, isReflectionName) is not null;

		/// <summary>
		/// Checks whether a <see cref="TypeDef"/> exists
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>/</c></param>
		/// <returns><c>true</c> if the <see cref="TypeDef"/> exists, <c>false</c> otherwise</returns>
		public static bool TypeExistsNormal(this ITypeDefFinder self, string fullName) => self.Find(fullName, false) is not null;

		/// <summary>
		/// Checks whether a <see cref="TypeDef"/> exists
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="fullName">Full name of the type (no assembly information). Nested types are separated by <c>+</c></param>
		/// <returns><c>true</c> if the <see cref="TypeDef"/> exists, <c>false</c> otherwise</returns>
		public static bool TypeExistsReflection(this ITypeDefFinder self, string fullName) => self.Find(fullName, true) is not null;
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Interface to access a local or a parameter
	/// </summary>
	public interface IVariable {
		/// <summary>
		/// Gets the variable type
		/// </summary>
		TypeSig Type { get; }

		/// <summary>
		/// Gets the 0-based position
		/// </summary>
		int Index { get; }

		/// <summary>
		/// Gets/sets the variable name
		/// </summary>
		string Name { get; set; }
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ManifestResource table
	/// </summary>
	[DebuggerDisplay("{Offset} {Name.String} {Implementation}")]
	public abstract class ManifestResource : IHasCustomAttribute, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.ManifestResource, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 18;

		/// <summary>
		/// From column ManifestResource.Offset
		/// </summary>
		public uint Offset {
			get => offset;
			set => offset = value;
		}
		/// <summary/>
		protected uint offset;

		/// <summary>
		/// From column ManifestResource.Flags
		/// </summary>
		public ManifestResourceAttributes Flags {
			get => (ManifestResourceAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column ManifestResource.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column ManifestResource.Implementation
		/// </summary>
		public IImplementation Implementation {
			get => implementation;
			set => implementation = value;
		}
		/// <summary/>
		protected IImplementation implementation;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 18;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(ManifestResourceAttributes andMask, ManifestResourceAttributes orMask) =>
			attributes = (attributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Gets/sets the visibility
		/// </summary>
		public ManifestResourceAttributes Visibility {
			get => (ManifestResourceAttributes)attributes & ManifestResourceAttributes.VisibilityMask;
			set => ModifyAttributes(~ManifestResourceAttributes.VisibilityMask, value & ManifestResourceAttributes.VisibilityMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="ManifestResourceAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic => ((ManifestResourceAttributes)attributes & ManifestResourceAttributes.VisibilityMask) == ManifestResourceAttributes.Public;

		/// <summary>
		/// <c>true</c> if <see cref="ManifestResourceAttributes.Private"/> is set
		/// </summary>
		public bool IsPrivate => ((ManifestResourceAttributes)attributes & ManifestResourceAttributes.VisibilityMask) == ManifestResourceAttributes.Private;
	}

	/// <summary>
	/// A ManifestResource row created by the user and not present in the original .NET file
	/// </summary>
	public class ManifestResourceUser : ManifestResource {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ManifestResourceUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="implementation">Implementation</param>
		public ManifestResourceUser(UTF8String name, IImplementation implementation)
			: this(name, implementation, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="implementation">Implementation</param>
		/// <param name="flags">Flags</param>
		public ManifestResourceUser(UTF8String name, IImplementation implementation, ManifestResourceAttributes flags)
			: this(name, implementation, flags, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="implementation">Implementation</param>
		/// <param name="flags">Flags</param>
		/// <param name="offset">Offset</param>
		public ManifestResourceUser(UTF8String name, IImplementation implementation, ManifestResourceAttributes flags, uint offset) {
			this.name = name;
			this.implementation = implementation;
			attributes = (int)flags;
			this.offset = offset;
		}
	}

	/// <summary>
	/// Created from a row in the ManifestResource table
	/// </summary>
	sealed class ManifestResourceMD : ManifestResource, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.ManifestResource, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ManifestResource</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ManifestResourceMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ManifestResourceTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"ManifestResource rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadManifestResourceRow(origRid, out var row);
			Debug.Assert(b);
			offset = row.Offset;
			attributes = (int)row.Flags;
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			implementation = readerModule.ResolveImplementation(row.Implementation);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// ManifestResource flags. See CorHdr.h/CorManifestResourceFlags
	/// </summary>
	[Flags]
	public enum ManifestResourceAttributes : uint {
		/// <summary/>
		VisibilityMask	= 0x0007,
		/// <summary>The Resource is exported from the Assembly.</summary>
		Public			= 0x0001,
		/// <summary>The Resource is private to the Assembly.</summary>
		Private			= 0x0002,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Reads <see cref="MarshalType"/>s
	/// </summary>
	public struct MarshalBlobReader {
		readonly ModuleDef module;
		DataReader reader;
		readonly GenericParamContext gpContext;

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from the <c>#Blob</c> heap
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="sig">Blob offset</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDefMD module, uint sig) => Read(module, module.BlobStream.CreateReader(sig), new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from the <c>#Blob</c> heap
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="sig">Blob offset</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDefMD module, uint sig, GenericParamContext gpContext) => Read(module, module.BlobStream.CreateReader(sig), gpContext);

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from <paramref name="data"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="data">Marshal data</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDef module, byte[] data) => Read(module, ByteArrayDataReaderFactory.CreateReader(data), new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from <paramref name="data"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="data">Marshal data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDef module, byte[] data, GenericParamContext gpContext) => Read(module, ByteArrayDataReaderFactory.CreateReader(data), gpContext);

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from <see cref="reader"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">A reader that will be owned by us</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDef module, DataReader reader) => Read(module, reader, new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from <see cref="reader"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">A reader that will be owned by us</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="MarshalType"/> instance</returns>
		public static MarshalType Read(ModuleDef module, DataReader reader, GenericParamContext gpContext) {
			var marshalReader = new MarshalBlobReader(module, ref reader, gpContext);
			return marshalReader.Read();
		}

		MarshalBlobReader(ModuleDef module, ref DataReader reader, GenericParamContext gpContext) {
			this.module = module;
			this.reader = reader;
			this.gpContext = gpContext;
		}

		MarshalType Read() {
			MarshalType returnValue;
			try {
				var nativeType = (NativeType)reader.ReadByte();
				NativeType nt;
				int size;
				switch (nativeType) {
				case NativeType.FixedSysString:
					size = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					returnValue = new FixedSysStringMarshalType(size);
					break;

				case NativeType.SafeArray:
					var vt = CanRead() ? (VariantType)reader.ReadCompressedUInt32() : VariantType.NotInitialized;
					var udtName = CanRead() ? ReadUTF8String() : null;
					var udtRef = udtName is null ? null : TypeNameParser.ParseReflection(module, UTF8String.ToSystemStringOrEmpty(udtName), null, gpContext);
					returnValue = new SafeArrayMarshalType(vt, udtRef);
					break;

				case NativeType.FixedArray:
					size = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					nt = CanRead() ? (NativeType)reader.ReadCompressedUInt32() : NativeType.NotInitialized;
					returnValue = new FixedArrayMarshalType(size, nt);
					break;

				case NativeType.Array:
					nt = CanRead() ? (NativeType)reader.ReadCompressedUInt32() : NativeType.NotInitialized;
					int paramNum = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					size = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					int flags = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					returnValue = new ArrayMarshalType(nt, paramNum, size, flags);
					break;

				case NativeType.CustomMarshaler:
					var guid = ReadUTF8String();
					var nativeTypeName = ReadUTF8String();
					var custMarshalerName = ReadUTF8String();
					var cmRef = custMarshalerName.DataLength == 0 ? null : TypeNameParser.ParseReflection(module, UTF8String.ToSystemStringOrEmpty(custMarshalerName), new CAAssemblyRefFinder(module), gpContext);
					var cookie = ReadUTF8String();
					returnValue = new CustomMarshalType(guid, nativeTypeName, cmRef, cookie);
					break;

				case NativeType.IUnknown:
				case NativeType.IDispatch:
				case NativeType.IntF:
					int iidParamIndex = CanRead() ? (int)reader.ReadCompressedUInt32() : -1;
					return new InterfaceMarshalType(nativeType, iidParamIndex);

				default:
					returnValue = new MarshalType(nativeType);
					break;
				}
			}
			catch {
				returnValue = new RawMarshalType(reader.ToArray());
			}

			return returnValue;
		}

		bool CanRead() => reader.Position < reader.Length;

		UTF8String ReadUTF8String() {
			uint len = reader.ReadCompressedUInt32();
			return len == 0 ? UTF8String.Empty : new UTF8String(reader.ReadBytes((int)len));
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Base class of all marshal types
	/// </summary>
	public class MarshalType {
		/// <summary>
		/// The native type
		/// </summary>
		protected readonly NativeType nativeType;

		/// <summary>
		/// Gets the <see cref="dnlib.DotNet.NativeType"/>
		/// </summary>
		public NativeType NativeType => nativeType;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nativeType">Native type</param>
		public MarshalType(NativeType nativeType) => this.nativeType = nativeType;

		/// <inheritdoc/>
		public override string ToString() => nativeType.ToString();
	}

	/// <summary>
	/// Contains the raw marshal blob data
	/// </summary>
	public sealed class RawMarshalType : MarshalType {
		byte[] data;

		/// <summary>
		/// Gets/sets the raw data
		/// </summary>
		public byte[] Data {
			get => data;
			set => data = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Raw data</param>
		public RawMarshalType(byte[] data)
			: base(NativeType.RawBlob) => this.data = data;
	}

	/// <summary>
	/// A <see cref="NativeType.FixedSysString"/> marshal type
	/// </summary>
	public sealed class FixedSysStringMarshalType : MarshalType {
		int size;

		/// <summary>
		/// Gets/sets the size
		/// </summary>
		public int Size {
			get => size;
			set => size = value;
		}

		/// <summary>
		/// <c>true</c> if <see cref="Size"/> is valid
		/// </summary>
		public bool IsSizeValid => size >= 0;

		/// <summary>
		/// Default constructor
		/// </summary>
		public FixedSysStringMarshalType()
			: this(-1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="size">Size</param>
		public FixedSysStringMarshalType(int size)
			: base(NativeType.FixedSysString) => this.size = size;

		/// <inheritdoc/>
		public override string ToString() {
			if (IsSizeValid)
				return $"{nativeType} ({size})";
			return $"{nativeType} (<no size>)";
		}
	}

	/// <summary>
	/// A <see cref="NativeType.SafeArray"/> marshal type
	/// </summary>
	public sealed class SafeArrayMarshalType : MarshalType {
		VariantType vt;
		ITypeDefOrRef userDefinedSubType;

		/// <summary>
		/// Gets/sets the variant type
		/// </summary>
		public VariantType VariantType {
			get => vt;
			set => vt = value;
		}

		/// <summary>
		/// Gets/sets the user-defined sub type (it's usually <c>null</c>)
		/// </summary>
		public ITypeDefOrRef UserDefinedSubType {
			get => userDefinedSubType;
			set => userDefinedSubType = value;
		}

		/// <summary>
		/// <c>true</c> if <see cref="VariantType"/> is valid
		/// </summary>
		public bool IsVariantTypeValid => vt != VariantType.NotInitialized;

		/// <summary>
		/// <c>true</c> if <see cref="UserDefinedSubType"/> is valid
		/// </summary>
		public bool IsUserDefinedSubTypeValid => userDefinedSubType is not null;

		/// <summary>
		/// Default constructor
		/// </summary>
		public SafeArrayMarshalType()
			: this(VariantType.NotInitialized, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="vt">Variant type</param>
		public SafeArrayMarshalType(VariantType vt)
			: this(vt, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="userDefinedSubType">User-defined sub type</param>
		public SafeArrayMarshalType(ITypeDefOrRef userDefinedSubType)
			: this(VariantType.NotInitialized, userDefinedSubType) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="vt">Variant type</param>
		/// <param name="userDefinedSubType">User-defined sub type</param>
		public SafeArrayMarshalType(VariantType vt, ITypeDefOrRef userDefinedSubType)
			: base(NativeType.SafeArray) {
			this.vt = vt;
			this.userDefinedSubType = userDefinedSubType;
		}

		/// <inheritdoc/>
		public override string ToString() {
			var udt = userDefinedSubType;
			if (udt is not null)
				return $"{nativeType} ({vt}, {udt})";
			return $"{nativeType} ({vt})";
		}
	}

	/// <summary>
	/// A <see cref="NativeType.FixedArray"/> marshal type
	/// </summary>
	public sealed class FixedArrayMarshalType : MarshalType {
		int size;
		NativeType elementType;

		/// <summary>
		/// Gets/sets the element type
		/// </summary>
		public NativeType ElementType {
			get => elementType;
			set => elementType = value;
		}

		/// <summary>
		/// Gets/sets the size
		/// </summary>
		public int Size {
			get => size;
			set => size = value;
		}

		/// <summary>
		/// <c>true</c> if <see cref="ElementType"/> is valid
		/// </summary>
		public bool IsElementTypeValid => elementType != NativeType.NotInitialized;

		/// <summary>
		/// <c>true</c> if <see cref="Size"/> is valid
		/// </summary>
		public bool IsSizeValid => size >= 0;

		/// <summary>
		/// Default constructor
		/// </summary>
		public FixedArrayMarshalType()
			: this(0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="size">Size</param>
		public FixedArrayMarshalType(int size)
			: this(size, NativeType.NotInitialized) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="size">Size</param>
		/// <param name="elementType">Element type</param>
		public FixedArrayMarshalType(int size, NativeType elementType)
			: base(NativeType.FixedArray) {
			this.size = size;
			this.elementType = elementType;
		}

		/// <inheritdoc/>
		public override string ToString() => $"{nativeType} ({size}, {elementType})";
	}

	/// <summary>
	/// A <see cref="NativeType.Array"/> marshal type
	/// </summary>
	public sealed class ArrayMarshalType : MarshalType {
		NativeType elementType;
		int paramNum;
		int numElems;
		int flags;

		/// <summary>
		/// Gets/sets the element type
		/// </summary>
		public NativeType ElementType {
			get => elementType;
			set => elementType = value;
		}

		/// <summary>
		/// Gets/sets the parameter number
		/// </summary>
		public int ParamNumber {
			get => paramNum;
			set => paramNum = value;
		}

		/// <summary>
		/// Gets/sets the size of the array
		/// </summary>
		public int Size {
			get => numElems;
			set => numElems = value;
		}

		/// <summary>
		/// Gets/sets the flags
		/// </summary>
		public int Flags {
			get => flags;
			set => flags = value;
		}

		/// <summary>
		/// <c>true</c> if <see cref="ElementType"/> is valid
		/// </summary>
		public bool IsElementTypeValid => elementType != NativeType.NotInitialized;

		/// <summary>
		/// <c>true</c> if <see cref="ParamNumber"/> is valid
		/// </summary>
		public bool IsParamNumberValid => paramNum >= 0;

		/// <summary>
		/// <c>true</c> if <see cref="Size"/> is valid
		/// </summary>
		public bool IsSizeValid => numElems >= 0;

		/// <summary>
		/// <c>true</c> if <see cref="Flags"/> is valid
		/// </summary>
		public bool IsFlagsValid => flags >= 0;

		const int ntaSizeParamIndexSpecified = 1;

		/// <summary>
		/// <c>true</c> if <c>ntaSizeParamIndexSpecified</c> bit is set, <c>false</c> if it's not
		/// set or if <see cref="Flags"/> is invalid.
		/// </summary>
		public bool IsSizeParamIndexSpecified => IsFlagsValid && (flags & ntaSizeParamIndexSpecified) != 0;

		/// <summary>
		/// <c>true</c> if <c>ntaSizeParamIndexSpecified</c> bit is not set, <c>false</c> if it's
		/// set or if <see cref="Flags"/> is invalid.
		/// </summary>
		public bool IsSizeParamIndexNotSpecified => IsFlagsValid && (flags & ntaSizeParamIndexSpecified) == 0;

		/// <summary>
		/// Default constructor
		/// </summary>
		public ArrayMarshalType()
			: this(NativeType.NotInitialized, -1, -1, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="elementType">Element type</param>
		public ArrayMarshalType(NativeType elementType)
			: this(elementType, -1, -1, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="elementType">Element type</param>
		/// <param name="paramNum">Parameter number</param>
		public ArrayMarshalType(NativeType elementType, int paramNum)
			: this(elementType, paramNum, -1, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="elementType">Element type</param>
		/// <param name="paramNum">Parameter number</param>
		/// <param name="numElems">Number of elements</param>
		public ArrayMarshalType(NativeType elementType, int paramNum, int numElems)
			: this(elementType, paramNum, numElems, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="elementType">Element type</param>
		/// <param name="paramNum">Parameter number</param>
		/// <param name="numElems">Number of elements</param>
		/// <param name="flags">Flags</param>
		public ArrayMarshalType(NativeType elementType, int paramNum, int numElems, int flags)
			: base(NativeType.Array) {
			this.elementType = elementType;
			this.paramNum = paramNum;
			this.numElems = numElems;
			this.flags = flags;
		}

		/// <inheritdoc/>
		public override string ToString() => $"{nativeType} ({elementType}, {paramNum}, {numElems}, {flags})";
	}

	/// <summary>
	/// A <see cref="NativeType.CustomMarshaler"/> marshal type
	/// </summary>
	public sealed class CustomMarshalType : MarshalType {
		UTF8String guid;
		UTF8String nativeTypeName;
		ITypeDefOrRef custMarshaler;
		UTF8String cookie;

		/// <summary>
		/// Gets/sets the <c>GUID</c> string
		/// </summary>
		public UTF8String Guid {
			get => guid;
			set => guid = value;
		}

		/// <summary>
		/// Gets/sets the native type name string
		/// </summary>
		public UTF8String NativeTypeName {
			get => nativeTypeName;
			set => nativeTypeName = value;
		}

		/// <summary>
		/// Gets/sets the custom marshaler
		/// </summary>
		public ITypeDefOrRef CustomMarshaler {
			get => custMarshaler;
			set => custMarshaler = value;
		}

		/// <summary>
		/// Gets/sets the cookie string
		/// </summary>
		public UTF8String Cookie {
			get => cookie;
			set => cookie = value;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public CustomMarshalType()
			: this(null, null, null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">GUID string</param>
		public CustomMarshalType(UTF8String guid)
			: this(guid, null, null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">GUID string</param>
		/// <param name="nativeTypeName">Native type name string</param>
		public CustomMarshalType(UTF8String guid, UTF8String nativeTypeName)
			: this(guid, nativeTypeName, null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">GUID string</param>
		/// <param name="nativeTypeName">Native type name string</param>
		/// <param name="custMarshaler">Custom marshaler name string</param>
		public CustomMarshalType(UTF8String guid, UTF8String nativeTypeName, ITypeDefOrRef custMarshaler)
			: this(guid, nativeTypeName, custMarshaler, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">GUID string</param>
		/// <param name="nativeTypeName">Native type name string</param>
		/// <param name="custMarshaler">Custom marshaler name string</param>
		/// <param name="cookie">Cookie string</param>
		public CustomMarshalType(UTF8String guid, UTF8String nativeTypeName, ITypeDefOrRef custMarshaler, UTF8String cookie)
			: base(NativeType.CustomMarshaler) {
			this.guid = guid;
			this.nativeTypeName = nativeTypeName;
			this.custMarshaler = custMarshaler;
			this.cookie = cookie;
		}

		/// <inheritdoc/>
		public override string ToString() => $"{nativeType} ({guid}, {nativeTypeName}, {custMarshaler}, {cookie})";
	}

	/// <summary>
	/// A <see cref="NativeType.IUnknown"/>, <see cref="NativeType.IDispatch"/> or a
	/// <see cref="NativeType.IntF"/> marshal type
	/// </summary>
	public sealed class InterfaceMarshalType : MarshalType {
		int iidParamIndex;

		/// <summary>
		/// Gets/sets the IID parameter index
		/// </summary>
		public int IidParamIndex {
			get => iidParamIndex;
			set => iidParamIndex = value;
		}

		/// <summary>
		/// <c>true</c> if <see cref="IidParamIndex"/> is valid
		/// </summary>
		public bool IsIidParamIndexValid => iidParamIndex >= 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nativeType">Native type</param>
		public InterfaceMarshalType(NativeType nativeType)
			: this(nativeType, -1) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nativeType">Native type</param>
		/// <param name="iidParamIndex">IID parameter index</param>
		public InterfaceMarshalType(NativeType nativeType, int iidParamIndex)
			: base(nativeType) {
			if (nativeType != NativeType.IUnknown &&
				nativeType != NativeType.IDispatch &&
				nativeType != NativeType.IntF)
				throw new ArgumentException("Invalid nativeType");
			this.iidParamIndex = iidParamIndex;
		}

		/// <inheritdoc/>
		public override string ToString() => $"{nativeType} ({iidParamIndex})";
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Metadata token
	/// </summary>
	[DebuggerDisplay("{Table} {Rid}")]
	public readonly struct MDToken : IEquatable<MDToken>, IComparable<MDToken> {
		/// <summary>
		/// Mask to get the rid from a raw metadata token
		/// </summary>
		public const uint RID_MASK = 0x00FFFFFF;

		/// <summary>
		/// Max rid value
		/// </summary>
		public const uint RID_MAX = RID_MASK;

		/// <summary>
		/// Number of bits to right shift a raw metadata token to get the table index
		/// </summary>
		public const int TABLE_SHIFT = 24;

		readonly uint token;

		/// <summary>
		/// Returns the table type
		/// </summary>
		public Table Table => ToTable(token);

		/// <summary>
		/// Returns the row id
		/// </summary>
		public uint Rid => ToRID(token);

		/// <summary>
		/// Returns the raw token
		/// </summary>
		public uint Raw => token;

		/// <summary>
		/// Returns <c>true</c> if it's a <c>null</c> token
		/// </summary>
		public bool IsNull => Rid == 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="token">Raw token</param>
		public MDToken(uint token) => this.token = token;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="token">Raw token</param>
		public MDToken(int token)
			: this((uint)token) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">The table type</param>
		/// <param name="rid">Row id</param>
		public MDToken(Table table, uint rid)
			: this(((uint)table << TABLE_SHIFT) | rid) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">The table type</param>
		/// <param name="rid">Row id</param>
		public MDToken(Table table, int rid)
			: this(((uint)table << TABLE_SHIFT) | (uint)rid) {
		}

		/// <summary>
		/// Returns the <c>rid</c> (row ID)
		/// </summary>
		/// <param name="token">A raw metadata token</param>
		/// <returns>A <c>rid</c></returns>
		public static uint ToRID(uint token) => token & RID_MASK;

		/// <summary>
		/// Returns the <c>rid</c> (row ID)
		/// </summary>
		/// <param name="token">A raw metadata token</param>
		/// <returns>A <c>rid</c></returns>
		public static uint ToRID(int token) => ToRID((uint)token);

		/// <summary>
		/// Returns the <c>table</c>
		/// </summary>
		/// <param name="token">A raw metadata token</param>
		/// <returns>A metadata table index</returns>
		public static Table ToTable(uint token) => (Table)(token >> TABLE_SHIFT);

		/// <summary>
		/// Returns the <c>table</c>
		/// </summary>
		/// <param name="token">A raw metadata token</param>
		/// <returns>A metadata table index</returns>
		public static Table ToTable(int token) => ToTable((uint)token);

		/// <summary>
		/// Gets the token as a raw 32-bit signed integer
		/// </summary>
		public int ToInt32() => (int)token;

		/// <summary>
		/// Gets the token as a raw 32-bit unsigned integer
		/// </summary>
		public uint ToUInt32() => token;

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(MDToken left, MDToken right) => left.CompareTo(right) == 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(MDToken left, MDToken right) => left.CompareTo(right) != 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator <(MDToken left, MDToken right) => left.CompareTo(right) < 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator >(MDToken left, MDToken right) => left.CompareTo(right) > 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator <=(MDToken left, MDToken right) => left.CompareTo(right) <= 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator >=(MDToken left, MDToken right) => left.CompareTo(right) >= 0;

		/// <inheritdoc/>
		public int CompareTo(MDToken other) => token.CompareTo(other.token);

		/// <inheritdoc/>
		public bool Equals(MDToken other) => CompareTo(other) == 0;

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			if (!(obj is MDToken))
				return false;
			return Equals((MDToken)obj);
		}

		/// <inheritdoc/>
		public override int GetHashCode() => (int)token;

		/// <inheritdoc/>
		public override string ToString() => token.ToString("X8");
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Finds types, fields, methods, etc in a module. If nothing has been added to the module, it's
	/// faster to call ResolveMethodDef(), ResolveTypeRef() etc.
	/// </summary>
	public class MemberFinder {
		enum ObjectType {
			Unknown,
			EventDef,
			FieldDef,
			GenericParam,
			MemberRef,
			MethodDef,
			MethodSpec,
			PropertyDef,
			TypeDef,
			TypeRef,
			TypeSig,
			TypeSpec,
			ExportedType,
		}

		/// <summary>
		/// All found <see cref="CustomAttribute"/>s
		/// </summary>
		public readonly Dictionary<CustomAttribute, bool> CustomAttributes = new Dictionary<CustomAttribute, bool>();

		/// <summary>
		/// All found <see cref="EventDef"/>s
		/// </summary>
		public readonly Dictionary<EventDef, bool> EventDefs = new Dictionary<EventDef, bool>();

		/// <summary>
		/// All found <see cref="FieldDef"/>s
		/// </summary>
		public readonly Dictionary<FieldDef, bool> FieldDefs = new Dictionary<FieldDef, bool>();

		/// <summary>
		/// All found <see cref="GenericParam"/>s
		/// </summary>
		public readonly Dictionary<GenericParam, bool> GenericParams = new Dictionary<GenericParam, bool>();

		/// <summary>
		/// All found <see cref="MemberRef"/>s
		/// </summary>
		public readonly Dictionary<MemberRef, bool> MemberRefs = new Dictionary<MemberRef, bool>();

		/// <summary>
		/// All found <see cref="MethodDef"/>s
		/// </summary>
		public readonly Dictionary<MethodDef, bool> MethodDefs = new Dictionary<MethodDef, bool>();

		/// <summary>
		/// All found <see cref="MethodSpec"/>s
		/// </summary>
		public readonly Dictionary<MethodSpec, bool> MethodSpecs = new Dictionary<MethodSpec, bool>();

		/// <summary>
		/// All found <see cref="PropertyDef"/>s
		/// </summary>
		public readonly Dictionary<PropertyDef, bool> PropertyDefs = new Dictionary<PropertyDef, bool>();

		/// <summary>
		/// All found <see cref="TypeDef"/>s
		/// </summary>
		public readonly Dictionary<TypeDef, bool> TypeDefs = new Dictionary<TypeDef, bool>();

		/// <summary>
		/// All found <see cref="TypeRef"/>s
		/// </summary>
		public readonly Dictionary<TypeRef, bool> TypeRefs = new Dictionary<TypeRef, bool>();

		/// <summary>
		/// All found <see cref="TypeSig"/>s
		/// </summary>
		public readonly Dictionary<TypeSig, bool> TypeSigs = new Dictionary<TypeSig, bool>();

		/// <summary>
		/// All found <see cref="TypeSpec"/>s
		/// </summary>
		public readonly Dictionary<TypeSpec, bool> TypeSpecs = new Dictionary<TypeSpec, bool>();

		/// <summary>
		/// All found <see cref="ExportedType"/>s
		/// </summary>
		public readonly Dictionary<ExportedType, bool> ExportedTypes = new Dictionary<ExportedType, bool>();

		Stack<object> objectStack;
		ModuleDef validModule;

		/// <summary>
		/// Finds all types, fields, etc
		/// </summary>
		/// <param name="module">The module to scan</param>
		/// <returns>Itself</returns>
		public MemberFinder FindAll(ModuleDef module) {
			validModule = module;

			// This needs to be big. About 2048 entries should be enough for most though...
			objectStack = new Stack<object>(0x1000);

			Add(module);
			ProcessAll();

			objectStack = null;

			return this;
		}

		void Push(object mr) {
			if (mr is null)
				return;
			objectStack.Push(mr);
		}

		void ProcessAll() {
			while (objectStack.Count > 0) {
				var o = objectStack.Pop();
				switch (GetObjectType(o)) {
				case ObjectType.Unknown: break;
				case ObjectType.EventDef:		Add((EventDef)o); break;
				case ObjectType.FieldDef:		Add((FieldDef)o); break;
				case ObjectType.GenericParam:	Add((GenericParam)o); break;
				case ObjectType.MemberRef:		Add((MemberRef)o); break;
				case ObjectType.MethodDef:		Add((MethodDef)o); break;
				case ObjectType.MethodSpec:		Add((MethodSpec)o); break;
				case ObjectType.PropertyDef:	Add((PropertyDef)o); break;
				case ObjectType.TypeDef:		Add((TypeDef)o); break;
				case ObjectType.TypeRef:		Add((TypeRef)o); break;
				case ObjectType.TypeSig:		Add((TypeSig)o); break;
				case ObjectType.TypeSpec:		Add((TypeSpec)o); break;
				case ObjectType.ExportedType:	Add((ExportedType)o); break;
				default: throw new InvalidOperationException($"Unknown type: {o.GetType()}");
				}
			}
		}

		readonly Dictionary<Type, ObjectType> toObjectType = new Dictionary<Type, ObjectType>();
		ObjectType GetObjectType(object o) {
			if (o is null)
				return ObjectType.Unknown;
			var type = o.GetType();
			if (toObjectType.TryGetValue(type, out var mrType))
				return mrType;
			mrType = GetObjectType2(o);
			toObjectType[type] = mrType;
			return mrType;
		}

		static ObjectType GetObjectType2(object o) {
			if (o is EventDef)		return ObjectType.EventDef;
			if (o is FieldDef)		return ObjectType.FieldDef;
			if (o is GenericParam)	return ObjectType.GenericParam;
			if (o is MemberRef)		return ObjectType.MemberRef;
			if (o is MethodDef)		return ObjectType.MethodDef;
			if (o is MethodSpec)	return ObjectType.MethodSpec;
			if (o is PropertyDef)	return ObjectType.PropertyDef;
			if (o is TypeDef)		return ObjectType.TypeDef;
			if (o is TypeRef)		return ObjectType.TypeRef;
			if (o is TypeSig)		return ObjectType.TypeSig;
			if (o is TypeSpec)		return ObjectType.TypeSpec;
			if (o is ExportedType)	return ObjectType.ExportedType;
			return ObjectType.Unknown;
		}

		void Add(ModuleDef mod) {
			Push(mod.ManagedEntryPoint);
			Add(mod.CustomAttributes);
			Add(mod.Types);
			Add(mod.ExportedTypes);
			if (mod.IsManifestModule)
				Add(mod.Assembly);
			Add(mod.VTableFixups);
			Add(mod.Resources);
		}

		void Add(VTableFixups fixups) {
			if (fixups is null)
				return;
			foreach (var fixup in fixups) {
				foreach (var method in fixup)
					Push(method);
			}
		}

		void Add(ResourceCollection resources) {
			foreach (var resource in resources) {
				Add(resource.CustomAttributes);
			}
		}

		void Add(AssemblyDef asm) {
			if (asm is null)
				return;
			Add(asm.DeclSecurities);
			Add(asm.CustomAttributes);
		}

		void Add(CallingConventionSig sig) {
			if (sig is null)
				return;

			if (sig is FieldSig fs) {
				Add(fs);
				return;
			}

			if (sig is MethodBaseSig mbs) {
				Add(mbs);
				return;
			}

			if (sig is LocalSig ls) {
				Add(ls);
				return;
			}

			if (sig is GenericInstMethodSig gims) {
				Add(gims);
				return;
			}
		}

		void Add(FieldSig sig) {
			if (sig is null)
				return;
			Add(sig.Type);
		}

		void Add(MethodBaseSig sig) {
			if (sig is null)
				return;
			Add(sig.RetType);
			Add(sig.Params);
			Add(sig.ParamsAfterSentinel);
		}

		void Add(LocalSig sig) {
			if (sig is null)
				return;
			Add(sig.Locals);
		}

		void Add(GenericInstMethodSig sig) {
			if (sig is null)
				return;
			Add(sig.GenericArguments);
		}

		void Add(IEnumerable<CustomAttribute> cas) {
			if (cas is null)
				return;
			foreach (var ca in cas)
				Add(ca);
		}

		void Add(CustomAttribute ca) {
			if (ca is null || CustomAttributes.ContainsKey(ca))
				return;
			CustomAttributes[ca] = true;
			Push(ca.Constructor);
			Add(ca.ConstructorArguments);
			Add(ca.NamedArguments);
		}

		void Add(IEnumerable<CAArgument> args) {
			if (args is null)
				return;
			foreach (var arg in args)
				Add(arg);
		}

		void Add(CAArgument arg) {
			// It's a struct so can't be null
			Add(arg.Type);
			if (arg.Value is TypeSig typeSig)
				Add(typeSig);
			else if (arg.Value is IList<CAArgument> args)
				Add(args);
		}

		void Add(IEnumerable<CANamedArgument> args) {
			if (args is null)
				return;
			foreach (var arg in args)
				Add(arg);
		}

		void Add(CANamedArgument arg) {
			if (arg is null)
				return;
			Add(arg.Type);
			Add(arg.Argument);
		}

		void Add(IEnumerable<DeclSecurity> decls) {
			if (decls is null)
				return;
			foreach (var decl in decls)
				Add(decl);
		}

		void Add(DeclSecurity decl) {
			if (decl is null)
				return;
			Add(decl.SecurityAttributes);
			Add(decl.CustomAttributes);
		}

		void Add(IEnumerable<SecurityAttribute> secAttrs) {
			if (secAttrs is null)
				return;
			foreach (var secAttr in secAttrs)
				Add(secAttr);
		}

		void Add(SecurityAttribute secAttr) {
			if (secAttr is null)
				return;
			Add(secAttr.AttributeType);
			Add(secAttr.NamedArguments);
		}

		void Add(ITypeDefOrRef tdr) {
			if (tdr is TypeDef td) {
				Add(td);
				return;
			}

			if (tdr is TypeRef tr) {
				Add(tr);
				return;
			}

			if (tdr is TypeSpec ts) {
				Add(ts);
				return;
			}
		}

		void Add(IEnumerable<EventDef> eds) {
			if (eds is null)
				return;
			foreach (var ed in eds)
				Add(ed);
		}

		void Add(EventDef ed) {
			if (ed is null || EventDefs.ContainsKey(ed))
				return;
			if (ed.DeclaringType is not null && ed.DeclaringType.Module != validModule)
				return;
			EventDefs[ed] = true;
			Push(ed.EventType);
			Add(ed.CustomAttributes);
			Add(ed.AddMethod);
			Add(ed.InvokeMethod);
			Add(ed.RemoveMethod);
			Add(ed.OtherMethods);
			Add(ed.DeclaringType);
		}

		void Add(IEnumerable<FieldDef> fds) {
			if (fds is null)
				return;
			foreach (var fd in fds)
				Add(fd);
		}

		void Add(FieldDef fd) {
			if (fd is null || FieldDefs.ContainsKey(fd))
				return;
			if (fd.DeclaringType is not null && fd.DeclaringType.Module != validModule)
				return;
			FieldDefs[fd] = true;
			Add(fd.CustomAttributes);
			Add(fd.Signature);
			Add(fd.DeclaringType);
			Add(fd.MarshalType);
		}

		void Add(IEnumerable<GenericParam> gps) {
			if (gps is null)
				return;
			foreach (var gp in gps)
				Add(gp);
		}

		void Add(GenericParam gp) {
			if (gp is null || GenericParams.ContainsKey(gp))
				return;
			GenericParams[gp] = true;
			Push(gp.Owner);
			Push(gp.Kind);
			Add(gp.GenericParamConstraints);
			Add(gp.CustomAttributes);
		}

		void Add(IEnumerable<GenericParamConstraint> gpcs) {
			if (gpcs is null)
				return;
			foreach (var gpc in gpcs)
				Add(gpc);
		}

		void Add(GenericParamConstraint gpc) {
			if (gpc is null)
				return;
			Add(gpc.Owner);
			Push(gpc.Constraint);
			Add(gpc.CustomAttributes);
		}

		void Add(MemberRef mr) {
			if (mr is null || MemberRefs.ContainsKey(mr))
				return;
			if (mr.Module != validModule)
				return;
			MemberRefs[mr] = true;
			Push(mr.Class);
			Add(mr.Signature);
			Add(mr.CustomAttributes);
		}

		void Add(IEnumerable<MethodDef> methods) {
			if (methods is null)
				return;
			foreach (var m in methods)
				Add(m);
		}

		void Add(MethodDef md) {
			if (md is null || MethodDefs.ContainsKey(md))
				return;
			if (md.DeclaringType is not null && md.DeclaringType.Module != validModule)
				return;
			MethodDefs[md] = true;
			Add(md.Signature);
			Add(md.ParamDefs);
			Add(md.GenericParameters);
			Add(md.DeclSecurities);
			Add(md.MethodBody);
			Add(md.CustomAttributes);
			Add(md.Overrides);
			Add(md.DeclaringType);
		}

		void Add(Emit.MethodBody mb) {
			if (mb is CilBody cb)
				Add(cb);
		}

		void Add(CilBody cb) {
			if (cb is null)
				return;
			Add(cb.Instructions);
			Add(cb.ExceptionHandlers);
			Add(cb.Variables);
		}

		void Add(IEnumerable<Instruction> instrs) {
			if (instrs is null)
				return;
			foreach (var instr in instrs) {
				if (instr is null)
					continue;
				switch (instr.OpCode.OperandType) {
				case Emit.OperandType.InlineTok:
				case Emit.OperandType.InlineType:
				case Emit.OperandType.InlineMethod:
				case Emit.OperandType.InlineField:
					Push(instr.Operand);
					break;

				case Emit.OperandType.InlineSig:
					Add(instr.Operand as CallingConventionSig);
					break;

				case Emit.OperandType.InlineVar:
				case Emit.OperandType.ShortInlineVar:
					var local = instr.Operand as Local;
					if (local is not null) {
						Add(local);
						break;
					}
					var arg = instr.Operand as Parameter;
					if (arg is not null) {
						Add(arg);
						break;
					}
					break;
				}
			}
		}

		void Add(IEnumerable<Emit.ExceptionHandler> ehs) {
			if (ehs is null)
				return;
			foreach (var eh in ehs)
				Push(eh.CatchType);
		}

		void Add(IEnumerable<Local> locals) {
			if (locals is null)
				return;
			foreach (var local in locals)
				Add(local);
		}

		void Add(Local local) {
			if (local is null)
				return;
			Add(local.Type);
		}

		void Add(IEnumerable<Parameter> ps) {
			if (ps is null)
				return;
			foreach (var p in ps)
				Add(p);
		}

		void Add(Parameter param) {
			if (param is null)
				return;
			Add(param.Type);
			Add(param.Method);
		}

		void Add(IEnumerable<ParamDef> pds) {
			if (pds is null)
				return;
			foreach (var pd in pds)
				Add(pd);
		}

		void Add(ParamDef pd) {
			if (pd is null)
				return;
			Add(pd.DeclaringMethod);
			Add(pd.CustomAttributes);
			Add(pd.MarshalType);
		}

		void Add(MarshalType mt) {
			if (mt is null)
				return;

			switch (mt.NativeType) {
			case NativeType.SafeArray:
				Add(((SafeArrayMarshalType)mt).UserDefinedSubType);
				break;

			case NativeType.CustomMarshaler:
				Add(((CustomMarshalType)mt).CustomMarshaler);
				break;
			}
		}

		void Add(IEnumerable<MethodOverride> mos) {
			if (mos is null)
				return;
			foreach (var mo in mos)
				Add(mo);
		}

		void Add(MethodOverride mo) {
			// It's a struct so can't be null
			Push(mo.MethodBody);
			Push(mo.MethodDeclaration);
		}

		void Add(MethodSpec ms) {
			if (ms is null || MethodSpecs.ContainsKey(ms))
				return;
			if (ms.Method is not null && ms.Method.DeclaringType is not null && ms.Method.DeclaringType.Module != validModule)
				return;
			MethodSpecs[ms] = true;
			Push(ms.Method);
			Add(ms.Instantiation);
			Add(ms.CustomAttributes);
		}

		void Add(IEnumerable<PropertyDef> pds) {
			if (pds is null)
				return;
			foreach (var pd in pds)
				Add(pd);
		}

		void Add(PropertyDef pd) {
			if (pd is null || PropertyDefs.ContainsKey(pd))
				return;
			if (pd.DeclaringType is not null && pd.DeclaringType.Module != validModule)
				return;
			PropertyDefs[pd] = true;
			Add(pd.Type);
			Add(pd.CustomAttributes);
			Add(pd.GetMethods);
			Add(pd.SetMethods);
			Add(pd.OtherMethods);
			Add(pd.DeclaringType);
		}

		void Add(IEnumerable<TypeDef> tds) {
			if (tds is null)
				return;
			foreach (var td in tds)
				Add(td);
		}

		void Add(TypeDef td) {
			if (td is null || TypeDefs.ContainsKey(td))
				return;
			if (td.Module != validModule)
				return;
			TypeDefs[td] = true;
			Push(td.BaseType);
			Add(td.Fields);
			Add(td.Methods);
			Add(td.GenericParameters);
			Add(td.Interfaces);
			Add(td.DeclSecurities);
			Add(td.DeclaringType);
			Add(td.Events);
			Add(td.Properties);
			Add(td.NestedTypes);
			Add(td.CustomAttributes);
		}

		void Add(IEnumerable<InterfaceImpl> iis) {
			if (iis is null)
				return;
			foreach (var ii in iis)
				Add(ii);
		}

		void Add(InterfaceImpl ii) {
			if (ii is null)
				return;
			Push(ii.Interface);
			Add(ii.CustomAttributes);
		}

		void Add(TypeRef tr) {
			if (tr is null || TypeRefs.ContainsKey(tr))
				return;
			if (tr.Module != validModule)
				return;
			TypeRefs[tr] = true;
			Push(tr.ResolutionScope);
			Add(tr.CustomAttributes);
		}

		void Add(IEnumerable<TypeSig> tss) {
			if (tss is null)
				return;
			foreach (var ts in tss)
				Add(ts);
		}

		void Add(TypeSig ts) {
			if (ts is null || TypeSigs.ContainsKey(ts))
				return;
			if (ts.Module != validModule)
				return;
			TypeSigs[ts] = true;

			for (; ts is not null; ts = ts.Next) {
				switch (ts.ElementType) {
				case ElementType.Void:
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
				case ElementType.String:
				case ElementType.ValueType:
				case ElementType.Class:
				case ElementType.TypedByRef:
				case ElementType.I:
				case ElementType.U:
				case ElementType.Object:
					var tdrs = (TypeDefOrRefSig)ts;
					Push(tdrs.TypeDefOrRef);
					break;

				case ElementType.FnPtr:
					var fps = (FnPtrSig)ts;
					Add(fps.Signature);
					break;

				case ElementType.GenericInst:
					var gis = (GenericInstSig)ts;
					Add(gis.GenericType);
					Add(gis.GenericArguments);
					break;

				case ElementType.CModReqd:
				case ElementType.CModOpt:
					var ms = (ModifierSig)ts;
					Push(ms.Modifier);
					break;

				case ElementType.End:
				case ElementType.Ptr:
				case ElementType.ByRef:
				case ElementType.Var:
				case ElementType.Array:
				case ElementType.ValueArray:
				case ElementType.R:
				case ElementType.SZArray:
				case ElementType.MVar:
				case ElementType.Internal:
				case ElementType.Module:
				case ElementType.Sentinel:
				case ElementType.Pinned:
				default:
					break;
				}
			}
		}

		void Add(TypeSpec ts) {
			if (ts is null || TypeSpecs.ContainsKey(ts))
				return;
			if (ts.Module != validModule)
				return;
			TypeSpecs[ts] = true;
			Add(ts.TypeSig);
			Add(ts.CustomAttributes);
		}

		void Add(IEnumerable<ExportedType> ets) {
			if (ets is null)
				return;
			foreach (var et in ets)
				Add(et);
		}

		void Add(ExportedType et) {
			if (et is null || ExportedTypes.ContainsKey(et))
				return;
			if (et.Module != validModule)
				return;
			ExportedTypes[et] = true;
			Add(et.CustomAttributes);
			Push(et.Implementation);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Methods to load properties to make sure they're initialized
	/// </summary>
	static class MemberMDInitializer {
		/// <summary>
		/// Read every collection element
		/// </summary>
		/// <typeparam name="T">Collection element type</typeparam>
		/// <param name="coll">Collection</param>
		public static void Initialize<T>(IEnumerable<T> coll) {
			if (coll is null)
				return;
			foreach (var c in coll) {
			}
		}

		/// <summary>
		/// Load the object instance
		/// </summary>
		/// <param name="o">The value (ignored)</param>
		public static void Initialize(object o) {
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the MemberRef table
	/// </summary>
	public abstract class MemberRef : IHasCustomAttribute, IMethodDefOrRef, ICustomAttributeType, IField, IContainsGenericParameter, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <summary>
		/// The owner module
		/// </summary>
		protected ModuleDef module;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.MemberRef, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 6;

		/// <inheritdoc/>
		public int MethodDefOrRefTag => 1;

		/// <inheritdoc/>
		public int CustomAttributeTypeTag => 3;

		/// <summary>
		/// From column MemberRef.Class
		/// </summary>
		public IMemberRefParent Class {
			get => @class;
			set => @class = value;
		}
		/// <summary/>
		protected IMemberRefParent @class;

		/// <summary>
		/// From column MemberRef.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column MemberRef.Signature
		/// </summary>
		public CallingConventionSig Signature {
			get => signature;
			set => signature = value;
		}
		/// <summary/>
		protected CallingConventionSig signature;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 6;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <inheritdoc/>
		public ITypeDefOrRef DeclaringType {
			get {
				var owner = @class;

				if (owner is ITypeDefOrRef tdr)
					return tdr;

				if (owner is MethodDef method)
					return method.DeclaringType;

				if (owner is ModuleRef mr) {
					var tr = GetGlobalTypeRef(mr);
					if (module is not null)
						return module.UpdateRowId(tr);
					return tr;
				}

				return null;
			}
		}

		TypeRefUser GetGlobalTypeRef(ModuleRef mr) {
			if (module is null)
				return CreateDefaultGlobalTypeRef(mr);
			var globalType = module.GlobalType;
			if (globalType is not null && new SigComparer().Equals(module, mr))
				return new TypeRefUser(module, globalType.Namespace, globalType.Name, mr);
			var asm = module.Assembly;
			if (asm is null)
				return CreateDefaultGlobalTypeRef(mr);
			var mod = asm.FindModule(mr.Name);
			if (mod is null)
				return CreateDefaultGlobalTypeRef(mr);
			globalType = mod.GlobalType;
			if (globalType is null)
				return CreateDefaultGlobalTypeRef(mr);
			return new TypeRefUser(module, globalType.Namespace, globalType.Name, mr);
		}

		TypeRefUser CreateDefaultGlobalTypeRef(ModuleRef mr) {
			var tr = new TypeRefUser(module, string.Empty, "<Module>", mr);
			if (module is not null)
				module.UpdateRowId(tr);
			return tr;
		}

		bool IIsTypeOrMethod.IsType => false;
		bool IIsTypeOrMethod.IsMethod => IsMethodRef;
		bool IMemberRef.IsField => IsFieldRef;
		bool IMemberRef.IsTypeSpec => false;
		bool IMemberRef.IsTypeRef => false;
		bool IMemberRef.IsTypeDef => false;
		bool IMemberRef.IsMethodSpec => false;
		bool IMemberRef.IsMethodDef => false;
		bool IMemberRef.IsMemberRef => true;
		bool IMemberRef.IsFieldDef => false;
		bool IMemberRef.IsPropertyDef => false;
		bool IMemberRef.IsEventDef => false;
		bool IMemberRef.IsGenericParam => false;

		/// <summary>
		/// <c>true</c> if this is a method reference (<see cref="MethodSig"/> != <c>null</c>)
		/// </summary>
		public bool IsMethodRef => MethodSig is not null;

		/// <summary>
		/// <c>true</c> if this is a field reference (<see cref="FieldSig"/> != <c>null</c>)
		/// </summary>
		public bool IsFieldRef => FieldSig is not null;

		/// <summary>
		/// Gets/sets the method sig
		/// </summary>
		public MethodSig MethodSig {
			get => signature as MethodSig;
			set => signature = value;
		}

		/// <summary>
		/// Gets/sets the field sig
		/// </summary>
		public FieldSig FieldSig {
			get => signature as FieldSig;
			set => signature = value;
		}

		/// <inheritdoc/>
		public ModuleDef Module => module;

		/// <summary>
		/// <c>true</c> if the method has a hidden 'this' parameter
		/// </summary>
		public bool HasThis {
			get {
				var ms = MethodSig;
				return ms is null ? false : ms.HasThis;
			}
		}

		/// <summary>
		/// <c>true</c> if the method has an explicit 'this' parameter
		/// </summary>
		public bool ExplicitThis {
			get {
				var ms = MethodSig;
				return ms is null ? false : ms.ExplicitThis;
			}
		}

		/// <summary>
		/// Gets the calling convention
		/// </summary>
		public CallingConvention CallingConvention {
			get {
				var ms = MethodSig;
				return ms is null ? 0 : ms.CallingConvention & CallingConvention.Mask;
			}
		}

		/// <summary>
		/// Gets/sets the method return type
		/// </summary>
		public TypeSig ReturnType {
			get => MethodSig?.RetType;
			set {
				var ms = MethodSig;
				if (ms is not null)
					ms.RetType = value;
			}
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters => (int)(MethodSig?.GenParamCount ?? 0);

		/// <summary>
		/// Gets the full name
		/// </summary>
		public string FullName {
			get {
				var parent = @class;
				IList<TypeSig> typeGenArgs = null;
				if (parent is TypeSpec) {
					if (((TypeSpec)parent).TypeSig is GenericInstSig sig)
						typeGenArgs = sig.GenericArguments;
				}
				var methodSig = MethodSig;
				if (methodSig is not null)
					return FullNameFactory.MethodFullName(GetDeclaringTypeFullName(parent), name, methodSig, typeGenArgs, null, null, null);
				var fieldSig = FieldSig;
				if (fieldSig is not null)
					return FullNameFactory.FieldFullName(GetDeclaringTypeFullName(parent), name, fieldSig, typeGenArgs, null);
				return string.Empty;
			}
		}

		/// <summary>
		/// Get the declaring type's full name
		/// </summary>
		/// <returns>Full name or <c>null</c> if there's no declaring type</returns>
		public string GetDeclaringTypeFullName() => GetDeclaringTypeFullName(@class);

		string GetDeclaringTypeFullName(IMemberRefParent parent) {
			if (parent is null)
				return null;
			if (parent is ITypeDefOrRef)
				return ((ITypeDefOrRef)parent).FullName;
			if (parent is ModuleRef)
				return $"[module:{((ModuleRef)parent).ToString()}]<Module>";
			if (parent is MethodDef) {
				var declaringType = ((MethodDef)parent).DeclaringType;
				return declaringType?.FullName;
			}
			return null;	// Should never be reached
		}

		/// <summary>
		/// Resolves the method/field
		/// </summary>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance or <c>null</c>
		/// if it couldn't be resolved.</returns>
		public IMemberForwarded Resolve() {
			if (module is null)
				return null;
			return module.Context.Resolver.Resolve(this);
		}

		/// <summary>
		/// Resolves the method/field
		/// </summary>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance</returns>
		/// <exception cref="MemberRefResolveException">If the method/field couldn't be resolved</exception>
		public IMemberForwarded ResolveThrow() {
			var memberDef = Resolve();
			if (memberDef is not null)
				return memberDef;
			throw new MemberRefResolveException($"Could not resolve method/field: {this} ({this.GetDefinitionAssembly()})");
		}

		/// <summary>
		/// Resolves the field
		/// </summary>
		/// <returns>A <see cref="FieldDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		public FieldDef ResolveField() => Resolve() as FieldDef;

		/// <summary>
		/// Resolves the field
		/// </summary>
		/// <returns>A <see cref="FieldDef"/> instance</returns>
		/// <exception cref="MemberRefResolveException">If the field couldn't be resolved</exception>
		public FieldDef ResolveFieldThrow() {
			var field = ResolveField();
			if (field is not null)
				return field;
			throw new MemberRefResolveException($"Could not resolve field: {this} ({this.GetDefinitionAssembly()})");
		}

		/// <summary>
		/// Resolves the method
		/// </summary>
		/// <returns>A <see cref="MethodDef"/> instance or <c>null</c> if it couldn't be resolved.</returns>
		public MethodDef ResolveMethod() => Resolve() as MethodDef;

		/// <summary>
		/// Resolves the method
		/// </summary>
		/// <returns>A <see cref="MethodDef"/> instance</returns>
		/// <exception cref="MemberRefResolveException">If the method couldn't be resolved</exception>
		public MethodDef ResolveMethodThrow() {
			var method = ResolveMethod();
			if (method is not null)
				return method;
			throw new MemberRefResolveException($"Could not resolve method: {this} ({this.GetDefinitionAssembly()})");
		}

		bool IContainsGenericParameter.ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);

		/// <summary>
		/// Gets a <see cref="GenericParamContext"/> that can be used as signature context
		/// </summary>
		/// <param name="gpContext">Context passed to the constructor</param>
		/// <param name="class">Field/method class owner</param>
		/// <returns></returns>
		protected static GenericParamContext GetSignatureGenericParamContext(GenericParamContext gpContext, IMemberRefParent @class) {
			TypeDef type = null;
			var method = gpContext.Method;

			if (@class is TypeSpec ts && ts.TypeSig is GenericInstSig gis)
				type = gis.GenericType.ToTypeDefOrRef().ResolveTypeDef();

			return new GenericParamContext(type, method);
		}

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A MemberRef row created by the user and not present in the original .NET file
	/// </summary>
	public class MemberRefUser : MemberRef {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		public MemberRefUser(ModuleDef module) => this.module = module;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of ref</param>
		public MemberRefUser(ModuleDef module, UTF8String name) {
			this.module = module;
			this.name = name;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of field ref</param>
		/// <param name="sig">Field sig</param>
		public MemberRefUser(ModuleDef module, UTF8String name, FieldSig sig)
			: this(module, name, sig, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of field ref</param>
		/// <param name="sig">Field sig</param>
		/// <param name="class">Owner of field</param>
		public MemberRefUser(ModuleDef module, UTF8String name, FieldSig sig, IMemberRefParent @class) {
			this.module = module;
			this.name = name;
			this.@class = @class;
			signature = sig;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of method ref</param>
		/// <param name="sig">Method sig</param>
		public MemberRefUser(ModuleDef module, UTF8String name, MethodSig sig)
			: this(module, name, sig, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Name of method ref</param>
		/// <param name="sig">Method sig</param>
		/// <param name="class">Owner of method</param>
		public MemberRefUser(ModuleDef module, UTF8String name, MethodSig sig, IMemberRefParent @class) {
			this.module = module;
			this.name = name;
			this.@class = @class;
			signature = sig;
		}
	}

	/// <summary>
	/// Created from a row in the MemberRef table
	/// </summary>
	sealed class MemberRefMD : MemberRef, IMDTokenProviderMD, IContainsGenericParameter2 {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		bool IContainsGenericParameter2.ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.MemberRef, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>MemberRef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public MemberRefMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.MemberRefTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"MemberRef rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			module = readerModule;
			bool b = readerModule.TablesStream.TryReadMemberRefRow(origRid, out var row);
			Debug.Assert(b);
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			@class = readerModule.ResolveMemberRefParent(row.Class, gpContext);
			signature = readerModule.ReadSignature(row.Signature, GetSignatureGenericParamContext(gpContext, @class));
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Method attributes, see CorHdr.h/CorMethodAttr
	/// </summary>
	[Flags]
	public enum MethodAttributes : ushort {
		/// <summary>member access mask - Use this mask to retrieve accessibility information.</summary>
		MemberAccessMask	= 0x0007,
		/// <summary>Member not referenceable.</summary>
		PrivateScope		= 0x0000,
		/// <summary>Member not referenceable.</summary>
		CompilerControlled	= PrivateScope,
		/// <summary>Accessible only by the parent type.</summary>
		Private				= 0x0001,
		/// <summary>Accessible by sub-types only in this Assembly.</summary>
		FamANDAssem			= 0x0002,
		/// <summary>Accessibly by anyone in the Assembly.</summary>
		Assembly			= 0x0003,
		/// <summary>Accessible only by type and sub-types.</summary>
		Family				= 0x0004,
		/// <summary>Accessibly by sub-types anywhere, plus anyone in assembly.</summary>
		FamORAssem			= 0x0005,
		/// <summary>Accessibly by anyone who has visibility to this scope.</summary>
		Public				= 0x0006,

		/// <summary>Defined on type, else per instance.</summary>
		Static				= 0x0010,
		/// <summary>Method may not be overridden.</summary>
		Final				= 0x0020,
		/// <summary>Method virtual.</summary>
		Virtual				= 0x0040,
		/// <summary>Method hides by name+sig, else just by name.</summary>
		HideBySig			= 0x0080,

		/// <summary>vtable layout mask - Use this mask to retrieve vtable attributes.</summary>
		VtableLayoutMask	= 0x0100,
		/// <summary>The default.</summary>
		ReuseSlot			= 0x0000,
		/// <summary>Method always gets a new slot in the vtable.</summary>
		NewSlot				= 0x0100,

		/// <summary>Overridability is the same as the visibility.</summary>
		CheckAccessOnOverride = 0x0200,
		/// <summary>Method does not provide an implementation.</summary>
		Abstract			= 0x0400,
		/// <summary>Method is special.  Name describes how.</summary>
		SpecialName			= 0x0800,

		/// <summary>Implementation is forwarded through pinvoke.</summary>
		PinvokeImpl			= 0x2000,
		/// <summary>Managed method exported via thunk to unmanaged code.</summary>
		UnmanagedExport		= 0x0008,

		/// <summary>Runtime should check name encoding.</summary>
		RTSpecialName		= 0x1000,
		/// <summary>Method has security associate with it.</summary>
		HasSecurity			= 0x4000,
		/// <summary>Method calls another method containing security code.</summary>
		RequireSecObject	= 0x8000,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Method table
	/// </summary>
	public abstract class MethodDef : IHasCustomAttribute, IHasDeclSecurity, IMemberRefParent, IMethodDefOrRef, IMemberForwarded, ICustomAttributeType, ITypeOrMethodDef, IManagedEntryPoint, IHasCustomDebugInformation, IListListener<GenericParam>, IListListener<ParamDef>, IMemberDef {
		internal static readonly UTF8String StaticConstructorName = ".cctor";
		internal static readonly UTF8String InstanceConstructorName = ".ctor";

		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// All parameters
		/// </summary>
		protected ParameterList parameterList;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.Method, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 0;

		/// <inheritdoc/>
		public int HasDeclSecurityTag => 1;

		/// <inheritdoc/>
		public int MemberRefParentTag => 3;

		/// <inheritdoc/>
		public int MethodDefOrRefTag => 0;

		/// <inheritdoc/>
		public int MemberForwardedTag => 1;

		/// <inheritdoc/>
		public int CustomAttributeTypeTag => 2;

		/// <inheritdoc/>
		public int TypeOrMethodDefTag => 1;

		/// <summary>
		/// From column Method.RVA
		/// </summary>
		public RVA RVA {
			get => rva;
			set => rva = value;
		}
		/// <summary/>
		protected RVA rva;

		/// <summary>
		/// From column Method.ImplFlags
		/// </summary>
		public MethodImplAttributes ImplAttributes {
			get => (MethodImplAttributes)implAttributes;
			set => implAttributes = (int)value;
		}
		/// <summary>Implementation attributes</summary>
		protected int implAttributes;

		/// <summary>
		/// From column Method.Flags
		/// </summary>
		public MethodAttributes Attributes {
			get => (MethodAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Method.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Method.Signature
		/// </summary>
		public CallingConventionSig Signature {
			get => signature;
			set => signature = value;
		}
		/// <summary/>
		protected CallingConventionSig signature;

		/// <summary>
		/// From column Method.ParamList
		/// </summary>
		public IList<ParamDef> ParamDefs {
			get {
				if (paramDefs is null)
					InitializeParamDefs();
				return paramDefs;
			}
		}
		/// <summary/>
		protected LazyList<ParamDef> paramDefs;
		/// <summary>Initializes <see cref="paramDefs"/></summary>
		protected virtual void InitializeParamDefs() =>
			Interlocked.CompareExchange(ref paramDefs, new LazyList<ParamDef>(this), null);

		/// <inheritdoc/>
		public IList<GenericParam> GenericParameters {
			get {
				if (genericParameters is null)
					InitializeGenericParameters();
				return genericParameters;
			}
		}
		/// <summary/>
		protected LazyList<GenericParam> genericParameters;
		/// <summary>Initializes <see cref="genericParameters"/></summary>
		protected virtual void InitializeGenericParameters() =>
			Interlocked.CompareExchange(ref genericParameters, new LazyList<GenericParam>(this), null);

		/// <inheritdoc/>
		public IList<DeclSecurity> DeclSecurities {
			get {
				if (declSecurities is null)
					InitializeDeclSecurities();
				return declSecurities;
			}
		}
		/// <summary/>
		protected IList<DeclSecurity> declSecurities;
		/// <summary>Initializes <see cref="declSecurities"/></summary>
		protected virtual void InitializeDeclSecurities() =>
			Interlocked.CompareExchange(ref declSecurities, new List<DeclSecurity>(), null);

		/// <inheritdoc/>
		public ImplMap ImplMap {
			get {
				if (!implMap_isInitialized)
					InitializeImplMap();
				return implMap;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				implMap = value;
				implMap_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ImplMap implMap;
		/// <summary/>
		protected bool implMap_isInitialized;

		void InitializeImplMap() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (implMap_isInitialized)
				return;
			implMap = GetImplMap_NoLock();
			implMap_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="implMap"/></summary>
		protected virtual ImplMap GetImplMap_NoLock() => null;

		/// <summary>Reset <see cref="ImplMap"/></summary>
		protected void ResetImplMap() => implMap_isInitialized = false;

		/// <summary>
		/// Gets/sets the method body. See also <see cref="Body"/>
		/// </summary>
		public Emit.MethodBody MethodBody {
			get {
				if (!methodBody_isInitialized)
					InitializeMethodBody();
				return methodBody;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				methodBody = value;
				methodBody_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected Emit.MethodBody methodBody;
		/// <summary/>
		protected bool methodBody_isInitialized;

		void InitializeMethodBody() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (methodBody_isInitialized)
				return;
			methodBody = GetMethodBody_NoLock();
			methodBody_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Frees the method body if it has been loaded. This does nothing if <see cref="CanFreeMethodBody"/>
		/// returns <c>false</c>.
		/// </summary>
		public void FreeMethodBody() {
			if (!CanFreeMethodBody)
				return;
			if (!methodBody_isInitialized)
				return;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			methodBody = null;
			methodBody_isInitialized = false;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="methodBody"/></summary>
		protected virtual Emit.MethodBody GetMethodBody_NoLock() => null;

		/// <summary>
		/// true if <see cref="FreeMethodBody()"/> can free the method body
		/// </summary>
		protected virtual bool CanFreeMethodBody => true;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 0;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// Gets the methods this method implements
		/// </summary>
		public IList<MethodOverride> Overrides {
			get {
				if (overrides is null)
					InitializeOverrides();
				return overrides;
			}
		}
		/// <summary/>
		protected IList<MethodOverride> overrides;
		/// <summary>Initializes <see cref="overrides"/></summary>
		protected virtual void InitializeOverrides() =>
			Interlocked.CompareExchange(ref overrides, new List<MethodOverride>(), null);

		/// <summary>
		/// Gets the export info or null if the method isn't exported to unmanaged code.
		/// </summary>
		public MethodExportInfo ExportInfo {
			get => exportInfo;
			set => exportInfo = value;
		}
		/// <summary/>
		protected MethodExportInfo exportInfo;

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public bool HasDeclSecurities => DeclSecurities.Count > 0;

		/// <summary>
		/// <c>true</c> if <see cref="ParamDefs"/> is not empty
		/// </summary>
		public bool HasParamDefs => ParamDefs.Count > 0;

		/// <summary>
		/// Gets/sets the declaring type (owner type)
		/// </summary>
		public TypeDef DeclaringType {
			get => declaringType2;
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType is not null)
					currentDeclaringType.Methods.Remove(this);	// Will set DeclaringType2 = null
				if (value is not null)
					value.Methods.Add(this);	// Will set DeclaringType2 = value
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType => declaringType2;

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get => declaringType2;
			set => declaringType2 = value;
		}
		/// <summary/>
		protected TypeDef declaringType2;

		/// <inheritdoc/>
		public ModuleDef Module => declaringType2?.Module;

		bool IIsTypeOrMethod.IsType => false;
		bool IIsTypeOrMethod.IsMethod => true;
		bool IMemberRef.IsField => false;
		bool IMemberRef.IsTypeSpec => false;
		bool IMemberRef.IsTypeRef => false;
		bool IMemberRef.IsTypeDef => false;
		bool IMemberRef.IsMethodSpec => false;
		bool IMemberRef.IsMethodDef => true;
		bool IMemberRef.IsMemberRef => false;
		bool IMemberRef.IsFieldDef => false;
		bool IMemberRef.IsPropertyDef => false;
		bool IMemberRef.IsEventDef => false;
		bool IMemberRef.IsGenericParam => false;

		/// <summary>
		/// Gets/sets the CIL method body. See also <see cref="FreeMethodBody()"/>
		/// </summary>
		public CilBody Body {
			get {
				if (!methodBody_isInitialized)
					InitializeMethodBody();
				return methodBody as CilBody;
			}
			set => MethodBody = value;
		}

		/// <summary>
		/// Gets/sets the native method body
		/// </summary>
		public NativeMethodBody NativeBody {
			get {
				if (!methodBody_isInitialized)
					InitializeMethodBody();
				return methodBody as NativeMethodBody;
			}
			set => MethodBody = value;
		}

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="GenericParam"/> in <see cref="GenericParameters"/>
		/// </summary>
		public bool HasGenericParameters => GenericParameters.Count > 0;

		/// <summary>
		/// <c>true</c> if it has a <see cref="Body"/>
		/// </summary>
		public bool HasBody => Body is not null;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="MethodOverride"/> in <see cref="Overrides"/>
		/// </summary>
		public bool HasOverrides => Overrides.Count > 0;

		/// <summary>
		/// <c>true</c> if <see cref="ImplMap"/> is not <c>null</c>
		/// </summary>
		public bool HasImplMap => ImplMap is not null;

		/// <summary>
		/// Gets the full name
		/// </summary>
		public string FullName => FullNameFactory.MethodFullName(declaringType2?.FullName, name, MethodSig, null, null, this, null);

		/// <summary>
		/// Gets/sets the <see cref="MethodSig"/>
		/// </summary>
		public MethodSig MethodSig {
			get => signature as MethodSig;
			set => signature = value;
		}

		/// <summary>
		/// Gets the parameters
		/// </summary>
		public ParameterList Parameters => parameterList;

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get {
				var sig = MethodSig;
				return sig is null ? 0 : (int)sig.GenParamCount;
			}
		}

		/// <summary>
		/// <c>true</c> if the method has a hidden 'this' parameter
		/// </summary>
		public bool HasThis {
			get {
				var ms = MethodSig;
				return ms is null ? false : ms.HasThis;
			}
		}

		/// <summary>
		/// <c>true</c> if the method has an explicit 'this' parameter
		/// </summary>
		public bool ExplicitThis {
			get {
				var ms = MethodSig;
				return ms is null ? false : ms.ExplicitThis;
			}
		}

		/// <summary>
		/// Gets the calling convention
		/// </summary>
		public CallingConvention CallingConvention {
			get {
				var ms = MethodSig;
				return ms is null ? 0 : ms.CallingConvention & CallingConvention.Mask;
			}
		}

		/// <summary>
		/// Gets/sets the method return type
		/// </summary>
		public TypeSig ReturnType {
			get => MethodSig?.RetType;
			set {
				var ms = MethodSig;
				if (ms is not null)
					ms.RetType = value;
			}
		}

		/// <summary>
		/// <c>true</c> if the method returns a value (i.e., return type is not <see cref="System.Void"/>)
		/// </summary>
		public bool HasReturnType => ReturnType.RemovePinnedAndModifiers().GetElementType() != ElementType.Void;

		/// <summary>
		/// Gets/sets the method semantics attributes. If you remove/add a method to a property or
		/// an event, you must manually update this property or eg. <see cref="IsSetter"/> won't
		/// work as expected.
		/// </summary>
		public MethodSemanticsAttributes SemanticsAttributes {
			get {
				if ((semAttrs & SEMATTRS_INITD) == 0)
					InitializeSemanticsAttributes();
				return (MethodSemanticsAttributes)semAttrs;
			}
			set => semAttrs = (ushort)value | SEMATTRS_INITD;
		}
		/// <summary>Set when <see cref="semAttrs"/> has been initialized</summary>
		protected internal static int SEMATTRS_INITD = unchecked((int)0x80000000);
		/// <summary/>
		protected internal int semAttrs;
		/// <summary>Initializes <see cref="semAttrs"/></summary>
		protected virtual void InitializeSemanticsAttributes() => semAttrs = 0 | SEMATTRS_INITD;

		/// <summary>
		/// Set or clear flags in <see cref="semAttrs"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, MethodSemanticsAttributes flags) {
			if ((semAttrs & SEMATTRS_INITD) == 0)
				InitializeSemanticsAttributes();
			if (set)
				semAttrs |= (int)flags;
			else
				semAttrs &= ~(int)flags;
		}

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(MethodAttributes andMask, MethodAttributes orMask) =>
			attributes = (attributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, MethodAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Modify <see cref="implAttributes"/> property: <see cref="implAttributes"/> =
		/// (<see cref="implAttributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyImplAttributes(MethodImplAttributes andMask, MethodImplAttributes orMask) =>
			implAttributes = (implAttributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Set or clear flags in <see cref="implAttributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyImplAttributes(bool set, MethodImplAttributes flags) {
			if (set)
				implAttributes |= (int)flags;
			else
				implAttributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the method access
		/// </summary>
		public MethodAttributes Access {
			get => (MethodAttributes)attributes & MethodAttributes.MemberAccessMask;
			set => ModifyAttributes(~MethodAttributes.MemberAccessMask, value & MethodAttributes.MemberAccessMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.PrivateScope"/> is set
		/// </summary>
		public bool IsCompilerControlled => IsPrivateScope;

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.PrivateScope"/> is set
		/// </summary>
		public bool IsPrivateScope => ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.PrivateScope;

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.Private"/> is set
		/// </summary>
		public bool IsPrivate => ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Private;

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.FamANDAssem"/> is set
		/// </summary>
		public bool IsFamilyAndAssembly => ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.FamANDAssem;

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.Assembly"/> is set
		/// </summary>
		public bool IsAssembly => ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Assembly;

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.Family"/> is set
		/// </summary>
		public bool IsFamily => ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Family;

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.FamORAssem"/> is set
		/// </summary>
		public bool IsFamilyOrAssembly => ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.FamORAssem;

		/// <summary>
		/// <c>true</c> if <see cref="MethodAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic => ((MethodAttributes)attributes & MethodAttributes.MemberAccessMask) == MethodAttributes.Public;

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.Static"/> bit
		/// </summary>
		public bool IsStatic {
			get => ((MethodAttributes)attributes & MethodAttributes.Static) != 0;
			set => ModifyAttributes(value, MethodAttributes.Static);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.Final"/> bit
		/// </summary>
		public bool IsFinal {
			get => ((MethodAttributes)attributes & MethodAttributes.Final) != 0;
			set => ModifyAttributes(value, MethodAttributes.Final);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.Virtual"/> bit
		/// </summary>
		public bool IsVirtual {
			get => ((MethodAttributes)attributes & MethodAttributes.Virtual) != 0;
			set => ModifyAttributes(value, MethodAttributes.Virtual);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.HideBySig"/> bit
		/// </summary>
		public bool IsHideBySig {
			get => ((MethodAttributes)attributes & MethodAttributes.HideBySig) != 0;
			set => ModifyAttributes(value, MethodAttributes.HideBySig);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.NewSlot"/> bit
		/// </summary>
		public bool IsNewSlot {
			get => ((MethodAttributes)attributes & MethodAttributes.NewSlot) != 0;
			set => ModifyAttributes(value, MethodAttributes.NewSlot);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.ReuseSlot"/> bit
		/// </summary>
		public bool IsReuseSlot {
			get => ((MethodAttributes)attributes & MethodAttributes.NewSlot) == 0;
			set => ModifyAttributes(!value, MethodAttributes.NewSlot);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.CheckAccessOnOverride"/> bit
		/// </summary>
		public bool IsCheckAccessOnOverride {
			get => ((MethodAttributes)attributes & MethodAttributes.CheckAccessOnOverride) != 0;
			set => ModifyAttributes(value, MethodAttributes.CheckAccessOnOverride);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.Abstract"/> bit
		/// </summary>
		public bool IsAbstract {
			get => ((MethodAttributes)attributes & MethodAttributes.Abstract) != 0;
			set => ModifyAttributes(value, MethodAttributes.Abstract);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get => ((MethodAttributes)attributes & MethodAttributes.SpecialName) != 0;
			set => ModifyAttributes(value, MethodAttributes.SpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.PinvokeImpl"/> bit
		/// </summary>
		public bool IsPinvokeImpl {
			get => ((MethodAttributes)attributes & MethodAttributes.PinvokeImpl) != 0;
			set => ModifyAttributes(value, MethodAttributes.PinvokeImpl);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.UnmanagedExport"/> bit
		/// </summary>
		public bool IsUnmanagedExport {
			get => ((MethodAttributes)attributes & MethodAttributes.UnmanagedExport) != 0;
			set => ModifyAttributes(value, MethodAttributes.UnmanagedExport);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get => ((MethodAttributes)attributes & MethodAttributes.RTSpecialName) != 0;
			set => ModifyAttributes(value, MethodAttributes.RTSpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.HasSecurity"/> bit
		/// </summary>
		public bool HasSecurity {
			get => ((MethodAttributes)attributes & MethodAttributes.HasSecurity) != 0;
			set => ModifyAttributes(value, MethodAttributes.HasSecurity);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodAttributes.RequireSecObject"/> bit
		/// </summary>
		public bool IsRequireSecObject {
			get => ((MethodAttributes)attributes & MethodAttributes.RequireSecObject) != 0;
			set => ModifyAttributes(value, MethodAttributes.RequireSecObject);
		}

		/// <summary>
		/// Gets/sets the code type
		/// </summary>
		public MethodImplAttributes CodeType {
			get => (MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask;
			set => ModifyImplAttributes(~MethodImplAttributes.CodeTypeMask, value & MethodImplAttributes.CodeTypeMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="MethodImplAttributes.IL"/> is set
		/// </summary>
		public bool IsIL => ((MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.IL;

		/// <summary>
		/// <c>true</c> if <see cref="MethodImplAttributes.Native"/> is set
		/// </summary>
		public bool IsNative => ((MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.Native;

		/// <summary>
		/// <c>true</c> if <see cref="MethodImplAttributes.OPTIL"/> is set
		/// </summary>
		public bool IsOPTIL => ((MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.OPTIL;

		/// <summary>
		/// <c>true</c> if <see cref="MethodImplAttributes.Runtime"/> is set
		/// </summary>
		public bool IsRuntime => ((MethodImplAttributes)implAttributes & MethodImplAttributes.CodeTypeMask) == MethodImplAttributes.Runtime;

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.Unmanaged"/> bit
		/// </summary>
		public bool IsUnmanaged {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.Unmanaged) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.Unmanaged);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.Managed"/> bit
		/// </summary>
		public bool IsManaged {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.Unmanaged) == 0;
			set => ModifyImplAttributes(!value, MethodImplAttributes.Unmanaged);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.ForwardRef"/> bit
		/// </summary>
		public bool IsForwardRef {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.ForwardRef) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.ForwardRef);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.PreserveSig"/> bit
		/// </summary>
		public bool IsPreserveSig {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.PreserveSig) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.PreserveSig);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.InternalCall"/> bit
		/// </summary>
		public bool IsInternalCall {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.InternalCall) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.InternalCall);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.Synchronized"/> bit
		/// </summary>
		public bool IsSynchronized {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.Synchronized) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.Synchronized);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.NoInlining"/> bit
		/// </summary>
		public bool IsNoInlining {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.NoInlining) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.NoInlining);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.AggressiveInlining"/> bit
		/// </summary>
		public bool IsAggressiveInlining {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.AggressiveInlining) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.AggressiveInlining);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.NoOptimization"/> bit
		/// </summary>
		public bool IsNoOptimization {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.NoOptimization) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.NoOptimization);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.AggressiveOptimization"/> bit
		/// </summary>
		public bool IsAggressiveOptimization {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.AggressiveOptimization) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.AggressiveOptimization);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodImplAttributes.SecurityMitigations"/> bit
		/// </summary>
		public bool HasSecurityMitigations {
			get => ((MethodImplAttributes)implAttributes & MethodImplAttributes.SecurityMitigations) != 0;
			set => ModifyImplAttributes(value, MethodImplAttributes.SecurityMitigations);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.Setter"/> bit
		/// </summary>
		public bool IsSetter {
			get => (SemanticsAttributes & MethodSemanticsAttributes.Setter) != 0;
			set => ModifyAttributes(value, MethodSemanticsAttributes.Setter);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.Getter"/> bit
		/// </summary>
		public bool IsGetter {
			get => (SemanticsAttributes & MethodSemanticsAttributes.Getter) != 0;
			set => ModifyAttributes(value, MethodSemanticsAttributes.Getter);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.Other"/> bit
		/// </summary>
		public bool IsOther {
			get => (SemanticsAttributes & MethodSemanticsAttributes.Other) != 0;
			set => ModifyAttributes(value, MethodSemanticsAttributes.Other);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.AddOn"/> bit
		/// </summary>
		public bool IsAddOn {
			get => (SemanticsAttributes & MethodSemanticsAttributes.AddOn) != 0;
			set => ModifyAttributes(value, MethodSemanticsAttributes.AddOn);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.RemoveOn"/> bit
		/// </summary>
		public bool IsRemoveOn {
			get => (SemanticsAttributes & MethodSemanticsAttributes.RemoveOn) != 0;
			set => ModifyAttributes(value, MethodSemanticsAttributes.RemoveOn);
		}

		/// <summary>
		/// Gets/sets the <see cref="MethodSemanticsAttributes.Fire"/> bit
		/// </summary>
		public bool IsFire {
			get => (SemanticsAttributes & MethodSemanticsAttributes.Fire) != 0;
			set => ModifyAttributes(value, MethodSemanticsAttributes.Fire);
		}

		/// <summary>
		/// <c>true</c> if this is the static type constructor
		/// </summary>
		public bool IsStaticConstructor => IsRuntimeSpecialName && UTF8String.Equals(name, StaticConstructorName);

		/// <summary>
		/// <c>true</c> if this is an instance constructor
		/// </summary>
		public bool IsInstanceConstructor => IsRuntimeSpecialName && UTF8String.Equals(name, InstanceConstructorName);

		/// <summary>
		/// <c>true</c> if this is a static or an instance constructor
		/// </summary>
		public bool IsConstructor => IsStaticConstructor || IsInstanceConstructor;

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnLazyAdd(int index, ref GenericParam value) => OnLazyAdd2(index, ref value);

		internal virtual void OnLazyAdd2(int index, ref GenericParam value) {
#if DEBUG
			if (value.Owner != this)
				throw new InvalidOperationException("Added generic param's Owner != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnAdd(int index, GenericParam value) {
			if (value.Owner is not null)
				throw new InvalidOperationException("Generic param is already owned by another type/method. Set Owner to null first.");
			value.Owner = this;
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnRemove(int index, GenericParam value) => value.Owner = null;

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnClear() {
			foreach (var gp in genericParameters.GetEnumerable_NoLock())
				gp.Owner = null;
		}

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnLazyAdd(int index, ref ParamDef value) => OnLazyAdd2(index, ref value);

		internal virtual void OnLazyAdd2(int index, ref ParamDef value) {
#if DEBUG
			if (value.DeclaringMethod != this)
				throw new InvalidOperationException("Added param's DeclaringMethod != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnAdd(int index, ParamDef value) {
			if (value.DeclaringMethod is not null)
				throw new InvalidOperationException("Param is already owned by another method. Set DeclaringMethod to null first.");
			value.DeclaringMethod = this;
		}

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnRemove(int index, ParamDef value) => value.DeclaringMethod = null;

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<ParamDef>.OnClear() {
			foreach (var pd in paramDefs.GetEnumerable_NoLock())
				pd.DeclaringMethod = null;
		}

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A Method row created by the user and not present in the original .NET file
	/// </summary>
	public class MethodDefUser : MethodDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public MethodDefUser() {
			paramDefs = new LazyList<ParamDef>(this);
			genericParameters = new LazyList<GenericParam>(this);
			parameterList = new ParameterList(this, null);
			semAttrs = 0 | SEMATTRS_INITD;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		public MethodDefUser(UTF8String name)
			: this(name, null, 0, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="methodSig">Method sig</param>
		public MethodDefUser(UTF8String name, MethodSig methodSig)
			: this(name, methodSig, 0, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="methodSig">Method sig</param>
		/// <param name="flags">Flags</param>
		public MethodDefUser(UTF8String name, MethodSig methodSig, MethodAttributes flags)
			: this(name, methodSig, 0, flags) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="methodSig">Method sig</param>
		/// <param name="implFlags">Impl flags</param>
		public MethodDefUser(UTF8String name, MethodSig methodSig, MethodImplAttributes implFlags)
			: this(name, methodSig, implFlags, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="methodSig">Method sig</param>
		/// <param name="implFlags">Impl flags</param>
		/// <param name="flags">Flags</param>
		public MethodDefUser(UTF8String name, MethodSig methodSig, MethodImplAttributes implFlags, MethodAttributes flags) {
			this.name = name;
			signature = methodSig;
			paramDefs = new LazyList<ParamDef>(this);
			genericParameters = new LazyList<GenericParam>(this);
			implAttributes = (int)implFlags;
			attributes = (int)flags;
			parameterList = new ParameterList(this, null);
			semAttrs = 0 | SEMATTRS_INITD;
		}
	}

	/// <summary>
	/// Created from a row in the Method table
	/// </summary>
	sealed class MethodDefMD : MethodDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly RVA origRva;
		readonly MethodImplAttributes origImplAttributes;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeParamDefs() {
			var list = readerModule.Metadata.GetParamRidList(origRid);
			var tmp = new LazyList<ParamDef, RidList>(list.Count, this, list, (list2, index) => readerModule.ResolveParam(list2[index]));
			Interlocked.CompareExchange(ref paramDefs, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeGenericParameters() {
			var list = readerModule.Metadata.GetGenericParamRidList(Table.Method, origRid);
			var tmp = new LazyList<GenericParam, RidList>(list.Count, this, list, (list2, index) => readerModule.ResolveGenericParam(list2[index]));
			Interlocked.CompareExchange(ref genericParameters, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeDeclSecurities() {
			var list = readerModule.Metadata.GetDeclSecurityRidList(Table.Method, origRid);
			var tmp = new LazyList<DeclSecurity, RidList>(list.Count, list, (list2, index) => readerModule.ResolveDeclSecurity(list2[index]));
			Interlocked.CompareExchange(ref declSecurities, tmp, null);
		}

		/// <inheritdoc/>
		protected override ImplMap GetImplMap_NoLock() => readerModule.ResolveImplMap(readerModule.Metadata.GetImplMapRid(Table.Method, origRid));

		/// <inheritdoc/>
		protected override Emit.MethodBody GetMethodBody_NoLock() => readerModule.ReadMethodBody(this, origRva, origImplAttributes, new GenericParamContext(declaringType2, this));

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.Method, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			if (Interlocked.CompareExchange(ref customDebugInfos, list, null) is null) {
				var body = Body;
				readerModule.InitializeCustomDebugInfos(this, body, list);
			}
		}

		/// <inheritdoc/>
		protected override void InitializeOverrides() {
			var dt = declaringType2 as TypeDefMD;
			var tmp = dt is null ? new List<MethodOverride>() : dt.GetMethodOverrides(this, new GenericParamContext(declaringType2, this));
			Interlocked.CompareExchange(ref overrides, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeSemanticsAttributes() {
			if (DeclaringType is TypeDefMD dt)
				dt.InitializeMethodSemanticsAttributes();
			semAttrs |= SEMATTRS_INITD;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Method</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public MethodDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.MethodTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"Method rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadMethodRow(origRid, out var row);
			Debug.Assert(b);
			rva = (RVA)row.RVA;
			implAttributes = row.ImplFlags;
			attributes = row.Flags;
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			origRva = rva;
			origImplAttributes = (MethodImplAttributes)implAttributes;
			declaringType2 = readerModule.GetOwnerType(this);
			signature = readerModule.ReadSignature(row.Signature, new GenericParamContext(declaringType2, this));
			parameterList = new ParameterList(this, declaringType2);
			exportInfo = readerModule.GetExportInfo(rid);
		}

		internal MethodDefMD InitializeAll() {
			MemberMDInitializer.Initialize(RVA);
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(ImplAttributes);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(Signature);
			MemberMDInitializer.Initialize(ImplMap);
			MemberMDInitializer.Initialize(MethodBody);
			MemberMDInitializer.Initialize(DeclaringType);
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(Overrides);
			MemberMDInitializer.Initialize(ParamDefs);
			MemberMDInitializer.Initialize(GenericParameters);
			MemberMDInitializer.Initialize(DeclSecurities);
			return this;
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref GenericParam value) {
			if (value.Owner != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadGenericParam(value.Rid).InitializeAll());
				value.Owner = this;
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref ParamDef value) {
			if (value.DeclaringMethod != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadParam(value.Rid).InitializeAll());
				value.DeclaringMethod = this;
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Contains the name and ordinal of a method that gets exported to unmanaged code.
	/// </summary>
	[DebuggerDisplay("{Ordinal} {Name} {Options}")]
	public sealed class MethodExportInfo {
		MethodExportInfoOptions options;
		ushort? ordinal;
		string name;

		const MethodExportInfoOptions DefaultOptions = MethodExportInfoOptions.FromUnmanaged;

		/// <summary>
		/// Gets the ordinal or null
		/// </summary>
		public ushort? Ordinal {
			get => ordinal;
			set => ordinal = value;
		}

		/// <summary>
		/// Gets the name. If it's null, and <see cref="Ordinal"/> is also null, the name of the method
		/// (<see cref="MethodDef.Name"/>) is used as the exported name.
		/// </summary>
		public string Name {
			get => name;
			set => name = value;
		}

		/// <summary>
		/// Gets the options
		/// </summary>
		public MethodExportInfoOptions Options {
			get => options;
			set => options = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public MethodExportInfo() => options = DefaultOptions;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name or null to export by ordinal</param>
		public MethodExportInfo(string name) {
			options = DefaultOptions;
			this.name = name;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ordinal">Ordinal</param>
		public MethodExportInfo(ushort ordinal) {
			options = DefaultOptions;
			this.ordinal = ordinal;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name or null to export by ordinal</param>
		/// <param name="ordinal">Ordinal or null to export by name</param>
		public MethodExportInfo(string name, ushort? ordinal) {
			options = DefaultOptions;
			this.name = name;
			this.ordinal = ordinal;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name or null to export by ordinal</param>
		/// <param name="ordinal">Ordinal or null to export by name</param>
		/// <param name="options">Options</param>
		public MethodExportInfo(string name, ushort? ordinal, MethodExportInfoOptions options) {
			this.options = options;
			this.name = name;
			this.ordinal = ordinal;
		}
	}

	/// <summary>
	/// Exported method options
	/// </summary>
	[Flags]
	public enum MethodExportInfoOptions {
		/// <summary>
		/// No bit is set
		/// </summary>
		None							= 0,

		/// <summary>
		/// Transition from unmanaged code
		/// </summary>
		FromUnmanaged					= 0x00000001,

		/// <summary>
		/// Also retain app domain
		/// </summary>
		FromUnmanagedRetainAppDomain	= 0x00000002,

		/// <summary>
		/// Call most derived method
		/// </summary>
		CallMostDerived					= 0x00000004,
	}
}





namespace dnlib.DotNet {
	sealed class MethodExportInfoProvider {
		readonly Dictionary<uint, MethodExportInfo> toInfo;

		public MethodExportInfoProvider(ModuleDefMD module) {
			toInfo = new Dictionary<uint, MethodExportInfo>();
			try {
				Initialize(module);
			}
			catch (OutOfMemoryException) {
			}
			catch (IOException) {
			}
		}

		void Initialize(ModuleDefMD module) {
			var vtblHdr = module.Metadata.ImageCor20Header.VTableFixups;
			if (vtblHdr.VirtualAddress == 0 || vtblHdr.Size == 0)
				return;

			var peImage = module.Metadata.PEImage;
			var exportHdr = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[0];
			if (exportHdr.VirtualAddress == 0 || exportHdr.Size < 0x28)
				return;

			if (!CpuArch.TryGetCpuArch(peImage.ImageNTHeaders.FileHeader.Machine, out var cpuArch)) {
				Debug.Fail($"Exported methods: Unsupported machine: {peImage.ImageNTHeaders.FileHeader.Machine}");
				return;
			}

			var reader = peImage.CreateReader();
			var offsetToInfo = GetOffsetToExportInfoDictionary(ref reader, peImage, exportHdr, cpuArch);
			reader.Position = (uint)peImage.ToFileOffset(vtblHdr.VirtualAddress);
			ulong endPos = (ulong)reader.Position + vtblHdr.Size;
			while ((ulong)reader.Position + 8 <= endPos && reader.CanRead(8U)) {
				var tableRva = (RVA)reader.ReadUInt32();
				int numSlots = reader.ReadUInt16();
				var flags = (VTableFlags)reader.ReadUInt16();
				bool is64bit = (flags & VTableFlags.Bit64) != 0;
				var exportOptions = ToMethodExportInfoOptions(flags);

				var pos = reader.Position;
				reader.Position = (uint)peImage.ToFileOffset(tableRva);
				uint slotSize = is64bit ? 8U : 4;
				while (numSlots-- > 0 && reader.CanRead(slotSize)) {
					var tokenPos = reader.Position;
					uint token = reader.ReadUInt32();
					if (offsetToInfo.TryGetValue(tokenPos, out var exportInfo))
						toInfo[token] = new MethodExportInfo(exportInfo.Name, exportInfo.Ordinal, exportOptions);
					if (slotSize == 8)
						reader.ReadUInt32();
				}
				reader.Position = pos;
			}
		}

		static MethodExportInfoOptions ToMethodExportInfoOptions(VTableFlags flags) {
			var res = MethodExportInfoOptions.None;
			if ((flags & VTableFlags.FromUnmanaged) != 0)
				res |= MethodExportInfoOptions.FromUnmanaged;
			if ((flags & VTableFlags.FromUnmanagedRetainAppDomain) != 0)
				res |= MethodExportInfoOptions.FromUnmanagedRetainAppDomain;
			if ((flags & VTableFlags.CallMostDerived) != 0)
				res |= MethodExportInfoOptions.CallMostDerived;
			return res;
		}

		static Dictionary<uint, MethodExportInfo> GetOffsetToExportInfoDictionary(ref DataReader reader, IPEImage peImage, ImageDataDirectory exportHdr, CpuArch cpuArch) {
			reader.Position = (uint)peImage.ToFileOffset(exportHdr.VirtualAddress);
			// Skip Characteristics(4), TimeDateStamp(4), MajorVersion(2), MinorVersion(2), Name(4)
			reader.Position += 16;
			uint ordinalBase = reader.ReadUInt32();
			int numFuncs = reader.ReadInt32();
			int numNames = reader.ReadInt32();
			uint offsetOfFuncs = (uint)peImage.ToFileOffset((RVA)reader.ReadUInt32());
			uint offsetOfNames = (uint)peImage.ToFileOffset((RVA)reader.ReadUInt32());
			uint offsetOfNameIndexes = (uint)peImage.ToFileOffset((RVA)reader.ReadUInt32());

			var names = ReadNames(ref reader, peImage, numNames, offsetOfNames, offsetOfNameIndexes);
			reader.Position = offsetOfFuncs;
			var allInfos = new MethodExportInfo[numFuncs];
			var dict = new Dictionary<uint, MethodExportInfo>(numFuncs);
			for (int i = 0; i < allInfos.Length; i++) {
				var nextOffset = reader.Position + 4;
				uint funcRva = 0;
				var rva = (RVA)reader.ReadUInt32();
				reader.Position = (uint)peImage.ToFileOffset(rva);
				bool rvaValid = rva != 0 && cpuArch.TryGetExportedRvaFromStub(ref reader, peImage, out funcRva);
				uint funcOffset = rvaValid ? (uint)peImage.ToFileOffset((RVA)funcRva) : 0;
				var exportInfo = new MethodExportInfo((ushort)(ordinalBase + (uint)i));
				if (funcOffset != 0)
					dict[funcOffset] = exportInfo;
				allInfos[i] = exportInfo;
				reader.Position = nextOffset;
			}

			foreach (var info in names) {
				int index = info.Index;
				if ((uint)index >= (uint)numFuncs)
					continue;
				allInfos[index].Ordinal = null;
				allInfos[index].Name = info.Name;
			}

			return dict;
		}

		static NameAndIndex[] ReadNames(ref DataReader reader, IPEImage peImage, int numNames, uint offsetOfNames, uint offsetOfNameIndexes) {
			var names = new NameAndIndex[numNames];

			reader.Position = offsetOfNameIndexes;
			for (int i = 0; i < names.Length; i++)
				names[i].Index = reader.ReadUInt16();

			var currentOffset = offsetOfNames;
			for (int i = 0; i < names.Length; i++, currentOffset += 4) {
				reader.Position = currentOffset;
				uint offsetOfName = (uint)peImage.ToFileOffset((RVA)reader.ReadUInt32());
				names[i].Name = ReadMethodNameASCIIZ(ref reader, offsetOfName);
			}

			return names;
		}

		struct NameAndIndex {
			public string Name;
			public int Index;
		}

		// If this method gets updated, also update the writer (ManagedExportsWriter)
		static string ReadMethodNameASCIIZ(ref DataReader reader, uint offset) {
			reader.Position = offset;
			return reader.TryReadZeroTerminatedUtf8String() ?? string.Empty;
		}

		public MethodExportInfo GetMethodExportInfo(uint token) {
			if (toInfo.Count == 0)
				return null;
			if (toInfo.TryGetValue(token, out var info))
				return new MethodExportInfo(info.Name, info.Ordinal, info.Options);
			return null;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Method impl attributes, see CorHdr.h/CorMethodImpl
	/// </summary>
	[Flags]
	public enum MethodImplAttributes : ushort {
		/// <summary>Flags about code type.</summary>
		CodeTypeMask			= 0x0003,
		/// <summary>Method impl is IL.</summary>
		IL						= 0x0000,
		/// <summary>Method impl is native.</summary>
		Native					= 0x0001,
		/// <summary>Method impl is OPTIL</summary>
		OPTIL					= 0x0002,
		/// <summary>Method impl is provided by the runtime.</summary>
		Runtime					= 0x0003,

		/// <summary>Flags specifying whether the code is managed or unmanaged.</summary>
		ManagedMask				= 0x0004,
		/// <summary>Method impl is unmanaged, otherwise managed.</summary>
		Unmanaged				= 0x0004,
		/// <summary>Method impl is managed.</summary>
		Managed					= 0x0000,

		/// <summary>Indicates method is defined; used primarily in merge scenarios.</summary>
		ForwardRef				= 0x0010,
		/// <summary>Indicates method sig is not to be mangled to do HRESULT conversion.</summary>
		PreserveSig				= 0x0080,

		/// <summary>Reserved for internal use.</summary>
		InternalCall			= 0x1000,

		/// <summary>Method is single threaded through the body.</summary>
		Synchronized			= 0x0020,
		/// <summary>Method may not be inlined.</summary>
		NoInlining				= 0x0008,
		/// <summary>Method should be inlined if possible.</summary>
		AggressiveInlining		= 0x0100,
		/// <summary>Method may not be optimized.</summary>
		NoOptimization			= 0x0040,
		/// <summary>Method may contain hot code and should be aggressively optimized.</summary>
		AggressiveOptimization	= 0x0200,
		/// <summary>The JIT compiler should look for security mitigation attributes, such as the user-defined System.Runtime.CompilerServices.SecurityMitigationsAttribute. If found, the JIT compiler applies any related security mitigations. Available starting with .NET Framework 4.8.</summary>
		SecurityMitigations		= 0x0400,
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Describes which method some method implements
	/// </summary>
	public struct MethodOverride {
		/// <summary>
		/// The method body. Usually a <see cref="MethodDef"/> but could be a <see cref="MemberRef"/>
		/// </summary>
		public IMethodDefOrRef MethodBody;

		/// <summary>
		/// The method <see cref="MethodBody"/> implements
		/// </summary>
		public IMethodDefOrRef MethodDeclaration;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="methodBody">Method body</param>
		/// <param name="methodDeclaration">The method <paramref name="methodBody"/> implements</param>
		public MethodOverride(IMethodDefOrRef methodBody, IMethodDefOrRef methodDeclaration) {
			MethodBody = methodBody;
			MethodDeclaration = methodDeclaration;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Method semantics flags, see CorHdr.h/CorMethodSemanticsAttr
	/// </summary>
	[Flags]
	public enum MethodSemanticsAttributes : ushort {
		/// <summary>No bit is set</summary>
		None		= 0,
		/// <summary>Setter for property</summary>
		Setter		= 0x0001,
		/// <summary>Getter for property</summary>
		Getter		= 0x0002,
		/// <summary>other method for property or event</summary>
		Other		= 0x0004,
		/// <summary>AddOn method for event</summary>
		AddOn		= 0x0008,
		/// <summary>RemoveOn method for event</summary>
		RemoveOn	= 0x0010,
		/// <summary>Fire method for event</summary>
		Fire		= 0x0020,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the MethodSpec table
	/// </summary>
	public abstract class MethodSpec : IHasCustomAttribute, IHasCustomDebugInformation, IMethod, IContainsGenericParameter {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.MethodSpec, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 21;

		/// <summary>
		/// From column MethodSpec.Method
		/// </summary>
		public IMethodDefOrRef Method {
			get => method;
			set => method = value;
		}
		/// <summary/>
		protected IMethodDefOrRef method;

		/// <summary>
		/// From column MethodSpec.Instantiation
		/// </summary>
		public CallingConventionSig Instantiation {
			get => instantiation;
			set => instantiation = value;
		}
		/// <summary/>
		protected CallingConventionSig instantiation;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 21;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <inheritdoc/>
		MethodSig IMethod.MethodSig {
			get => method?.MethodSig;
			set {
				var m = method;
				if (m is not null)
					m.MethodSig = value;
			}
		}

		/// <inheritdoc/>
		public UTF8String Name {
			get {
				var m = method;
				return m is null ? UTF8String.Empty : m.Name;
			}
			set {
				var m = method;
				if (m is not null)
					m.Name = value;
			}
		}

		/// <inheritdoc/>
		public ITypeDefOrRef DeclaringType => method?.DeclaringType;

		/// <summary>
		/// Gets/sets the generic instance method sig
		/// </summary>
		public GenericInstMethodSig GenericInstMethodSig {
			get => instantiation as GenericInstMethodSig;
			set => instantiation = value;
		}

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters => GenericInstMethodSig?.GenericArguments.Count ?? 0;

		/// <inheritdoc/>
		public ModuleDef Module => method?.Module;

		/// <summary>
		/// Gets the full name
		/// </summary>
		public string FullName {
			get {
				var methodGenArgs = GenericInstMethodSig?.GenericArguments;
				var m = method;
				if (m is MethodDef methodDef)
					return FullNameFactory.MethodFullName(methodDef.DeclaringType?.FullName, methodDef.Name, methodDef.MethodSig, null, methodGenArgs, null, null);

				if (m is MemberRef memberRef) {
					var methodSig = memberRef.MethodSig;
					if (methodSig is not null) {
						var gis = (memberRef.Class as TypeSpec)?.TypeSig as GenericInstSig;
						var typeGenArgs = gis?.GenericArguments;
						return FullNameFactory.MethodFullName(memberRef.GetDeclaringTypeFullName(), memberRef.Name, methodSig, typeGenArgs, methodGenArgs, null, null);
					}
				}

				return string.Empty;
			}
		}

		bool IIsTypeOrMethod.IsType => false;
		bool IIsTypeOrMethod.IsMethod => true;
		bool IMemberRef.IsField => false;
		bool IMemberRef.IsTypeSpec => false;
		bool IMemberRef.IsTypeRef => false;
		bool IMemberRef.IsTypeDef => false;
		bool IMemberRef.IsMethodSpec => true;
		bool IMemberRef.IsMethodDef => false;
		bool IMemberRef.IsMemberRef => false;
		bool IMemberRef.IsFieldDef => false;
		bool IMemberRef.IsPropertyDef => false;
		bool IMemberRef.IsEventDef => false;
		bool IMemberRef.IsGenericParam => false;
		bool IContainsGenericParameter.ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A MethodSpec row created by the user and not present in the original .NET file
	/// </summary>
	public class MethodSpecUser : MethodSpec {
		/// <summary>
		/// Default constructor
		/// </summary>
		public MethodSpecUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The generic method</param>
		public MethodSpecUser(IMethodDefOrRef method)
			: this(method, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The generic method</param>
		/// <param name="sig">The instantiated method sig</param>
		public MethodSpecUser(IMethodDefOrRef method, GenericInstMethodSig sig) {
			this.method = method;
			instantiation = sig;
		}
	}

	/// <summary>
	/// Created from a row in the MethodSpec table
	/// </summary>
	sealed class MethodSpecMD : MethodSpec, IMDTokenProviderMD, IContainsGenericParameter2 {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		bool IContainsGenericParameter2.ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.MethodSpec, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>MethodSpec</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public MethodSpecMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.MethodSpecTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"MethodSpec rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			bool b = readerModule.TablesStream.TryReadMethodSpecRow(origRid, out var row);
			Debug.Assert(b);
			method = readerModule.ResolveMethodDefOrRef(row.Method, gpContext);
			instantiation = readerModule.ReadSignature(row.Instantiation, gpContext);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// <see cref="ModuleDef"/> context
	/// </summary>
	public class ModuleContext {
		IAssemblyResolver assemblyResolver;
		IResolver resolver;
		readonly Emit.OpCode[][] experimentalOpCodes = new Emit.OpCode[12][];

		/// <summary>
		/// Gets/sets the assembly resolver. This is never <c>null</c>.
		/// </summary>
		public IAssemblyResolver AssemblyResolver {
			get {
				if (assemblyResolver is null)
					Interlocked.CompareExchange(ref assemblyResolver, NullResolver.Instance, null);
				return assemblyResolver;
			}
			set => assemblyResolver = value;
		}

		/// <summary>
		/// Gets/sets the resolver. This is never <c>null</c>.
		/// </summary>
		public IResolver Resolver {
			get {
				if (resolver is null)
					Interlocked.CompareExchange(ref resolver, NullResolver.Instance, null);
				return resolver;
			}
			set => resolver = value;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public ModuleContext() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="assemblyResolver">Assembly resolver or <c>null</c></param>
		public ModuleContext(IAssemblyResolver assemblyResolver)
			: this(assemblyResolver, new Resolver(assemblyResolver)) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="resolver">Type/method/field resolver or <c>null</c></param>
		public ModuleContext(IResolver resolver)
			: this(null, resolver) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="assemblyResolver">Assembly resolver or <c>null</c></param>
		/// <param name="resolver">Type/method/field resolver or <c>null</c></param>
		public ModuleContext(IAssemblyResolver assemblyResolver, IResolver resolver) {
			this.assemblyResolver = assemblyResolver;
			this.resolver = resolver;
			if (resolver is null && assemblyResolver is not null)
				this.resolver = new Resolver(assemblyResolver);
		}

		/// <summary>
		/// Registers an experimental CIL opcode. It must be a 2-byte opcode
		/// where the first byte lies within the range <c>0xF0..0xFB</c>.
		/// </summary>
		public void RegisterExperimentalOpCode(Emit.OpCode opCode) {
			byte high = (byte)((ushort)opCode.Value >> 8);
			byte low = (byte)opCode.Value;
			Emit.OpCode[] array = experimentalOpCodes[high - 0xF0] ??= new Emit.OpCode[256];

			array[low] = opCode;
		}

		/// <summary>
		/// Clears an experimental CIL opcode.
		/// </summary>
		public void ClearExperimentalOpCode(byte high, byte low) {
			Emit.OpCode[] array = experimentalOpCodes[high - 0xF0];

			if (array != null)
				array[low] = null;
		}

		/// <summary>
		/// Attempts to get an experimental CIL opcode.
		/// </summary>
		public Emit.OpCode GetExperimentalOpCode(byte high, byte low) {
			return experimentalOpCodes[high - 0xF0]?[low];
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// <see cref="ModuleDefMD"/> creation options
	/// </summary>
	public sealed class ModuleCreationOptions {
		internal static readonly ModuleCreationOptions Default = new ModuleCreationOptions();

		/// <summary>
		/// Module context
		/// </summary>
		public ModuleContext Context { get; set; }

		internal const PdbReaderOptions DefaultPdbReaderOptions = PdbReaderOptions.None;

		/// <summary>
		/// PDB reader options
		/// </summary>
		public PdbReaderOptions PdbOptions { get; set; } = DefaultPdbReaderOptions;

		/// <summary>
		/// Set it to A) the path (string) of the PDB file, B) the data (byte[]) of the PDB file or
		/// C) to an <see cref="DataReaderFactory"/> of the PDB data. The <see cref="DataReaderFactory"/> will
		/// be owned by the module. You don't need to initialize <see cref="TryToLoadPdbFromDisk"/>
		/// </summary>
		public object PdbFileOrData { get; set; }

		/// <summary>
		/// If <c>true</c>, will load the PDB file from disk if present, or an embedded portable PDB file
		/// stored in the PE file. The default value is <c>true</c>.
		/// You don't need to initialize <see cref="PdbFileOrData"/>.
		/// </summary>
		public bool TryToLoadPdbFromDisk { get; set; } = true;

		/// <summary>
		/// corlib assembly reference to use or <c>null</c> if the default one from the opened
		/// module should be used.
		/// </summary>
		public AssemblyRef CorLibAssemblyRef { get; set; }

		/// <summary>
		/// Runtime reader kind, default is <see cref="CLRRuntimeReaderKind.CLR"/>. It should be
		/// set to <see cref="CLRRuntimeReaderKind.Mono"/> if it's an obfuscated Mono/Unity assembly.
		/// </summary>
		public CLRRuntimeReaderKind Runtime { get; set; } = CLRRuntimeReaderKind.CLR;

		/// <summary>
		/// Default constructor
		/// </summary>
		public ModuleCreationOptions() { }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="context">Module context</param>
		public ModuleCreationOptions(ModuleContext context) => Context = context;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="runtime">Runtime reader kind, default is <see cref="CLRRuntimeReaderKind.CLR"/>. It should be
		/// set to <see cref="CLRRuntimeReaderKind.Mono"/> if it's an obfuscated Mono/Unity assembly.</param>
		public ModuleCreationOptions(CLRRuntimeReaderKind runtime) => Runtime = runtime;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="context">Module context</param>
		/// <param name="runtime">Runtime reader kind, default is <see cref="CLRRuntimeReaderKind.CLR"/>. It should be
		/// set to <see cref="CLRRuntimeReaderKind.Mono"/> if it's an obfuscated Mono/Unity assembly.</param>
		public ModuleCreationOptions(ModuleContext context, CLRRuntimeReaderKind runtime) {
			Context = context;
			Runtime = runtime;
		}
	}

	/// <summary>
	/// Runtime reader kind
	/// </summary>
	public enum CLRRuntimeReaderKind {
		/// <summary>
		/// Microsoft's CLRs (.NET Framework, .NET Core)
		/// </summary>
		CLR,

		/// <summary>
		/// Mono's CLR (Mono, Unity)
		/// </summary>
		Mono,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Module table
	/// </summary>
	public abstract class ModuleDef : IHasCustomAttribute, IHasCustomDebugInformation, IResolutionScope, IDisposable, IListListener<TypeDef>, IModule, ITypeDefFinder, IDnlibDef, ITokenResolver, ISignatureReaderHelper {
		/// <summary>Default characteristics</summary>
		protected const Characteristics DefaultCharacteristics = Characteristics.ExecutableImage | Characteristics.Bit32Machine;

		/// <summary>Default DLL characteristics</summary>
		protected const DllCharacteristics DefaultDllCharacteristics = DllCharacteristics.TerminalServerAware | DllCharacteristics.NoSeh | DllCharacteristics.NxCompat | DllCharacteristics.DynamicBase;

		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Initialize this in the ctor
		/// </summary>
		protected ICorLibTypes corLibTypes;

		/// <summary>
		/// PDB state
		/// </summary>
		protected PdbState pdbState;

		TypeDefFinder typeDefFinder;

		/// <summary>
		/// Array of last used rid in each table. I.e., next free rid is value + 1
		/// </summary>
		protected readonly int[] lastUsedRids = new int[64];

		/// <summary>Module context</summary>
		protected ModuleContext context;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.Module, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 7;

		/// <inheritdoc/>
		public int ResolutionScopeTag => 0;

		/// <summary>
		/// Gets/sets a user value. This is never used by dnlib. This property isn't thread safe.
		/// </summary>
		public object Tag {
			get => tag;
			set => tag = value;
		}
		object tag;

		/// <inheritdoc/>
		public ScopeType ScopeType => ScopeType.ModuleDef;

		/// <inheritdoc/>
		public string ScopeName => FullName;

		/// <summary>
		/// Gets/sets Module.Generation column
		/// </summary>
		public ushort Generation {
			get => generation;
			set => generation = value;
		}
		/// <summary/>
		protected ushort generation;

		/// <summary>
		/// Gets/sets Module.Name column
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// Gets/sets Module.Mvid column
		/// </summary>
		public Guid? Mvid {
			get => mvid;
			set => mvid = value;
		}
		/// <summary/>
		protected Guid? mvid;

		/// <summary>
		/// Gets/sets Module.EncId column
		/// </summary>
		public Guid? EncId {
			get => encId;
			set => encId = value;
		}
		/// <summary/>
		protected Guid? encId;

		/// <summary>
		/// Gets/sets Module.EncBaseId column
		/// </summary>
		public Guid? EncBaseId {
			get => encBaseId;
			set => encBaseId = value;
		}
		/// <summary/>
		protected Guid? encBaseId;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 7;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// Gets the module's assembly. To set this value, add this <see cref="ModuleDef"/>
		/// to <see cref="AssemblyDef.Modules"/>.
		/// </summary>
		public AssemblyDef Assembly {
			get => assembly;
			internal set => assembly = value;
		}
		/// <summary/>
		protected AssemblyDef assembly;

		/// <summary>
		/// Gets a list of all non-nested <see cref="TypeDef"/>s. See also <see cref="GetTypes()"/>
		/// </summary>
		public IList<TypeDef> Types {
			get {
				if (types is null)
					InitializeTypes();
				return types;
			}
		}
		/// <summary/>
		protected LazyList<TypeDef> types;
		/// <summary>Initializes <see cref="types"/></summary>
		protected virtual void InitializeTypes() =>
			Interlocked.CompareExchange(ref types, new LazyList<TypeDef>(this), null);

		/// <summary>
		/// Gets a list of all <see cref="ExportedType"/>s
		/// </summary>
		public IList<ExportedType> ExportedTypes {
			get {
				if (exportedTypes is null)
					InitializeExportedTypes();
				return exportedTypes;
			}
		}
		/// <summary/>
		protected IList<ExportedType> exportedTypes;
		/// <summary>Initializes <see cref="exportedTypes"/></summary>
		protected virtual void InitializeExportedTypes() =>
			Interlocked.CompareExchange(ref exportedTypes, new List<ExportedType>(), null);

		/// <summary>
		/// Gets/sets the native entry point. Only one of <see cref="NativeEntryPoint"/> and
		/// <see cref="ManagedEntryPoint"/> can be set. You write to one and the other one gets cleared.
		/// </summary>
		public RVA NativeEntryPoint {
			get {
				if (!nativeAndManagedEntryPoint_initialized)
					InitializeNativeAndManagedEntryPoint();
				return nativeEntryPoint;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				nativeEntryPoint = value;
				managedEntryPoint = null;
				Cor20HeaderFlags |= ComImageFlags.NativeEntryPoint;
				nativeAndManagedEntryPoint_initialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary>
		/// Gets/sets the managed entry point. Only one of <see cref="NativeEntryPoint"/> and
		/// <see cref="ManagedEntryPoint"/> can be set. You write to one and the other one gets cleared.
		/// </summary>
		public IManagedEntryPoint ManagedEntryPoint {
			get {
				if (!nativeAndManagedEntryPoint_initialized)
					InitializeNativeAndManagedEntryPoint();
				return managedEntryPoint;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				nativeEntryPoint = 0;
				managedEntryPoint = value;
				Cor20HeaderFlags &= ~ComImageFlags.NativeEntryPoint;
				nativeAndManagedEntryPoint_initialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected RVA nativeEntryPoint;
		/// <summary/>
		protected IManagedEntryPoint managedEntryPoint;
		/// <summary/>
		protected bool nativeAndManagedEntryPoint_initialized;

		void InitializeNativeAndManagedEntryPoint() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (nativeAndManagedEntryPoint_initialized)
				return;
			nativeEntryPoint = GetNativeEntryPoint_NoLock();
			managedEntryPoint = GetManagedEntryPoint_NoLock();
			nativeAndManagedEntryPoint_initialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}
		/// <summary>Called to initialize <see cref="nativeEntryPoint"/></summary>
		protected virtual RVA GetNativeEntryPoint_NoLock() => 0;
		/// <summary>Called to initialize <see cref="managedEntryPoint"/></summary>
		protected virtual IManagedEntryPoint GetManagedEntryPoint_NoLock() => null;

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <summary>
		/// Gets/sets the entry point method
		/// </summary>
		public MethodDef EntryPoint {
			get => ManagedEntryPoint as MethodDef;
			set => ManagedEntryPoint = value;
		}

		/// <summary>
		/// <c>true</c> if <see cref="NativeEntryPoint"/> is non-zero
		/// </summary>
		public bool IsNativeEntryPointValid => NativeEntryPoint != 0;

		/// <summary>
		/// <c>true</c> if <see cref="ManagedEntryPoint"/> is non-null
		/// </summary>
		public bool IsManagedEntryPointValid => ManagedEntryPoint is not null;

		/// <summary>
		/// <c>true</c> if <see cref="EntryPoint"/> is non-null
		/// </summary>
		public bool IsEntryPointValid => EntryPoint is not null;

		/// <summary>
		/// Gets a list of all <see cref="Resource"/>s
		/// </summary>
		public ResourceCollection Resources {
			get {
				if (resources is null)
					InitializeResources();
				return resources;
			}
		}
		/// <summary/>
		protected ResourceCollection resources;
		/// <summary>Initializes <see cref="resources"/></summary>
		protected virtual void InitializeResources() =>
			Interlocked.CompareExchange(ref resources, new ResourceCollection(), null);

		/// <summary>
		/// Gets/sets the <see cref="VTableFixups"/>. This is <c>null</c> if there are no
		/// vtable fixups.
		/// </summary>
		public VTableFixups VTableFixups {
			get {
				if (!vtableFixups_isInitialized)
					InitializeVTableFixups();
				return vtableFixups;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				vtableFixups = value;
				vtableFixups_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected VTableFixups vtableFixups;
		/// <summary/>
		protected bool vtableFixups_isInitialized;

		void InitializeVTableFixups() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (vtableFixups_isInitialized)
				return;
			vtableFixups = GetVTableFixups_NoLock();
			vtableFixups_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="vtableFixups"/></summary>
		protected virtual VTableFixups GetVTableFixups_NoLock() => null;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="TypeDef"/> in <see cref="Types"/>
		/// </summary>
		public bool HasTypes => Types.Count > 0;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="ExportedType"/> in <see cref="ExportedTypes"/>
		/// </summary>
		public bool HasExportedTypes => ExportedTypes.Count > 0;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="Resource"/> in <see cref="Resources"/>
		/// </summary>
		public bool HasResources => Resources.Count > 0;

		/// <inheritdoc/>
		public string FullName => UTF8String.ToSystemStringOrEmpty(name);

		/// <summary>
		/// Gets/sets the path of the module or an empty string if it wasn't loaded from disk
		/// </summary>
		public string Location {
			get => location;
			set => location = value;
		}
		/// <summary/>
		protected string location;

		/// <summary>
		/// Gets the <see cref="ICorLibTypes"/>
		/// </summary>
		public ICorLibTypes CorLibTypes => corLibTypes;

		/// <summary>
		/// Gets the <see cref="TypeDefFinder"/> instance
		/// </summary>
		TypeDefFinder TypeDefFinder {
			get {
				if (typeDefFinder is null)
					Interlocked.CompareExchange(ref typeDefFinder, new TypeDefFinder(Types), null);
				return typeDefFinder;
			}
		}

		/// <summary>
		/// Gets/sets the module context. This is never <c>null</c>.
		/// </summary>
		public ModuleContext Context {
			get {
				if (context is null)
					Interlocked.CompareExchange(ref context, new ModuleContext(), null);
				return context;
			}
			set => context = value ?? new ModuleContext();
		}

		/// <summary>
		/// If <c>true</c>, the <see cref="TypeDef"/> cache is enabled. The cache is used by
		/// <see cref="Find(string,bool)"/> and <see cref="Find(TypeRef)"/> to find types.
		/// <br/><br/>
		/// <c>IMPORTANT:</c> Only enable the cache if this module's types keep their exact
		/// name, namespace, and declaring type and if <c>no</c> type is either added or
		/// removed from <see cref="Types"/> or from any type that is reachable from the
		/// top-level types in <see cref="Types"/> (i.e., any type owned by this module).
		/// This is disabled by default. When disabled, all calls to <see cref="Find(string,bool)"/>
		/// and <see cref="Find(TypeRef)"/> will result in a slow <c>O(n)</c> (linear) search.
		/// </summary>
		/// <seealso cref="ResetTypeDefFindCache()"/>
		public bool EnableTypeDefFindCache {
			get => TypeDefFinder.IsCacheEnabled;
			set => TypeDefFinder.IsCacheEnabled = value;
		}

		/// <summary>
		/// <c>true</c> if this is the manifest (main) module
		/// </summary>
		public bool IsManifestModule {
			get {
				var asm = assembly;
				return asm is not null && asm.ManifestModule == this;
			}
		}

		/// <summary>
		/// Gets the global (aka. &lt;Module&gt;) type or <c>null</c> if there are no types
		/// </summary>
		public TypeDef GlobalType => Types.Count == 0 ? null : Types[0];

		/// <summary>
		/// true if it's the core library module, false if it's not the core library module,
		/// and null if it's not known.
		/// </summary>
		public bool? IsCoreLibraryModule { get; set; }

		/// <summary>
		/// Gets/sets the Win32 resources
		/// </summary>
		public Win32Resources Win32Resources {
			get {
				if (!win32Resources_isInitialized)
					InitializeWin32Resources();
				return win32Resources;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				win32Resources = value;
				win32Resources_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected Win32Resources win32Resources;
		/// <summary/>
		protected bool win32Resources_isInitialized;

		void InitializeWin32Resources() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (win32Resources_isInitialized)
				return;
			win32Resources = GetWin32Resources_NoLock();
			win32Resources_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="win32Resources"/></summary>
		protected virtual Win32Resources GetWin32Resources_NoLock() => null;

		/// <summary>
		/// Gets the <see cref="dnlib.DotNet.Pdb.PdbState"/>. This is <c>null</c> if no PDB file
		/// has been loaded or if no PDB file could be found.
		/// </summary>
		public PdbState PdbState => pdbState;

		/// <summary>
		/// Module kind
		/// </summary>
		public ModuleKind Kind { get; set; }

		/// <summary>
		/// Gets/sets the characteristics (from PE file header)
		/// </summary>
		public Characteristics Characteristics { get; set; }

		/// <summary>
		/// Gets/sets the DLL characteristics (from PE optional header)
		/// </summary>
		public DllCharacteristics DllCharacteristics { get; set; }

		/// <summary>
		/// Gets/sets the runtime version which is stored in the metadata header.
		/// See <see cref="MDHeaderRuntimeVersion"/>.
		/// </summary>
		/// <remarks>Not thread safe</remarks>
		public string RuntimeVersion {
			get => runtimeVersion;
			set {
				if (runtimeVersion != value) {
					runtimeVersion = value;
					cachedWinMDStatus = null;
					runtimeVersionWinMD = null;
					winMDVersion = null;
				}
			}
		}
		string runtimeVersion;

		/// <summary>
		/// Gets the WinMD status
		/// </summary>
		/// <remarks>Not thread safe</remarks>
		public WinMDStatus WinMDStatus {
			get {
				var cval = cachedWinMDStatus;
				if (cval is not null)
					return cval.Value;
				cachedWinMDStatus = cval = CalculateWinMDStatus(RuntimeVersion);
				return cval.Value;
			}
		}
		WinMDStatus? cachedWinMDStatus;

		/// <summary>
		/// <c>true</c> if this is a WinMD file
		/// </summary>
		public bool IsWinMD => WinMDStatus != WinMDStatus.None;

		/// <summary>
		/// <c>true</c> if this is a managed WinMD file
		/// </summary>
		public bool IsManagedWinMD => WinMDStatus == WinMDStatus.Managed;

		/// <summary>
		/// <c>true</c> if this is a pure (non-managed) WinMD file
		/// </summary>
		public bool IsPureWinMD => WinMDStatus == WinMDStatus.Pure;

		/// <summary>
		/// Gets the CLR runtime version of the managed WinMD file or <c>null</c> if none. This is
		/// similar to <see cref="RuntimeVersion"/> for normal non-WinMD files.
		/// </summary>
		/// <remarks>Not thread safe</remarks>
		public string RuntimeVersionWinMD {
			get {
				var rtver = runtimeVersionWinMD;
				if (rtver is not null)
					return rtver;
				runtimeVersionWinMD = rtver = CalculateRuntimeVersionWinMD(RuntimeVersion);
				return rtver;
			}
		}
		string runtimeVersionWinMD;

		/// <summary>
		/// Gets the WinMD version or <c>null</c> if none
		/// </summary>
		/// <remarks>Not thread safe</remarks>
		public string WinMDVersion {
			get {
				var ver = winMDVersion;
				if (ver is not null)
					return ver;
				winMDVersion = ver = CalculateWinMDVersion(RuntimeVersion);
				return ver;
			}
		}
		string winMDVersion;

		static WinMDStatus CalculateWinMDStatus(string version) {
			if (version is null)
				return WinMDStatus.None;
			if (!version.StartsWith("WindowsRuntime ", StringComparison.Ordinal))
				return WinMDStatus.None;

			return version.IndexOf(';') < 0 ? WinMDStatus.Pure : WinMDStatus.Managed;
		}

		static string CalculateRuntimeVersionWinMD(string version) {
			// Original parser code:
			// CoreCLR file: src/md/winmd/adapter.cpp
			// Func: WinMDAdapter::Create(IMDCommon *pRawMDCommon, /*[out]*/ WinMDAdapter **ppAdapter)
			if (version is null)
				return null;
			if (!version.StartsWith("WindowsRuntime ", StringComparison.Ordinal))
				return null;
			int index = version.IndexOf(';');
			if (index < 0)
				return null;
			var s = version.Substring(index + 1);
			if (s.StartsWith("CLR", StringComparison.OrdinalIgnoreCase))
				s = s.Substring(3);
			s = s.TrimStart(' ');

			return s;
		}

		static string CalculateWinMDVersion(string version) {
			if (version is null)
				return null;
			if (!version.StartsWith("WindowsRuntime ", StringComparison.Ordinal))
				return null;
			int index = version.IndexOf(';');
			if (index < 0)
				return version;
			return version.Substring(0, index);
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.0 string (only the major
		/// and minor version numbers are checked)
		/// </summary>
		public bool IsClr10 {
			get {
				var ver = RuntimeVersion ?? string.Empty;
				return ver.StartsWith(MDHeaderRuntimeVersion.MS_CLR_10_PREFIX) ||
					ver.StartsWith(MDHeaderRuntimeVersion.MS_CLR_10_PREFIX_X86RETAIL) ||
					ver == MDHeaderRuntimeVersion.MS_CLR_10_RETAIL ||
					ver == MDHeaderRuntimeVersion.MS_CLR_10_COMPLUS;
			}
		}

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.0 string
		/// </summary>
		public bool IsClr10Exactly =>
			RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_10 ||
			RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_10_X86RETAIL ||
			RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_10_RETAIL ||
			RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_10_COMPLUS;

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.1 string (only the major
		/// and minor version numbers are checked)
		/// </summary>
		public bool IsClr11 => (RuntimeVersion ?? string.Empty).StartsWith(MDHeaderRuntimeVersion.MS_CLR_11_PREFIX);

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.1 string
		/// </summary>
		public bool IsClr11Exactly => RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_11;

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.0 or v1.1 string (only the
		/// major and minor version numbers are checked)
		/// </summary>
		public bool IsClr1x => IsClr10 || IsClr11;

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v1.0 or v1.1 string
		/// </summary>
		public bool IsClr1xExactly => IsClr10Exactly || IsClr11Exactly;

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v2.0 string (only the major
		/// and minor version numbers are checked)
		/// </summary>
		public bool IsClr20 => (RuntimeVersion ?? string.Empty).StartsWith(MDHeaderRuntimeVersion.MS_CLR_20_PREFIX);

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v2.0 string
		/// </summary>
		public bool IsClr20Exactly => RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_20;

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v4.0 string (only the major
		/// and minor version numbers are checked)
		/// </summary>
		public bool IsClr40 => (RuntimeVersion ?? string.Empty).StartsWith(MDHeaderRuntimeVersion.MS_CLR_40_PREFIX);

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the CLR v4.0 string
		/// </summary>
		public bool IsClr40Exactly => RuntimeVersion == MDHeaderRuntimeVersion.MS_CLR_40;

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the ECMA 2002 string
		/// </summary>
		public bool IsEcma2002 => RuntimeVersion == MDHeaderRuntimeVersion.ECMA_2002;

		/// <summary>
		/// <c>true</c> if <see cref="RuntimeVersion"/> is the ECMA 2005 string
		/// </summary>
		public bool IsEcma2005 => RuntimeVersion == MDHeaderRuntimeVersion.ECMA_2005;

		/// <summary>
		/// Gets/sets the <see cref="Machine"/> (from PE header)
		/// </summary>
		public Machine Machine { get; set; }

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is <see cref="PE.Machine.I386"/>, <see cref="PE.Machine.I386_Native_Apple"/>, ...
		/// </summary>
		public bool IsI386 => Machine.IsI386();

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is <see cref="PE.Machine.IA64"/>
		/// </summary>
		public bool IsIA64 => Machine == Machine.IA64;

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is <see cref="PE.Machine.AMD64"/>, <see cref="PE.Machine.AMD64_Native_Apple"/>, ...
		/// </summary>
		public bool IsAMD64 => Machine.IsAMD64();

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is <see cref="PE.Machine.ARMNT"/>, <see cref="PE.Machine.ARMNT_Native_Apple"/>, ...
		/// </summary>
		public bool IsARM => Machine.IsARMNT();

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is <see cref="PE.Machine.ARM64"/>, <see cref="PE.Machine.ARM64_Native_Apple"/>, ...
		/// </summary>
		public bool IsARM64 => Machine.IsARM64();

		/// <summary>
		/// <c>true</c> if <see cref="Machine"/> is s390x, <see cref="PE.Machine.S390X_Native_Apple"/>, ...
		/// </summary>
		public bool IsS390x => Machine.IsS390x();

		/// <summary>
		/// Gets/sets the <see cref="Cor20HeaderFlags"/> (from .NET header)
		/// </summary>
		public ComImageFlags Cor20HeaderFlags {
			get => (ComImageFlags)cor20HeaderFlags;
			set => cor20HeaderFlags = (int)value;
		}
		/// <summary/>
		protected int cor20HeaderFlags;

		/// <summary>
		/// Gets/sets the runtime version number in the COR20 header. The major version is
		/// in the high 16 bits. The minor version is in the low 16 bits. This is normally 2.5
		/// (0x00020005), but if it's .NET Framework 1.x, it should be 2.0 (0x00020000). If this is
		/// <c>null</c>, the default value will be used when saving the module (2.0 if CLR 1.x,
		/// and 2.5 if not CLR 1.x).
		/// </summary>
		public uint? Cor20HeaderRuntimeVersion { get; set; }

		/// <summary>
		/// Gets the tables header version. The major version is in the upper 8 bits and the
		/// minor version is in the lower 8 bits. .NET Framework 1.0/1.1 use version 1.0 (0x0100) and
		/// .NET Framework 2.x and later use version 2.0 (0x0200). 1.0 has no support for generics,
		/// 1.1 has support for generics (GenericParam rows have an extra Kind column),
		/// and 2.0 has support for generics (GenericParam rows have the standard 4 columns).
		/// No other version is supported. If this is <c>null</c>, the default version is
		/// used (1.0 if .NET Framework 1.x, else 2.0).
		/// </summary>
		public ushort? TablesHeaderVersion { get; set; }

		/// <summary>
		/// Set or clear flags in <see cref="cor20HeaderFlags"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyComImageFlags(bool set, ComImageFlags flags) {
#if THREAD_SAFE
			int origVal, newVal;
			do {
				origVal = cor20HeaderFlags;
				if (set)
					newVal = origVal | (int)flags;
				else
					newVal = origVal & ~(int)flags;
			} while (Interlocked.CompareExchange(ref cor20HeaderFlags, newVal, origVal) != origVal);
#else
			if (set)
				cor20HeaderFlags |= (int)flags;
			else
				cor20HeaderFlags &= ~(int)flags;
#endif
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags.ILOnly"/> bit
		/// </summary>
		public bool IsILOnly {
			get => ((ComImageFlags)cor20HeaderFlags & ComImageFlags.ILOnly) != 0;
			set => ModifyComImageFlags(value, ComImageFlags.ILOnly);
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags.Bit32Required"/> bit
		/// </summary>
		public bool Is32BitRequired {
			get => ((ComImageFlags)cor20HeaderFlags & ComImageFlags.Bit32Required) != 0;
			set => ModifyComImageFlags(value, ComImageFlags.Bit32Required);
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags.StrongNameSigned"/> bit
		/// </summary>
		public bool IsStrongNameSigned {
			get => ((ComImageFlags)cor20HeaderFlags & ComImageFlags.StrongNameSigned) != 0;
			set => ModifyComImageFlags(value, ComImageFlags.StrongNameSigned);
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags.NativeEntryPoint"/> bit
		/// </summary>
		public bool HasNativeEntryPoint {
			get => ((ComImageFlags)cor20HeaderFlags & ComImageFlags.NativeEntryPoint) != 0;
			set => ModifyComImageFlags(value, ComImageFlags.NativeEntryPoint);
		}

		/// <summary>
		/// Gets/sets the <see cref="ComImageFlags.Bit32Preferred"/> bit
		/// </summary>
		public bool Is32BitPreferred {
			get => ((ComImageFlags)cor20HeaderFlags & ComImageFlags.Bit32Preferred) != 0;
			set => ModifyComImageFlags(value, ComImageFlags.Bit32Preferred);
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (!disposing)
				return;
			var tdf = typeDefFinder;
			if (tdf is not null) {
				tdf.Dispose();
				typeDefFinder = null;
			}
			pdbState?.Dispose();
			pdbState = null;
		}

		/// <summary>
		/// Gets all the types (including nested types) present in this module
		/// </summary>
		public IEnumerable<TypeDef> GetTypes() => AllTypesHelper.Types(Types);

		/// <summary>
		/// Adds <paramref name="typeDef"/> as a non-nested type. If it's already nested, its
		/// <see cref="TypeDef.DeclaringType"/> will be set to <c>null</c>.
		/// </summary>
		/// <param name="typeDef">The <see cref="TypeDef"/> to insert</param>
		public void AddAsNonNestedType(TypeDef typeDef) {
			if (typeDef is null)
				return;
			typeDef.DeclaringType = null;
			Types.Add(typeDef);
		}

		/// <summary>
		/// Updates the <c>rid</c> to the next free <c>rid</c> available. It's only updated if
		/// the original <c>rid</c> is 0.
		/// </summary>
		/// <typeparam name="T">IMDTokenProvider</typeparam>
		/// <param name="tableRow">The row that should be updated</param>
		/// <returns>Returns the input</returns>
		public T UpdateRowId<T>(T tableRow) where T : IMDTokenProvider {
			if (tableRow != null && tableRow.Rid == 0)
				tableRow.Rid = GetNextFreeRid(tableRow.MDToken.Table);
			return tableRow;
		}

		/// <summary>
		/// Updates the <c>rid</c> to the next free <c>rid</c> available.
		/// </summary>
		/// <typeparam name="T">IMDTokenProvider</typeparam>
		/// <param name="tableRow">The row that should be updated</param>
		/// <returns>Returns the input</returns>
		public T ForceUpdateRowId<T>(T tableRow) where T : IMDTokenProvider {
			if (tableRow != null)
				tableRow.Rid = GetNextFreeRid(tableRow.MDToken.Table);
			return tableRow;
		}

		uint GetNextFreeRid(Table table) {
			var lastUsedRids = this.lastUsedRids;
			if ((uint)table >= lastUsedRids.Length)
				return 0;
			return (uint)Interlocked.Increment(ref lastUsedRids[(int)table]) & 0x00FFFFFF;
		}

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public ITypeDefOrRef Import(Type type) => new Importer(this).Import(type);

		/// <summary>
		/// Imports a <see cref="Type"/> as a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="type"/> is invalid</returns>
		public TypeSig ImportAsTypeSig(Type type) => new Importer(this).ImportAsTypeSig(type);

		/// <summary>
		/// Imports a <see cref="FieldInfo"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="fieldInfo">The field</param>
		/// <returns>The imported field or <c>null</c> if <paramref name="fieldInfo"/> is invalid
		/// or if we failed to import the field</returns>
		public MemberRef Import(FieldInfo fieldInfo) => (MemberRef)new Importer(this).Import(fieldInfo);

		/// <summary>
		/// Imports a <see cref="MethodBase"/> as a <see cref="IMethod"/>. This will be either
		/// a <see cref="MemberRef"/> or a <see cref="MethodSpec"/>.
		/// </summary>
		/// <param name="methodBase">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="methodBase"/> is invalid
		/// or if we failed to import the method</returns>
		public IMethod Import(MethodBase methodBase) => new Importer(this).Import(methodBase);

		/// <summary>
		/// Imports a <see cref="IType"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public IType Import(IType type) => new Importer(this).Import(type);

		/// <summary>
		/// Imports a <see cref="TypeDef"/> as a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeRef Import(TypeDef type) => (TypeRef)new Importer(this).Import(type);

		/// <summary>
		/// Imports a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeRef Import(TypeRef type) => (TypeRef)new Importer(this).Import(type);

		/// <summary>
		/// Imports a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeSpec Import(TypeSpec type) => new Importer(this).Import(type);

		/// <summary>
		/// Imports a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>The imported type or <c>null</c></returns>
		public TypeSig Import(TypeSig type) => new Importer(this).Import(type);

		/// <summary>
		/// Imports a <see cref="IField"/>
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
		public MemberRef Import(IField field) => (MemberRef)new Importer(this).Import(field);

		/// <summary>
		/// Imports a <see cref="FieldDef"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The imported type or <c>null</c> if <paramref name="field"/> is invalid</returns>
		public MemberRef Import(FieldDef field) => (MemberRef)new Importer(this).Import(field);

		/// <summary>
		/// Imports a <see cref="IMethod"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public IMethod Import(IMethod method) => new Importer(this).Import(method);

		/// <summary>
		/// Imports a <see cref="MethodDef"/> as a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public MemberRef Import(MethodDef method) => (MemberRef)new Importer(this).Import(method);

		/// <summary>
		/// Imports a <see cref="MethodSpec"/>
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The imported method or <c>null</c> if <paramref name="method"/> is invalid</returns>
		public MethodSpec Import(MethodSpec method) => new Importer(this).Import(method);

		/// <summary>
		/// Imports a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="memberRef">The member ref</param>
		/// <returns>The imported member ref or <c>null</c> if <paramref name="memberRef"/> is invalid</returns>
		public MemberRef Import(MemberRef memberRef) => new Importer(this).Import(memberRef);

		/// <summary>
		/// Writes the module to a file on disk. If the file exists, it will be overwritten.
		/// </summary>
		/// <param name="filename">Filename</param>
		public void Write(string filename) => Write(filename, null);

		/// <summary>
		/// Writes the module to a file on disk. If the file exists, it will be overwritten.
		/// </summary>
		/// <param name="filename">Filename</param>
		/// <param name="options">Writer options</param>
		public void Write(string filename, ModuleWriterOptions options) {
			var writer = new ModuleWriter(this, options ?? new ModuleWriterOptions(this));
			writer.Write(filename);
		}

		/// <summary>
		/// Writes the module to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		public void Write(Stream dest) => Write(dest, null);

		/// <summary>
		/// Writes the module to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		/// <param name="options">Writer options</param>
		public void Write(Stream dest, ModuleWriterOptions options) {
			var writer = new ModuleWriter(this, options ?? new ModuleWriterOptions(this));
			writer.Write(dest);
		}

		/// <summary>
		/// Resets the <see cref="TypeDef"/> cache which can be enabled by setting
		/// <see cref="EnableTypeDefFindCache"/> to <c>true</c>. Use this method if the cache is
		/// enabled but some of the types have been modified (eg. removed, added, renamed).
		/// </summary>
		public void ResetTypeDefFindCache() => TypeDefFinder.ResetCache();

		/// <summary>
		/// Finds a <see cref="ResourceData"/>
		/// </summary>
		/// <param name="type">Type</param>
		/// <param name="name">Name</param>
		/// <param name="langId">Language ID</param>
		/// <returns>The <see cref="ResourceData"/> or <c>null</c> if none found</returns>
		public ResourceData FindWin32ResourceData(ResourceName type, ResourceName name, ResourceName langId) => Win32Resources?.Find(type, name, langId);

		/// <summary>
		/// Creates a new <see cref="dnlib.DotNet.Pdb.PdbState"/>
		/// </summary>
		/// <param name="pdbFileKind">PDB file kind</param>
		public void CreatePdbState(PdbFileKind pdbFileKind) => SetPdbState(new PdbState(this, pdbFileKind));

		/// <summary>
		/// Sets a <see cref="dnlib.DotNet.Pdb.PdbState"/>
		/// </summary>
		/// <param name="pdbState">New <see cref="dnlib.DotNet.Pdb.PdbState"/></param>
		public void SetPdbState(PdbState pdbState) {
			if (pdbState is null)
				throw new ArgumentNullException(nameof(pdbState));
			var orig = Interlocked.CompareExchange(ref this.pdbState, pdbState, null);
			if (orig is not null)
				throw new InvalidOperationException("PDB file has already been initialized");
		}

		uint GetCor20RuntimeVersion() {
			var rtVer = Cor20HeaderRuntimeVersion;
			if (rtVer is not null)
				return rtVer.Value;
			return IsClr1x ? 0x00020000U : 0x00020005;
		}

		/// <summary>
		/// Returns the size of a pointer. Assumes it's 32-bit if pointer size is unknown or
		/// if it can be 32-bit or 64-bit.
		/// </summary>
		/// <returns>Size of a pointer (4 or 8)</returns>
		public int GetPointerSize() => GetPointerSize(4);

		/// <summary>
		/// Returns the size of a pointer
		/// </summary>
		/// <param name="defaultPointerSize">Default pointer size if it's not known or if it
		/// can be 32-bit or 64-bit</param>
		/// <returns>Size of a pointer (4 or 8)</returns>
		public int GetPointerSize(int defaultPointerSize) => GetPointerSize(defaultPointerSize, defaultPointerSize);

		/// <summary>
		/// Returns the size of a pointer
		/// </summary>
		/// <param name="defaultPointerSize">Default pointer size</param>
		/// <param name="prefer32bitPointerSize">Pointer size if it's prefer-32-bit (should usually be 4)</param>
		/// <returns></returns>
		public int GetPointerSize(int defaultPointerSize, int prefer32bitPointerSize) {
			var machine = Machine;
			if (machine.Is64Bit())
				return 8;
			if (!machine.IsI386())
				return 4;

			// Machine is I386 so it's either x86 or platform neutral

			// If the runtime version is < 2.5, then it's always loaded as a 32-bit process.
			if (GetCor20RuntimeVersion() < 0x00020005)
				return 4;

			// If it's a 32-bit PE header, and ILOnly is cleared, it's always loaded as a
			// 32-bit process.
			var flags = (ComImageFlags)cor20HeaderFlags;
			if ((flags & ComImageFlags.ILOnly) == 0)
				return 4;

			// 32-bit Preferred flag is new in .NET Framework 4.5. See CorHdr.h in Windows SDK for more info
			switch (flags & (ComImageFlags.Bit32Required | ComImageFlags.Bit32Preferred)) {
			case 0:
				// Machine and ILOnly flag should be checked
				break;

			case ComImageFlags.Bit32Preferred:
				// Illegal
				break;

			case ComImageFlags.Bit32Required:
				// x86 image (32-bit process)
				return 4;

			case ComImageFlags.Bit32Required | ComImageFlags.Bit32Preferred:
				// Platform neutral but prefers to be 32-bit
				return prefer32bitPointerSize;
			}

			return defaultPointerSize;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnLazyAdd(int index, ref TypeDef value) {
#if DEBUG
			if (value.DeclaringType is not null)
				throw new InvalidOperationException("Added type's DeclaringType is not null");
#endif
			value.Module2 = this;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnAdd(int index, TypeDef value) {
			if (value.DeclaringType is not null)
				throw new InvalidOperationException("Nested type is already owned by another type. Set DeclaringType to null first.");
			if (value.Module is not null)
				throw new InvalidOperationException("Type is already owned by another module. Remove it from that module's type list.");
			value.Module2 = this;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnRemove(int index, TypeDef value) => value.Module2 = null;

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnClear() {
			foreach (var type in types.GetEnumerable_NoLock())
				type.Module2 = null;
		}

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. For speed, enable <see cref="EnableTypeDefFindCache"/>
		/// if possible (read the documentation first).
		/// </summary>
		/// <param name="fullName">Full name of the type (no assembly information)</param>
		/// <param name="isReflectionName"><c>true</c> if it's a reflection name, and nested
		/// type names are separated by a <c>+</c> character. If <c>false</c>, nested type names
		/// are separated by a <c>/</c> character.</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public TypeDef Find(string fullName, bool isReflectionName) => TypeDefFinder.Find(fullName, isReflectionName);

		/// <summary>
		/// Finds a <see cref="TypeDef"/>. Its scope (i.e., module or assembly) is ignored when
		/// looking up the type. For speed, enable <see cref="EnableTypeDefFindCache"/> if possible
		/// (read the documentation first).
		/// </summary>
		/// <param name="typeRef">The type ref</param>
		/// <returns>An existing <see cref="TypeDef"/> or <c>null</c> if it wasn't found.</returns>
		public TypeDef Find(TypeRef typeRef) => TypeDefFinder.Find(typeRef);

		/// <summary>
		/// Finds a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="typeRef">The type</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if it wasn't found</returns>
		public TypeDef Find(ITypeDefOrRef typeRef) {
			if (typeRef is TypeDef td)
				return td.Module == this ? td : null;

			if (typeRef is TypeRef tr)
				return Find(tr);

			var ts = typeRef as TypeSpec;
			if (ts is null)
				return null;
			var sig = ts.TypeSig as TypeDefOrRefSig;
			if (sig is null)
				return null;

			td = sig.TypeDef;
			if (td is not null)
				return td.Module == this ? td : null;

			tr = sig.TypeRef;
			if (tr is not null)
				return Find(tr);

			return null;
		}

		/// <summary>
		/// Creates a new <see cref="ModuleContext"/> instance. There should normally only be one
		/// instance shared by all <see cref="ModuleDef"/>s.
		/// </summary>
		/// <returns>A new <see cref="ModuleContext"/> instance</returns>
		public static ModuleContext CreateModuleContext() {
			var ctx = new ModuleContext();
			var asmRes = new AssemblyResolver(ctx);
			var res = new Resolver(asmRes);
			ctx.AssemblyResolver = asmRes;
			ctx.Resolver = res;
			asmRes.DefaultModuleContext = ctx;
			return ctx;
		}

		/// <summary>
		/// Load everything in this module. All types, fields, asm refs, etc are loaded, all their
		/// properties are read to make sure everything is cached.
		/// </summary>
		/// <param name="cancellationToken">Cancellation token or <c>null</c></param>
		public virtual void LoadEverything(ICancellationToken cancellationToken = null) => ModuleLoader.LoadAll(this, cancellationToken);

		/// <inheritdoc/>
		public override string ToString() => FullName;

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="mdToken">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="mdToken"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(MDToken mdToken) => ResolveToken(mdToken.Raw, new GenericParamContext());

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="mdToken">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="mdToken"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(MDToken mdToken, GenericParamContext gpContext) => ResolveToken(mdToken.Raw, gpContext);

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(int token) => ResolveToken((uint)token, new GenericParamContext());

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(int token, GenericParamContext gpContext) => ResolveToken((uint)token, gpContext);

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public IMDTokenProvider ResolveToken(uint token) => ResolveToken(token, new GenericParamContext());

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public virtual IMDTokenProvider ResolveToken(uint token, GenericParamContext gpContext) => null;

		/// <summary>
		/// Gets all <see cref="AssemblyRef"/>s
		/// </summary>
		public IEnumerable<AssemblyRef> GetAssemblyRefs() {
			for (uint rid = 1; ; rid++) {
				var asmRef = ResolveToken(new MDToken(Table.AssemblyRef, rid).Raw) as AssemblyRef;
				if (asmRef is null)
					break;
				yield return asmRef;
			}
		}

		/// <summary>
		/// Gets all <see cref="ModuleRef"/>s
		/// </summary>
		public IEnumerable<ModuleRef> GetModuleRefs() {
			for (uint rid = 1; ; rid++) {
				var modRef = ResolveToken(new MDToken(Table.ModuleRef, rid).Raw) as ModuleRef;
				if (modRef is null)
					break;
				yield return modRef;
			}
		}

		/// <summary>
		/// Gets all <see cref="MemberRef"/>s. <see cref="MemberRef"/>s with generic parameters
		/// aren't cached and a new copy is always returned.
		/// </summary>
		public IEnumerable<MemberRef> GetMemberRefs() => GetMemberRefs(new GenericParamContext());

		/// <summary>
		/// Gets all <see cref="MemberRef"/>s. <see cref="MemberRef"/>s with generic parameters
		/// aren't cached and a new copy is always returned.
		/// </summary>
		/// <param name="gpContext">Generic parameter context</param>
		public IEnumerable<MemberRef> GetMemberRefs(GenericParamContext gpContext) {
			for (uint rid = 1; ; rid++) {
				var mr = ResolveToken(new MDToken(Table.MemberRef, rid).Raw, gpContext) as MemberRef;
				if (mr is null)
					break;
				yield return mr;
			}
		}

		/// <summary>
		/// Gets all <see cref="TypeRef"/>s
		/// </summary>
		public IEnumerable<TypeRef> GetTypeRefs() {
			for (uint rid = 1; ; rid++) {
				var mr = ResolveToken(new MDToken(Table.TypeRef, rid).Raw) as TypeRef;
				if (mr is null)
					break;
				yield return mr;
			}
		}

		/// <summary>
		/// Finds an assembly reference by name. If there's more than one, pick the one with
		/// the greatest version number.
		/// </summary>
		/// <param name="simpleName">Simple name of assembly (eg. "mscorlib")</param>
		/// <returns>The found <see cref="AssemblyRef"/> or <c>null</c> if there's no such
		/// assembly reference.</returns>
		public AssemblyRef GetAssemblyRef(UTF8String simpleName) {
			AssemblyRef found = null;
			foreach (var asmRef in GetAssemblyRefs()) {
				if (asmRef.Name != simpleName)
					continue;
				if (IsGreaterAssemblyRefVersion(found, asmRef))
					found = asmRef;
			}
			return found;
		}

		/// <summary>
		/// Compare asm refs' version
		/// </summary>
		/// <param name="found">First asm ref</param>
		/// <param name="newOne">New asm ref</param>
		/// <returns></returns>
		protected static bool IsGreaterAssemblyRefVersion(AssemblyRef found, AssemblyRef newOne) {
			if (found is null)
				return true;
			var foundVer = found.Version;
			var newVer = newOne.Version;
			return foundVer is null || (newVer is not null && newVer >= foundVer);
		}

		ITypeDefOrRef ISignatureReaderHelper.ResolveTypeDefOrRef(uint codedToken, GenericParamContext gpContext) {
			if (!CodedToken.TypeDefOrRef.Decode(codedToken, out uint token))
				return null;
			return ResolveToken(token) as ITypeDefOrRef;
		}

		TypeSig ISignatureReaderHelper.ConvertRTInternalAddress(IntPtr address) => null;
	}

	/// <summary>
	/// A Module row created by the user and not present in the original .NET file
	/// </summary>
	public class ModuleDefUser : ModuleDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ModuleDefUser()
			: this(null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <remarks><see cref="ModuleDef.Mvid"/> is initialized to a random <see cref="Guid"/></remarks>
		/// <param name="name">Module nam</param>
		public ModuleDefUser(UTF8String name)
			: this(name, Guid.NewGuid()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Module name</param>
		/// <param name="mvid">Module version ID</param>
		public ModuleDefUser(UTF8String name, Guid? mvid)
			: this(name, mvid, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Module name</param>
		/// <param name="mvid">Module version ID</param>
		/// <param name="corLibAssemblyRef">Corlib assembly ref or <c>null</c></param>
		public ModuleDefUser(UTF8String name, Guid? mvid, AssemblyRef corLibAssemblyRef) {
			Kind = ModuleKind.Windows;
			Characteristics = DefaultCharacteristics;
			DllCharacteristics = DefaultDllCharacteristics;
			RuntimeVersion = MDHeaderRuntimeVersion.MS_CLR_20;
			Machine = Machine.I386;
			cor20HeaderFlags = (int)ComImageFlags.ILOnly;
			Cor20HeaderRuntimeVersion = 0x00020005;	// .NET Framework 2.0 or later should use 2.5
			TablesHeaderVersion = 0x0200;			// .NET Framework 2.0 or later should use 2.0
			types = new LazyList<TypeDef>(this);
			exportedTypes = new LazyList<ExportedType>();
			resources = new ResourceCollection();
			corLibTypes = new CorLibTypes(this, corLibAssemblyRef);
			types = new LazyList<TypeDef>(this);
			this.name = name;
			this.mvid = mvid;
			types.Add(CreateModuleType());
			UpdateRowId(this);
		}

		TypeDef CreateModuleType() {
			var type = UpdateRowId(new TypeDefUser(UTF8String.Empty, "<Module>", null));
			type.Attributes = TypeAttributes.NotPublic | TypeAttributes.AutoLayout | TypeAttributes.Class | TypeAttributes.AnsiClass;
			return type;
		}
	}

	/// <summary>
	/// Created from a row in the Module table
	/// </summary>
	public class ModuleDefMD2 : ModuleDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.Module, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override RVA GetNativeEntryPoint_NoLock() => readerModule.GetNativeEntryPoint();

		/// <inheritdoc/>
		protected override IManagedEntryPoint GetManagedEntryPoint_NoLock() => readerModule.GetManagedEntryPoint();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Module</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		internal ModuleDefMD2(ModuleDefMD readerModule, uint rid) {
			if (rid == 1 && readerModule is null)
				readerModule = (ModuleDefMD)this;
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (rid != 1 && readerModule.TablesStream.ModuleTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"Module rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			if (rid != 1) {
				Kind = ModuleKind.Windows;
				Characteristics = DefaultCharacteristics;
				DllCharacteristics = DefaultDllCharacteristics;
				RuntimeVersion = MDHeaderRuntimeVersion.MS_CLR_20;
				Machine = Machine.I386;
				cor20HeaderFlags = (int)ComImageFlags.ILOnly;
				Cor20HeaderRuntimeVersion = 0x00020005;	// .NET Framework 2.0 or later should use 2.5
				TablesHeaderVersion = 0x0200;			// .NET Framework 2.0 or later should use 2.0
				corLibTypes = new CorLibTypes(this);
				location = string.Empty;
				InitializeFromRawRow();
			}
		}

		/// <summary>
		/// Initialize fields from the raw <c>Module</c> row
		/// </summary>
		protected void InitializeFromRawRow() {
			bool b = readerModule.TablesStream.TryReadModuleRow(origRid, out var row);
			Debug.Assert(b);
			generation = row.Generation;
			mvid = readerModule.GuidStream.Read(row.Mvid);
			encId = readerModule.GuidStream.Read(row.EncId);
			encBaseId = readerModule.GuidStream.Read(row.EncBaseId);
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			if (origRid == 1)
				assembly = readerModule.ResolveAssembly(origRid);
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Created from a row in the Module table
	/// </summary>
	public sealed class ModuleDefMD : ModuleDefMD2, IInstructionOperandResolver {
		/// <summary>The file that contains all .NET metadata</summary>
		MetadataBase metadata;
		IMethodDecrypter methodDecrypter;
		IStringDecrypter stringDecrypter;

		StrongBox<RidList> moduleRidList;

		SimpleLazyList<ModuleDefMD2> listModuleDefMD;
		SimpleLazyList<TypeRefMD> listTypeRefMD;
		SimpleLazyList<TypeDefMD> listTypeDefMD;
		SimpleLazyList<FieldDefMD> listFieldDefMD;
		SimpleLazyList<MethodDefMD> listMethodDefMD;
		SimpleLazyList<ParamDefMD> listParamDefMD;
		SimpleLazyList2<InterfaceImplMD> listInterfaceImplMD;
		SimpleLazyList2<MemberRefMD> listMemberRefMD;
		SimpleLazyList<ConstantMD> listConstantMD;
		SimpleLazyList<DeclSecurityMD> listDeclSecurityMD;
		SimpleLazyList<ClassLayoutMD> listClassLayoutMD;
		SimpleLazyList2<StandAloneSigMD> listStandAloneSigMD;
		SimpleLazyList<EventDefMD> listEventDefMD;
		SimpleLazyList<PropertyDefMD> listPropertyDefMD;
		SimpleLazyList<ModuleRefMD> listModuleRefMD;
		SimpleLazyList2<TypeSpecMD> listTypeSpecMD;
		SimpleLazyList<ImplMapMD> listImplMapMD;
		SimpleLazyList<AssemblyDefMD> listAssemblyDefMD;
		SimpleLazyList<AssemblyRefMD> listAssemblyRefMD;
		SimpleLazyList<FileDefMD> listFileDefMD;
		SimpleLazyList<ExportedTypeMD> listExportedTypeMD;
		SimpleLazyList<ManifestResourceMD> listManifestResourceMD;
		SimpleLazyList<GenericParamMD> listGenericParamMD;
		SimpleLazyList2<MethodSpecMD> listMethodSpecMD;
		SimpleLazyList2<GenericParamConstraintMD> listGenericParamConstraintMD;

		/// <summary>
		/// Gets/sets the method decrypter
		/// </summary>
		public IMethodDecrypter MethodDecrypter {
			get => methodDecrypter;
			set => methodDecrypter = value;
		}

		/// <summary>
		/// Gets/sets the string decrypter
		/// </summary>
		public IStringDecrypter StringDecrypter {
			get => stringDecrypter;
			set => stringDecrypter = value;
		}

		/// <summary>
		/// Returns the .NET metadata interface
		/// </summary>
		public MD.Metadata Metadata => metadata;

		/// <summary>
		/// Returns the #~ or #- tables stream
		/// </summary>
		public TablesStream TablesStream => metadata.TablesStream;

		/// <summary>
		/// Returns the #Strings stream
		/// </summary>
		public StringsStream StringsStream => metadata.StringsStream;

		/// <summary>
		/// Returns the #Blob stream
		/// </summary>
		public BlobStream BlobStream => metadata.BlobStream;

		/// <summary>
		/// Returns the #GUID stream
		/// </summary>
		public GuidStream GuidStream => metadata.GuidStream;

		/// <summary>
		/// Returns the #US stream
		/// </summary>
		public USStream USStream => metadata.USStream;

		/// <inheritdoc/>
		protected override void InitializeTypes() {
			var list = Metadata.GetNonNestedClassRidList();
			var tmp = new LazyList<TypeDef, RidList>(list.Count, this, list, (list2, index) => ResolveTypeDef(list2[index]));
			Interlocked.CompareExchange(ref types, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeExportedTypes() {
			var list = Metadata.GetExportedTypeRidList();
			var tmp = new LazyList<ExportedType, RidList>(list.Count, list, (list2, i) => ResolveExportedType(list2[i]));
			Interlocked.CompareExchange(ref exportedTypes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeResources() {
			var table = TablesStream.ManifestResourceTable;
			var tmp = new ResourceCollection((int)table.Rows, null, (ctx, i) => CreateResource((uint)i + 1));
			Interlocked.CompareExchange(ref resources, tmp, null);
		}

		/// <inheritdoc/>
		protected override Win32Resources GetWin32Resources_NoLock() => metadata.PEImage.Win32Resources;

		/// <inheritdoc/>
		protected override VTableFixups GetVTableFixups_NoLock() {
			var vtableFixupsInfo = metadata.ImageCor20Header.VTableFixups;
			if (vtableFixupsInfo.VirtualAddress == 0 || vtableFixupsInfo.Size == 0)
				return null;
			return new VTableFixups(this);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a file
		/// </summary>
		/// <param name="fileName">File name of an existing .NET module/assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(string fileName, ModuleContext context) => Load(fileName, new ModuleCreationOptions(context));

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a file
		/// </summary>
		/// <param name="fileName">File name of an existing .NET module/assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(string fileName, ModuleCreationOptions options = null) => Load(MetadataFactory.Load(fileName, options?.Runtime ?? CLRRuntimeReaderKind.CLR), options);

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a byte[]
		/// </summary>
		/// <param name="data">Contents of a .NET module/assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(byte[] data, ModuleContext context) => Load(data, new ModuleCreationOptions(context));

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a byte[]
		/// </summary>
		/// <param name="data">Contents of a .NET module/assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(byte[] data, ModuleCreationOptions options = null) => Load(MetadataFactory.Load(data, options?.Runtime ?? CLRRuntimeReaderKind.CLR), options);

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod) => Load(mod, (ModuleCreationOptions)null, GetImageLayout(mod));

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod, ModuleContext context) => Load(mod, new ModuleCreationOptions(context), GetImageLayout(mod));

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod, ModuleCreationOptions options) => Load(mod, options, GetImageLayout(mod));

		static ImageLayout GetImageLayout(System.Reflection.Module mod) {
			var fqn = mod.FullyQualifiedName;
			if (fqn.Length > 0 && fqn[0] == '<' && fqn[fqn.Length - 1] == '>')
				return ImageLayout.File;
			return ImageLayout.Memory;
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <param name="imageLayout">Image layout of the module in memory</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod, ModuleContext context, ImageLayout imageLayout) => Load(mod, new ModuleCreationOptions(context), imageLayout);

		static IntPtr GetModuleHandle(System.Reflection.Module mod) {
#if NETSTANDARD
			var GetHINSTANCE = typeof(Marshal).GetMethod("GetHINSTANCE", new[] { typeof(System.Reflection.Module) });
			if (GetHINSTANCE is null)
				return IntPtr.Zero;

			return (IntPtr)GetHINSTANCE.Invoke(null, new[] { mod });
#else
			return Marshal.GetHINSTANCE(mod);
#endif
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a reflection module
		/// </summary>
		/// <param name="mod">An existing reflection module</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <param name="imageLayout">Image layout of the module in memory</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(System.Reflection.Module mod, ModuleCreationOptions options, ImageLayout imageLayout) {
			var addr = GetModuleHandle(mod);
			if (addr != IntPtr.Zero && addr != new IntPtr(-1))
				return Load(addr, options, imageLayout);
			var location = mod.FullyQualifiedName;
			if (string.IsNullOrEmpty(location) || location[0] == '<')
				throw new InvalidOperationException($"Module {mod} has no HINSTANCE");
			return Load(location, options);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr) => Load(MetadataFactory.Load(addr, CLRRuntimeReaderKind.CLR), (ModuleCreationOptions)null);

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr, ModuleContext context) => Load(MetadataFactory.Load(addr, CLRRuntimeReaderKind.CLR), new ModuleCreationOptions(context));

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr, ModuleCreationOptions options) => Load(MetadataFactory.Load(addr, options?.Runtime ?? CLRRuntimeReaderKind.CLR), options);

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance
		/// </summary>
		/// <param name="peImage">PE image</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IPEImage peImage) => Load(MetadataFactory.Load(peImage, CLRRuntimeReaderKind.CLR), (ModuleCreationOptions)null);

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance
		/// </summary>
		/// <param name="peImage">PE image</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IPEImage peImage, ModuleContext context) => Load(MetadataFactory.Load(peImage, CLRRuntimeReaderKind.CLR), new ModuleCreationOptions(context));

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance
		/// </summary>
		/// <param name="peImage">PE image</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IPEImage peImage, ModuleCreationOptions options) => Load(MetadataFactory.Load(peImage, options?.Runtime ?? CLRRuntimeReaderKind.CLR), options);

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <param name="imageLayout">Image layout of the file in memory</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr, ModuleContext context, ImageLayout imageLayout) => Load(MetadataFactory.Load(addr, imageLayout, CLRRuntimeReaderKind.CLR), new ModuleCreationOptions(context));

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a memory location
		/// </summary>
		/// <param name="addr">Address of a .NET module/assembly</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <param name="imageLayout">Image layout of the file in memory</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		public static ModuleDefMD Load(IntPtr addr, ModuleCreationOptions options, ImageLayout imageLayout) => Load(MetadataFactory.Load(addr, imageLayout, options?.Runtime ?? CLRRuntimeReaderKind.CLR), options);

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleCreationOptions)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream (owned by caller)</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		public static ModuleDefMD Load(Stream stream) => Load(stream, (ModuleCreationOptions)null);

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleContext)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream (owned by caller)</param>
		/// <param name="context">Module context or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		public static ModuleDefMD Load(Stream stream, ModuleContext context) => Load(stream, new ModuleCreationOptions(context));

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a stream
		/// </summary>
		/// <remarks>This will read all bytes from the stream and call <see cref="Load(byte[],ModuleContext)"/>.
		/// It's better to use one of the other Load() methods.</remarks>
		/// <param name="stream">The stream (owned by caller)</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance</returns>
		/// <exception cref="ArgumentNullException">If <paramref name="stream"/> is <c>null</c></exception>
		public static ModuleDefMD Load(Stream stream, ModuleCreationOptions options) {
			if (stream is null)
				throw new ArgumentNullException(nameof(stream));
			if (stream.Length > int.MaxValue)
				throw new ArgumentException("Stream is too big");
			var data = new byte[(int)stream.Length];
			stream.Position = 0;
			if (stream.Read(data, 0, data.Length) != data.Length)
				throw new IOException("Could not read all bytes from the stream");
			return Load(data, options);
		}

		/// <summary>
		/// Creates a <see cref="ModuleDefMD"/> instance from a <see cref="Metadata"/>
		/// </summary>
		/// <param name="metadata">The metadata</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance that now owns <paramref name="metadata"/></returns>
		internal static ModuleDefMD Load(MetadataBase metadata, ModuleCreationOptions options) => new ModuleDefMD(metadata, options);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">The metadata</param>
		/// <param name="options">Module creation options or <c>null</c></param>
		/// <exception cref="ArgumentNullException">If <paramref name="metadata"/> is <c>null</c></exception>
		ModuleDefMD(MetadataBase metadata, ModuleCreationOptions options)
			: base(null, 1) {
#if DEBUG
			if (metadata is null)
				throw new ArgumentNullException(nameof(metadata));
#endif
			if (options is null)
				options = ModuleCreationOptions.Default;
			this.metadata = metadata;
			context = options.Context;
			Initialize();
			InitializeFromRawRow();
			location = metadata.PEImage.Filename ?? string.Empty;

			Kind = GetKind();
			Characteristics = Metadata.PEImage.ImageNTHeaders.FileHeader.Characteristics;
			DllCharacteristics = Metadata.PEImage.ImageNTHeaders.OptionalHeader.DllCharacteristics;
			RuntimeVersion = Metadata.VersionString;
			Machine = Metadata.PEImage.ImageNTHeaders.FileHeader.Machine;
			Cor20HeaderFlags = Metadata.ImageCor20Header.Flags;
			Cor20HeaderRuntimeVersion = (uint)(Metadata.ImageCor20Header.MajorRuntimeVersion << 16) | Metadata.ImageCor20Header.MinorRuntimeVersion;
			TablesHeaderVersion = Metadata.TablesStream.Version;
			corLibTypes = new CorLibTypes(this, options.CorLibAssemblyRef ?? FindCorLibAssemblyRef() ?? CreateDefaultCorLibAssemblyRef());
			InitializePdb(options);
		}

		void InitializePdb(ModuleCreationOptions options) {
			if (options is null)
				return;
			LoadPdb(CreateSymbolReader(options));
		}

		SymbolReader CreateSymbolReader(ModuleCreationOptions options) {
			if (options.PdbFileOrData is not null) {
				var pdbFileName = options.PdbFileOrData as string;
				if (!string.IsNullOrEmpty(pdbFileName)) {
					var symReader = Pdb.SymbolReaderFactory.Create(options.PdbOptions, metadata, pdbFileName);
					if (symReader is not null)
						return symReader;
				}

				if (options.PdbFileOrData is byte[] pdbData)
					return Pdb.SymbolReaderFactory.Create(options.PdbOptions, metadata, pdbData);

				if (options.PdbFileOrData is DataReaderFactory pdbStream)
					return Pdb.SymbolReaderFactory.Create(options.PdbOptions, metadata, pdbStream);
			}

			if (options.TryToLoadPdbFromDisk)
				return Pdb.SymbolReaderFactory.CreateFromAssemblyFile(options.PdbOptions, metadata, location ?? string.Empty);

			return null;
		}

		/// <summary>
		/// Loads symbols using <paramref name="symbolReader"/>
		/// </summary>
		/// <param name="symbolReader">PDB symbol reader</param>
		public void LoadPdb(SymbolReader symbolReader) {
			if (symbolReader is null)
				return;
			if (pdbState is not null)
				throw new InvalidOperationException("PDB file has already been initialized");

			var orig = Interlocked.CompareExchange(ref pdbState, new PdbState(symbolReader, this), null);
			if (orig is not null)
				throw new InvalidOperationException("PDB file has already been initialized");
		}

		/// <summary>
		/// Loads symbols from a PDB file
		/// </summary>
		/// <param name="pdbFileName">PDB file name</param>
		public void LoadPdb(string pdbFileName) =>
			LoadPdb(ModuleCreationOptions.DefaultPdbReaderOptions, pdbFileName);

		/// <summary>
		/// Loads symbols from a PDB file
		/// </summary>
		/// <param name="options">PDB reader options</param>
		/// <param name="pdbFileName">PDB file name</param>
		public void LoadPdb(PdbReaderOptions options, string pdbFileName) =>
			LoadPdb(Pdb.SymbolReaderFactory.Create(options, metadata, pdbFileName));

		/// <summary>
		/// Loads symbols from a byte array
		/// </summary>
		/// <param name="pdbData">PDB data</param>
		public void LoadPdb(byte[] pdbData) =>
			LoadPdb(ModuleCreationOptions.DefaultPdbReaderOptions, pdbData);

		/// <summary>
		/// Loads symbols from a byte array
		/// </summary>
		/// <param name="options">PDB reader options</param>
		/// <param name="pdbData">PDB data</param>
		public void LoadPdb(PdbReaderOptions options, byte[] pdbData) =>
			LoadPdb(Pdb.SymbolReaderFactory.Create(options, metadata, pdbData));

		/// <summary>
		/// Loads symbols from a stream
		/// </summary>
		/// <param name="pdbStream">PDB file stream which is now owned by us</param>
		public void LoadPdb(DataReaderFactory pdbStream) =>
			LoadPdb(ModuleCreationOptions.DefaultPdbReaderOptions, pdbStream);

		/// <summary>
		/// Loads symbols from a stream
		/// </summary>
		/// <param name="options">PDB reader options</param>
		/// <param name="pdbStream">PDB file stream which is now owned by us</param>
		public void LoadPdb(PdbReaderOptions options, DataReaderFactory pdbStream) =>
			LoadPdb(Pdb.SymbolReaderFactory.Create(options, metadata, pdbStream));

		/// <summary>
		/// Loads symbols if a PDB file is available
		/// </summary>
		public void LoadPdb() =>
			LoadPdb(ModuleCreationOptions.DefaultPdbReaderOptions);

		/// <summary>
		/// Loads symbols if a PDB file is available
		/// </summary>
		/// <param name="options">PDB reader options</param>
		public void LoadPdb(PdbReaderOptions options) =>
			LoadPdb(Pdb.SymbolReaderFactory.CreateFromAssemblyFile(options, metadata, location ?? string.Empty));

		internal void InitializeCustomDebugInfos(MDToken token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
			var ps = pdbState;
			if (ps is null)
				return;
			ps.InitializeCustomDebugInfos(token, gpContext, result);
		}

		ModuleKind GetKind() {
			if (TablesStream.AssemblyTable.Rows < 1)
				return ModuleKind.NetModule;

			var peImage = Metadata.PEImage;
			if ((peImage.ImageNTHeaders.FileHeader.Characteristics & Characteristics.Dll) != 0)
				return ModuleKind.Dll;

			return peImage.ImageNTHeaders.OptionalHeader.Subsystem switch {
				Subsystem.WindowsCui => ModuleKind.Console,
				_ => ModuleKind.Windows,
			};
		}

		void Initialize() {
			var ts = metadata.TablesStream;

			listModuleDefMD = new SimpleLazyList<ModuleDefMD2>(ts.ModuleTable.Rows, rid2 => rid2 == 1 ? this : new ModuleDefMD2(this, rid2));
			listTypeRefMD = new SimpleLazyList<TypeRefMD>(ts.TypeRefTable.Rows, rid2 => new TypeRefMD(this, rid2));
			listTypeDefMD = new SimpleLazyList<TypeDefMD>(ts.TypeDefTable.Rows, rid2 => new TypeDefMD(this, rid2));
			listFieldDefMD = new SimpleLazyList<FieldDefMD>(ts.FieldTable.Rows, rid2 => new FieldDefMD(this, rid2));
			listMethodDefMD = new SimpleLazyList<MethodDefMD>(ts.MethodTable.Rows, rid2 => new MethodDefMD(this, rid2));
			listParamDefMD = new SimpleLazyList<ParamDefMD>(ts.ParamTable.Rows, rid2 => new ParamDefMD(this, rid2));
			listInterfaceImplMD = new SimpleLazyList2<InterfaceImplMD>(ts.InterfaceImplTable.Rows, (rid2, gpContext) => new InterfaceImplMD(this, rid2, gpContext));
			listMemberRefMD = new SimpleLazyList2<MemberRefMD>(ts.MemberRefTable.Rows, (rid2, gpContext) => new MemberRefMD(this, rid2, gpContext));
			listConstantMD = new SimpleLazyList<ConstantMD>(ts.ConstantTable.Rows, rid2 => new ConstantMD(this, rid2));
			listDeclSecurityMD = new SimpleLazyList<DeclSecurityMD>(ts.DeclSecurityTable.Rows, rid2 => new DeclSecurityMD(this, rid2));
			listClassLayoutMD = new SimpleLazyList<ClassLayoutMD>(ts.ClassLayoutTable.Rows, rid2 => new ClassLayoutMD(this, rid2));
			listStandAloneSigMD = new SimpleLazyList2<StandAloneSigMD>(ts.StandAloneSigTable.Rows, (rid2, gpContext) => new StandAloneSigMD(this, rid2, gpContext));
			listEventDefMD = new SimpleLazyList<EventDefMD>(ts.EventTable.Rows, rid2 => new EventDefMD(this, rid2));
			listPropertyDefMD = new SimpleLazyList<PropertyDefMD>(ts.PropertyTable.Rows, rid2 => new PropertyDefMD(this, rid2));
			listModuleRefMD = new SimpleLazyList<ModuleRefMD>(ts.ModuleRefTable.Rows, rid2 => new ModuleRefMD(this, rid2));
			listTypeSpecMD = new SimpleLazyList2<TypeSpecMD>(ts.TypeSpecTable.Rows, (rid2, gpContext) => new TypeSpecMD(this, rid2, gpContext));
			listImplMapMD = new SimpleLazyList<ImplMapMD>(ts.ImplMapTable.Rows, rid2 => new ImplMapMD(this, rid2));
			listAssemblyDefMD = new SimpleLazyList<AssemblyDefMD>(ts.AssemblyTable.Rows, rid2 => new AssemblyDefMD(this, rid2));
			listFileDefMD = new SimpleLazyList<FileDefMD>(ts.FileTable.Rows, rid2 => new FileDefMD(this, rid2));
			listAssemblyRefMD = new SimpleLazyList<AssemblyRefMD>(ts.AssemblyRefTable.Rows, rid2 => new AssemblyRefMD(this, rid2));
			listExportedTypeMD = new SimpleLazyList<ExportedTypeMD>(ts.ExportedTypeTable.Rows, rid2 => new ExportedTypeMD(this, rid2));
			listManifestResourceMD = new SimpleLazyList<ManifestResourceMD>(ts.ManifestResourceTable.Rows, rid2 => new ManifestResourceMD(this, rid2));
			listGenericParamMD = new SimpleLazyList<GenericParamMD>(ts.GenericParamTable.Rows, rid2 => new GenericParamMD(this, rid2));
			listMethodSpecMD = new SimpleLazyList2<MethodSpecMD>(ts.MethodSpecTable.Rows, (rid2, gpContext) => new MethodSpecMD(this, rid2, gpContext));
			listGenericParamConstraintMD = new SimpleLazyList2<GenericParamConstraintMD>(ts.GenericParamConstraintTable.Rows, (rid2, gpContext) => new GenericParamConstraintMD(this, rid2, gpContext));

			for (int i = 0; i < 64; i++) {
				var tbl = TablesStream.Get((Table)i);
				lastUsedRids[i] = tbl is null ? 0 : (int)tbl.Rows;
			}
		}

		static readonly Dictionary<string, int> preferredCorLibs = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase) {
			// .NET Framework
			{ "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", 100 },
			{ "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", 90 },
			{ "mscorlib, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", 60 },
			{ "mscorlib, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", 50 },

			// Silverlight
			{ "mscorlib, Version=5.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e", 80 },
			{ "mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e", 70 },

			// Zune
			{ "mscorlib, Version=3.5.0.0, Culture=neutral, PublicKeyToken=e92a8b81eba7ceb7", 60 },

			// Compact Framework
			{ "mscorlib, Version=3.5.0.0, Culture=neutral, PublicKeyToken=969db8053d3322ac", 60 },
			{ "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=969db8053d3322ac", 50 },
		};
		static readonly string[] corlibs = new string[] {
			"System.Private.CoreLib",
			"System.Runtime",
			"netstandard",
			"mscorlib",
		};

		/// <summary>
		/// Finds a mscorlib <see cref="AssemblyRef"/>
		/// </summary>
		/// <returns>An existing <see cref="AssemblyRef"/> instance or <c>null</c> if it wasn't found</returns>
		AssemblyRef FindCorLibAssemblyRef() {
			var numAsmRefs = TablesStream.AssemblyRefTable.Rows;
			AssemblyRef corLibAsmRef = null;

			int currentPriority = int.MinValue;
			for (uint i = 1; i <= numAsmRefs; i++) {
				var asmRef = ResolveAssemblyRef(i);
				if (!preferredCorLibs.TryGetValue(asmRef.FullName, out int priority))
					continue;
				if (priority > currentPriority) {
					currentPriority = priority;
					corLibAsmRef = asmRef;
				}
			}
			if (corLibAsmRef is not null)
				return corLibAsmRef;

			foreach (var corlib in corlibs) {
				for (uint i = 1; i <= numAsmRefs; i++) {
					var asmRef = ResolveAssemblyRef(i);
					if (!UTF8String.ToSystemStringOrEmpty(asmRef.Name).Equals(corlib, StringComparison.OrdinalIgnoreCase))
						continue;
					if (IsGreaterAssemblyRefVersion(corLibAsmRef, asmRef))
						corLibAsmRef = asmRef;
				}
				if (corLibAsmRef is not null)
					return corLibAsmRef;
			}

			// If we've loaded mscorlib itself, it won't have any AssemblyRefs to itself.
			var asm = Assembly;
			if (asm is not null && (asm.IsCorLib() || Find("System.Object", false) is not null)) {
				IsCoreLibraryModule = true;
				return UpdateRowId(new AssemblyRefUser(asm));
			}

			return corLibAsmRef;
		}

		/// <summary>
		/// Called when no corlib assembly reference was found
		/// </summary>
		/// <returns></returns>
		AssemblyRef CreateDefaultCorLibAssemblyRef() {
			var asmRef = GetAlternativeCorLibReference();
			if (asmRef is not null)
				return UpdateRowId(asmRef);

			if (IsClr40)
				return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR40());
			if (IsClr20)
				return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR20());
			if (IsClr11)
				return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR11());
			if (IsClr10)
				return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR10());
			return UpdateRowId(AssemblyRefUser.CreateMscorlibReferenceCLR40());
		}

		AssemblyRef GetAlternativeCorLibReference() {
			foreach (var asmRef in GetAssemblyRefs()) {
				if (IsAssemblyRef(asmRef, systemRuntimeName, contractsPublicKeyToken))
					return asmRef;
			}
			foreach (var asmRef in GetAssemblyRefs()) {
				if (IsAssemblyRef(asmRef, corefxName, contractsPublicKeyToken))
					return asmRef;
			}
			return null;
		}

		static bool IsAssemblyRef(AssemblyRef asmRef, UTF8String name, PublicKeyToken token) {
			if (asmRef.Name != name)
				return false;
			var pkot = asmRef.PublicKeyOrToken;
			if (pkot is null)
				return false;
			return token.Equals(pkot.Token);
		}
		static readonly UTF8String systemRuntimeName = new UTF8String("System.Runtime");
		static readonly UTF8String corefxName = new UTF8String("corefx");
		static readonly PublicKeyToken contractsPublicKeyToken = new PublicKeyToken("b03f5f7f11d50a3a");

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			// Call base first since it will dispose of all the resources, which will
			// eventually use metadata that we will dispose
			base.Dispose(disposing);
			if (disposing) {
				var md = metadata;
				if (md is not null)
					md.Dispose();
				metadata = null;
			}
		}

		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="token">The metadata token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public override IMDTokenProvider ResolveToken(uint token, GenericParamContext gpContext) {
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.Module => ResolveModule(rid),
				Table.TypeRef => ResolveTypeRef(rid),
				Table.TypeDef => ResolveTypeDef(rid),
				Table.Field => ResolveField(rid),
				Table.Method => ResolveMethod(rid),
				Table.Param => ResolveParam(rid),
				Table.InterfaceImpl => ResolveInterfaceImpl(rid, gpContext),
				Table.MemberRef => ResolveMemberRef(rid, gpContext),
				Table.Constant => ResolveConstant(rid),
				Table.DeclSecurity => ResolveDeclSecurity(rid),
				Table.ClassLayout => ResolveClassLayout(rid),
				Table.StandAloneSig => ResolveStandAloneSig(rid, gpContext),
				Table.Event => ResolveEvent(rid),
				Table.Property => ResolveProperty(rid),
				Table.ModuleRef => ResolveModuleRef(rid),
				Table.TypeSpec => ResolveTypeSpec(rid, gpContext),
				Table.ImplMap => ResolveImplMap(rid),
				Table.Assembly => ResolveAssembly(rid),
				Table.AssemblyRef => ResolveAssemblyRef(rid),
				Table.File => ResolveFile(rid),
				Table.ExportedType => ResolveExportedType(rid),
				Table.ManifestResource => ResolveManifestResource(rid),
				Table.GenericParam => ResolveGenericParam(rid),
				Table.MethodSpec => ResolveMethodSpec(rid, gpContext),
				Table.GenericParamConstraint => ResolveGenericParamConstraint(rid, gpContext),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="ModuleDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ModuleDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ModuleDef ResolveModule(uint rid) => listModuleDefMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="TypeRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public TypeRef ResolveTypeRef(uint rid) => listTypeRefMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="TypeDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public TypeDef ResolveTypeDef(uint rid) => listTypeDefMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="FieldDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="FieldDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public FieldDef ResolveField(uint rid) => listFieldDefMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="MethodDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="MethodDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MethodDef ResolveMethod(uint rid) => listMethodDefMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="ParamDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ParamDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ParamDef ResolveParam(uint rid) => listParamDefMD[rid - 1];

		/// <summary>
		/// Resolves an <see cref="InterfaceImpl"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="InterfaceImpl"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public InterfaceImpl ResolveInterfaceImpl(uint rid) => listInterfaceImplMD[rid - 1, new GenericParamContext()];

		/// <summary>
		/// Resolves an <see cref="InterfaceImpl"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="InterfaceImpl"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public InterfaceImpl ResolveInterfaceImpl(uint rid, GenericParamContext gpContext) => listInterfaceImplMD[rid - 1, gpContext];

		/// <summary>
		/// Resolves a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="MemberRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MemberRef ResolveMemberRef(uint rid) => listMemberRefMD[rid - 1, new GenericParamContext()];

		/// <summary>
		/// Resolves a <see cref="MemberRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="MemberRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MemberRef ResolveMemberRef(uint rid, GenericParamContext gpContext) => listMemberRefMD[rid - 1, gpContext];

		/// <summary>
		/// Resolves a <see cref="Constant"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="Constant"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public Constant ResolveConstant(uint rid) => listConstantMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="DeclSecurity"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="DeclSecurity"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public DeclSecurity ResolveDeclSecurity(uint rid) => listDeclSecurityMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="ClassLayout"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ClassLayout"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ClassLayout ResolveClassLayout(uint rid) => listClassLayoutMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="StandAloneSig"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="StandAloneSig"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public StandAloneSig ResolveStandAloneSig(uint rid) => listStandAloneSigMD[rid - 1, new GenericParamContext()];

		/// <summary>
		/// Resolves a <see cref="StandAloneSig"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="StandAloneSig"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public StandAloneSig ResolveStandAloneSig(uint rid, GenericParamContext gpContext) => listStandAloneSigMD[rid - 1, gpContext];

		/// <summary>
		/// Resolves an <see cref="EventDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="EventDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public EventDef ResolveEvent(uint rid) => listEventDefMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="PropertyDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="PropertyDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public PropertyDef ResolveProperty(uint rid) => listPropertyDefMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="ModuleRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ModuleRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ModuleRef ResolveModuleRef(uint rid) => listModuleRefMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="TypeSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public TypeSpec ResolveTypeSpec(uint rid) => listTypeSpecMD[rid - 1, new GenericParamContext()];

		/// <summary>
		/// Resolves a <see cref="TypeSpec"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="TypeSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public TypeSpec ResolveTypeSpec(uint rid, GenericParamContext gpContext) => listTypeSpecMD[rid - 1, gpContext];

		/// <summary>
		/// Resolves an <see cref="ImplMap"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ImplMap"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ImplMap ResolveImplMap(uint rid) => listImplMapMD[rid - 1];

		/// <summary>
		/// Resolves an <see cref="AssemblyDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="AssemblyDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public AssemblyDef ResolveAssembly(uint rid) => listAssemblyDefMD[rid - 1];

		/// <summary>
		/// Resolves an <see cref="AssemblyRef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="AssemblyRef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public AssemblyRef ResolveAssemblyRef(uint rid) => listAssemblyRefMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="FileDef"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="FileDef"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public FileDef ResolveFile(uint rid) => listFileDefMD[rid - 1];

		/// <summary>
		/// Resolves an <see cref="ExportedType"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ExportedType"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ExportedType ResolveExportedType(uint rid) => listExportedTypeMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="ManifestResource"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="ManifestResource"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public ManifestResource ResolveManifestResource(uint rid) => listManifestResourceMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="GenericParam"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="GenericParam"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public GenericParam ResolveGenericParam(uint rid) => listGenericParamMD[rid - 1];

		/// <summary>
		/// Resolves a <see cref="MethodSpec"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="MethodSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MethodSpec ResolveMethodSpec(uint rid) => listMethodSpecMD[rid - 1, new GenericParamContext()];

		/// <summary>
		/// Resolves a <see cref="MethodSpec"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="MethodSpec"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public MethodSpec ResolveMethodSpec(uint rid, GenericParamContext gpContext) => listMethodSpecMD[rid - 1, gpContext];

		/// <summary>
		/// Resolves a <see cref="GenericParamConstraint"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <returns>A <see cref="GenericParamConstraint"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public GenericParamConstraint ResolveGenericParamConstraint(uint rid) => listGenericParamConstraintMD[rid - 1, new GenericParamContext()];

		/// <summary>
		/// Resolves a <see cref="GenericParamConstraint"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="GenericParamConstraint"/> instance or <c>null</c> if <paramref name="rid"/> is invalid</returns>
		public GenericParamConstraint ResolveGenericParamConstraint(uint rid, GenericParamContext gpContext) => listGenericParamConstraintMD[rid - 1, gpContext];

		/// <summary>
		/// Resolves a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>TypeDefOrRef</c> coded token</param>
		/// <returns>A <see cref="ITypeDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ITypeDefOrRef ResolveTypeDefOrRef(uint codedToken) => ResolveTypeDefOrRef(codedToken, new GenericParamContext());

		/// <summary>
		/// Resolves a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>TypeDefOrRef</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="ITypeDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ITypeDefOrRef ResolveTypeDefOrRef(uint codedToken, GenericParamContext gpContext) {
			if (!CodedToken.TypeDefOrRef.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.TypeDef => ResolveTypeDef(rid),
				Table.TypeRef => ResolveTypeRef(rid),
				Table.TypeSpec => ResolveTypeSpec(rid, gpContext),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="IHasConstant"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasConstant</c> coded token</param>
		/// <returns>A <see cref="IHasConstant"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasConstant ResolveHasConstant(uint codedToken) {
			if (!CodedToken.HasConstant.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.Field => ResolveField(rid),
				Table.Param => ResolveParam(rid),
				Table.Property => ResolveProperty(rid),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="IHasCustomAttribute"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasCustomAttribute</c> coded token</param>
		/// <returns>A <see cref="IHasCustomAttribute"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasCustomAttribute ResolveHasCustomAttribute(uint codedToken) => ResolveHasCustomAttribute(codedToken, new GenericParamContext());

		/// <summary>
		/// Resolves a <see cref="IHasCustomAttribute"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasCustomAttribute</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IHasCustomAttribute"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasCustomAttribute ResolveHasCustomAttribute(uint codedToken, GenericParamContext gpContext) {
			if (!CodedToken.HasCustomAttribute.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.Method => ResolveMethod(rid),
				Table.Field => ResolveField(rid),
				Table.TypeRef => ResolveTypeRef(rid),
				Table.TypeDef => ResolveTypeDef(rid),
				Table.Param => ResolveParam(rid),
				Table.InterfaceImpl => ResolveInterfaceImpl(rid, gpContext),
				Table.MemberRef => ResolveMemberRef(rid, gpContext),
				Table.Module => ResolveModule(rid),
				Table.DeclSecurity => ResolveDeclSecurity(rid),
				Table.Property => ResolveProperty(rid),
				Table.Event => ResolveEvent(rid),
				Table.StandAloneSig => ResolveStandAloneSig(rid, gpContext),
				Table.ModuleRef => ResolveModuleRef(rid),
				Table.TypeSpec => ResolveTypeSpec(rid, gpContext),
				Table.Assembly => ResolveAssembly(rid),
				Table.AssemblyRef => ResolveAssemblyRef(rid),
				Table.File => ResolveFile(rid),
				Table.ExportedType => ResolveExportedType(rid),
				Table.ManifestResource => ResolveManifestResource(rid),
				Table.GenericParam => ResolveGenericParam(rid),
				Table.MethodSpec => ResolveMethodSpec(rid, gpContext),
				Table.GenericParamConstraint => ResolveGenericParamConstraint(rid, gpContext),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="IHasFieldMarshal"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasFieldMarshal</c> coded token</param>
		/// <returns>A <see cref="IHasFieldMarshal"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasFieldMarshal ResolveHasFieldMarshal(uint codedToken) {
			if (!CodedToken.HasFieldMarshal.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.Field => ResolveField(rid),
				Table.Param => ResolveParam(rid),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="IHasDeclSecurity"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasDeclSecurity</c> coded token</param>
		/// <returns>A <see cref="IHasDeclSecurity"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasDeclSecurity ResolveHasDeclSecurity(uint codedToken) {
			if (!CodedToken.HasDeclSecurity.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.TypeDef => ResolveTypeDef(rid),
				Table.Method => ResolveMethod(rid),
				Table.Assembly => ResolveAssembly(rid),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="IMemberRefParent"/>
		/// </summary>
		/// <param name="codedToken">A <c>MemberRefParent</c> coded token</param>
		/// <returns>A <see cref="IMemberRefParent"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMemberRefParent ResolveMemberRefParent(uint codedToken) => ResolveMemberRefParent(codedToken, new GenericParamContext());

		/// <summary>
		/// Resolves a <see cref="IMemberRefParent"/>
		/// </summary>
		/// <param name="codedToken">A <c>MemberRefParent</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMemberRefParent"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMemberRefParent ResolveMemberRefParent(uint codedToken, GenericParamContext gpContext) {
			if (!CodedToken.MemberRefParent.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.TypeDef => ResolveTypeDef(rid),
				Table.TypeRef => ResolveTypeRef(rid),
				Table.ModuleRef => ResolveModuleRef(rid),
				Table.Method => ResolveMethod(rid),
				Table.TypeSpec => ResolveTypeSpec(rid, gpContext),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="IHasSemantic"/>
		/// </summary>
		/// <param name="codedToken">A <c>HasSemantic</c> coded token</param>
		/// <returns>A <see cref="IHasSemantic"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IHasSemantic ResolveHasSemantic(uint codedToken) {
			if (!CodedToken.HasSemantic.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.Event => ResolveEvent(rid),
				Table.Property => ResolveProperty(rid),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="IMethodDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>MethodDefOrRef</c> coded token</param>
		/// <returns>A <see cref="IMethodDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMethodDefOrRef ResolveMethodDefOrRef(uint codedToken) => ResolveMethodDefOrRef(codedToken, new GenericParamContext());

		/// <summary>
		/// Resolves a <see cref="IMethodDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>MethodDefOrRef</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="IMethodDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMethodDefOrRef ResolveMethodDefOrRef(uint codedToken, GenericParamContext gpContext) {
			if (!CodedToken.MethodDefOrRef.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.Method => ResolveMethod(rid),
				Table.MemberRef => ResolveMemberRef(rid, gpContext),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="IMemberForwarded"/>
		/// </summary>
		/// <param name="codedToken">A <c>MemberForwarded</c> coded token</param>
		/// <returns>A <see cref="IMemberForwarded"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IMemberForwarded ResolveMemberForwarded(uint codedToken) {
			if (!CodedToken.MemberForwarded.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.Field => ResolveField(rid),
				Table.Method => ResolveMethod(rid),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves an <see cref="IImplementation"/>
		/// </summary>
		/// <param name="codedToken">An <c>Implementation</c> coded token</param>
		/// <returns>A <see cref="IImplementation"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IImplementation ResolveImplementation(uint codedToken) {
			if (!CodedToken.Implementation.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.File => ResolveFile(rid),
				Table.AssemblyRef => ResolveAssemblyRef(rid),
				Table.ExportedType => ResolveExportedType(rid),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="ICustomAttributeType"/>
		/// </summary>
		/// <param name="codedToken">A <c>CustomAttributeType</c> coded token</param>
		/// <returns>A <see cref="ICustomAttributeType"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ICustomAttributeType ResolveCustomAttributeType(uint codedToken) => ResolveCustomAttributeType(codedToken, new GenericParamContext());

		/// <summary>
		/// Resolves a <see cref="ICustomAttributeType"/>
		/// </summary>
		/// <param name="codedToken">A <c>CustomAttributeType</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="ICustomAttributeType"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ICustomAttributeType ResolveCustomAttributeType(uint codedToken, GenericParamContext gpContext) {
			if (!CodedToken.CustomAttributeType.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.Method => ResolveMethod(rid),
				Table.MemberRef => ResolveMemberRef(rid, gpContext),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="IResolutionScope"/>
		/// </summary>
		/// <param name="codedToken">A <c>ResolutionScope</c> coded token</param>
		/// <returns>A <see cref="IResolutionScope"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public IResolutionScope ResolveResolutionScope(uint codedToken) {
			if (!CodedToken.ResolutionScope.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.Module => ResolveModule(rid),
				Table.ModuleRef => ResolveModuleRef(rid),
				Table.AssemblyRef => ResolveAssemblyRef(rid),
				Table.TypeRef => ResolveTypeRef(rid),
				_ => null,
			};
		}

		/// <summary>
		/// Resolves a <see cref="ITypeOrMethodDef"/>
		/// </summary>
		/// <param name="codedToken">A <c>TypeOrMethodDef</c>> coded token</param>
		/// <returns>A <see cref="ITypeOrMethodDef"/> or <c>null</c> if <paramref name="codedToken"/> is invalid</returns>
		public ITypeOrMethodDef ResolveTypeOrMethodDef(uint codedToken) {
			if (!CodedToken.TypeOrMethodDef.Decode(codedToken, out uint token))
				return null;
			uint rid = MDToken.ToRID(token);
			return MDToken.ToTable(token) switch {
				Table.TypeDef => ResolveTypeDef(rid),
				Table.Method => ResolveMethod(rid),
				_ => null,
			};
		}

		/// <summary>
		/// Reads a signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public CallingConventionSig ReadSignature(uint sig) => SignatureReader.ReadSig(this, sig, new GenericParamContext());

		/// <summary>
		/// Reads a signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public CallingConventionSig ReadSignature(uint sig, GenericParamContext gpContext) => SignatureReader.ReadSig(this, sig, gpContext);

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public TypeSig ReadTypeSignature(uint sig) => SignatureReader.ReadTypeSig(this, sig, new GenericParamContext());

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public TypeSig ReadTypeSignature(uint sig, GenericParamContext gpContext) => SignatureReader.ReadTypeSig(this, sig, gpContext);

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public TypeSig ReadTypeSignature(uint sig, out byte[] extraData) => SignatureReader.ReadTypeSig(this, sig, new GenericParamContext(), out extraData);

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public TypeSig ReadTypeSignature(uint sig, GenericParamContext gpContext, out byte[] extraData) => SignatureReader.ReadTypeSig(this, sig, gpContext, out extraData);

		/// <summary>
		/// Reads a <see cref="MarshalType"/> from the blob
		/// </summary>
		/// <param name="table">Table of owner</param>
		/// <param name="rid">Row ID of owner</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="MarshalType"/> instance or <c>null</c> if there's no field
		/// marshal for this owner.</returns>
		internal MarshalType ReadMarshalType(Table table, uint rid, GenericParamContext gpContext) {
			if (!TablesStream.TryReadFieldMarshalRow(Metadata.GetFieldMarshalRid(table, rid), out var row))
				return null;
			return MarshalBlobReader.Read(this, row.NativeType, gpContext);
		}

		/// <summary>
		/// Reads a CIL method body
		/// </summary>
		/// <param name="parameters">Method parameters</param>
		/// <param name="rva">RVA</param>
		/// <returns>A new <see cref="CilBody"/> instance. It's empty if RVA is invalid (eg. 0 or
		/// it doesn't point to a CIL method body)</returns>
		public CilBody ReadCilBody(IList<Parameter> parameters, RVA rva) => ReadCilBody(parameters, rva, new GenericParamContext());

		/// <summary>
		/// Reads a CIL method body
		/// </summary>
		/// <param name="parameters">Method parameters</param>
		/// <param name="rva">RVA</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CilBody"/> instance. It's empty if RVA is invalid (eg. 0 or
		/// it doesn't point to a CIL method body)</returns>
		public CilBody ReadCilBody(IList<Parameter> parameters, RVA rva, GenericParamContext gpContext) {
			if (rva == 0)
				return new CilBody();

			// Create a full stream so position will be the real position in the file. This
			// is important when reading exception handlers since those must be 4-byte aligned.
			// If we create a partial stream starting from rva, then position will be 0 and always
			// 4-byte aligned. All fat method bodies should be 4-byte aligned, but the CLR doesn't
			// seem to verify it. We must parse the method exactly the way the CLR parses it.
			var offset = metadata.PEImage.ToFileOffset(rva);
			if (offset == 0)
				return new CilBody();

			var reader = metadata.PEImage.CreateReader();
			reader.Position = (uint)offset;
			return MethodBodyReader.CreateCilBody(this, reader, parameters, gpContext, Context);
		}

		/// <summary>
		/// Returns the owner type of a field
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>The owner type or <c>null</c> if none</returns>
		internal TypeDef GetOwnerType(FieldDefMD field) => ResolveTypeDef(Metadata.GetOwnerTypeOfField(field.OrigRid));

		/// <summary>
		/// Returns the owner type of a method
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>The owner type or <c>null</c> if none</returns>
		internal TypeDef GetOwnerType(MethodDefMD method) => ResolveTypeDef(Metadata.GetOwnerTypeOfMethod(method.OrigRid));

		/// <summary>
		/// Returns the owner type of an event
		/// </summary>
		/// <param name="evt">The event</param>
		/// <returns>The owner type or <c>null</c> if none</returns>
		internal TypeDef GetOwnerType(EventDefMD evt) => ResolveTypeDef(Metadata.GetOwnerTypeOfEvent(evt.OrigRid));

		/// <summary>
		/// Returns the owner type of a property
		/// </summary>
		/// <param name="property">The property</param>
		/// <returns>The owner type or <c>null</c> if none</returns>
		internal TypeDef GetOwnerType(PropertyDefMD property) => ResolveTypeDef(Metadata.GetOwnerTypeOfProperty(property.OrigRid));

		/// <summary>
		/// Returns the owner type/method of a generic param
		/// </summary>
		/// <param name="gp">The generic param</param>
		/// <returns>The owner type/method or <c>null</c> if none</returns>
		internal ITypeOrMethodDef GetOwner(GenericParamMD gp) => ResolveTypeOrMethodDef(Metadata.GetOwnerOfGenericParam(gp.OrigRid));

		/// <summary>
		/// Returns the owner generic param of a generic param constraint
		/// </summary>
		/// <param name="gpc">The generic param constraint</param>
		/// <returns>The owner generic param or <c>null</c> if none</returns>
		internal GenericParam GetOwner(GenericParamConstraintMD gpc) => ResolveGenericParam(Metadata.GetOwnerOfGenericParamConstraint(gpc.OrigRid));

		/// <summary>
		/// Returns the owner method of a param
		/// </summary>
		/// <param name="pd">The param</param>
		/// <returns>The owner method or <c>null</c> if none</returns>
		internal MethodDef GetOwner(ParamDefMD pd) => ResolveMethod(Metadata.GetOwnerOfParam(pd.OrigRid));

		/// <summary>
		/// Reads a module
		/// </summary>
		/// <param name="fileRid">File rid</param>
		/// <param name="owner">The assembly owning the module we should read</param>
		/// <returns>A new <see cref="ModuleDefMD"/> instance or <c>null</c> if <paramref name="fileRid"/>
		/// is invalid or if it's not a .NET module.</returns>
		internal ModuleDefMD ReadModule(uint fileRid, AssemblyDef owner) {
			var fileDef = ResolveFile(fileRid);
			if (fileDef is null)
				return null;
			if (!fileDef.ContainsMetadata)
				return null;
			var fileName = GetValidFilename(GetBaseDirectoryOfImage(), UTF8String.ToSystemString(fileDef.Name));
			if (fileName is null)
				return null;
			ModuleDefMD module;
			try {
				module = Load(fileName);
			}
			catch {
				module = null;
			}
			if (module is not null) {
				// share context
				module.context = context;

				var asm = module.Assembly;
				if (asm is not null && asm != owner)
					asm.Modules.Remove(module);
			}
			return module;
		}

		/// <summary>
		/// Gets a list of all <c>File</c> rids that are .NET modules. Call <see cref="ReadModule(uint,AssemblyDef)"/>
		/// to read one of these modules.
		/// </summary>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		internal RidList GetModuleRidList() {
			if (moduleRidList is null)
				InitializeModuleList();
			return moduleRidList.Value;
		}

		void InitializeModuleList() {
			if (moduleRidList is not null)
				return;
			uint rows = TablesStream.FileTable.Rows;
			var newModuleRidList = new List<uint>((int)rows);

			var baseDir = GetBaseDirectoryOfImage();
			for (uint fileRid = 1; fileRid <= rows; fileRid++) {
				var fileDef = ResolveFile(fileRid);
				if (fileDef is null)
					continue;	// Should never happen
				if (!fileDef.ContainsMetadata)
					continue;
				var pathName = GetValidFilename(baseDir, UTF8String.ToSystemString(fileDef.Name));
				if (pathName is not null)
					newModuleRidList.Add(fileRid);
			}
			Interlocked.CompareExchange(ref moduleRidList, new StrongBox<RidList>(RidList.Create(newModuleRidList)), null);
		}

		/// <summary>
		/// Concatenates the inputs and returns the result if it's a valid path
		/// </summary>
		/// <param name="baseDir">Base dir</param>
		/// <param name="name">File name</param>
		/// <returns>Full path to the file or <c>null</c> if one of the inputs is invalid</returns>
		static string GetValidFilename(string baseDir, string name) {
			if (baseDir is null)
				return null;

			string pathName;
			try {
				if (name.IndexOfAny(Path.GetInvalidPathChars()) >= 0)
					return null;
				pathName = Path.Combine(baseDir, name);
				if (pathName != Path.GetFullPath(pathName))
					return null;
				if (!File.Exists(pathName))
					return null;
			}
			catch {
				return null;
			}

			return pathName;
		}

		/// <summary>
		/// Gets the base directory where this .NET module is located on disk
		/// </summary>
		/// <returns>Base directory or <c>null</c> if unknown or if an error occurred</returns>
		string GetBaseDirectoryOfImage() {
			var imageFileName = Location;
			if (string.IsNullOrEmpty(imageFileName))
				return null;
			try {
				return Path.GetDirectoryName(imageFileName);
			}
			catch (IOException) {
			}
			catch (ArgumentException) {
			}
			return null;
		}

		/// <summary>
		/// Creates a <see cref="Resource"/> instance
		/// </summary>
		/// <param name="rid"><c>ManifestResource</c> rid</param>
		/// <returns>A new <see cref="Resource"/> instance</returns>
		Resource CreateResource(uint rid) {
			if (!TablesStream.TryReadManifestResourceRow(rid, out var row))
				return new EmbeddedResource(UTF8String.Empty, Array2.Empty<byte>(), 0) { Rid = rid };

			if (!CodedToken.Implementation.Decode(row.Implementation, out MDToken token))
				return new EmbeddedResource(UTF8String.Empty, Array2.Empty<byte>(), 0) { Rid = rid };

			var mr = ResolveManifestResource(rid);
			if (mr is null)
				return new EmbeddedResource(UTF8String.Empty, Array2.Empty<byte>(), 0) { Rid = rid };

			if (token.Rid == 0) {
				if (TryCreateResourceStream(mr.Offset, out var dataReaderFactory, out uint resourceOffset, out uint resourceLength))
					return new EmbeddedResourceMD(this, mr, dataReaderFactory, resourceOffset, resourceLength);
				return new EmbeddedResourceMD(this, mr, Array2.Empty<byte>());
			}

			if (mr.Implementation is FileDef file)
				return new LinkedResourceMD(this, mr, file);

			if (mr.Implementation is AssemblyRef asmRef)
				return new AssemblyLinkedResourceMD(this, mr, asmRef);

			return new EmbeddedResourceMD(this, mr, Array2.Empty<byte>());
		}

		[HandleProcessCorruptedStateExceptions, SecurityCritical]	// Req'd on .NET Framework 4.0
		bool TryCreateResourceStream(uint offset, out DataReaderFactory dataReaderFactory, out uint resourceOffset, out uint resourceLength) {
			dataReaderFactory = null;
			resourceOffset = 0;
			resourceLength = 0;

			try {
				var peImage = metadata.PEImage;
				var cor20Header = metadata.ImageCor20Header;
				var resources = cor20Header.Resources;
				if (resources.VirtualAddress == 0 || resources.Size == 0)
					return false;
				var fullReader = peImage.CreateReader();

				var resourcesBaseOffs = (uint)peImage.ToFileOffset(resources.VirtualAddress);
				if (resourcesBaseOffs == 0 || (ulong)resourcesBaseOffs + offset > uint.MaxValue)
					return false;
				if ((ulong)offset + 4 > resources.Size)
					return false;
				if ((ulong)resourcesBaseOffs + offset + 4 > fullReader.Length)
					return false;
				fullReader.Position = resourcesBaseOffs + offset;
				resourceLength = fullReader.ReadUInt32();   // Could throw
				resourceOffset = fullReader.Position;
				if (resourceLength == 0 || (ulong)fullReader.Position + resourceLength > fullReader.Length)
					return false;
				if ((ulong)fullReader.Position - resourcesBaseOffs + resourceLength - 1 >= resources.Size)
					return false;

				if (peImage.MayHaveInvalidAddresses) {
					var rsrcReader = peImage.CreateReader((FileOffset)fullReader.Position, resourceLength);
					for (; rsrcReader.Position < rsrcReader.Length; rsrcReader.Position += Math.Min(rsrcReader.BytesLeft, 0x1000))
						rsrcReader.ReadByte();	// Could throw
					rsrcReader.Position = rsrcReader.Length - 1;	// length is never 0 if we're here
					rsrcReader.ReadByte();	// Could throw
				}

				dataReaderFactory = peImage.DataReaderFactory;
				return true;
			}
			catch (IOException) {
			}
			catch (AccessViolationException) {
			}
			return false;
		}

		/// <summary>
		/// Reads a <see cref="CustomAttribute"/>
		/// </summary>
		/// <param name="caRid">Custom attribute rid</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance or <c>null</c> if
		/// <paramref name="caRid"/> is invalid</returns>
		public CustomAttribute ReadCustomAttribute(uint caRid) => ReadCustomAttribute(caRid, new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="CustomAttribute"/>
		/// </summary>
		/// <param name="caRid">Custom attribute rid</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CustomAttribute"/> instance or <c>null</c> if
		/// <paramref name="caRid"/> is invalid</returns>
		public CustomAttribute ReadCustomAttribute(uint caRid, GenericParamContext gpContext) {
			if (!TablesStream.TryReadCustomAttributeRow(caRid, out var caRow))
				return null;
			return CustomAttributeReader.Read(this, ResolveCustomAttributeType(caRow.Type, gpContext), caRow.Value, gpContext);
		}

		/// <summary>
		/// Reads data somewhere in the address space of the image
		/// </summary>
		/// <param name="rva">RVA of data</param>
		/// <param name="size">Size of data</param>
		/// <returns>All the data or <c>null</c> if <paramref name="rva"/> or <paramref name="size"/>
		/// is invalid</returns>
		public byte[] ReadDataAt(RVA rva, int size) {
			if (size < 0)
				return null;
			var peImage = Metadata.PEImage;
			var reader = peImage.CreateReader(rva, (uint)size);
			if (reader.Length < size)
				return null;
			return reader.ReadBytes(size);
		}

		/// <summary>
		/// Gets the native entry point or 0 if none
		/// </summary>
		public RVA GetNativeEntryPoint() {
			var cor20Header = Metadata.ImageCor20Header;
			if ((cor20Header.Flags & ComImageFlags.NativeEntryPoint) == 0)
				return 0;
			return (RVA)cor20Header.EntryPointToken_or_RVA;
		}

		/// <summary>
		/// Gets the managed entry point (a Method or a File) or null if none
		/// </summary>
		public IManagedEntryPoint GetManagedEntryPoint() {
			var cor20Header = Metadata.ImageCor20Header;
			if ((cor20Header.Flags & ComImageFlags.NativeEntryPoint) != 0)
				return null;
			return ResolveToken(cor20Header.EntryPointToken_or_RVA) as IManagedEntryPoint;
		}

		/// <summary>
		/// Reads a new <see cref="FieldDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="FieldDefMD"/> instance</returns>
		internal FieldDefMD ReadField(uint rid) => new FieldDefMD(this, rid);

		/// <summary>
		/// Reads a new <see cref="MethodDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="MethodDefMD"/> instance</returns>
		internal MethodDefMD ReadMethod(uint rid) => new MethodDefMD(this, rid);

		/// <summary>
		/// Reads a new <see cref="EventDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="EventDefMD"/> instance</returns>
		internal EventDefMD ReadEvent(uint rid) => new EventDefMD(this, rid);

		/// <summary>
		/// Reads a new <see cref="PropertyDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="PropertyDefMD"/> instance</returns>
		internal PropertyDefMD ReadProperty(uint rid) => new PropertyDefMD(this, rid);

		/// <summary>
		/// Reads a new <see cref="ParamDefMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="ParamDefMD"/> instance</returns>
		internal ParamDefMD ReadParam(uint rid) => new ParamDefMD(this, rid);

		/// <summary>
		/// Reads a new <see cref="GenericParamMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="GenericParamMD"/> instance</returns>
		internal GenericParamMD ReadGenericParam(uint rid) => new GenericParamMD(this, rid);

		/// <summary>
		/// Reads a new <see cref="GenericParamConstraintMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <returns>A new <see cref="GenericParamConstraintMD"/> instance</returns>
		internal GenericParamConstraintMD ReadGenericParamConstraint(uint rid) => new GenericParamConstraintMD(this, rid, new GenericParamContext());

		/// <summary>
		/// Reads a new <see cref="GenericParamConstraintMD"/> instance. This one is not cached.
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="GenericParamConstraintMD"/> instance</returns>
		internal GenericParamConstraintMD ReadGenericParamConstraint(uint rid, GenericParamContext gpContext) => new GenericParamConstraintMD(this, rid, gpContext);

		/// <summary>
		/// Reads a method body
		/// </summary>
		/// <param name="method">Method</param>
		/// <param name="rva">Method RVA</param>
		/// <param name="implAttrs">Method impl attrs</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="MethodBody"/> or <c>null</c> if none</returns>
		internal Emit.MethodBody ReadMethodBody(MethodDefMD method, RVA rva, MethodImplAttributes implAttrs, GenericParamContext gpContext) {
			var mDec = methodDecrypter;
			if (mDec is not null && mDec.GetMethodBody(method.OrigRid, rva, method.Parameters, gpContext, out var mb)) {
				if (mb is CilBody cilBody)
					return InitializeBodyFromPdb(method, cilBody);
				return mb;
			}

			if (rva == 0)
				return null;
			var codeType = implAttrs & MethodImplAttributes.CodeTypeMask;
			if (codeType == MethodImplAttributes.IL)
				return InitializeBodyFromPdb(method, ReadCilBody(method.Parameters, rva, gpContext));
			if (codeType == MethodImplAttributes.Native)
				return new NativeMethodBody(rva);
			return null;
		}

		/// <summary>
		/// Updates <paramref name="body"/> with the PDB info (if any)
		/// </summary>
		/// <param name="method">Owner method</param>
		/// <param name="body">Method body</param>
		/// <returns>Returns originak <paramref name="body"/> value</returns>
		CilBody InitializeBodyFromPdb(MethodDefMD method, CilBody body) {
			var ps = pdbState;
			if (ps is not null)
				ps.InitializeMethodBody(this, method, body);
			return body;
		}

		internal void InitializeCustomDebugInfos(MethodDefMD method, CilBody body, IList<PdbCustomDebugInfo> customDebugInfos) {
			if (body is null)
				return;

			var ps = pdbState;
			if (ps is not null)
				ps.InitializeCustomDebugInfos(method, body, customDebugInfos);
		}

		/// <summary>
		/// Reads a string from the #US heap
		/// </summary>
		/// <param name="token">String token</param>
		/// <returns>A non-null string</returns>
		public string ReadUserString(uint token) {
			var sDec = stringDecrypter;
			if (sDec is not null) {
				var s = sDec.ReadUserString(token);
				if (s is not null)
					return s;
			}
			return USStream.ReadNoNull(token & 0x00FFFFFF);
		}

		internal MethodExportInfo GetExportInfo(uint methodRid) {
			if (methodExportInfoProvider is null)
				InitializeMethodExportInfoProvider();
			return methodExportInfoProvider.GetMethodExportInfo(0x06000000 + methodRid);
		}

		void InitializeMethodExportInfoProvider() =>
			Interlocked.CompareExchange(ref methodExportInfoProvider, new MethodExportInfoProvider(this), null);
		MethodExportInfoProvider methodExportInfoProvider;

		/// <summary>
		/// Writes the mixed-mode module to a file on disk. If the file exists, it will be overwritten.
		/// </summary>
		/// <param name="filename">Filename</param>
		public void NativeWrite(string filename) => NativeWrite(filename, null);

		/// <summary>
		/// Writes the mixed-mode module to a file on disk. If the file exists, it will be overwritten.
		/// </summary>
		/// <param name="filename">Filename</param>
		/// <param name="options">Writer options</param>
		public void NativeWrite(string filename, DNW.NativeModuleWriterOptions options) {
			var writer = new DNW.NativeModuleWriter(this, options ?? new DNW.NativeModuleWriterOptions(this, optimizeImageSize: true));
			writer.Write(filename);
		}

		/// <summary>
		/// Writes the mixed-mode module to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		public void NativeWrite(Stream dest) => NativeWrite(dest, null);

		/// <summary>
		/// Writes the mixed-mode module to a stream.
		/// </summary>
		/// <param name="dest">Destination stream</param>
		/// <param name="options">Writer options</param>
		public void NativeWrite(Stream dest, DNW.NativeModuleWriterOptions options) {
			var writer = new DNW.NativeModuleWriter(this, options ?? new DNW.NativeModuleWriterOptions(this, optimizeImageSize: true));
			writer.Write(dest);
		}

		/// <summary>
		/// Reads data from the #Blob. The following columns are returned:
		/// Field.Signature
		/// Method.Signature
		/// MemberRef.Signature
		/// Constant.Value
		/// CustomAttribute.Value
		/// FieldMarshal.NativeType
		/// DeclSecurity.PermissionSet
		/// StandAloneSig.Signature
		/// Property.Type
		/// TypeSpec.Signature
		/// Assembly.PublicKey
		/// AssemblyRef.PublicKeyOrToken
		/// File.HashValue
		/// MethodSpec.Instantiation
		/// </summary>
		/// <param name="token">A token</param>
		/// <returns>The value in the #Blob or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public byte[] ReadBlob(uint token) {
			uint rid = MDToken.ToRID(token);
			switch (MDToken.ToTable(token)) {
			case Table.Field:
				if (!TablesStream.TryReadFieldRow(rid, out var fieldRow))
					break;
				return BlobStream.Read(fieldRow.Signature);

			case Table.Method:
				if (!TablesStream.TryReadMethodRow(rid, out var methodRow))
					break;
				return BlobStream.Read(methodRow.Signature);

			case Table.MemberRef:
				if (!TablesStream.TryReadMemberRefRow(rid, out var mrRow))
					break;
				return BlobStream.Read(mrRow.Signature);

			case Table.Constant:
				if (!TablesStream.TryReadConstantRow(rid, out var constRow))
					break;
				return BlobStream.Read(constRow.Value);

			case Table.CustomAttribute:
				if (!TablesStream.TryReadCustomAttributeRow(rid, out var caRow))
					break;
				return BlobStream.Read(caRow.Value);

			case Table.FieldMarshal:
				if (!TablesStream.TryReadFieldMarshalRow(rid, out var fmRow))
					break;
				return BlobStream.Read(fmRow.NativeType);

			case Table.DeclSecurity:
				if (!TablesStream.TryReadDeclSecurityRow(rid, out var dsRow))
					break;
				return BlobStream.Read(dsRow.PermissionSet);

			case Table.StandAloneSig:
				if (!TablesStream.TryReadStandAloneSigRow(rid, out var sasRow))
					break;
				return BlobStream.Read(sasRow.Signature);

			case Table.Property:
				if (!TablesStream.TryReadPropertyRow(rid, out var propRow))
					break;
				return BlobStream.Read(propRow.Type);

			case Table.TypeSpec:
				if (!TablesStream.TryReadTypeSpecRow(rid, out var tsRow))
					break;
				return BlobStream.Read(tsRow.Signature);

			case Table.Assembly:
				if (!TablesStream.TryReadAssemblyRow(rid, out var asmRow))
					break;
				return BlobStream.Read(asmRow.PublicKey);

			case Table.AssemblyRef:
				// HashValue is also in the #Blob but the user has to read it some other way
				if (!TablesStream.TryReadAssemblyRefRow(rid, out var asmRefRow))
					break;
				return BlobStream.Read(asmRefRow.PublicKeyOrToken);

			case Table.File:
				if (!TablesStream.TryReadFileRow(rid, out var fileRow))
					break;
				return BlobStream.Read(fileRow.HashValue);

			case Table.MethodSpec:
				if (!TablesStream.TryReadMethodSpecRow(rid, out var msRow))
					break;
				return BlobStream.Read(msRow.Instantiation);
			}

			return null;
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Module kind
	/// </summary>
	public enum ModuleKind {
		/// <summary>
		/// Console UI module
		/// </summary>
		Console,

		/// <summary>
		/// Windows GUI module
		/// </summary>
		Windows,

		/// <summary>
		/// DLL module
		/// </summary>
		Dll,

		/// <summary>
		/// Netmodule (it has no assembly manifest)
		/// </summary>
		NetModule,
	}
}





namespace dnlib.DotNet {
	readonly struct ModuleLoader {
		readonly ModuleDef module;
		readonly ICancellationToken cancellationToken;
		readonly Dictionary<object, bool> seen;
		readonly Stack<object> stack;

		ModuleLoader(ModuleDef module, ICancellationToken cancellationToken) {
			const int CAPACITY = 0x4000;
			this.module = module;
			this.cancellationToken = cancellationToken;
			seen = new Dictionary<object, bool>(CAPACITY);
			stack = new Stack<object>(CAPACITY);
		}

		public static void LoadAll(ModuleDef module, ICancellationToken cancellationToken) =>
			new ModuleLoader(module, cancellationToken).Load();

		void Add(UTF8String a) { }
		void Add(Guid? a) { }
		void Add(ushort a) { }
		void Add(AssemblyHashAlgorithm a) { }
		void Add(Version a) { }
		void Add(AssemblyAttributes a) { }
		void Add(PublicKeyBase a) { }
		void Add(RVA a) { }
		void Add(IManagedEntryPoint a) { }
		void Add(string a) { }
		void Add(WinMDStatus a) { }
		void Add(TypeAttributes a) { }
		void Add(FieldAttributes a) { }
		void Add(uint? a) { }
		void Add(byte[] a) { }
		void Add(MethodImplAttributes a) { }
		void Add(MethodAttributes a) { }
		void Add(MethodSemanticsAttributes a) { }
		void Add(ParamAttributes a) { }
		void Add(ElementType a) { }
		void Add(SecurityAction a) { }
		void Add(EventAttributes a) { }
		void Add(PropertyAttributes a) { }
		void Add(PInvokeAttributes a) { }
		void Add(FileAttributes a) { }
		void Add(ManifestResourceAttributes a) { }
		void Add(GenericParamAttributes a) { }
		void Add(NativeType a) { }

		void Load() {
			LoadAllTables();
			Load(module);
			Process();
		}

		void Process() {
			while (stack.Count != 0) {
				if (cancellationToken is not null)
					cancellationToken.ThrowIfCancellationRequested();
				var o = stack.Pop();
				LoadObj(o);
			}
		}

		void LoadAllTables() {
			var resolver = module as ITokenResolver;
			if (resolver is null)
				return;
			for (Table tbl = 0; tbl <= Table.GenericParamConstraint; tbl++) {
				for (uint rid = 1; ; rid++) {
					var o = resolver.ResolveToken(new MDToken(tbl, rid).Raw, new GenericParamContext());
					if (o is null)
						break;
					Add(o);
					Process();
				}
			}
		}

		void LoadObj(object o) {
			if (o is TypeSig ts) {
				Load(ts);
				return;
			}

			if (o is IMDTokenProvider mdt) {
				Load(mdt);
				return;
			}

			if (o is CustomAttribute ca) {
				Load(ca);
				return;
			}

			if (o is SecurityAttribute sa) {
				Load(sa);
				return;
			}

			if (o is CANamedArgument na) {
				Load(na);
				return;
			}

			if (o is Parameter p) {
				Load(p);
				return;
			}

			if (o is PdbMethod pdbMethod) {
				Load(pdbMethod);
				return;
			}

			if (o is ResourceDirectory rd) {
				Load(rd);
				return;
			}

			if (o is ResourceData rdata) {
				Load(rdata);
				return;
			}

			Debug.Fail("Unknown type");
		}

		void Load(TypeSig ts) {
			if (ts is null)
				return;
			Add(ts.Next);

			switch (ts.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.ValueType:
			case ElementType.Class:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
				Add(((TypeDefOrRefSig)ts).TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
				var vsig = (GenericSig)ts;
				Add(vsig.OwnerType);
				Add(vsig.OwnerMethod);
				break;

			case ElementType.GenericInst:
				var gis = (GenericInstSig)ts;
				Add(gis.GenericType);
				Add(gis.GenericArguments);
				break;

			case ElementType.FnPtr:
				var fpsig = (FnPtrSig)ts;
				Add(fpsig.Signature);
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
				var cmod = (ModifierSig)ts;
				Add(cmod.Modifier);
				break;

			case ElementType.End:
			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.ValueArray:
			case ElementType.SZArray:
			case ElementType.Module:
			case ElementType.Pinned:
			case ElementType.Sentinel:
			case ElementType.R:
			case ElementType.Internal:
			default:
				break;
			}
		}

		void Load(IMDTokenProvider mdt) {
			if (mdt is null)
				return;
			switch (mdt.MDToken.Table) {
			case Table.Module:					Load((ModuleDef)mdt); break;
			case Table.TypeRef:					Load((TypeRef)mdt); break;
			case Table.TypeDef:					Load((TypeDef)mdt); break;
			case Table.Field:					Load((FieldDef)mdt); break;
			case Table.Method:					Load((MethodDef)mdt); break;
			case Table.Param:					Load((ParamDef)mdt); break;
			case Table.InterfaceImpl:			Load((InterfaceImpl)mdt); break;
			case Table.MemberRef:				Load((MemberRef)mdt); break;
			case Table.Constant:				Load((Constant)mdt); break;
			case Table.DeclSecurity:			Load((DeclSecurity)mdt); break;
			case Table.ClassLayout:				Load((ClassLayout)mdt); break;
			case Table.StandAloneSig:			Load((StandAloneSig)mdt); break;
			case Table.Event:					Load((EventDef)mdt); break;
			case Table.Property:				Load((PropertyDef)mdt); break;
			case Table.ModuleRef:				Load((ModuleRef)mdt); break;
			case Table.TypeSpec:				Load((TypeSpec)mdt); break;
			case Table.ImplMap:					Load((ImplMap)mdt); break;
			case Table.Assembly:				Load((AssemblyDef)mdt); break;
			case Table.AssemblyRef:				Load((AssemblyRef)mdt); break;
			case Table.File:					Load((FileDef)mdt); break;
			case Table.ExportedType:			Load((ExportedType)mdt); break;
			case Table.GenericParam:			Load((GenericParam)mdt); break;
			case Table.MethodSpec:				Load((MethodSpec)mdt); break;
			case Table.GenericParamConstraint:	Load((GenericParamConstraint)mdt); break;

			case Table.ManifestResource:
				var rsrc = mdt as Resource;
				if (rsrc is not null) {
					Load(rsrc);
					break;
				}

				var mr = mdt as ManifestResource;
				if (mr is not null) {
					Load(mr);
					break;
				}

				Debug.Fail("Unknown ManifestResource");
				break;

			case Table.FieldPtr:
			case Table.MethodPtr:
			case Table.ParamPtr:
			case Table.CustomAttribute:
			case Table.FieldMarshal:
			case Table.FieldLayout:
			case Table.EventMap:
			case Table.EventPtr:
			case Table.PropertyMap:
			case Table.PropertyPtr:
			case Table.MethodSemantics:
			case Table.MethodImpl:
			case Table.FieldRVA:
			case Table.ENCLog:
			case Table.ENCMap:
			case Table.AssemblyProcessor:
			case Table.AssemblyOS:
			case Table.AssemblyRefProcessor:
			case Table.AssemblyRefOS:
			case Table.NestedClass:
			case Table.Document:
			case Table.MethodDebugInformation:
			case Table.LocalScope:
			case Table.LocalVariable:
			case Table.LocalConstant:
			case Table.ImportScope:
			case Table.StateMachineMethod:
			case Table.CustomDebugInformation:
				break;

			default:
				Debug.Fail("Unknown type");
				break;
			}
		}

		void Load(ModuleDef obj) {
			if (obj is null || obj != module)
				return;
			Add(obj.Generation);
			Add(obj.Name);
			Add(obj.Mvid);
			Add(obj.EncId);
			Add(obj.EncBaseId);
			Add(obj.CustomAttributes);
			Add(obj.Assembly);
			Add(obj.Types);
			Add(obj.ExportedTypes);
			Add(obj.NativeEntryPoint);
			Add(obj.ManagedEntryPoint);
			Add(obj.Resources);
			Add(obj.VTableFixups);
			Add(obj.Location);
			Add(obj.Win32Resources);
			Add(obj.RuntimeVersion);
			Add(obj.WinMDStatus);
			Add(obj.RuntimeVersionWinMD);
			Add(obj.WinMDVersion);
			Add(obj.PdbState);
		}

		void Load(TypeRef obj) {
			if (obj is null)
				return;
			Add(obj.ResolutionScope);
			Add(obj.Name);
			Add(obj.Namespace);
			Add(obj.CustomAttributes);
		}

		void Load(TypeDef obj) {
			if (obj is null)
				return;
			Add(obj.Module2);
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Namespace);
			Add(obj.BaseType);
			Add(obj.Fields);
			Add(obj.Methods);
			Add(obj.GenericParameters);
			Add(obj.Interfaces);
			Add(obj.DeclSecurities);
			Add(obj.ClassLayout);
			Add(obj.DeclaringType);
			Add(obj.DeclaringType2);
			Add(obj.NestedTypes);
			Add(obj.Events);
			Add(obj.Properties);
			Add(obj.CustomAttributes);
		}

		void Load(FieldDef obj) {
			if (obj is null)
				return;
			Add(obj.CustomAttributes);
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Signature);
			Add(obj.FieldOffset);
			Add(obj.MarshalType);
			Add(obj.RVA);
			Add(obj.InitialValue);
			Add(obj.ImplMap);
			Add(obj.Constant);
			Add(obj.DeclaringType);
		}

		void Load(MethodDef obj) {
			if (obj is null)
				return;
			Add(obj.RVA);
			Add(obj.ImplAttributes);
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Signature);
			Add(obj.ParamDefs);
			Add(obj.GenericParameters);
			Add(obj.DeclSecurities);
			Add(obj.ImplMap);
			Add(obj.MethodBody);
			Add(obj.CustomAttributes);
			Add(obj.Overrides);
			Add(obj.DeclaringType);
			Add(obj.Parameters);
			Add(obj.SemanticsAttributes);
		}

		void Load(ParamDef obj) {
			if (obj is null)
				return;
			Add(obj.DeclaringMethod);
			Add(obj.Attributes);
			Add(obj.Sequence);
			Add(obj.Name);
			Add(obj.MarshalType);
			Add(obj.Constant);
			Add(obj.CustomAttributes);
		}

		void Load(InterfaceImpl obj) {
			if (obj is null)
				return;
			Add(obj.Interface);
			Add(obj.CustomAttributes);
		}

		void Load(MemberRef obj) {
			if (obj is null)
				return;
			Add(obj.Class);
			Add(obj.Name);
			Add(obj.Signature);
			Add(obj.CustomAttributes);
		}

		void Load(Constant obj) {
			if (obj is null)
				return;
			Add(obj.Type);
			var o = obj.Value;
		}

		void Load(DeclSecurity obj) {
			if (obj is null)
				return;
			Add(obj.Action);
			Add(obj.SecurityAttributes);
			Add(obj.CustomAttributes);
			obj.GetBlob();
		}

		void Load(ClassLayout obj) {
			if (obj is null)
				return;
			Add(obj.PackingSize);
			Add(obj.ClassSize);
		}

		void Load(StandAloneSig obj) {
			if (obj is null)
				return;
			Add(obj.Signature);
			Add(obj.CustomAttributes);
		}

		void Load(EventDef obj) {
			if (obj is null)
				return;
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.EventType);
			Add(obj.CustomAttributes);
			Add(obj.AddMethod);
			Add(obj.InvokeMethod);
			Add(obj.RemoveMethod);
			Add(obj.OtherMethods);
			Add(obj.DeclaringType);
		}

		void Load(PropertyDef obj) {
			if (obj is null)
				return;
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Type);
			Add(obj.Constant);
			Add(obj.CustomAttributes);
			Add(obj.GetMethods);
			Add(obj.SetMethods);
			Add(obj.OtherMethods);
			Add(obj.DeclaringType);
		}

		void Load(ModuleRef obj) {
			if (obj is null)
				return;
			Add(obj.Name);
			Add(obj.CustomAttributes);
		}

		void Load(TypeSpec obj) {
			if (obj is null)
				return;
			Add(obj.TypeSig);
			Add(obj.ExtraData);
			Add(obj.CustomAttributes);
		}

		void Load(ImplMap obj) {
			if (obj is null)
				return;
			Add(obj.Attributes);
			Add(obj.Name);
			Add(obj.Module);
		}

		void Load(AssemblyDef obj) {
			if (obj is null)
				return;
			if (obj.ManifestModule != module)
				return;
			Add(obj.HashAlgorithm);
			Add(obj.Version);
			Add(obj.Attributes);
			Add(obj.PublicKey);
			Add(obj.Name);
			Add(obj.Culture);
			Add(obj.DeclSecurities);
			Add(obj.Modules);
			Add(obj.CustomAttributes);
		}

		void Load(AssemblyRef obj) {
			if (obj is null)
				return;
			Add(obj.Version);
			Add(obj.Attributes);
			Add(obj.PublicKeyOrToken);
			Add(obj.Name);
			Add(obj.Culture);
			Add(obj.Hash);
			Add(obj.CustomAttributes);
		}

		void Load(FileDef obj) {
			if (obj is null)
				return;
			Add(obj.Flags);
			Add(obj.Name);
			Add(obj.HashValue);
			Add(obj.CustomAttributes);
		}

		void Load(ExportedType obj) {
			if (obj is null)
				return;
			Add(obj.CustomAttributes);
			Add(obj.Attributes);
			Add(obj.TypeDefId);
			Add(obj.TypeName);
			Add(obj.TypeNamespace);
			Add(obj.Implementation);
		}

		void Load(Resource obj) {
			if (obj is null)
				return;

			Add(obj.Offset);
			Add(obj.Name);
			Add(obj.Attributes);
			Add(obj.CustomAttributes);

			switch (obj.ResourceType) {
			case ResourceType.Embedded:
				break;

			case ResourceType.AssemblyLinked:
				var ar = (AssemblyLinkedResource)obj;
				Add(ar.Assembly);
				break;

			case ResourceType.Linked:
				var lr = (LinkedResource)obj;
				Add(lr.File);
				Add(lr.Hash);
				break;

			default:
				Debug.Fail("Unknown resource");
				break;
			}
		}

		void Load(ManifestResource obj) {
			if (obj is null)
				return;
			Add(obj.Offset);
			Add(obj.Flags);
			Add(obj.Name);
			Add(obj.Implementation);
			Add(obj.CustomAttributes);
		}

		void Load(GenericParam obj) {
			if (obj is null)
				return;
			Add(obj.Owner);
			Add(obj.Number);
			Add(obj.Flags);
			Add(obj.Name);
			Add(obj.Kind);
			Add(obj.GenericParamConstraints);
			Add(obj.CustomAttributes);
		}

		void Load(MethodSpec obj) {
			if (obj is null)
				return;
			Add(obj.Method);
			Add(obj.Instantiation);
			Add(obj.CustomAttributes);
		}

		void Load(GenericParamConstraint obj) {
			if (obj is null)
				return;
			Add(obj.Owner);
			Add(obj.Constraint);
			Add(obj.CustomAttributes);
		}

		void Load(CANamedArgument obj) {
			if (obj is null)
				return;
			Add(obj.Type);
			Add(obj.Name);
			Load(obj.Argument);
		}

		void Load(Parameter obj) {
			if (obj is null)
				return;
			Add(obj.Type);
		}

		void Load(SecurityAttribute obj) {
			if (obj is null)
				return;
			Add(obj.AttributeType);
			Add(obj.NamedArguments);
		}

		void Load(CustomAttribute obj) {
			if (obj is null)
				return;
			Add(obj.Constructor);
			Add(obj.RawData);
			Add(obj.ConstructorArguments);
			Add(obj.NamedArguments);
		}

		void Load(MethodOverride obj) {
			Add(obj.MethodBody);
			Add(obj.MethodDeclaration);
		}

		void AddCAValue(object obj) {
			if (obj is CAArgument) {
				Load((CAArgument)obj);
				return;
			}

			if (obj is IList<CAArgument> list) {
				Add(list);
				return;
			}

			if (obj is IMDTokenProvider md) {
				Add(md);
				return;
			}
		}

		void Load(CAArgument obj) {
			Add(obj.Type);
			AddCAValue(obj.Value);
		}

		void Load(PdbMethod obj) { }

		void Load(ResourceDirectory obj) {
			if (obj is null)
				return;
			Add(obj.Directories);
			Add(obj.Data);
		}

		void Load(ResourceData obj) { }

		void AddToStack<T>(T t) where T : class {
			if (t is null)
				return;
			if (seen.ContainsKey(t))
				return;
			seen[t] = true;
			stack.Push(t);
		}

		void Add(CustomAttribute obj) => AddToStack(obj);
		void Add(SecurityAttribute obj) => AddToStack(obj);
		void Add(CANamedArgument obj) => AddToStack(obj);
		void Add(Parameter obj) => AddToStack(obj);
		void Add(IMDTokenProvider o) => AddToStack(o);
		void Add(PdbMethod pdbMethod) { }
		void Add(TypeSig ts) => AddToStack(ts);
		void Add(ResourceDirectory rd) => AddToStack(rd);
		void Add(ResourceData rd) => AddToStack(rd);

		void Add<T>(IList<T> list) where T : IMDTokenProvider {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(IList<TypeSig> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(IList<CustomAttribute> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(IList<SecurityAttribute> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(IList<MethodOverride> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Load(item);
		}

		void Add(IList<CAArgument> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Load(item);
		}

		void Add(IList<CANamedArgument> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(ParameterList list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(IList<Instruction> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(IList<Emit.ExceptionHandler> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(IList<Local> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(IList<ResourceDirectory> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(IList<ResourceData> list) {
			if (list is null)
				return;
			foreach (var item in list)
				Add(item);
		}

		void Add(VTableFixups vtf) {
			if (vtf is null)
				return;
			foreach (var fixup in vtf) {
				foreach (var method in fixup)
					Add(method);
			}
		}

		void Add(Win32Resources vtf) {
			if (vtf is null)
				return;
			Add(vtf.Root);
		}

		void Add(CallingConventionSig sig) {
			if (sig is MethodBaseSig msig) {
				Add(msig);
				return;
			}

			if (sig is FieldSig fsig) {
				Add(fsig);
				return;
			}

			if (sig is LocalSig lsig) {
				Add(lsig);
				return;
			}

			if (sig is GenericInstMethodSig gsig) {
				Add(gsig);
				return;
			}

			Debug.Assert(sig is null);
		}

		void Add(MethodBaseSig msig) {
			if (msig is null)
				return;
			Add(msig.ExtraData);
			Add(msig.RetType);
			Add(msig.Params);
			Add(msig.ParamsAfterSentinel);
		}

		void Add(FieldSig fsig) {
			if (fsig is null)
				return;
			Add(fsig.ExtraData);
			Add(fsig.Type);
		}

		void Add(LocalSig lsig) {
			if (lsig is null)
				return;
			Add(lsig.ExtraData);
			Add(lsig.Locals);
		}

		void Add(GenericInstMethodSig gsig) {
			if (gsig is null)
				return;
			Add(gsig.ExtraData);
			Add(gsig.GenericArguments);
		}

		void Add(MarshalType mt) {
			if (mt is null)
				return;
			Add(mt.NativeType);
		}

		void Add(Emit.MethodBody mb) {
			if (mb is CilBody cilBody) {
				Add(cilBody);
				return;
			}

			if (mb is NativeMethodBody nb) {
				Add(nb);
				return;
			}

			Debug.Assert(mb is null, "Unknown method body");
		}

		void Add(NativeMethodBody body) {
			if (body is null)
				return;
			Add(body.RVA);
		}

		void Add(CilBody body) {
			if (body is null)
				return;
			Add(body.Instructions);
			Add(body.ExceptionHandlers);
			Add(body.Variables);
			Add(body.PdbMethod);
		}

		void Add(Instruction instr) {
			if (instr is null)
				return;

			if (instr.Operand is IMDTokenProvider mdt) {
				Add(mdt);
				return;
			}

			if (instr.Operand is Parameter p) {
				Add(p);
				return;
			}

			if (instr.Operand is Local l) {
				Add(l);
				return;
			}

			if (instr.Operand is CallingConventionSig csig) {
				Add(csig);
				return;
			}
		}

		void Add(Emit.ExceptionHandler eh) {
			if (eh is null)
				return;
			Add(eh.CatchType);
		}

		void Add(Local local) {
			if (local is null)
				return;
			Add(local.Type);
		}

		void Add(PdbState state) {
			if (state is null)
				return;
			Add(state.UserEntryPoint);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the ModuleRef table
	/// </summary>
	public abstract class ModuleRef : IHasCustomAttribute, IMemberRefParent, IHasCustomDebugInformation, IResolutionScope, IModule, IOwnerModule {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <summary>
		/// The owner module
		/// </summary>
		protected ModuleDef module;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.ModuleRef, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 12;

		/// <inheritdoc/>
		public int MemberRefParentTag => 2;

		/// <inheritdoc/>
		public int ResolutionScopeTag => 1;

		/// <inheritdoc/>
		public ScopeType ScopeType => ScopeType.ModuleRef;

		/// <inheritdoc/>
		public string ScopeName => FullName;

		/// <summary>
		/// From column ModuleRef.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 12;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <inheritdoc/>
		public ModuleDef Module => module;

		/// <summary>
		/// Gets the definition module, i.e., the module which it references, or <c>null</c>
		/// if the module can't be found.
		/// </summary>
		public ModuleDef DefinitionModule {
			get {
				if (module is null)
					return null;
				var n = name;
				if (UTF8String.CaseInsensitiveEquals(n, module.Name))
					return module;
				return DefinitionAssembly?.FindModule(n);
			}
		}

		/// <summary>
		/// Gets the definition assembly, i.e., the assembly of the module it references, or
		/// <c>null</c> if the assembly can't be found.
		/// </summary>
		public AssemblyDef DefinitionAssembly => module?.Assembly;

		/// <inheritdoc/>
		public string FullName => UTF8String.ToSystemStringOrEmpty(name);

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A ModuleRef row created by the user and not present in the original .NET file
	/// </summary>
	public class ModuleRefUser : ModuleRef {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		public ModuleRefUser(ModuleDef module)
			: this(module, UTF8String.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Module name</param>
		public ModuleRefUser(ModuleDef module, UTF8String name) {
			this.module = module;
			this.name = name;
		}
	}

	/// <summary>
	/// Created from a row in the ModuleRef table
	/// </summary>
	sealed class ModuleRefMD : ModuleRef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.ModuleRef, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>ModuleRef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ModuleRefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ModuleRefTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"ModuleRef rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			module = readerModule;
			bool b = readerModule.TablesStream.TryReadModuleRefRow(origRid, out var row);
			Debug.Assert(b);
			name = readerModule.StringsStream.ReadNoNull(row.Name);
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Native types used by field marshals. See CorHdr.h/CorNativeType
	/// </summary>
	public enum NativeType : uint {
		/// <summary>Deprecated</summary>
		End					= 0x00,
		/// <summary>void</summary>
		Void				= 0x01,
		/// <summary>bool</summary>
		Boolean				= 0x02,
		/// <summary>int8</summary>
		I1					= 0x03,
		/// <summary>unsigned int8</summary>
		U1					= 0x04,
		/// <summary>int16</summary>
		I2					= 0x05,
		/// <summary>unsigned int16</summary>
		U2					= 0x06,
		/// <summary>int32</summary>
		I4					= 0x07,
		/// <summary>unsigned int32</summary>
		U4					= 0x08,
		/// <summary>int64</summary>
		I8					= 0x09,
		/// <summary>unsigned int64</summary>
		U8					= 0x0A,
		/// <summary>float32</summary>
		R4					= 0x0B,
		/// <summary>float64</summary>
		R8					= 0x0C,
		/// <summary>syschar</summary>
		SysChar				= 0x0D,
		/// <summary>variant</summary>
		Variant				= 0x0E,
		/// <summary>currency</summary>
		Currency			= 0x0F,
		/// <summary>ptr</summary>
		Ptr					= 0x10,
		/// <summary>decimal</summary>
		Decimal				= 0x11,
		/// <summary>date</summary>
		Date				= 0x12,
		/// <summary>bstr</summary>
		BStr				= 0x13,
		/// <summary>lpstr</summary>
		LPStr				= 0x14,
		/// <summary>lpwstr</summary>
		LPWStr				= 0x15,
		/// <summary>lptstr</summary>
		LPTStr				= 0x16,
		/// <summary>fixed sysstring</summary>
		FixedSysString		= 0x17,
		/// <summary>objectref</summary>
		ObjectRef			= 0x18,
		/// <summary>iunknown</summary>
		IUnknown			= 0x19,
		/// <summary>idispatch</summary>
		IDispatch			= 0x1A,
		/// <summary>struct</summary>
		Struct				= 0x1B,
		/// <summary>interface</summary>
		IntF				= 0x1C,
		/// <summary>safearray</summary>
		SafeArray			= 0x1D,
		/// <summary>fixed array</summary>
		FixedArray			= 0x1E,
		/// <summary>int</summary>
		Int					= 0x1F,
		/// <summary>uint</summary>
		UInt				= 0x20,
		/// <summary>nested struct</summary>
		NestedStruct		= 0x21,
		/// <summary>byvalstr</summary>
		ByValStr			= 0x22,
		/// <summary>ansi bstr</summary>
		ANSIBStr			= 0x23,
		/// <summary>tbstr</summary>
		TBStr				= 0x24,
		/// <summary>variant bool</summary>
		VariantBool			= 0x25,
		/// <summary>func</summary>
		Func				= 0x26,
		/// <summary>as any</summary>
		ASAny				= 0x28,
		/// <summary>array</summary>
		Array				= 0x2A,
		/// <summary>lpstruct</summary>
		LPStruct			= 0x2B,
		/// <summary>custom marshaler</summary>
		CustomMarshaler		= 0x2C,
		/// <summary>error</summary>
		Error				= 0x2D,
		/// <summary>iinspectable</summary>
		IInspectable		= 0x2E,
		/// <summary>hstring</summary>
		HString				= 0x2F,
		/// <summary>UTF-8 encoded string</summary>
		LPUTF8Str			= 0x30,
		/// <summary>first invalid element type</summary>
		Max					= 0x50,
		/// <summary>Value wasn't present in the blob</summary>
		NotInitialized		= 0xFFFFFFFE,
		/// <summary>Raw marshal blob type</summary>
		RawBlob				= 0xFFFFFFFF,
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// A resolver that always fails
	/// </summary>
	public sealed class NullResolver : IAssemblyResolver, IResolver {
		/// <summary>
		/// The one and only instance of this type
		/// </summary>
		public static readonly NullResolver Instance = new NullResolver();

		NullResolver() {
		}

		/// <inheritdoc/>
		public AssemblyDef Resolve(IAssembly assembly, ModuleDef sourceModule) => null;

		/// <inheritdoc/>
		public TypeDef Resolve(TypeRef typeRef, ModuleDef sourceModule) => null;

		/// <inheritdoc/>
		public IMemberForwarded Resolve(MemberRef memberRef) => null;
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Parameter flags. See CorHdr.h/CorParamAttr
	/// </summary>
	[Flags]
	public enum ParamAttributes : ushort {
		/// <summary>Param is [In]</summary>
		In					= 0x0001,
		/// <summary>Param is [out]</summary>
		Out					= 0x0002,
		/// <summary>Param is a locale identifier</summary>
		Lcid				= 0x0004,
		/// <summary>Param is a return value</summary>
		Retval				= 0x0008,
		/// <summary>Param is optional</summary>
		Optional			= 0x0010,

		/// <summary>Param has default value.</summary>
		HasDefault			= 0x1000,
		/// <summary>Param has FieldMarshal.</summary>
		HasFieldMarshal		= 0x2000,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Param table
	/// </summary>
	[DebuggerDisplay("{Sequence} {Name}")]
	public abstract class ParamDef : IHasConstant, IHasCustomAttribute, IHasFieldMarshal, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.Param, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasConstantTag => 1;

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 4;

		/// <inheritdoc/>
		public int HasFieldMarshalTag => 1;

		/// <summary>
		/// Gets the declaring method
		/// </summary>
		public MethodDef DeclaringMethod {
			get => declaringMethod;
			internal set => declaringMethod = value;
		}
		/// <summary/>
		protected MethodDef declaringMethod;

		/// <summary>
		/// From column Param.Flags
		/// </summary>
		public ParamAttributes Attributes {
			get => (ParamAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Param.Sequence
		/// </summary>
		public ushort Sequence {
			get => sequence;
			set => sequence = value;
		}
		/// <summary/>
		protected ushort sequence;

		/// <summary>
		/// From column Param.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <inheritdoc/>
		public MarshalType MarshalType {
			get {
				if (!marshalType_isInitialized)
					InitializeMarshalType();
				return marshalType;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				marshalType = value;
				marshalType_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected MarshalType marshalType;
		/// <summary/>
		protected bool marshalType_isInitialized;

		void InitializeMarshalType() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (marshalType_isInitialized)
				return;
			marshalType = GetMarshalType_NoLock();
			marshalType_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="marshalType"/></summary>
		protected virtual MarshalType GetMarshalType_NoLock() => null;

		/// <summary>Reset <see cref="MarshalType"/></summary>
		protected void ResetMarshalType() => marshalType_isInitialized = false;

		/// <inheritdoc/>
		public Constant Constant {
			get {
				if (!constant_isInitialized)
					InitializeConstant();
				return constant;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				constant = value;
				constant_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected Constant constant;
		/// <summary/>
		protected bool constant_isInitialized;

		void InitializeConstant() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (constant_isInitialized)
				return;
			constant = GetConstant_NoLock();
			constant_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="constant"/></summary>
		protected virtual Constant GetConstant_NoLock() => null;

		/// <summary>Reset <see cref="Constant"/></summary>
		protected void ResetConstant() => constant_isInitialized = false;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 4;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// <c>true</c> if <see cref="Constant"/> is not <c>null</c>
		/// </summary>
		public bool HasConstant => Constant is not null;

		/// <summary>
		/// Gets the constant element type or <see cref="dnlib.DotNet.ElementType.End"/> if there's no constant
		/// </summary>
		public ElementType ElementType {
			get {
				var c = Constant;
				return c is null ? ElementType.End : c.Type;
			}
		}

		/// <summary>
		/// <c>true</c> if <see cref="MarshalType"/> is not <c>null</c>
		/// </summary>
		public bool HasMarshalType => MarshalType is not null;

		/// <inheritdoc/>
		public string FullName {
			get {
				var n = name;
				if (UTF8String.IsNullOrEmpty(n))
					return $"A_{sequence}";
				return n.String;
			}
		}

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, ParamAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.In"/> bit
		/// </summary>
		public bool IsIn {
			get => ((ParamAttributes)attributes & ParamAttributes.In) != 0;
			set => ModifyAttributes(value, ParamAttributes.In);
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.Out"/> bit
		/// </summary>
		public bool IsOut {
			get => ((ParamAttributes)attributes & ParamAttributes.Out) != 0;
			set => ModifyAttributes(value, ParamAttributes.Out);
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.Lcid"/> bit
		/// </summary>
		public bool IsLcid {
			get => ((ParamAttributes)attributes & ParamAttributes.Lcid) != 0;
			set => ModifyAttributes(value, ParamAttributes.Lcid);
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.Retval"/> bit
		/// </summary>
		public bool IsRetval {
			get => ((ParamAttributes)attributes & ParamAttributes.Retval) != 0;
			set => ModifyAttributes(value, ParamAttributes.Retval);
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.Optional"/> bit
		/// </summary>
		public bool IsOptional {
			get => ((ParamAttributes)attributes & ParamAttributes.Optional) != 0;
			set => ModifyAttributes(value, ParamAttributes.Optional);
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.HasDefault"/> bit
		/// </summary>
		public bool HasDefault {
			get => ((ParamAttributes)attributes & ParamAttributes.HasDefault) != 0;
			set => ModifyAttributes(value, ParamAttributes.HasDefault);
		}

		/// <summary>
		/// Gets/sets the <see cref="ParamAttributes.HasFieldMarshal"/> bit
		/// </summary>
		public bool HasFieldMarshal {
			get => ((ParamAttributes)attributes & ParamAttributes.HasFieldMarshal) != 0;
			set => ModifyAttributes(value, ParamAttributes.HasFieldMarshal);
		}
	}

	/// <summary>
	/// A Param row created by the user and not present in the original .NET file
	/// </summary>
	public class ParamDefUser : ParamDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ParamDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public ParamDefUser(UTF8String name)
			: this(name, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="sequence">Sequence</param>
		public ParamDefUser(UTF8String name, ushort sequence)
			: this(name, sequence, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="sequence">Sequence</param>
		/// <param name="flags">Flags</param>
		public ParamDefUser(UTF8String name, ushort sequence, ParamAttributes flags) {
			this.name = name;
			this.sequence = sequence;
			attributes = (int)flags;
		}
	}

	/// <summary>
	/// Created from a row in the Param table
	/// </summary>
	sealed class ParamDefMD : ParamDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override MarshalType GetMarshalType_NoLock() =>
			readerModule.ReadMarshalType(Table.Param, origRid, GenericParamContext.Create(declaringMethod));

		/// <inheritdoc/>
		protected override Constant GetConstant_NoLock() =>
			readerModule.ResolveConstant(readerModule.Metadata.GetConstantRid(Table.Param, origRid));

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.Param, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), GenericParamContext.Create(declaringMethod), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Param</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public ParamDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.ParamTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"Param rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadParamRow(origRid, out var row);
			Debug.Assert(b);
			attributes = row.Flags;
			sequence = row.Sequence;
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			declaringMethod = readerModule.GetOwner(this);
		}

		internal ParamDefMD InitializeAll() {
			MemberMDInitializer.Initialize(DeclaringMethod);
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(Sequence);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(MarshalType);
			MemberMDInitializer.Initialize(Constant);
			MemberMDInitializer.Initialize(CustomAttributes);
			return this;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A list of all method parameters
	/// </summary>
	[DebuggerDisplay("Count = {Count}")]
	[DebuggerTypeProxy(typeof(ParameterList_CollectionDebugView))]
	public sealed class ParameterList : IList<Parameter> {
		readonly MethodDef method;
		readonly List<Parameter> parameters;
		readonly Parameter hiddenThisParameter;
		ParamDef hiddenThisParamDef;
		readonly Parameter returnParameter;
		int methodSigIndexBase;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Gets the owner method
		/// </summary>
		public MethodDef Method => method;

		/// <summary>
		/// Gets the number of parameters, including a possible hidden 'this' parameter
		/// </summary>
		public int Count {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return parameters.Count;
#if THREAD_SAFE
				}
				finally { theLock.ExitReadLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets the index of the first parameter that is present in the method signature.
		/// If this is a static method, the value is 0, else it's an instance method so the
		/// index is 1 since the first parameter is the hidden 'this' parameter.
		/// </summary>
		public int MethodSigIndexBase {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return methodSigIndexBase == 1 ? 1 : 0;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
		}

		/// <summary>
		/// Gets the N'th parameter
		/// </summary>
		/// <param name="index">The parameter index</param>
		public Parameter this[int index] {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return parameters[index];
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set => throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the method return parameter
		/// </summary>
		public Parameter ReturnParameter {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return returnParameter;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The method with all parameters</param>
		/// <param name="declaringType"><paramref name="method"/>'s declaring type</param>
		public ParameterList(MethodDef method, TypeDef declaringType) {
			this.method = method;
			parameters = new List<Parameter>();
			methodSigIndexBase = -1;
			hiddenThisParameter = new Parameter(this, 0, Parameter.HIDDEN_THIS_METHOD_SIG_INDEX);
			returnParameter = new Parameter(this, -1, Parameter.RETURN_TYPE_METHOD_SIG_INDEX);
			UpdateThisParameterType(declaringType);
			UpdateParameterTypes();
		}

		/// <summary>
		/// Should be called when the method's declaring type has changed
		/// </summary>
		/// <param name="methodDeclaringType">Method declaring type</param>
		internal void UpdateThisParameterType(TypeDef methodDeclaringType) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (methodDeclaringType is null)
				hiddenThisParameter.Type = null;
			else {
				bool isValueType = methodDeclaringType.IsValueType;
				ClassOrValueTypeSig instSig;
				if (isValueType)
					instSig = new ValueTypeSig(methodDeclaringType);
				else
					instSig = new ClassSig(methodDeclaringType);
				TypeSig thisTypeSig;
				if (methodDeclaringType.HasGenericParameters) {
					int gpCount = methodDeclaringType.GenericParameters.Count;
					var genArgs = new List<TypeSig>(gpCount);
					for (int i = 0; i < gpCount; i++)
						genArgs.Add(new GenericVar(i, methodDeclaringType));
					thisTypeSig = new GenericInstSig(instSig, genArgs);
				}
				else
					thisTypeSig = instSig;
				hiddenThisParameter.Type = isValueType ? new ByRefSig(thisTypeSig) : thisTypeSig;
			}
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Should be called when the method sig has changed
		/// </summary>
		public void UpdateParameterTypes() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var sig = method.MethodSig;
			if (sig is null) {
				methodSigIndexBase = -1;
				parameters.Clear();
				return;
			}
			if (UpdateThisParameter_NoLock(sig))
				parameters.Clear();
			returnParameter.Type = sig.RetType;
			ResizeParameters_NoLock(sig.Params.Count + methodSigIndexBase);
			if (methodSigIndexBase > 0)
				parameters[0] = hiddenThisParameter;
			for (int i = 0; i < sig.Params.Count; i++)
				parameters[i + methodSigIndexBase].Type = sig.Params[i];
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		bool UpdateThisParameter_NoLock(MethodSig methodSig) {
			int newIndex;
			if (methodSig is null)
				newIndex = -1;
			else
				newIndex = methodSig.ImplicitThis ? 1 : 0;
			if (methodSigIndexBase == newIndex)
				return false;
			methodSigIndexBase = newIndex;
			return true;
		}

		void ResizeParameters_NoLock(int length) {
			if (parameters.Count == length)
				return;
			if (parameters.Count < length) {
				for (int i = parameters.Count; i < length; i++)
					parameters.Add(new Parameter(this, i, i - methodSigIndexBase));
			}
			else {
				while (parameters.Count > length)
					parameters.RemoveAt(parameters.Count - 1);
			}
		}

		internal ParamDef FindParamDef(Parameter param) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			return FindParamDef_NoLock(param);
#if THREAD_SAFE
			} finally { theLock.ExitReadLock(); }
#endif
		}

		ParamDef FindParamDef_NoLock(Parameter param) {
			int seq;
			if (param.IsReturnTypeParameter)
				seq = 0;
			else if (param.IsNormalMethodParameter)
				seq = param.MethodSigIndex + 1;
			else
				return hiddenThisParamDef;

			var paramDefs = method.ParamDefs;
			int count = paramDefs.Count;
			for (int i = 0; i < count; i++) {
				var paramDef = paramDefs[i];
				if (paramDef is not null && paramDef.Sequence == seq)
					return paramDef;
			}
			return null;
		}

		internal void TypeUpdated(Parameter param) {
			var sig = method.MethodSig;
			if (sig is null)
				return;
			int index = param.MethodSigIndex;
			if (index == Parameter.RETURN_TYPE_METHOD_SIG_INDEX)
				sig.RetType = param.Type;
			else if (index >= 0)
				sig.Params[index] = param.Type;
		}

		internal void CreateParamDef(Parameter param) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var paramDef = FindParamDef_NoLock(param);
			if (paramDef is not null)
				return;
			if (param.IsHiddenThisParameter) {
				hiddenThisParamDef = UpdateRowId_NoLock(new ParamDefUser(UTF8String.Empty, ushort.MaxValue, 0));
				return;
			}
			int seq = param.IsReturnTypeParameter ? 0 : param.MethodSigIndex + 1;
			paramDef = UpdateRowId_NoLock(new ParamDefUser(UTF8String.Empty, (ushort)seq, 0));
			method.ParamDefs.Add(paramDef);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		ParamDef UpdateRowId_NoLock(ParamDef pd) {
			var dt = method.DeclaringType;
			if (dt is null)
				return pd;
			var module = dt.Module;
			if (module is null)
				return pd;
			return module.UpdateRowId(pd);
		}

		/// <inheritdoc/>
		public int IndexOf(Parameter item) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			return parameters.IndexOf(item);
#if THREAD_SAFE
			}
			finally { theLock.ExitReadLock(); }
#endif
		}

		void IList<Parameter>.Insert(int index, Parameter item) => throw new NotSupportedException();
		void IList<Parameter>.RemoveAt(int index) => throw new NotSupportedException();
		void ICollection<Parameter>.Add(Parameter item) => throw new NotSupportedException();
		void ICollection<Parameter>.Clear() => throw new NotSupportedException();

		bool ICollection<Parameter>.Contains(Parameter item) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			return parameters.Contains(item);
#if THREAD_SAFE
			}
			finally { theLock.ExitReadLock(); }
#endif
		}

		void ICollection<Parameter>.CopyTo(Parameter[] array, int arrayIndex) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			parameters.CopyTo(array, arrayIndex);
#if THREAD_SAFE
			}
			finally { theLock.ExitReadLock(); }
#endif
		}

		bool ICollection<Parameter>.IsReadOnly => true;
		bool ICollection<Parameter>.Remove(Parameter item) => throw new NotSupportedException();

		/// <summary>
		/// Enumerator
		/// </summary>
		public struct Enumerator : IEnumerator<Parameter> {
			readonly ParameterList list;
			List<Parameter>.Enumerator listEnumerator;
			Parameter current;

			internal Enumerator(ParameterList list) {
				this.list = list;
				current = default;
#if THREAD_SAFE
				list.theLock.EnterReadLock(); try {
#endif
				listEnumerator = list.parameters.GetEnumerator();
#if THREAD_SAFE
				} finally { list.theLock.ExitReadLock(); }
#endif
			}

			/// <summary>
			/// Gets the current value
			/// </summary>
			public Parameter Current => current;
			Parameter IEnumerator<Parameter>.Current => current;
			object System.Collections.IEnumerator.Current => current;

			/// <summary>
			/// Moves to the next element in the collection
			/// </summary>
			/// <returns></returns>
			public bool MoveNext() {
#if THREAD_SAFE
				list.theLock.EnterWriteLock(); try {
#endif
				var res = listEnumerator.MoveNext();
				current = listEnumerator.Current;
				return res;
#if THREAD_SAFE
				} finally { list.theLock.ExitWriteLock(); }
#endif
			}

			/// <summary>
			/// Disposes the enumerator
			/// </summary>
			public void Dispose() => listEnumerator.Dispose();

			void System.Collections.IEnumerator.Reset() => throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the list enumerator
		/// </summary>
		/// <returns></returns>
		public Enumerator GetEnumerator() => new Enumerator(this);
		IEnumerator<Parameter> IEnumerable<Parameter>.GetEnumerator() => GetEnumerator();
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
	}

	/// <summary>
	/// A method parameter
	/// </summary>
	public sealed class Parameter : IVariable {
		readonly ParameterList parameterList;
		TypeSig typeSig;
		readonly int paramIndex;
		readonly int methodSigIndex;

		/// <summary>
		/// The hidden 'this' parameter's <see cref="MethodSigIndex"/>
		/// </summary>
		public const int HIDDEN_THIS_METHOD_SIG_INDEX = -2;

		/// <summary>
		/// The return type parameter's <see cref="MethodSigIndex"/>
		/// </summary>
		public const int RETURN_TYPE_METHOD_SIG_INDEX = -1;

		/// <summary>
		/// Gets the parameter index. If the method has a hidden 'this' parameter, that parameter
		/// has index 0 and the remaining parameters in the method signature start from index 1.
		/// The method return parameter has index <c>-1</c>.
		/// </summary>
		public int Index => paramIndex;

		/// <summary>
		/// Gets the index of the parameter in the method signature. See also
		/// <see cref="HIDDEN_THIS_METHOD_SIG_INDEX"/> and <see cref="RETURN_TYPE_METHOD_SIG_INDEX"/>
		/// </summary>
		public int MethodSigIndex => methodSigIndex;

		/// <summary>
		/// <c>true</c> if it's a normal visible method parameter, i.e., it's not the hidden
		/// 'this' parameter and it's not the method return type parameter.
		/// </summary>
		public bool IsNormalMethodParameter => methodSigIndex >= 0;

		/// <summary>
		/// <c>true</c> if it's the hidden 'this' parameter
		/// </summary>
		public bool IsHiddenThisParameter => methodSigIndex == HIDDEN_THIS_METHOD_SIG_INDEX;

		/// <summary>
		/// <c>true</c> if it's the method return type parameter
		/// </summary>
		public bool IsReturnTypeParameter => methodSigIndex == RETURN_TYPE_METHOD_SIG_INDEX;

		/// <summary>
		/// Gets the parameter type
		/// </summary>
		public TypeSig Type {
			get => typeSig;
			set {
				typeSig = value;
				if (parameterList is not null)
					parameterList.TypeUpdated(this);
			}
		}

		/// <summary>
		/// Gets the owner method
		/// </summary>
		public MethodDef Method => parameterList?.Method;

		/// <summary>
		/// Gets the <see cref="dnlib.DotNet.ParamDef"/> or <c>null</c> if not present
		/// </summary>
		public ParamDef ParamDef => parameterList?.FindParamDef(this);

		/// <summary>
		/// <c>true</c> if it has a <see cref="dnlib.DotNet.ParamDef"/>
		/// </summary>
		public bool HasParamDef => ParamDef is not null;

		/// <summary>
		/// Gets the name from <see cref="ParamDef"/>. If <see cref="ParamDef"/> is <c>null</c>,
		/// an empty string is returned.
		/// </summary>
		public string Name {
			get {
				var paramDef = ParamDef;
				return paramDef is null ? string.Empty : UTF8String.ToSystemStringOrEmpty(paramDef.Name);
			}
			set {
				var paramDef = ParamDef;
				if (paramDef is not null)
					paramDef.Name = value;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="paramIndex">Parameter index</param>
		public Parameter(int paramIndex) {
			this.paramIndex = paramIndex;
			methodSigIndex = paramIndex;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="paramIndex">Parameter index</param>
		/// <param name="type">Parameter type</param>
		public Parameter(int paramIndex, TypeSig type) {
			this.paramIndex = paramIndex;
			methodSigIndex = paramIndex;
			typeSig = type;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="paramIndex">Parameter index (0 is hidden this param if it exists)</param>
		/// <param name="methodSigIndex">Index in method signature</param>
		public Parameter(int paramIndex, int methodSigIndex) {
			this.paramIndex = paramIndex;
			this.methodSigIndex = methodSigIndex;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="paramIndex">Parameter index (0 is hidden this param if it exists)</param>
		/// <param name="methodSigIndex">Index in method signature</param>
		/// <param name="type">Parameter type</param>
		public Parameter(int paramIndex, int methodSigIndex, TypeSig type) {
			this.paramIndex = paramIndex;
			this.methodSigIndex = methodSigIndex;
			typeSig = type;
		}

		internal Parameter(ParameterList parameterList, int paramIndex, int methodSigIndex) {
			this.parameterList = parameterList;
			this.paramIndex = paramIndex;
			this.methodSigIndex = methodSigIndex;
		}

		/// <summary>
		/// Creates a <see cref="dnlib.DotNet.ParamDef"/> if it doesn't already exist
		/// </summary>
		public void CreateParamDef() {
			if (parameterList is not null)
				parameterList.CreateParamDef(this);
		}

		/// <inheritdoc/>
		public override string ToString() {
			var name = Name;
			if (string.IsNullOrEmpty(name)) {
				if (IsReturnTypeParameter)
					return "RET_PARAM";
				return $"A_{paramIndex}";
			}
			return name;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// P/Invoke attributes, see CorHdr.h/CorPinvokeMap
	/// </summary>
	[Flags]
	public enum PInvokeAttributes : ushort {
		/// <summary>Pinvoke is to use the member name as specified.</summary>
		NoMangle			= 0x0001,

		/// <summary>Use this mask to retrieve the CharSet information.</summary>
		CharSetMask			= 0x0006,
		/// <summary/>
		CharSetNotSpec		= 0x0000,
		/// <summary/>
		CharSetAnsi			= 0x0002,
		/// <summary/>
		CharSetUnicode		= 0x0004,
		/// <summary/>
		CharSetAuto			= 0x0006,

		/// <summary/>
		BestFitUseAssem		= 0x0000,
		/// <summary/>
		BestFitEnabled		= 0x0010,
		/// <summary/>
		BestFitDisabled		= 0x0020,
		/// <summary/>
		BestFitMask			= 0x0030,

		/// <summary/>
		ThrowOnUnmappableCharUseAssem	= 0x0000,
		/// <summary/>
		ThrowOnUnmappableCharEnabled	= 0x1000,
		/// <summary/>
		ThrowOnUnmappableCharDisabled	= 0x2000,
		/// <summary/>
		ThrowOnUnmappableCharMask		= 0x3000,

		/// <summary>Information about target function. Not relevant for fields.</summary>
		SupportsLastError	= 0x0040,

		/// <summary/>
		CallConvMask		= 0x0700,
		/// <summary>Pinvoke will use native callconv appropriate to target windows platform.</summary>
		CallConvWinapi		= 0x0100,
		/// <summary/>
		CallConvCdecl		= 0x0200,
		/// <summary/>
		CallConvStdcall		= 0x0300,
		/// <summary/>
		CallConvStdCall		= CallConvStdcall,
		/// <summary>In M9, pinvoke will raise exception.</summary>
		CallConvThiscall	= 0x0400,
		/// <summary/>
		CallConvFastcall	= 0x0500,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Property attributes, see CorHdr.h/CorPropertyAttr
	/// </summary>
	[Flags]
	public enum PropertyAttributes : ushort {
		/// <summary>property is special.  Name describes how.</summary>
		SpecialName			= 0x0200,
		/// <summary>Runtime(metadata internal APIs) should check name encoding.</summary>
		RTSpecialName		= 0x0400,
		/// <summary>Property has default</summary>
		HasDefault			= 0x1000,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the Property table
	/// </summary>
	public abstract class PropertyDef : IHasConstant, IHasCustomAttribute, IHasSemantic, IHasCustomDebugInformation, IFullName, IMemberDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.Property, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasConstantTag => 2;

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 9;

		/// <inheritdoc/>
		public int HasSemanticTag => 1;

		/// <summary>
		/// From column Property.PropFlags
		/// </summary>
		public PropertyAttributes Attributes {
			get => (PropertyAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column Property.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column Property.Type
		/// </summary>
		public CallingConventionSig Type {
			get => type;
			set => type = value;
		}
		/// <summary/>
		protected CallingConventionSig type;

		/// <inheritdoc/>
		public Constant Constant {
			get {
				if (!constant_isInitialized)
					InitializeConstant();
				return constant;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				constant = value;
				constant_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected Constant constant;
		/// <summary/>
		protected bool constant_isInitialized;

		void InitializeConstant() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (constant_isInitialized)
				return;
			constant = GetConstant_NoLock();
			constant_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="constant"/></summary>
		protected virtual Constant GetConstant_NoLock() => null;

		/// <summary>Reset <see cref="Constant"/></summary>
		protected void ResetConstant() => constant_isInitialized = false;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 9;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// Gets/sets the first getter method. Writing <c>null</c> will clear all get methods.
		/// </summary>
		public MethodDef GetMethod {
			get {
				if (otherMethods is null)
					InitializePropertyMethods();
				return getMethods.Count == 0 ? null : getMethods[0];
			}
			set {
				if (otherMethods is null)
					InitializePropertyMethods();
				if (value is null)
					getMethods.Clear();
				else if (getMethods.Count == 0)
					getMethods.Add(value);
				else
					getMethods[0] = value;
			}
		}

		/// <summary>
		/// Gets/sets the first setter method. Writing <c>null</c> will clear all set methods.
		/// </summary>
		public MethodDef SetMethod {
			get {
				if (otherMethods is null)
					InitializePropertyMethods();
				return setMethods.Count == 0 ? null : setMethods[0];
			}
			set {
				if (otherMethods is null)
					InitializePropertyMethods();
				if (value is null)
					setMethods.Clear();
				else if (setMethods.Count == 0)
					setMethods.Add(value);
				else
					setMethods[0] = value;
			}
		}

		/// <summary>
		/// Gets all getter methods
		/// </summary>
		public IList<MethodDef> GetMethods {
			get {
				if (otherMethods is null)
					InitializePropertyMethods();
				return getMethods;
			}
		}

		/// <summary>
		/// Gets all setter methods
		/// </summary>
		public IList<MethodDef> SetMethods {
			get {
				if (otherMethods is null)
					InitializePropertyMethods();
				return setMethods;
			}
		}

		/// <summary>
		/// Gets the other methods
		/// </summary>
		public IList<MethodDef> OtherMethods {
			get {
				if (otherMethods is null)
					InitializePropertyMethods();
				return otherMethods;
			}
		}

		void InitializePropertyMethods() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (otherMethods is null)
				InitializePropertyMethods_NoLock();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Initializes <see cref="otherMethods"/>, <see cref="getMethods"/>,
		/// and <see cref="setMethods"/>.
		/// </summary>
		protected virtual void InitializePropertyMethods_NoLock() {
			getMethods = new List<MethodDef>();
			setMethods = new List<MethodDef>();
			otherMethods = new List<MethodDef>();
		}

		/// <summary/>
		protected IList<MethodDef> getMethods;
		/// <summary/>
		protected IList<MethodDef> setMethods;
		/// <summary/>
		protected IList<MethodDef> otherMethods;

		/// <summary>Reset <see cref="GetMethods"/>, <see cref="SetMethods"/>, <see cref="OtherMethods"/></summary>
		protected void ResetMethods() => otherMethods = null;

		/// <summary>
		/// <c>true</c> if there are no methods attached to this property
		/// </summary>
		public bool IsEmpty =>
			// The first property access initializes the other fields we access here
			GetMethods.Count == 0 &&
			setMethods.Count == 0 &&
			otherMethods.Count == 0;

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <summary>
		/// <c>true</c> if <see cref="OtherMethods"/> is not empty
		/// </summary>
		public bool HasOtherMethods => OtherMethods.Count > 0;

		/// <summary>
		/// <c>true</c> if <see cref="Constant"/> is not <c>null</c>
		/// </summary>
		public bool HasConstant => Constant is not null;

		/// <summary>
		/// Gets the constant element type or <see cref="dnlib.DotNet.ElementType.End"/> if there's no constant
		/// </summary>
		public ElementType ElementType {
			get {
				var c = Constant;
				return c is null ? ElementType.End : c.Type;
			}
		}

		/// <summary>
		/// Gets/sets the property sig
		/// </summary>
		public PropertySig PropertySig {
			get => type as PropertySig;
			set => type = value;
		}

		/// <summary>
		/// Gets/sets the declaring type (owner type)
		/// </summary>
		public TypeDef DeclaringType {
			get => declaringType2;
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType is not null)
					currentDeclaringType.Properties.Remove(this);	// Will set DeclaringType2 = null
				if (value is not null)
					value.Properties.Add(this);	// Will set DeclaringType2 = value
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType => declaringType2;

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get => declaringType2;
			set => declaringType2 = value;
		}
		/// <summary/>
		protected TypeDef declaringType2;

		/// <inheritdoc/>
		public ModuleDef Module => declaringType2?.Module;

		/// <summary>
		/// Gets the full name of the property
		/// </summary>
		public string FullName => FullNameFactory.PropertyFullName(declaringType2?.FullName, name, type, null, null);

		bool IIsTypeOrMethod.IsType => false;
		bool IIsTypeOrMethod.IsMethod => false;
		bool IMemberRef.IsField => false;
		bool IMemberRef.IsTypeSpec => false;
		bool IMemberRef.IsTypeRef => false;
		bool IMemberRef.IsTypeDef => false;
		bool IMemberRef.IsMethodSpec => false;
		bool IMemberRef.IsMethodDef => false;
		bool IMemberRef.IsMemberRef => false;
		bool IMemberRef.IsFieldDef => false;
		bool IMemberRef.IsPropertyDef => true;
		bool IMemberRef.IsEventDef => false;
		bool IMemberRef.IsGenericParam => false;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, PropertyAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the <see cref="PropertyAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get => ((PropertyAttributes)attributes & PropertyAttributes.SpecialName) != 0;
			set => ModifyAttributes(value, PropertyAttributes.SpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="PropertyAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get => ((PropertyAttributes)attributes & PropertyAttributes.RTSpecialName) != 0;
			set => ModifyAttributes(value, PropertyAttributes.RTSpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="PropertyAttributes.HasDefault"/> bit
		/// </summary>
		public bool HasDefault {
			get => ((PropertyAttributes)attributes & PropertyAttributes.HasDefault) != 0;
			set => ModifyAttributes(value, PropertyAttributes.HasDefault);
		}

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A Property row created by the user and not present in the original .NET file
	/// </summary>
	public class PropertyDefUser : PropertyDef {
		/// <summary>
		/// Default constructor
		/// </summary>
		public PropertyDefUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public PropertyDefUser(UTF8String name)
			: this(name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="sig">Property signature</param>
		public PropertyDefUser(UTF8String name, PropertySig sig)
			: this(name, sig, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="sig">Property signature</param>
		/// <param name="flags">Flags</param>
		public PropertyDefUser(UTF8String name, PropertySig sig, PropertyAttributes flags) {
			this.name = name;
			type = sig;
			attributes = (int)flags;
		}
	}

	/// <summary>
	/// Created from a row in the Property table
	/// </summary>
	sealed class PropertyDefMD : PropertyDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override Constant GetConstant_NoLock() => readerModule.ResolveConstant(readerModule.Metadata.GetConstantRid(Table.Property, origRid));

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.Property, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(declaringType2), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>Property</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public PropertyDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.PropertyTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"Property rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadPropertyRow(origRid, out var row);
			Debug.Assert(b);
			attributes = row.PropFlags;
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			declaringType2 = readerModule.GetOwnerType(this);
			type = readerModule.ReadSignature(row.Type, new GenericParamContext(declaringType2));
		}

		internal PropertyDefMD InitializeAll() {
			MemberMDInitializer.Initialize(Attributes);
			MemberMDInitializer.Initialize(Name);
			MemberMDInitializer.Initialize(Type);
			MemberMDInitializer.Initialize(Constant);
			MemberMDInitializer.Initialize(CustomAttributes);
			MemberMDInitializer.Initialize(GetMethod);
			MemberMDInitializer.Initialize(SetMethod);
			MemberMDInitializer.Initialize(OtherMethods);
			MemberMDInitializer.Initialize(DeclaringType);
			return this;
		}

		/// <inheritdoc/>
		protected override void InitializePropertyMethods_NoLock() {
			if (otherMethods is not null)
				return;
			IList<MethodDef> newOtherMethods;
			IList<MethodDef> newGetMethods, newSetMethods;
			var dt = declaringType2 as TypeDefMD;
			if (dt is null) {
				newGetMethods = new List<MethodDef>();
				newSetMethods = new List<MethodDef>();
				newOtherMethods = new List<MethodDef>();
			}
			else
				dt.InitializeProperty(this, out newGetMethods, out newSetMethods, out newOtherMethods);
			getMethods = newGetMethods;
			setMethods = newSetMethods;
			// Must be initialized last
			otherMethods = newOtherMethods;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Represents a public key
	/// </summary>
	public sealed class PublicKey : PublicKeyBase {
		const AssemblyHashAlgorithm DEFAULT_ALGORITHM = AssemblyHashAlgorithm.SHA1;
		PublicKeyToken publicKeyToken;

		/// <summary>
		/// Gets the <see cref="PublicKeyToken"/>
		/// </summary>
		public override PublicKeyToken Token {
			get {
				if (publicKeyToken is null && !IsNullOrEmpty)
					Interlocked.CompareExchange(ref publicKeyToken, AssemblyHash.CreatePublicKeyToken(data), null);
				return publicKeyToken;
			}
		}

		/// <inheritdoc/>
		public override byte[] Data => data;

		/// <summary>
		/// Constructor
		/// </summary>
		public PublicKey() : base((byte[])null) { }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Public key data</param>
		public PublicKey(byte[] data)
			: base(data) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hexString">Public key data as a hex string or the string <c>"null"</c>
		/// to set public key data to <c>null</c></param>
		public PublicKey(string hexString)
			: base(hexString) {
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			if ((object)this == obj)
				return true;
			var other = obj as PublicKey;
			if (other is null)
				return false;
			return Utils.Equals(Data, other.Data);
		}

		/// <inheritdoc/>
		public override int GetHashCode() => Utils.GetHashCode(Data);
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Public key / public key token base class
	/// </summary>
	public abstract class PublicKeyBase {
		/// <summary>
		/// The key data
		/// </summary>
		protected readonly byte[] data;

		/// <summary>
		/// Returns <c>true</c> if <see cref="Data"/> is <c>null</c> or empty
		/// </summary>
		public bool IsNullOrEmpty => data is null || data.Length == 0;

		/// <summary>
		/// Returns <c>true</c> if <see cref="Data"/> is <c>null</c>
		/// </summary>
		public bool IsNull => Data is null;

		/// <summary>
		/// Gets/sets key data
		/// </summary>
		public virtual byte[] Data => data;

		/// <summary>
		/// Gets the <see cref="PublicKeyToken"/>
		/// </summary>
		public abstract PublicKeyToken Token { get; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Key data</param>
		protected PublicKeyBase(byte[] data) => this.data = data;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="hexString">Key data as a hex string or the string <c>"null"</c>
		/// to set key data to <c>null</c></param>
		protected PublicKeyBase(string hexString) => data = Parse(hexString);

		static byte[] Parse(string hexString) {
			if (hexString is null || hexString == "null")
				return null;
			return Utils.ParseBytes(hexString);
		}

		/// <summary>
		/// Checks whether a public key or token is null or empty
		/// </summary>
		/// <param name="a">Public key or token instance</param>
		public static bool IsNullOrEmpty2(PublicKeyBase a) => a is null || a.IsNullOrEmpty;

		/// <summary>
		/// Returns a <see cref="PublicKeyToken"/>
		/// </summary>
		/// <param name="pkb">A <see cref="PublicKey"/> or a <see cref="PublicKeyToken"/> instance</param>
		public static PublicKeyToken ToPublicKeyToken(PublicKeyBase pkb) {
			if (pkb is PublicKeyToken pkt)
				return pkt;
			if (pkb is PublicKey pk)
				return pk.Token;
			return null;
		}

		/// <summary>
		/// Compares two <see cref="PublicKeyBase"/>s as <see cref="PublicKeyToken"/>s
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public static int TokenCompareTo(PublicKeyBase a, PublicKeyBase b) {
			if (a == b)
				return 0;
			return TokenCompareTo(ToPublicKeyToken(a), ToPublicKeyToken(b));
		}

		/// <summary>
		/// Checks whether two public key tokens are equal
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public static bool TokenEquals(PublicKeyBase a, PublicKeyBase b) => TokenCompareTo(a, b) == 0;

		static readonly byte[] EmptyByteArray = Array2.Empty<byte>();
		/// <summary>
		/// Compares two <see cref="PublicKeyToken"/>s
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public static int TokenCompareTo(PublicKeyToken a, PublicKeyToken b) {
			if (a == b)
				return 0;
			return TokenCompareTo(a?.Data, b?.Data);
		}

		static int TokenCompareTo(byte[] a, byte[] b) => Utils.CompareTo(a ?? EmptyByteArray, b ?? EmptyByteArray);

		/// <summary>
		/// Checks whether two public key tokens are equal
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public static bool TokenEquals(PublicKeyToken a, PublicKeyToken b) => TokenCompareTo(a, b) == 0;

		/// <summary>
		/// Gets the public key token hash code
		/// </summary>
		/// <param name="a">Public key or token</param>
		/// <returns>The hash code</returns>
		public static int GetHashCodeToken(PublicKeyBase a) => GetHashCode(ToPublicKeyToken(a));

		/// <summary>
		/// Gets the public key token hash code
		/// </summary>
		/// <param name="a">Public key token</param>
		/// <returns>The hash code</returns>
		public static int GetHashCode(PublicKeyToken a) {
			if (a is null)
				return 0;
			return Utils.GetHashCode(a.Data);
		}

		/// <summary>
		/// Creates a <see cref="PublicKey"/>
		/// </summary>
		/// <param name="data">Public key data or <c>null</c></param>
		/// <returns>A new <see cref="PublicKey"/> instance or <c>null</c> if <paramref name="data"/>
		/// was <c>null</c></returns>
		public static PublicKey CreatePublicKey(byte[] data) {
			if (data is null)
				return null;
			return new PublicKey(data);
		}

		/// <summary>
		/// Creates a <see cref="PublicKeyToken"/>
		/// </summary>
		/// <param name="data">Public key token data or <c>null</c></param>
		/// <returns>A new <see cref="PublicKeyToken"/> instance or <c>null</c> if <paramref name="data"/>
		/// was <c>null</c></returns>
		public static PublicKeyToken CreatePublicKeyToken(byte[] data) {
			if (data is null)
				return null;
			return new PublicKeyToken(data);
		}

		/// <summary>
		/// Gets the raw public key / public key token byte array
		/// </summary>
		/// <param name="pkb">The instance or <c>null</c></param>
		/// <returns>Raw public key / public key token data or <c>null</c></returns>
		public static byte[] GetRawData(PublicKeyBase pkb) {
			if (pkb is null)
				return null;
			return pkb.Data;
		}

		/// <inheritdoc/>
		public override string ToString() {
			var d = Data;
			if (d is null || d.Length == 0)
				return "null";
			return Utils.ToHex(d, false);
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Represents a public key token
	/// </summary>
	public sealed class PublicKeyToken : PublicKeyBase {
		/// <summary>
		/// Gets the <see cref="PublicKeyToken"/>
		/// </summary>
		public override PublicKeyToken Token => this;

		/// <summary>
		/// Constructor
		/// </summary>
		public PublicKeyToken() : base((byte[])null) { }

		/// <inheritdoc/>
		public PublicKeyToken(byte[] data)
			: base(data) {
		}

		/// <inheritdoc/>
		public PublicKeyToken(string hexString)
			: base(hexString) {
		}

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			if ((object)this == obj)
				return true;
			var other = obj as PublicKeyToken;
			if (other is null)
				return false;
			return Utils.Equals(Data, other.Data);
		}

		/// <inheritdoc/>
		public override int GetHashCode() => Utils.GetHashCode(Data);
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Recursion counter
	/// </summary>
	struct RecursionCounter {
		/// <summary>
		/// Max recursion count. If this is reached, we won't continue, and will use a default value.
		/// </summary>
		public const int MAX_RECURSION_COUNT = 100;
		int counter;

		/// <summary>
		/// Gets the recursion counter
		/// </summary>
		public int Counter => counter;

		/// <summary>
		/// Increments <see cref="counter"/> if it's not too high. <c>ALL</c> instance methods
		/// that can be called recursively must call this method and <see cref="Decrement"/>
		/// (if this method returns <c>true</c>)
		/// </summary>
		/// <returns><c>true</c> if it was incremented and caller can continue, <c>false</c> if
		/// it was <c>not</c> incremented and the caller must return to its caller.</returns>
		public bool Increment() {
			if (counter >= MAX_RECURSION_COUNT)
				return false;
			counter++;
			return true;
		}

		/// <summary>
		/// Must be called before returning to caller if <see cref="Increment"/>
		/// returned <c>true</c>.
		/// </summary>
		public void Decrement() {
#if DEBUG
			if (counter <= 0)
				throw new InvalidOperationException("recursionCounter <= 0");
#endif
			counter--;
		}

		/// <inheritdoc/>
		public override string ToString() => counter.ToString();
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Extension methods for reflection types, methods, fields
	/// </summary>
	static class ReflectionExtensions {
		public static void GetTypeNamespaceAndName_TypeDefOrRef(this Type type, out string @namespace, out string name) {
			Debug.Assert(type.IsTypeDef());
			name = Unescape(type.Name) ?? string.Empty;
			if (!type.IsNested)
				@namespace = type.Namespace ?? string.Empty;
			else {
				var declTypeFullName = Unescape(type.DeclaringType.FullName);
				var typeFullName = Unescape(type.FullName);
				if (declTypeFullName.Length + 1 + name.Length == typeFullName.Length)
					@namespace = string.Empty;
				else
					@namespace = typeFullName.Substring(declTypeFullName.Length + 1, typeFullName.Length - declTypeFullName.Length - 1 - name.Length - 1);
			}
		}

		/// <summary>
		/// Checks whether it's a <see cref="ElementType.SZArray"/>
		/// </summary>
		/// <param name="self">The type</param>
		public static bool IsSZArray(this Type self) {
			if (self is null || !self.IsArray)
				return false;
			var prop = self.GetType().GetProperty("IsSzArray", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if (prop is not null)
				return (bool)prop.GetValue(self, Array2.Empty<object>());
			return (self.Name ?? string.Empty).EndsWith("[]");
		}

		/// <summary>
		/// Gets a <see cref="Type"/>'s <see cref="ElementType"/>
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The type's element type</returns>
		public static ElementType GetElementType2(this Type a) {
			if (a is null)
				return ElementType.End;	// Any invalid one is good enough
			if (a.IsArray)
				return IsSZArray(a) ? ElementType.SZArray : ElementType.Array;
			if (a.IsByRef)
				return ElementType.ByRef;
			if (a.IsPointer)
				return ElementType.Ptr;
			if (a.IsGenericParameter)
				return a.DeclaringMethod is null ? ElementType.Var : ElementType.MVar;
			if (a.IsGenericType && !a.IsGenericTypeDefinition)
				return ElementType.GenericInst;

			if (a == typeof(void))			return ElementType.Void;
			if (a == typeof(bool))			return ElementType.Boolean;
			if (a == typeof(char))			return ElementType.Char;
			if (a == typeof(sbyte))			return ElementType.I1;
			if (a == typeof(byte))			return ElementType.U1;
			if (a == typeof(short))			return ElementType.I2;
			if (a == typeof(ushort))		return ElementType.U2;
			if (a == typeof(int))			return ElementType.I4;
			if (a == typeof(uint))			return ElementType.U4;
			if (a == typeof(long))			return ElementType.I8;
			if (a == typeof(ulong))			return ElementType.U8;
			if (a == typeof(float))			return ElementType.R4;
			if (a == typeof(double))		return ElementType.R8;
			if (a == typeof(string))		return ElementType.String;
			if (a == typeof(TypedReference))return ElementType.TypedByRef;
			if (a == typeof(IntPtr))		return ElementType.I;
			if (a == typeof(UIntPtr))		return ElementType.U;
			if (a == typeof(object))		return ElementType.Object;

			return a.IsValueType ? ElementType.ValueType : ElementType.Class;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="mb"/> is a generic method, but
		/// not a generic method definition, i.e., a MethodSpec.
		/// </summary>
		/// <param name="mb">The method</param>
		public static bool IsGenericButNotGenericMethodDefinition(this MethodBase mb) =>
			mb is not null && !mb.IsGenericMethodDefinition && mb.IsGenericMethod;

		/// <summary>
		/// Checks whether a parameter/prop/event type should be treated as if it is really a
		/// generic instance type and not a generic type definition. In the .NET metadata (method
		/// sig), the parameter is a generic instance type, but the CLR treats it as if it's just
		/// a generic type def. This seems to happen only if the parameter type is exactly the same
		/// type as the declaring type, eg. a method similar to: <c>MyType&lt;!0&gt; MyType::SomeMethod()</c>.
		/// </summary>
		/// <param name="declaringType">Declaring type of method/event/property</param>
		/// <param name="t">Parameter/property/event type</param>
		internal static bool MustTreatTypeAsGenericInstType(this Type declaringType, Type t) =>
			declaringType is not null && declaringType.IsGenericTypeDefinition && t == declaringType;

		/// <summary>
		/// Checks whether <paramref name="type"/> is a type definition and not a type spec
		/// (eg. pointer or generic type instantiation)
		/// </summary>
		/// <param name="type">this</param>
		public static bool IsTypeDef(this Type type) =>
			type is not null && !type.HasElementType && (!type.IsGenericType || type.IsGenericTypeDefinition);

		internal static string Unescape(string name) {
			if (string.IsNullOrEmpty(name) || name.IndexOf('\\') < 0)
				return name;
			var sb = new StringBuilder(name.Length);
			for (int i = 0; i < name.Length; i++) {
				if (name[i] == '\\' && i < name.Length - 1 && IsReservedTypeNameChar(name[i + 1]))
					sb.Append(name[++i]);
				else
					sb.Append(name[i]);
			}
			return sb.ToString();
		}

		static bool IsReservedTypeNameChar(char c) {
			switch (c) {
			case ',':
			case '+':
			case '&':
			case '*':
			case '[':
			case ']':
			case '\\':
				return true;
			default:
				return false;
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Resolve exception base class
	/// </summary>
	[Serializable]
	public class ResolveException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ResolveException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public ResolveException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public ResolveException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected ResolveException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Thrown if an assembly couldn't be resolved
	/// </summary>
	[Serializable]
	public class AssemblyResolveException : ResolveException {
		/// <summary>
		/// Default constructor
		/// </summary>
		public AssemblyResolveException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public AssemblyResolveException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public AssemblyResolveException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected AssemblyResolveException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Thrown if a type couldn't be resolved
	/// </summary>
	[Serializable]
	public class TypeResolveException : ResolveException {
		/// <summary>
		/// Default constructor
		/// </summary>
		public TypeResolveException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public TypeResolveException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public TypeResolveException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected TypeResolveException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Thrown if a method/field couldn't be resolved
	/// </summary>
	[Serializable]
	public class MemberRefResolveException : ResolveException {
		/// <summary>
		/// Default constructor
		/// </summary>
		public MemberRefResolveException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public MemberRefResolveException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public MemberRefResolveException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected MemberRefResolveException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Resolves types, methods, fields
	/// </summary>
	public sealed class Resolver : IResolver {
		readonly IAssemblyResolver assemblyResolver;

		/// <summary>
		/// <c>true</c> to project WinMD types to CLR types, eg. <c>Windows.UI.Xaml.Interop.TypeName</c>
		/// gets converted to <c>System.Type</c> before trying to resolve the type. This is enabled
		/// by default.
		/// </summary>
		public bool ProjectWinMDRefs {
			get => projectWinMDRefs;
			set => projectWinMDRefs = value;
		}
		bool projectWinMDRefs = true;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="assemblyResolver">The assembly resolver</param>
		public Resolver(IAssemblyResolver assemblyResolver) =>
			this.assemblyResolver = assemblyResolver ?? throw new ArgumentNullException(nameof(assemblyResolver));

		/// <inheritdoc/>
		public TypeDef Resolve(TypeRef typeRef, ModuleDef sourceModule) {
			if (typeRef is null)
				return null;

			if (ProjectWinMDRefs)
				typeRef = WinMDHelpers.ToCLR(typeRef.Module ?? sourceModule, typeRef) ?? typeRef;

			var nonNestedTypeRef = TypeRef.GetNonNestedTypeRef(typeRef);
			if (nonNestedTypeRef is null)
				return null;

			var nonNestedResolutionScope = nonNestedTypeRef.ResolutionScope;
			var nonNestedModule = nonNestedTypeRef.Module;
			if (nonNestedResolutionScope is AssemblyRef asmRef) {
				var asm = assemblyResolver.Resolve(asmRef, sourceModule ?? nonNestedModule);
				return asm is null ? null : asm.Find(typeRef) ?? ResolveExportedType(asm.Modules, typeRef, sourceModule);
			}

			if (nonNestedResolutionScope is ModuleDef moduleDef)
				return moduleDef.Find(typeRef) ?? ResolveExportedType(new ModuleDef[] { moduleDef }, typeRef, sourceModule);

			if (nonNestedResolutionScope is ModuleRef moduleRef) {
				if (nonNestedModule is null)
					return null;
				if (new SigComparer().Equals(moduleRef, nonNestedModule))
					return nonNestedModule.Find(typeRef) ??
						ResolveExportedType(new ModuleDef[] { nonNestedModule }, typeRef, sourceModule);
				var nonNestedAssembly = nonNestedModule.Assembly;
				if (nonNestedAssembly is null)
					return null;
				var resolvedModule = nonNestedAssembly.FindModule(moduleRef.Name);
				return resolvedModule is null ? null : resolvedModule.Find(typeRef) ??
						ResolveExportedType(new ModuleDef[] { resolvedModule }, typeRef, sourceModule);
			}

			return null;
		}

		TypeDef ResolveExportedType(IList<ModuleDef> modules, TypeRef typeRef, ModuleDef sourceModule) {
			for (int i = 0; i < 30; i++) {
				var exportedType = FindExportedType(modules, typeRef);
				if (exportedType is null)
					return null;

				var asmResolver = modules[0].Context.AssemblyResolver;
				var etAsm = asmResolver.Resolve(exportedType.DefinitionAssembly, sourceModule ?? typeRef.Module);
				if (etAsm is null)
					return null;

				var td = etAsm.Find(typeRef);
				if (td is not null)
					return td;

				modules = etAsm.Modules;
			}

			return null;
		}

		static ExportedType FindExportedType(IList<ModuleDef> modules, TypeRef typeRef) {
			if (typeRef is null)
				return null;
			int count = modules.Count;
			for (int i = 0; i < count; i++) {
				var module = modules[i];
				var exportedTypes = module.ExportedTypes;
				int count2 = exportedTypes.Count;
				for (int j = 0; j < count2; j++) {
					var exportedType = exportedTypes[j];
					if (new SigComparer(SigComparerOptions.DontCompareTypeScope).Equals(exportedType, typeRef))
						return exportedType;
				}
			}
			return null;
		}

		/// <inheritdoc/>
		public IMemberForwarded Resolve(MemberRef memberRef) {
			if (memberRef is null)
				return null;
			if (ProjectWinMDRefs)
				memberRef = WinMDHelpers.ToCLR(memberRef.Module, memberRef) ?? memberRef;
			var parent = memberRef.Class;
			if (parent is MethodDef method)
				return method;
			return GetDeclaringType(memberRef, parent)?.Resolve(memberRef);
		}

		TypeDef GetDeclaringType(MemberRef memberRef, IMemberRefParent parent) {
			if (memberRef is null || parent is null)
				return null;

			if (parent is TypeSpec ts)
				parent = ts.ScopeType;

			if (parent is TypeDef declaringTypeDef)
				return declaringTypeDef;

			if (parent is TypeRef declaringTypeRef)
				return Resolve(declaringTypeRef, memberRef.Module);

			// A module ref is used to reference the global type of a module in the same
			// assembly as the current module.
			if (parent is ModuleRef moduleRef) {
				var module = memberRef.Module;
				if (module is null)
					return null;
				TypeDef globalType = null;
				if (new SigComparer().Equals(module, moduleRef))
					globalType = module.GlobalType;
				var modAsm = module.Assembly;
				if (globalType is null && modAsm is not null) {
					var moduleDef = modAsm.FindModule(moduleRef.Name);
					if (moduleDef is not null)
						globalType = moduleDef.GlobalType;
				}
				return globalType;
			}

			if (parent is MethodDef method)
				return method.DeclaringType;

			return null;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Type of resource
	/// </summary>
	public enum ResourceType {
		/// <summary>
		/// It's a <see cref="EmbeddedResource"/>
		/// </summary>
		Embedded,

		/// <summary>
		/// It's a <see cref="AssemblyLinkedResource"/>
		/// </summary>
		AssemblyLinked,

		/// <summary>
		/// It's a <see cref="LinkedResource"/>
		/// </summary>
		Linked,
	}

	/// <summary>
	/// Resource base class
	/// </summary>
	public abstract class Resource : IMDTokenProvider, IHasCustomAttribute, IHasCustomDebugInformation {
		private protected uint rid;
		private protected uint? offset;
		UTF8String name;
		ManifestResourceAttributes flags;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.ManifestResource, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <summary>
		/// Gets/sets the offset of the resource
		/// </summary>
		public uint? Offset {
			get => offset;
			set => offset = value;
		}

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}

		/// <summary>
		/// Gets/sets the flags
		/// </summary>
		public ManifestResourceAttributes Attributes {
			get => flags;
			set => flags = value;
		}

		/// <summary>
		/// Gets the type of resource
		/// </summary>
		public abstract ResourceType ResourceType { get; }

		/// <summary>
		/// Gets/sets the visibility
		/// </summary>
		public ManifestResourceAttributes Visibility {
			get => flags & ManifestResourceAttributes.VisibilityMask;
			set => flags = (flags & ~ManifestResourceAttributes.VisibilityMask) | (value & ManifestResourceAttributes.VisibilityMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="ManifestResourceAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic => (flags & ManifestResourceAttributes.VisibilityMask) == ManifestResourceAttributes.Public;

		/// <summary>
		/// <c>true</c> if <see cref="ManifestResourceAttributes.Private"/> is set
		/// </summary>
		public bool IsPrivate => (flags & ManifestResourceAttributes.VisibilityMask) == ManifestResourceAttributes.Private;

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 18;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 18;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="flags">flags</param>
		protected Resource(UTF8String name, ManifestResourceAttributes flags) {
			this.name = name;
			this.flags = flags;
		}
	}

	/// <summary>
	/// A resource that is embedded in a .NET module. This is the most common type of resource.
	/// </summary>
	public class EmbeddedResource : Resource {
		readonly DataReaderFactory dataReaderFactory;
		readonly uint resourceStartOffset;
		readonly uint resourceLength;

		/// <summary>
		/// Gets the length of the data
		/// </summary>
		public uint Length => resourceLength;

		/// <inheritdoc/>
		public override ResourceType ResourceType => ResourceType.Embedded;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="data">Resource data</param>
		/// <param name="flags">Resource flags</param>
		public EmbeddedResource(UTF8String name, byte[] data, ManifestResourceAttributes flags = ManifestResourceAttributes.Private)
			: this(name, ByteArrayDataReaderFactory.Create(data, filename: null), 0, (uint)data.Length, flags) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="dataReaderFactory">Data reader factory</param>
		/// <param name="offset">Offset of resource data</param>
		/// <param name="length">Length of resource data</param>
		/// <param name="flags">Resource flags</param>
		public EmbeddedResource(UTF8String name, DataReaderFactory dataReaderFactory, uint offset, uint length, ManifestResourceAttributes flags = ManifestResourceAttributes.Private)
			: base(name, flags) {
			this.dataReaderFactory = dataReaderFactory ?? throw new ArgumentNullException(nameof(dataReaderFactory));
			resourceStartOffset = offset;
			resourceLength = length;
		}

		/// <summary>
		/// Gets a data reader that can access the resource
		/// </summary>
		/// <returns></returns>
		public DataReader CreateReader() => dataReaderFactory.CreateReader(resourceStartOffset, resourceLength);

		/// <inheritdoc/>
		public override string ToString() => $"{UTF8String.ToSystemStringOrEmpty(Name)} - size: {(resourceLength)}";
	}

	sealed class EmbeddedResourceMD : EmbeddedResource, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.ManifestResource, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		public EmbeddedResourceMD(ModuleDefMD readerModule, ManifestResource mr, byte[] data)
			: this(readerModule, mr, ByteArrayDataReaderFactory.Create(data, filename: null), 0, (uint)data.Length) {
		}

		public EmbeddedResourceMD(ModuleDefMD readerModule, ManifestResource mr, DataReaderFactory dataReaderFactory, uint offset, uint length)
			: base(mr.Name, dataReaderFactory, offset, length, mr.Flags) {
			this.readerModule = readerModule;
			origRid = rid = mr.Rid;
			this.offset = mr.Offset;
		}
	}

	/// <summary>
	/// A reference to a resource in another assembly
	/// </summary>
	public class AssemblyLinkedResource : Resource {
		AssemblyRef asmRef;

		/// <inheritdoc/>
		public override ResourceType ResourceType => ResourceType.AssemblyLinked;

		/// <summary>
		/// Gets/sets the assembly reference
		/// </summary>
		public AssemblyRef Assembly {
			get => asmRef;
			set => asmRef = value ?? throw new ArgumentNullException(nameof(value));
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="asmRef">Assembly reference</param>
		/// <param name="flags">Resource flags</param>
		public AssemblyLinkedResource(UTF8String name, AssemblyRef asmRef, ManifestResourceAttributes flags)
			: base(name, flags) => this.asmRef = asmRef ?? throw new ArgumentNullException(nameof(asmRef));

		/// <inheritdoc/>
		public override string ToString() => $"{UTF8String.ToSystemStringOrEmpty(Name)} - assembly: {asmRef.FullName}";
	}

	sealed class AssemblyLinkedResourceMD : AssemblyLinkedResource, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.ManifestResource, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		public AssemblyLinkedResourceMD(ModuleDefMD readerModule, ManifestResource mr, AssemblyRef asmRef) : base(mr.Name, asmRef, mr.Flags) {
			this.readerModule = readerModule;
			origRid = rid = mr.Rid;
			offset = mr.Offset;
		}
	}

	/// <summary>
	/// A resource that is stored in a file on disk
	/// </summary>
	public class LinkedResource : Resource {
		FileDef file;

		/// <inheritdoc/>
		public override ResourceType ResourceType => ResourceType.Linked;

		/// <summary>
		/// Gets/sets the file
		/// </summary>
		public FileDef File {
			get => file;
			set => file = value ?? throw new ArgumentNullException(nameof(value));
		}

		/// <summary>
		/// Gets/sets the hash
		/// </summary>
		public byte[] Hash {
			get => file.HashValue;
			set => file.HashValue = value;
		}

		/// <summary>
		/// Gets/sets the file name
		/// </summary>
		public UTF8String FileName => file is null ? UTF8String.Empty : file.Name;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <param name="file">The file</param>
		/// <param name="flags">Resource flags</param>
		public LinkedResource(UTF8String name, FileDef file, ManifestResourceAttributes flags)
			: base(name, flags) => this.file = file;

		/// <inheritdoc/>
		public override string ToString() => $"{UTF8String.ToSystemStringOrEmpty(Name)} - file: {UTF8String.ToSystemStringOrEmpty(FileName)}";
	}

	sealed class LinkedResourceMD : LinkedResource, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.ManifestResource, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		public LinkedResourceMD(ModuleDefMD readerModule, ManifestResource mr, FileDef file) : base(mr.Name, file, mr.Flags) {
			this.readerModule = readerModule;
			origRid = rid = mr.Rid;
			offset = mr.Offset;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A collection of <see cref="Resource"/>s
	/// </summary>
	public class ResourceCollection : LazyList<Resource, object> {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ResourceCollection() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="listener">List listener</param>
		public ResourceCollection(IListListener<Resource> listener)
			: base(listener) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Initial length of the list</param>
		/// <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
		/// <param name="readOriginalValue">Delegate instance that returns original values</param>
		public ResourceCollection(int length, object context, Func<object, int, Resource> readOriginalValue)
			: base(length, context, readOriginalValue) {
		}

		/// <summary>
		/// Finds the index of a resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The index of the <see cref="Resource"/> or <c>-1</c> if none was found</returns>
		public int IndexOf(UTF8String name) {
			int i = -1;
			foreach (var resource in this) {
				i++;
				if (resource is not null && resource.Name == name)
					return i;
			}
			return -1;
		}

		/// <summary>
		/// Finds the index of an embedded resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The index of the <see cref="EmbeddedResource"/> or <c>-1</c> if none was found</returns>
		public int IndexOfEmbeddedResource(UTF8String name) {
			int i = -1;
			foreach (var resource in this) {
				i++;
				if (resource is not null &&
					resource.ResourceType == ResourceType.Embedded &&
					resource.Name == name)
					return i;
			}
			return -1;
		}

		/// <summary>
		/// Finds the index of an assembly linked resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The index of the <see cref="AssemblyLinkedResource"/> or <c>-1</c> if none was found</returns>
		public int IndexOfAssemblyLinkedResource(UTF8String name) {
			int i = -1;
			foreach (var resource in this) {
				i++;
				if (resource is not null &&
					resource.ResourceType == ResourceType.AssemblyLinked &&
					resource.Name == name)
					return i;
			}
			return -1;
		}

		/// <summary>
		/// Finds the index of a linked resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The index of the <see cref="LinkedResource"/> or <c>-1</c> if none was found</returns>
		public int IndexOfLinkedResource(UTF8String name) {
			int i = -1;
			foreach (var resource in this) {
				i++;
				if (resource is not null &&
					resource.ResourceType == ResourceType.Linked &&
					resource.Name == name)
					return i;
			}
			return -1;
		}

		/// <summary>
		/// Finds a resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The <see cref="Resource"/> or <c>null</c> if none was found</returns>
		public Resource Find(UTF8String name) {
			foreach (var resource in this) {
				if (resource is not null && resource.Name == name)
					return resource;
			}
			return null;
		}

		/// <summary>
		/// Finds an embedded resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The <see cref="EmbeddedResource"/> or <c>null</c> if none was found</returns>
		public EmbeddedResource FindEmbeddedResource(UTF8String name) {
			foreach (var resource in this) {
				if (resource is not null &&
					resource.ResourceType == ResourceType.Embedded &&
					resource.Name == name)
					return (EmbeddedResource)resource;
			}
			return null;
		}

		/// <summary>
		/// Finds an assembly linked resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The <see cref="AssemblyLinkedResource"/> or <c>null</c> if none was found</returns>
		public AssemblyLinkedResource FindAssemblyLinkedResource(UTF8String name) {
			foreach (var resource in this) {
				if (resource is not null &&
					resource.ResourceType == ResourceType.AssemblyLinked &&
					resource.Name == name)
					return (AssemblyLinkedResource)resource;
			}
			return null;
		}

		/// <summary>
		/// Finds a linked resource
		/// </summary>
		/// <param name="name">Name of resource</param>
		/// <returns>The <see cref="LinkedResource"/> or <c>null</c> if none was found</returns>
		public LinkedResource FindLinkedResource(UTF8String name) {
			foreach (var resource in this) {
				if (resource is not null &&
					resource.ResourceType == ResourceType.Linked &&
					resource.Name == name)
					return (LinkedResource)resource;
			}
			return null;
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Security action. See CorHdr.h/CorDeclSecurity
	/// </summary>
	public enum SecurityAction : short {
		/// <summary>Mask allows growth of enum.</summary>
		ActionMask			= 0x001F,
		/// <summary/>
		ActionNil			= 0x0000,
		/// <summary/>
		Request				= 0x0001,
		/// <summary/>
		Demand				= 0x0002,
		/// <summary/>
		Assert				= 0x0003,
		/// <summary/>
		Deny				= 0x0004,
		/// <summary/>
		PermitOnly			= 0x0005,
		/// <summary/>
		LinktimeCheck		= 0x0006,
		/// <summary/>
		LinkDemand			= LinktimeCheck,
		/// <summary/>
		InheritanceCheck	= 0x0007,
		/// <summary/>
		InheritDemand		= InheritanceCheck,
		/// <summary/>
		RequestMinimum		= 0x0008,
		/// <summary/>
		RequestOptional		= 0x0009,
		/// <summary/>
		RequestRefuse		= 0x000A,
		/// <summary>Persisted grant set at prejit time</summary>
		PrejitGrant			= 0x000B,
		/// <summary>Persisted grant set at prejit time</summary>
		PreJitGrant			= PrejitGrant,
		/// <summary>Persisted denied set at prejit time</summary>
		PrejitDenied		= 0x000C,
		/// <summary>Persisted denied set at prejit time</summary>
		PreJitDeny			= PrejitDenied,
		/// <summary/>
		NonCasDemand		= 0x000D,
		/// <summary/>
		NonCasLinkDemand	= 0x000E,
		/// <summary/>
		NonCasInheritance	= 0x000F,
		/// <summary>Maximum legal value</summary>
		MaximumValue		= 0x000F,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A <c>DeclSecurity</c> security attribute
	/// </summary>
	public sealed class SecurityAttribute : ICustomAttribute {
		ITypeDefOrRef attrType;
		readonly IList<CANamedArgument> namedArguments;

		/// <summary>
		/// Gets/sets the attribute type
		/// </summary>
		public ITypeDefOrRef AttributeType {
			get => attrType;
			set => attrType = value;
		}

		/// <summary>
		/// Gets the full name of the attribute type
		/// </summary>
		public string TypeFullName {
			get {
				var at = attrType;
				return at is null ? string.Empty : at.FullName;
			}
		}

		/// <summary>
		/// Gets all named arguments (field and property values)
		/// </summary>
		public IList<CANamedArgument> NamedArguments => namedArguments;

		/// <summary>
		/// <c>true</c> if <see cref="NamedArguments"/> is not empty
		/// </summary>
		public bool HasNamedArguments => namedArguments.Count > 0;

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are field arguments
		/// </summary>
		public IEnumerable<CANamedArgument> Fields {
			get {
				var namedArguments = this.namedArguments;
				int count = namedArguments.Count;
				for (int i = 0; i < count; i++) {
					var namedArg = namedArguments[i];
					if (namedArg.IsField)
						yield return namedArg;
				}
			}
		}

		/// <summary>
		/// Gets all <see cref="CANamedArgument"/>s that are property arguments
		/// </summary>
		public IEnumerable<CANamedArgument> Properties {
			get {
				var namedArguments = this.namedArguments;
				int count = namedArguments.Count;
				for (int i = 0; i < count; i++) {
					var namedArg = namedArguments[i];
					if (namedArg.IsProperty)
						yield return namedArg;
				}
			}
		}

		/// <summary>
		/// Creates a <see cref="SecurityAttribute"/> from an XML string.
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="xml">XML</param>
		/// <returns>A new <see cref="SecurityAttribute"/> instance</returns>
		public static SecurityAttribute CreateFromXml(ModuleDef module, string xml) {
			var attrType = module.CorLibTypes.GetTypeRef("System.Security.Permissions", "PermissionSetAttribute");
			var utf8Xml = new UTF8String(xml);
			var namedArg = new CANamedArgument(false, module.CorLibTypes.String, "XML", new CAArgument(module.CorLibTypes.String, utf8Xml));
			var list = new List<CANamedArgument> { namedArg };
			return new SecurityAttribute(attrType, list);
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public SecurityAttribute()
			: this(null, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="attrType">Attribute type</param>
		public SecurityAttribute(ITypeDefOrRef attrType)
			: this(attrType, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="attrType">Attribute type</param>
		/// <param name="namedArguments">Named arguments that will be owned by this instance</param>
		public SecurityAttribute(ITypeDefOrRef attrType, IList<CANamedArgument> namedArguments) {
			this.attrType = attrType;
			this.namedArguments = namedArguments ?? new List<CANamedArgument>();
		}

		/// <inheritdoc/>
		public override string ToString() => TypeFullName;
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// See CorSerializationType/CorHdr.h
	/// </summary>
	enum SerializationType : byte {
		/// <summary/>
		Undefined	= 0,
		/// <summary>System.Boolean</summary>
		Boolean		= ElementType.Boolean,
		/// <summary>System.Char</summary>
		Char		= ElementType.Char,
		/// <summary>System.SByte</summary>
		I1			= ElementType.I1,
		/// <summary>System.Byte</summary>
		U1			= ElementType.U1,
		/// <summary>System.Int16</summary>
		I2			= ElementType.I2,
		/// <summary>System.UInt16</summary>
		U2			= ElementType.U2,
		/// <summary>System.Int32</summary>
		I4			= ElementType.I4,
		/// <summary>System.UInt32</summary>
		U4			= ElementType.U4,
		/// <summary>System.Int64</summary>
		I8			= ElementType.I8,
		/// <summary>System.UInt64</summary>
		U8			= ElementType.U8,
		/// <summary>System.Single</summary>
		R4			= ElementType.R4,
		/// <summary>System.Double</summary>
		R8			= ElementType.R8,
		/// <summary>System.String</summary>
		String		= ElementType.String,
		/// <summary>Single-dimension, zero lower bound array ([])</summary>
		SZArray		= ElementType.SZArray,
		/// <summary>System.Type</summary>
		Type		= 0x50,
		/// <summary>Boxed value type</summary>
		TaggedObject= 0x51,
		/// <summary>A field</summary>
		Field		= 0x53,
		/// <summary>A property</summary>
		Property	= 0x54,
		/// <summary>An enum</summary>
		Enum		= 0x55,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Compares types
	/// </summary>
	public sealed class TypeEqualityComparer : IEqualityComparer<IType>, IEqualityComparer<ITypeDefOrRef>, IEqualityComparer<TypeRef>, IEqualityComparer<TypeDef>, IEqualityComparer<TypeSpec>, IEqualityComparer<TypeSig>, IEqualityComparer<ExportedType> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Default instance
		/// </summary>
		public static readonly TypeEqualityComparer Instance = new TypeEqualityComparer(0);

		/// <summary>
		/// Case insensitive names
		/// </summary>
		public static readonly TypeEqualityComparer CaseInsensitive = new TypeEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public TypeEqualityComparer(SigComparerOptions options) => this.options = options;

		/// <inheritdoc/>
		public bool Equals(IType x, IType y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(IType obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(ITypeDefOrRef x, ITypeDefOrRef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(ITypeDefOrRef obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(TypeRef x, TypeRef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(TypeRef obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(TypeDef x, TypeDef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(TypeDef obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(TypeSpec x, TypeSpec y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(TypeSpec obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(TypeSig x, TypeSig y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(TypeSig obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(ExportedType x, ExportedType y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(ExportedType obj) => new SigComparer(options).GetHashCode(obj);
	}

	/// <summary>
	/// Compares fields
	/// </summary>
	public sealed class FieldEqualityComparer : IEqualityComparer<IField>, IEqualityComparer<FieldDef>, IEqualityComparer<MemberRef> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Compares the declaring types
		/// </summary>
		public static readonly FieldEqualityComparer CompareDeclaringTypes = new FieldEqualityComparer(SigComparerOptions.CompareMethodFieldDeclaringType);

		/// <summary>
		/// Doesn't compare the declaring types
		/// </summary>
		public static readonly FieldEqualityComparer DontCompareDeclaringTypes = new FieldEqualityComparer(0);

		/// <summary>
		/// Compares the declaring types, case insensitive names
		/// </summary>
		public static readonly FieldEqualityComparer CaseInsensitiveCompareDeclaringTypes = new FieldEqualityComparer(SigComparerOptions.CompareMethodFieldDeclaringType | SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Doesn't compare the declaring types, case insensitive names
		/// </summary>
		public static readonly FieldEqualityComparer CaseInsensitiveDontCompareDeclaringTypes = new FieldEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public FieldEqualityComparer(SigComparerOptions options) => this.options = options;

		/// <inheritdoc/>
		public bool Equals(IField x, IField y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(IField obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(FieldDef x, FieldDef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(FieldDef obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(MemberRef x, MemberRef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(MemberRef obj) => new SigComparer(options).GetHashCode(obj);
	}

	/// <summary>
	/// Compares methods
	/// </summary>
	public sealed class MethodEqualityComparer : IEqualityComparer<IMethod>, IEqualityComparer<IMethodDefOrRef>, IEqualityComparer<MethodDef>, IEqualityComparer<MemberRef>, IEqualityComparer<MethodSpec> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Compares the declaring types
		/// </summary>
		public static readonly MethodEqualityComparer CompareDeclaringTypes = new MethodEqualityComparer(SigComparerOptions.CompareMethodFieldDeclaringType);

		/// <summary>
		/// Doesn't compare the declaring types
		/// </summary>
		public static readonly MethodEqualityComparer DontCompareDeclaringTypes = new MethodEqualityComparer(0);

		/// <summary>
		/// Compares the declaring types, case insensitive names
		/// </summary>
		public static readonly MethodEqualityComparer CaseInsensitiveCompareDeclaringTypes = new MethodEqualityComparer(SigComparerOptions.CompareMethodFieldDeclaringType | SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Doesn't compare the declaring types, case insensitive names
		/// </summary>
		public static readonly MethodEqualityComparer CaseInsensitiveDontCompareDeclaringTypes = new MethodEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public MethodEqualityComparer(SigComparerOptions options) => this.options = options;

		/// <inheritdoc/>
		public bool Equals(IMethod x, IMethod y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(IMethod obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(IMethodDefOrRef x, IMethodDefOrRef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(IMethodDefOrRef obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(MethodDef x, MethodDef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(MethodDef obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(MemberRef x, MemberRef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(MemberRef obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(MethodSpec x, MethodSpec y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(MethodSpec obj) => new SigComparer(options).GetHashCode(obj);
	}

	/// <summary>
	/// Compares properties
	/// </summary>
	public sealed class PropertyEqualityComparer : IEqualityComparer<PropertyDef> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Compares the declaring types
		/// </summary>
		public static readonly PropertyEqualityComparer CompareDeclaringTypes = new PropertyEqualityComparer(SigComparerOptions.ComparePropertyDeclaringType);

		/// <summary>
		/// Doesn't compare the declaring types
		/// </summary>
		public static readonly PropertyEqualityComparer DontCompareDeclaringTypes = new PropertyEqualityComparer(0);

		/// <summary>
		/// Compares the declaring types, case insensitive names
		/// </summary>
		public static readonly PropertyEqualityComparer CaseInsensitiveCompareDeclaringTypes = new PropertyEqualityComparer(SigComparerOptions.ComparePropertyDeclaringType | SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Doesn't compare the declaring types, case insensitive names
		/// </summary>
		public static readonly PropertyEqualityComparer CaseInsensitiveDontCompareDeclaringTypes = new PropertyEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public PropertyEqualityComparer(SigComparerOptions options) => this.options = options;

		/// <inheritdoc/>
		public bool Equals(PropertyDef x, PropertyDef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(PropertyDef obj) => new SigComparer(options).GetHashCode(obj);
	}

	/// <summary>
	/// Compares events
	/// </summary>
	public sealed class EventEqualityComparer : IEqualityComparer<EventDef> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Compares the declaring types
		/// </summary>
		public static readonly EventEqualityComparer CompareDeclaringTypes = new EventEqualityComparer(SigComparerOptions.CompareEventDeclaringType);

		/// <summary>
		/// Doesn't compare the declaring types
		/// </summary>
		public static readonly EventEqualityComparer DontCompareDeclaringTypes = new EventEqualityComparer(0);

		/// <summary>
		/// Compares the declaring types, case insensitive names
		/// </summary>
		public static readonly EventEqualityComparer CaseInsensitiveCompareDeclaringTypes = new EventEqualityComparer(SigComparerOptions.CompareEventDeclaringType | SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Doesn't compare the declaring types, case insensitive names
		/// </summary>
		public static readonly EventEqualityComparer CaseInsensitiveDontCompareDeclaringTypes = new EventEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public EventEqualityComparer(SigComparerOptions options) => this.options = options;

		/// <inheritdoc/>
		public bool Equals(EventDef x, EventDef y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(EventDef obj) => new SigComparer(options).GetHashCode(obj);
	}

	/// <summary>
	/// Compares calling convention signatures
	/// </summary>
	public sealed class SignatureEqualityComparer : IEqualityComparer<CallingConventionSig>, IEqualityComparer<MethodBaseSig>, IEqualityComparer<MethodSig>, IEqualityComparer<PropertySig>, IEqualityComparer<FieldSig>, IEqualityComparer<LocalSig>, IEqualityComparer<GenericInstMethodSig> {
		readonly SigComparerOptions options;

		/// <summary>
		/// Default instance
		/// </summary>
		public static readonly SignatureEqualityComparer Instance = new SignatureEqualityComparer(0);

		/// <summary>
		/// Case insensitive names
		/// </summary>
		public static readonly SignatureEqualityComparer CaseInsensitive = new SignatureEqualityComparer(SigComparerOptions.CaseInsensitiveAll);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public SignatureEqualityComparer(SigComparerOptions options) => this.options = options;

		/// <inheritdoc/>
		public bool Equals(CallingConventionSig x, CallingConventionSig y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(CallingConventionSig obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(MethodBaseSig x, MethodBaseSig y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(MethodBaseSig obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(MethodSig x, MethodSig y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(MethodSig obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(PropertySig x, PropertySig y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(PropertySig obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(FieldSig x, FieldSig y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(FieldSig obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(LocalSig x, LocalSig y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(LocalSig obj) => new SigComparer(options).GetHashCode(obj);

		/// <inheritdoc/>
		public bool Equals(GenericInstMethodSig x, GenericInstMethodSig y) => new SigComparer(options).Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(GenericInstMethodSig obj) => new SigComparer(options).GetHashCode(obj);
	}

	/// <summary>
	/// Decides how to compare types, sigs, etc
	/// </summary>
	[Flags]
	public enum SigComparerOptions : uint {
		/// <summary>
		/// Don't compare a type's (assembly/module) scope
		/// </summary>
		DontCompareTypeScope = 1,

		/// <summary>
		/// Compares a method/field's declaring type.
		/// </summary>
		CompareMethodFieldDeclaringType = 2,

		/// <summary>
		/// Compares a property's declaring type
		/// </summary>
		ComparePropertyDeclaringType = 4,

		/// <summary>
		/// Compares an event's declaring type
		/// </summary>
		CompareEventDeclaringType = 8,

		/// <summary>
		/// Compares method / field / property / event declaring types
		/// </summary>
		CompareDeclaringTypes = CompareMethodFieldDeclaringType | ComparePropertyDeclaringType | CompareEventDeclaringType,

		/// <summary>
		/// Compares parameters after a sentinel in method sigs. Should not be enabled when
		/// comparing <see cref="MethodSig"/>s against <see cref="MethodInfo"/>s since it's
		/// not possible to get those sentinel params from a <see cref="MethodInfo"/>.
		/// </summary>
		CompareSentinelParams = 0x10,

		/// <summary>
		/// Compares assembly public key token
		/// </summary>
		CompareAssemblyPublicKeyToken = 0x20,

		/// <summary>
		/// Compares assembly version
		/// </summary>
		CompareAssemblyVersion = 0x40,

		/// <summary>
		/// Compares assembly locale
		/// </summary>
		CompareAssemblyLocale = 0x80,

		/// <summary>
		/// If set, a <see cref="TypeRef"/> and an <see cref="ExportedType"/> can reference the
		/// global <c>&lt;Module&gt;</c> type.
		/// </summary>
		TypeRefCanReferenceGlobalType = 0x100,

		/// <summary>
		/// Don't compare a method/property's return type
		/// </summary>
		DontCompareReturnType = 0x200,

		// Internal only
		//SubstituteGenericParameters = 0x400,

		/// <summary>
		/// Type namespaces are case insensitive
		/// </summary>
		CaseInsensitiveTypeNamespaces = 0x800,

		/// <summary>
		/// Type names (not namespaces) are case insensitive
		/// </summary>
		CaseInsensitiveTypeNames = 0x1000,

		/// <summary>
		/// Type names and namespaces are case insensitive
		/// </summary>
		CaseInsensitiveTypes = CaseInsensitiveTypeNamespaces | CaseInsensitiveTypeNames,

		/// <summary>
		/// Method and field names are case insensitive
		/// </summary>
		CaseInsensitiveMethodFieldNames = 0x2000,

		/// <summary>
		/// Property names are case insensitive
		/// </summary>
		CaseInsensitivePropertyNames = 0x4000,

		/// <summary>
		/// Event names are case insensitive
		/// </summary>
		CaseInsensitiveEventNames = 0x8000,

		/// <summary>
		/// Type namespaces, type names, method names, field names, property names
		/// and event names are all case insensitive
		/// </summary>
		CaseInsensitiveAll = CaseInsensitiveTypeNamespaces | CaseInsensitiveTypeNames |
						CaseInsensitiveMethodFieldNames | CaseInsensitivePropertyNames |
						CaseInsensitiveEventNames,

		/// <summary>
		/// A field that is <see cref="FieldAttributes.PrivateScope"/> can compare equal to
		/// a <see cref="MemberRef"/>
		/// </summary>
		PrivateScopeFieldIsComparable = 0x10000,

		/// <summary>
		/// A method that is <see cref="MethodAttributes.PrivateScope"/> can compare equal to
		/// a <see cref="MemberRef"/>
		/// </summary>
		PrivateScopeMethodIsComparable = 0x20000,

		/// <summary>
		/// A field that is <see cref="FieldAttributes.PrivateScope"/> and a method that is
		/// <see cref="MethodAttributes.PrivateScope"/> can compare equal to a <see cref="MemberRef"/>
		/// </summary>
		PrivateScopeIsComparable = PrivateScopeFieldIsComparable | PrivateScopeMethodIsComparable,

		/// <summary>
		/// Raw (bit by bit) comparison of signatures. This matches what the CLR does when it
		/// compares signatures. This means that metadata tokens will be compared.
		/// </summary>
		RawSignatureCompare = 0x40000,

		/// <summary>
		/// Ignore required and optional modifiers when comparing <see cref="TypeSig"/>s.
		/// They're already ignored when comparing eg. a <see cref="TypeSig"/> with a
		/// <see cref="TypeRef"/>.
		/// </summary>
		IgnoreModifiers = 0x80000,

		/// <summary>
		/// By default, all module and assembly compares when they're both the system library
		/// (eg. mscorlib or System.Runtime.dll) return true, even if they're really different,
		/// eg. mscorlib (.NET Framework 2.0) vs mscorlib (Windows CE). If this flag is set, the system
		/// library is compared just like any other module/assembly.
		/// </summary>
		MscorlibIsNotSpecial = 0x100000,

		/// <summary>
		/// Don't project CLR compatible WinMD references back to the original CLR type/method before comparing
		/// </summary>
		DontProjectWinMDRefs = 0x200000,

		/// <summary>
		/// Don't check type equivalence when comparing types. Starting with .NET Framework 4.0, two different
		/// types can be considered equivalent if eg. a TypeIdentifierAttribute is used.
		/// </summary>
		DontCheckTypeEquivalence = 0x400000,

		/// <summary>
		/// When comparing types, don't compare a multi-dimensional array's lower bounds and sizes
		/// </summary>
		IgnoreMultiDimensionalArrayLowerBoundsAndSizes = 0x800000,
	}

	/// <summary>
	/// Compares types, signatures, methods, fields, properties, events
	/// </summary>
	public struct SigComparer {
		const SigComparerOptions SigComparerOptions_SubstituteGenericParameters = (SigComparerOptions)0x400;

		const int HASHCODE_MAGIC_GLOBAL_TYPE = 1654396648;
		const int HASHCODE_MAGIC_NESTED_TYPE = -1049070942;
		const int HASHCODE_MAGIC_ET_MODULE = -299744851;
		const int HASHCODE_MAGIC_ET_VALUEARRAY = -674970533;
		const int HASHCODE_MAGIC_ET_GENERICINST = -2050514639;
		const int HASHCODE_MAGIC_ET_VAR = 1288450097;
		const int HASHCODE_MAGIC_ET_MVAR = -990598495;
		const int HASHCODE_MAGIC_ET_ARRAY = -96331531;
		const int HASHCODE_MAGIC_ET_SZARRAY = 871833535;
		const int HASHCODE_MAGIC_ET_BYREF = -634749586;
		const int HASHCODE_MAGIC_ET_PTR = 1976400808;
		const int HASHCODE_MAGIC_ET_SENTINEL = 68439620;

		RecursionCounter recursionCounter;
		SigComparerOptions options;
		GenericArguments genericArguments;
		readonly ModuleDef sourceModule;

		bool DontCompareTypeScope => (options & SigComparerOptions.DontCompareTypeScope) != 0;
		bool CompareMethodFieldDeclaringType => (options & SigComparerOptions.CompareMethodFieldDeclaringType) != 0;
		bool ComparePropertyDeclaringType => (options & SigComparerOptions.ComparePropertyDeclaringType) != 0;
		bool CompareEventDeclaringType => (options & SigComparerOptions.CompareEventDeclaringType) != 0;
		bool CompareSentinelParams => (options & SigComparerOptions.CompareSentinelParams) != 0;
		bool CompareAssemblyPublicKeyToken => (options & SigComparerOptions.CompareAssemblyPublicKeyToken) != 0;
		bool CompareAssemblyVersion => (options & SigComparerOptions.CompareAssemblyVersion) != 0;
		bool CompareAssemblyLocale => (options & SigComparerOptions.CompareAssemblyLocale) != 0;
		bool TypeRefCanReferenceGlobalType => (options & SigComparerOptions.TypeRefCanReferenceGlobalType) != 0;
		bool DontCompareReturnType => (options & SigComparerOptions.DontCompareReturnType) != 0;
		bool SubstituteGenericParameters => (options & SigComparerOptions_SubstituteGenericParameters) != 0;
		bool CaseInsensitiveTypeNamespaces => (options & SigComparerOptions.CaseInsensitiveTypeNamespaces) != 0;
		bool CaseInsensitiveTypeNames => (options & SigComparerOptions.CaseInsensitiveTypeNames) != 0;
		bool CaseInsensitiveMethodFieldNames => (options & SigComparerOptions.CaseInsensitiveMethodFieldNames) != 0;
		bool CaseInsensitivePropertyNames => (options & SigComparerOptions.CaseInsensitivePropertyNames) != 0;
		bool CaseInsensitiveEventNames => (options & SigComparerOptions.CaseInsensitiveEventNames) != 0;
		bool PrivateScopeFieldIsComparable => (options & SigComparerOptions.PrivateScopeFieldIsComparable) != 0;
		bool PrivateScopeMethodIsComparable => (options & SigComparerOptions.PrivateScopeMethodIsComparable) != 0;
		bool RawSignatureCompare => (options & SigComparerOptions.RawSignatureCompare) != 0;
		bool IgnoreModifiers => (options & SigComparerOptions.IgnoreModifiers) != 0;
		bool MscorlibIsNotSpecial => (options & SigComparerOptions.MscorlibIsNotSpecial) != 0;
		bool DontProjectWinMDRefs => (options & SigComparerOptions.DontProjectWinMDRefs) != 0;
		bool DontCheckTypeEquivalence => (options & SigComparerOptions.DontCheckTypeEquivalence) != 0;
		bool IgnoreMultiDimensionalArrayLowerBoundsAndSizes => (options & SigComparerOptions.IgnoreMultiDimensionalArrayLowerBoundsAndSizes) != 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		public SigComparer(SigComparerOptions options)
			: this(options, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Comparison options</param>
		/// <param name="sourceModule">The module which the comparison take place in.</param>
		public SigComparer(SigComparerOptions options, ModuleDef sourceModule) {
			recursionCounter = new RecursionCounter();
			this.options = options;
			genericArguments = null;
			this.sourceModule = sourceModule;
		}

		/// <summary>
		/// <see cref="ElementType.FnPtr"/> is mapped to <see cref="System.IntPtr"/>, so use
		/// the same hash code for both
		/// </summary>
		int GetHashCode_FnPtr_SystemIntPtr() {
			// ********************************************
			// IMPORTANT: This must match GetHashCode(TYPE)
			// ********************************************

			return GetHashCode_TypeNamespace("System") +
					GetHashCode_TypeName("IntPtr");
		}

		bool Equals_Names(bool caseInsensitive, UTF8String a, UTF8String b) {
			if (caseInsensitive)
				return UTF8String.ToSystemStringOrEmpty(a).Equals(UTF8String.ToSystemStringOrEmpty(b), StringComparison.OrdinalIgnoreCase);
			return UTF8String.Equals(a, b);
		}

		bool Equals_Names(bool caseInsensitive, string a, string b) {
			if (caseInsensitive)
				return (a ?? string.Empty).Equals(b ?? string.Empty, StringComparison.OrdinalIgnoreCase);
			return (a ?? string.Empty) == (b ?? string.Empty);
		}

		int GetHashCode_Name(bool caseInsensitive, string a) {
			if (caseInsensitive)
				return (a ?? string.Empty).ToUpperInvariant().GetHashCode();
			return (a ?? string.Empty).GetHashCode();
		}

		bool Equals_TypeNamespaces(UTF8String a, UTF8String b) => Equals_Names(CaseInsensitiveTypeNamespaces, a, b);
		bool Equals_TypeNamespaces(UTF8String a, string b) => Equals_Names(CaseInsensitiveTypeNamespaces, UTF8String.ToSystemStringOrEmpty(a), b);
		int GetHashCode_TypeNamespace(UTF8String a) => GetHashCode_Name(CaseInsensitiveTypeNamespaces, UTF8String.ToSystemStringOrEmpty(a));
		int GetHashCode_TypeNamespace(string a) => GetHashCode_Name(CaseInsensitiveTypeNamespaces, a);
		bool Equals_TypeNames(UTF8String a, UTF8String b) => Equals_Names(CaseInsensitiveTypeNames, a, b);
		bool Equals_TypeNames(UTF8String a, string b) => Equals_Names(CaseInsensitiveTypeNames, UTF8String.ToSystemStringOrEmpty(a), b);
		int GetHashCode_TypeName(UTF8String a) => GetHashCode_Name(CaseInsensitiveTypeNames, UTF8String.ToSystemStringOrEmpty(a));
		int GetHashCode_TypeName(string a) => GetHashCode_Name(CaseInsensitiveTypeNames, a);
		bool Equals_MethodFieldNames(UTF8String a, UTF8String b) => Equals_Names(CaseInsensitiveMethodFieldNames, a, b);
		bool Equals_MethodFieldNames(UTF8String a, string b) => Equals_Names(CaseInsensitiveMethodFieldNames, UTF8String.ToSystemStringOrEmpty(a), b);
		int GetHashCode_MethodFieldName(UTF8String a) => GetHashCode_Name(CaseInsensitiveMethodFieldNames, UTF8String.ToSystemStringOrEmpty(a));
		int GetHashCode_MethodFieldName(string a) => GetHashCode_Name(CaseInsensitiveMethodFieldNames, a);
		bool Equals_PropertyNames(UTF8String a, UTF8String b) => Equals_Names(CaseInsensitivePropertyNames, a, b);
		bool Equals_PropertyNames(UTF8String a, string b) => Equals_Names(CaseInsensitivePropertyNames, UTF8String.ToSystemStringOrEmpty(a), b);
		int GetHashCode_PropertyName(UTF8String a) => GetHashCode_Name(CaseInsensitivePropertyNames, UTF8String.ToSystemStringOrEmpty(a));
		int GetHashCode_PropertyName(string a) => GetHashCode_Name(CaseInsensitivePropertyNames, a);
		bool Equals_EventNames(UTF8String a, UTF8String b) => Equals_Names(CaseInsensitiveEventNames, a, b);
		bool Equals_EventNames(UTF8String a, string b) => Equals_Names(CaseInsensitiveEventNames, UTF8String.ToSystemStringOrEmpty(a), b);
		int GetHashCode_EventName(UTF8String a) => GetHashCode_Name(CaseInsensitiveEventNames, UTF8String.ToSystemStringOrEmpty(a));
		int GetHashCode_EventName(string a) => GetHashCode_Name(CaseInsensitiveEventNames, a);

		SigComparerOptions ClearOptions(SigComparerOptions flags) {
			var old = options;
			options &= ~flags;
			return old;
		}

		SigComparerOptions SetOptions(SigComparerOptions flags) {
			var old = options;
			options |= flags;
			return old;
		}

		void RestoreOptions(SigComparerOptions oldFlags) => options = oldFlags;

		void InitializeGenericArguments() {
			if (genericArguments is null)
				genericArguments = new GenericArguments();
		}

		static GenericInstSig GetGenericInstanceType(IMemberRefParent parent) {
			var ts = parent as TypeSpec;
			if (ts is null)
				return null;
			return ts.TypeSig.RemoveModifiers() as GenericInstSig;
		}

		bool Equals(IAssembly aAsm, IAssembly bAsm, TypeRef b) {
			if (Equals(aAsm, bAsm))
				return true;

			// Could be an exported type. Resolve it and check again.

			var td = b.Resolve(sourceModule);
			return td is not null && Equals(aAsm, td.Module.Assembly);
		}

		bool Equals(IAssembly aAsm, IAssembly bAsm, ExportedType b) {
			if (Equals(aAsm, bAsm))
				return true;

			var td = b.Resolve();
			return td is not null && Equals(aAsm, td.Module.Assembly);
		}

		bool Equals(IAssembly aAsm, TypeRef a, IAssembly bAsm, TypeRef b) {
			if (Equals(aAsm, bAsm))
				return true;

			// Could be exported types. Resolve them and check again.

			var tda = a.Resolve(sourceModule);
			var tdb = b.Resolve(sourceModule);
			return tda is not null && tdb is not null && Equals(tda.Module.Assembly, tdb.Module.Assembly);
		}

		bool Equals(IAssembly aAsm, ExportedType a, IAssembly bAsm, ExportedType b) {
			if (Equals(aAsm, bAsm))
				return true;

			var tda = a.Resolve();
			var tdb = b.Resolve();
			return tda is not null && tdb is not null && Equals(tda.Module.Assembly, tdb.Module.Assembly);
		}

		bool Equals(IAssembly aAsm, TypeRef a, IAssembly bAsm, ExportedType b) {
			if (Equals(aAsm, bAsm))
				return true;

			// Could be an exported type. Resolve it and check again.

			var tda = a.Resolve(sourceModule);
			var tdb = b.Resolve();
			return tda is not null && tdb is not null && Equals(tda.Module.Assembly, tdb.Module.Assembly);
		}

		bool Equals(TypeDef a, IModule bMod, TypeRef b) {
			if (Equals(a.Module, bMod) && Equals(a.DefinitionAssembly, b.DefinitionAssembly))
				return true;

			// Could be an exported type. Resolve it and check again.

			var td = b.Resolve(sourceModule);
			if (td is null)
				return false;
			if (!DontCheckTypeEquivalence) {
				if (TIAHelper.Equivalent(a, td))
					return true;
			}
			return Equals(a.Module, td.Module) && Equals(a.DefinitionAssembly, td.DefinitionAssembly);
		}

		bool Equals(TypeDef a, FileDef bFile, ExportedType b) {
			if (Equals(a.Module, bFile) && Equals(a.DefinitionAssembly, b.DefinitionAssembly))
				return true;

			var td = b.Resolve();
			return td is not null && Equals(a.Module, td.Module) && Equals(a.DefinitionAssembly, td.DefinitionAssembly);
		}

		bool TypeDefScopeEquals(TypeDef a, TypeDef b) {
			if (a is null || b is null)
				return false;
			if (!DontCheckTypeEquivalence) {
				if (TIAHelper.Equivalent(a, b))
					return true;
			}
			return Equals(a.Module, b.Module);
		}

		bool Equals(TypeRef a, IModule ma, TypeRef b, IModule mb) {
			if (Equals(ma, mb) && Equals(a.DefinitionAssembly, b.DefinitionAssembly))
				return true;

			// Could be exported types. Resolve them and check again.

			var tda = a.Resolve(sourceModule);
			var tdb = b.Resolve(sourceModule);
			return tda is not null && tdb is not null &&
				Equals(tda.Module, tdb.Module) && Equals(tda.DefinitionAssembly, tdb.DefinitionAssembly);
		}

		bool Equals(TypeRef a, IModule ma, ExportedType b, FileDef fb) {
			if (Equals(ma, fb) && Equals(a.DefinitionAssembly, b.DefinitionAssembly))
				return true;

			// Could be an exported type. Resolve it and check again.

			var tda = a.Resolve(sourceModule);
			var tdb = b.Resolve();
			return tda is not null && tdb is not null &&
				Equals(tda.Module, tdb.Module) && Equals(tda.DefinitionAssembly, tdb.DefinitionAssembly);
		}

		bool Equals(Assembly aAsm, IAssembly bAsm, TypeRef b) {
			if (Equals(bAsm, aAsm))
				return true;

			// Could be an exported type. Resolve it and check again.

			var td = b.Resolve(sourceModule);
			return td is not null && Equals(td.Module.Assembly, aAsm);
		}

		bool Equals(Assembly aAsm, IAssembly bAsm, ExportedType b) {
			if (Equals(bAsm, aAsm))
				return true;

			var td = b.Resolve();
			return td is not null && Equals(td.Module.Assembly, aAsm);
		}

		bool Equals(Type a, IModule bMod, TypeRef b) {
			if (Equals(bMod, a.Module) && Equals(b.DefinitionAssembly, a.Assembly))
				return true;

			// Could be an exported type. Resolve it and check again.

			var td = b.Resolve(sourceModule);
			return td is not null && Equals(td.Module, a.Module) && Equals(td.DefinitionAssembly, a.Assembly);
		}

		bool Equals(Type a, FileDef bFile, ExportedType b) {
			if (Equals(bFile, a.Module) && Equals(b.DefinitionAssembly, a.Assembly))
				return true;

			var td = b.Resolve();
			return td is not null && Equals(td.Module, a.Module) && Equals(td.DefinitionAssembly, a.Assembly);
		}

		/// <summary>
		/// Compare members
		/// </summary>
		/// <param name="a">Member #1</param>
		/// <param name="b">Member #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IMemberRef a, IMemberRef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			IType ta, tb;
			IField fa, fb;
			IMethod ma, mb;
			PropertyDef pa, pb;
			EventDef ea, eb;

			if ((ta = a as IType) is not null && (tb = b as IType) is not null)
				result = Equals(ta, tb);
			else if ((fa = a as IField) is not null && (fb = b as IField) is not null && fa.IsField && fb.IsField)
				result = Equals(fa, fb);
			else if ((ma = a as IMethod) is not null && (mb = b as IMethod) is not null)
				result = Equals(ma, mb);
			else if ((pa = a as PropertyDef) is not null && (pb = b as PropertyDef) is not null)
				result = Equals(pa, pb);
			else if ((ea = a as EventDef) is not null && (eb = b as EventDef) is not null)
				result = Equals(ea, eb);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a member
		/// </summary>
		/// <param name="a">The member</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IMemberRef a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int result;
			IType ta;
			IField fa;
			IMethod ma;
			PropertyDef pa;
			EventDef ea;

			if ((ta = a as IType) is not null)
				result = GetHashCode(ta);
			else if ((fa = a as IField) is not null)
				result = GetHashCode(fa);
			else if ((ma = a as IMethod) is not null)
				result = GetHashCode(ma);
			else if ((pa = a as PropertyDef) is not null)
				result = GetHashCode(pa);
			else if ((ea = a as EventDef) is not null)
				result = GetHashCode(ea);
			else
				result = 0;		// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ITypeDefOrRef a, ITypeDefOrRef b) => Equals((IType)a, (IType)b);

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(ITypeDefOrRef a) => GetHashCode((IType)a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IType a, IType b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeDef tda, tdb;
			TypeRef tra, trb;
			TypeSpec tsa, tsb;
			TypeSig sa, sb;
			ExportedType eta, etb;

			if ((tda = a as TypeDef) is not null & (tdb = b as TypeDef) is not null)
				result = Equals(tda, tdb);
			else if ((tra = a as TypeRef) is not null & (trb = b as TypeRef) is not null)
				result = Equals(tra, trb);
			else if ((tsa = a as TypeSpec) is not null & (tsb = b as TypeSpec) is not null)
				result = Equals(tsa, tsb);
			else if ((sa = a as TypeSig) is not null & (sb = b as TypeSig) is not null)
				result = Equals(sa, sb);
			else if ((eta = a as ExportedType) is not null & (etb = b as ExportedType) is not null)
				result = Equals(eta, etb);
			else if (tda is not null && trb is not null)
				result = Equals(tda, trb);		// TypeDef vs TypeRef
			else if (tra is not null && tdb is not null)
				result = Equals(tdb, tra);		// TypeDef vs TypeRef
			else if (tda is not null && tsb is not null)
				result = Equals(tda, tsb);		// TypeDef vs TypeSpec
			else if (tsa is not null && tdb is not null)
				result = Equals(tdb, tsa);		// TypeDef vs TypeSpec
			else if (tda is not null && sb is not null)
				result = Equals(tda, sb);		// TypeDef vs TypeSig
			else if (sa is not null && tdb is not null)
				result = Equals(tdb, sa);		// TypeDef vs TypeSig
			else if (tda is not null && etb is not null)
				result = Equals(tda, etb);		// TypeDef vs ExportedType
			else if (eta is not null && tdb is not null)
				result = Equals(tdb, eta);		// TypeDef vs ExportedType
			else if (tra is not null && tsb is not null)
				result = Equals(tra, tsb);		// TypeRef vs TypeSpec
			else if (tsa is not null && trb is not null)
				result = Equals(trb, tsa);		// TypeRef vs TypeSpec
			else if (tra is not null && sb is not null)
				result = Equals(tra, sb);		// TypeRef vs TypeSig
			else if (sa is not null && trb is not null)
				result = Equals(trb, sa);		// TypeRef vs TypeSig
			else if (tra is not null && etb is not null)
				result = Equals(tra, etb);		// TypeRef vs ExportedType
			else if (eta is not null && trb is not null)
				result = Equals(trb, eta);		// TypeRef vs ExportedType
			else if (tsa is not null && sb is not null)
				result = Equals(tsa, sb);		// TypeSpec vs TypeSig
			else if (sa is not null && tsb is not null)
				result = Equals(tsb, sa);		// TypeSpec vs TypeSig
			else if (tsa is not null && etb is not null)
				result = Equals(tsa, etb);		// TypeSpec vs ExportedType
			else if (eta is not null && tsb is not null)
				result = Equals(tsb, eta);		// TypeSpec vs ExportedType
			else if (sa is not null && etb is not null)
				result = Equals(sa, etb);		// TypeSig vs ExportedType
			else if (eta is not null && sb is not null)
				result = Equals(sb, eta);		// TypeSig vs ExportedType
			else
				result = false;	// Should never be reached

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IType a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash;
			TypeDef td;
			TypeRef tr;
			TypeSpec ts;
			TypeSig sig;
			ExportedType et;

			if ((td = a as TypeDef) is not null)
				hash = GetHashCode(td);
			else if ((tr = a as TypeRef) is not null)
				hash = GetHashCode(tr);
			else if ((ts = a as TypeSpec) is not null)
				hash = GetHashCode(ts);
			else if ((sig = a as TypeSig) is not null)
				hash = GetHashCode(sig);
			else if ((et = a as ExportedType) is not null)
				hash = GetHashCode(et);
			else
				hash = 0;	// Should never be reached

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, TypeDef b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, TypeRef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			IModule bMod;
			AssemblyRef bAsm;
			TypeRef dtb;

			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
				if (tra is not null) {
					result = Equals(tra, b);
					goto exit;
				}
			}

			var scope = b.ResolutionScope;

			if (!Equals_TypeNames(a.Name, b.Name) || !Equals_TypeNamespaces(a.Namespace, b.Namespace))
				result = false;
			else if ((dtb = scope as TypeRef) is not null)	// nested type
				result = Equals(a.DeclaringType, dtb);	// Compare enclosing types
			else if (a.DeclaringType is not null) {
				// a is nested, b isn't
				result = false;
			}
			else if (DontCompareTypeScope)
				result = true;
			else if ((bMod = scope as IModule) is not null)	// 'b' is defined in the same assembly as 'a'
				result = Equals(a, bMod, b);
			else if ((bAsm = scope as AssemblyRef) is not null) {
				var aMod = a.Module;
				result = aMod is not null && Equals(aMod.Assembly, bAsm, b);
				if (!result) {
					if (!DontCheckTypeEquivalence) {
						var tdb = b.Resolve();
						result = TypeDefScopeEquals(a, tdb);
					}
				}
			}
			else {
				result = false;
				//TODO: Handle the case where scope is null
			}

			if (result && !TypeRefCanReferenceGlobalType && a.IsGlobalModuleType)
				result = false;
exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, TypeDef b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ExportedType dtb;
			FileDef bFile;
			AssemblyRef bAsm;
			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
				if (tra is not null) {
					result = Equals(tra, b);
					goto exit;
				}
			}

			var scope = b.Implementation;

			if (!Equals_TypeNames(a.Name, b.TypeName) || !Equals_TypeNamespaces(a.Namespace, b.TypeNamespace))
				result = false;
			else if ((dtb = scope as ExportedType) is not null) {	// nested type
				result = Equals(a.DeclaringType, dtb);	// Compare enclosing types
			}
			else if (a.DeclaringType is not null) {
				result = false;	// a is nested, b isn't
			}
			else if (DontCompareTypeScope)
				result = true;
			else {
				if ((bFile = scope as FileDef) is not null)
					result = Equals(a, bFile, b);
				else if ((bAsm = scope as AssemblyRef) is not null) {
					var aMod = a.Module;
					result = aMod is not null && Equals(aMod.Assembly, bAsm, b);
				}
				else
					result = false;
				if (!result && !DontCheckTypeEquivalence) {
					var tdb = b.Resolve();
					result = TypeDefScopeEquals(a, tdb);
				}
			}

			if (result && !TypeRefCanReferenceGlobalType && a.IsGlobalModuleType)
				result = false;
exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, TypeDef b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, TypeSpec b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			return Equals(a, b.TypeSig);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, TypeDef b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, TypeSig b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			//*************************************************************
			// If this code gets updated, update GetHashCode(TypeSig),
			// Equals(TypeRef,TypeSig) and Equals(TypeSig,ExportedType) too
			//*************************************************************
			if (b is TypeDefOrRefSig b2)
				result = Equals(a, (IType)b2.TypeDefOrRef);
			else if (b is ModifierSig || b is PinnedSig)
				result = Equals(a, b.Next);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, TypeRef b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, TypeSpec b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			return Equals(a, b.TypeSig);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, TypeRef b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}
			bool result = Equals_TypeNames(a.Name, b.TypeName) &&
					Equals_TypeNamespaces(a.Namespace, b.TypeNamespace) &&
					EqualsScope(a, b);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, TypeRef b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, TypeSig b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			//*************************************************************
			// If this code gets updated, update GetHashCode(TypeSig),
			// Equals(TypeRef,TypeSig) and Equals(TypeSig,ExportedType) too
			//*************************************************************
			if (b is TypeDefOrRefSig b2)
				result = Equals(a, (IType)b2.TypeDefOrRef);
			else if (b is ModifierSig || b is PinnedSig)
				result = Equals(a, b.Next);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, TypeSpec b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, TypeSig b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			return Equals(a.TypeSig, b);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, TypeSpec b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			return Equals(a.TypeSig, b);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, TypeSig b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			//*************************************************************
			// If this code gets updated, update GetHashCode(TypeSig),
			// Equals(TypeRef,TypeSig) and Equals(TypeSig,ExportedType) too
			//*************************************************************
			if (a is TypeDefOrRefSig a2)
				result = Equals(a2.TypeDefOrRef, b);
			else if (a is ModifierSig || a is PinnedSig)
				result = Equals(a.Next, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		int GetHashCodeGlobalType() {
			// We don't always know the name+namespace of the global type, eg. when it's
			// referenced by a ModuleRef. Use the same hash for all global types.
			return HASHCODE_MAGIC_GLOBAL_TYPE;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, TypeRef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}
			bool result = Equals_TypeNames(a.Name, b.Name) &&
					Equals_TypeNamespaces(a.Namespace, b.Namespace) &&
					EqualsResolutionScope(a, b);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(TypeRef a) {
			// ************************************************************************************
			// IMPORTANT: This hash code must match the Type/TypeRef/TypeDef/ExportedType
			// hash code and GetHashCode_FnPtr_SystemIntPtr() method
			// ************************************************************************************

			// See GetHashCode(Type) for the reason why null returns GetHashCodeGlobalType()
			if (a is null)
				return TypeRefCanReferenceGlobalType ? GetHashCodeGlobalType() : 0;
			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;

			int hash;
			hash = GetHashCode_TypeName(a.Name);
			if (a.ResolutionScope is TypeRef)
				hash += HASHCODE_MAGIC_NESTED_TYPE;
			else
				hash += GetHashCode_TypeNamespace(a.Namespace);
			return hash;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, ExportedType b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}
			bool result = Equals_TypeNames(a.TypeName, b.TypeName) &&
					Equals_TypeNamespaces(a.TypeNamespace, b.TypeNamespace) &&
					EqualsImplementation(a, b);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(ExportedType a) {
			// ************************************************************************************
			// IMPORTANT: This hash code must match the Type/TypeRef/TypeDef/ExportedType
			// hash code and GetHashCode_FnPtr_SystemIntPtr() method
			// ************************************************************************************

			// See GetHashCode(Type) for the reason why null returns GetHashCodeGlobalType()
			if (a is null)
				return TypeRefCanReferenceGlobalType ? GetHashCodeGlobalType() : 0;
			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
			int hash;
			hash = GetHashCode_TypeName(a.TypeName);
			if (a.Implementation is ExportedType)
				hash += HASHCODE_MAGIC_NESTED_TYPE;
			else
				hash += GetHashCode_TypeNamespace(a.TypeNamespace);
			return hash;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, TypeDef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;

			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				var trb = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b);
				if (tra is not null || trb is not null) {
					result = Equals((IType)tra ?? a, (IType)trb ?? b);
					goto exit;
				}
			}
			result = Equals_TypeNames(a.Name, b.Name) &&
					Equals_TypeNamespaces(a.Namespace, b.Namespace) &&
					Equals(a.DeclaringType, b.DeclaringType) &&
					(DontCompareTypeScope || TypeDefScopeEquals(a, b));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(TypeDef a) {
			// ************************************************************************************
			// IMPORTANT: This hash code must match the Type/TypeRef/TypeDef/ExportedType
			// hash code and GetHashCode_FnPtr_SystemIntPtr() method
			// ************************************************************************************

			// See GetHashCode(Type) for the reason why null returns GetHashCodeGlobalType()
			if (a is null || a.IsGlobalModuleType)
				return GetHashCodeGlobalType();
			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				if (tra is not null)
					return GetHashCode(tra);
			}

			int hash;
			hash = GetHashCode_TypeName(a.Name);
			if (a.DeclaringType is not null)
				hash += HASHCODE_MAGIC_NESTED_TYPE;
			else
				hash += GetHashCode_TypeNamespace(a.Namespace);
			return hash;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, TypeSpec b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals(a.TypeSig, b.TypeSig);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(TypeSpec a) {
			if (a is null)
				return 0;
			return GetHashCode(a.TypeSig);
		}

		/// <summary>
		/// Compares resolution scopes
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool EqualsResolutionScope(TypeRef a, TypeRef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			var ra = a.ResolutionScope;
			var rb = b.ResolutionScope;
			if (ra == rb)
				return true;
			if (ra is null || rb is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeRef ea, eb;
			IModule ma, mb;
			AssemblyRef aa, ab;
			ModuleDef modDef;
			bool resolveCheck = true;

			// if one of them is a TypeRef, the other one must be too
			if ((ea = ra as TypeRef) is not null | (eb = rb as TypeRef) is not null) {
				result = Equals(ea, eb);
				resolveCheck = false;
			}
			else if (DontCompareTypeScope)
				result = true;
			// only compare if both are modules
			else if ((ma = ra as IModule) is not null & (mb = rb as IModule) is not null)
				result = Equals(a, ma, b, mb);
			// only compare if both are assemblies
			else if ((aa = ra as AssemblyRef) is not null & (ab = rb as AssemblyRef) is not null)
				result = Equals(aa, a, ab, b);
			else if (aa is not null && rb is ModuleRef) {
				var bMod = b.Module;
				result = bMod is not null && Equals(bMod.Assembly, b, aa, a);
			}
			else if (ab is not null && ra is ModuleRef) {
				var aMod = a.Module;
				result = aMod is not null && Equals(aMod.Assembly, a, ab, b);
			}
			else if (aa is not null && (modDef = rb as ModuleDef) is not null)
				result = Equals(modDef.Assembly, aa, a);
			else if (ab is not null && (modDef = ra as ModuleDef) is not null)
				result = Equals(modDef.Assembly, ab, b);
			else {
				result = false;
				resolveCheck = false;
			}
			if (!result && resolveCheck) {
				if (!DontCheckTypeEquivalence) {
					var td1 = a.Resolve();
					var td2 = b.Resolve();
					if (td1 is not null && td2 is not null)
						result = TypeDefScopeEquals(td1, td2);
				}
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares implementation
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool EqualsImplementation(ExportedType a, ExportedType b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			var ia = a.Implementation;
			var ib = b.Implementation;
			if (ia == ib)
				return true;
			if (ia is null || ib is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ExportedType ea, eb;
			FileDef fa, fb;
			AssemblyRef aa, ab;
			bool checkResolve = true;

			// if one of them is an ExportedType, the other one must be too
			if ((ea = ia as ExportedType) is not null | (eb = ib as ExportedType) is not null) {
				result = Equals(ea, eb);
				checkResolve = false;
			}
			else if (DontCompareTypeScope)
				result = true;
			// only compare if both are files
			else if ((fa = ia as FileDef) is not null & (fb = ib as FileDef) is not null)
				result = Equals(fa, fb);
			// only compare if both are assemblies
			else if ((aa = ia as AssemblyRef) is not null & (ab = ib as AssemblyRef) is not null)
				result = Equals(aa, a, ab, b);
			else if (fa is not null && ab is not null)
				result = Equals(a.DefinitionAssembly, ab, b);
			else if (fb is not null && aa is not null)
				result = Equals(b.DefinitionAssembly, aa, a);
			else {
				result = false;
				checkResolve = false;
			}
			if (!result && checkResolve && !DontCheckTypeEquivalence) {
				var td1 = a.Resolve();
				var td2 = b.Resolve();
				if (td1 is not null && td2 is not null)
					result = TypeDefScopeEquals(td1, td2);
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares resolution scope and implementation
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool EqualsScope(TypeRef a, ExportedType b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			var ra = a.ResolutionScope;
			var ib = b.Implementation;
			if (ra == ib)
				return true;
			if (ra is null || ib is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeRef ea;
			ExportedType eb;
			IModule ma;
			FileDef fb;
			AssemblyRef aa, ab;
			bool checkResolve = true;

			// If one is a nested type, the other one must be too
			if ((ea = ra as TypeRef) is not null | (eb = ib as ExportedType) is not null) {
				result = Equals(ea, eb);
				checkResolve = false;
			}
			else if (DontCompareTypeScope)
				result = true;
			else if ((ma = ra as IModule) is not null & (fb = ib as FileDef) is not null)
				result = Equals(a, ma, b, fb);
			else if ((aa = ra as AssemblyRef) is not null & (ab = ib as AssemblyRef) is not null)
				result = Equals(aa, a, ab, b);
			else if (ma is not null && ab is not null)
				result = Equals(a.DefinitionAssembly, ab, b);
			else if (fb is not null && aa is not null)
				result = Equals(b.DefinitionAssembly, aa, a);
			else {
				checkResolve = false;
				result = false;
			}
			if (!result && checkResolve && !DontCheckTypeEquivalence) {
				var td1 = a.Resolve();
				var td2 = b.Resolve();
				if (td1 is not null && td2 is not null)
					result = TypeDefScopeEquals(td1, td2);
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares files
		/// </summary>
		/// <param name="a">File #1</param>
		/// <param name="b">File #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(FileDef a, FileDef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;

			return UTF8String.CaseInsensitiveEquals(a.Name, b.Name);
		}

		/// <summary>
		/// Compares a module with a file
		/// </summary>
		/// <param name="a">Module</param>
		/// <param name="b">File</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IModule a, FileDef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;

			//TODO: You should compare against the module's file name, not the name in the metadata!
			return UTF8String.CaseInsensitiveEquals(a.Name, b.Name);
		}

		/// <summary>
		/// Compares modules
		/// </summary>
		/// <param name="a">Module #1</param>
		/// <param name="b">Module #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal bool Equals(IModule a, IModule b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;

			return UTF8String.CaseInsensitiveEquals(a.Name, b.Name);
		}

		static bool IsCorLib(ModuleDef a) => a is not null && a.IsManifestModule && a.Assembly.IsCorLib();

		static bool IsCorLib(IModule a) {
			var mod = a as ModuleDef;
			return mod is not null && mod.IsManifestModule && mod.Assembly.IsCorLib();
		}

		static bool IsCorLib(Module a) => a is not null && a.Assembly.ManifestModule == a && a.Assembly == typeof(void).Assembly;
		static bool IsCorLib(IAssembly a) => a.IsCorLib();
		static bool IsCorLib(Assembly a) => a == typeof(void).Assembly;

		/// <summary>
		/// Compares modules
		/// </summary>
		/// <param name="a">Module #1</param>
		/// <param name="b">Module #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(ModuleDef a, ModuleDef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals((IModule)a, (IModule)b) && Equals(a.Assembly, b.Assembly);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares assemblies
		/// </summary>
		/// <param name="a">Assembly #1</param>
		/// <param name="b">Assembly #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IAssembly a, IAssembly b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;
			if (!recursionCounter.Increment())
				return false;

			bool result = UTF8String.CaseInsensitiveEquals(a.Name, b.Name) &&
				(!CompareAssemblyPublicKeyToken || PublicKeyBase.TokenEquals(a.PublicKeyOrToken, b.PublicKeyOrToken)) &&
				(!CompareAssemblyVersion || Utils.Equals(a.Version, b.Version)) &&
				(!CompareAssemblyLocale || Utils.LocaleEquals(a.Culture, b.Culture));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, TypeSig b) {
			if (IgnoreModifiers) {
				a = a.RemoveModifiers();
				b = b.RemoveModifiers();
			}
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}

			if (a.ElementType != b.ElementType) {
				// Signatures must be identical. It's possible to have a U4 in a sig (short form
				// of System.UInt32), or a ValueType + System.UInt32 TypeRef (long form), but these
				// should not match in a sig (also the long form is invalid).
				result = false;
			}
			else {
				switch (a.ElementType) {
				case ElementType.Void:
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
				case ElementType.String:
				case ElementType.TypedByRef:
				case ElementType.I:
				case ElementType.U:
				case ElementType.Object:
				case ElementType.Sentinel:
					result = true;
					break;

				case ElementType.Ptr:
				case ElementType.ByRef:
				case ElementType.SZArray:
				case ElementType.Pinned:
					result = Equals(a.Next, b.Next);
					break;

				case ElementType.Array:
					ArraySig ara = a as ArraySig, arb = b as ArraySig;
					result = ara.Rank == arb.Rank &&
							(IgnoreMultiDimensionalArrayLowerBoundsAndSizes ||
							(Equals(ara.Sizes, arb.Sizes) &&
							Equals(ara.LowerBounds, arb.LowerBounds))) &&
							Equals(a.Next, b.Next);
					break;

				case ElementType.ValueType:
				case ElementType.Class:
					if (RawSignatureCompare)
						result = TokenEquals((a as ClassOrValueTypeSig).TypeDefOrRef, (b as ClassOrValueTypeSig).TypeDefOrRef);
					else
						result = Equals((IType)(a as ClassOrValueTypeSig).TypeDefOrRef, (IType)(b as ClassOrValueTypeSig).TypeDefOrRef);
					break;

				case ElementType.Var:
				case ElementType.MVar:
					result = (a as GenericSig).Number == (b as GenericSig).Number;
					break;

				case ElementType.GenericInst:
					var gia = (GenericInstSig)a;
					var gib = (GenericInstSig)b;
					if (RawSignatureCompare) {
						var gt1 = gia.GenericType;
						var gt2 = gib.GenericType;
						result = TokenEquals(gt1?.TypeDefOrRef, gt2?.TypeDefOrRef) &&
								Equals(gia.GenericArguments, gib.GenericArguments);
					}
					else {
						result = Equals(gia.GenericType, gib.GenericType) &&
								Equals(gia.GenericArguments, gib.GenericArguments);
					}
					break;

				case ElementType.FnPtr:
					result = Equals((a as FnPtrSig).Signature, (b as FnPtrSig).Signature);
					break;

				case ElementType.CModReqd:
				case ElementType.CModOpt:
					if (RawSignatureCompare)
						result = TokenEquals((a as ModifierSig).Modifier, (b as ModifierSig).Modifier) &&
								Equals(a.Next, b.Next);
					else
						result = Equals((IType)(a as ModifierSig).Modifier, (IType)(b as ModifierSig).Modifier) &&
								Equals(a.Next, b.Next);
					break;

				case ElementType.ValueArray:
					result = (a as ValueArraySig).Size == (b as ValueArraySig).Size && Equals(a.Next, b.Next);
					break;

				case ElementType.Module:
					result = (a as ModuleSig).Index == (b as ModuleSig).Index && Equals(a.Next, b.Next);
					break;

				case ElementType.End:
				case ElementType.R:
				case ElementType.Internal:
				default:
					result = false;
					break;
				}
			}

			recursionCounter.Decrement();
			return result;
		}

		static bool TokenEquals(ITypeDefOrRef a, ITypeDefOrRef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			return a.MDToken == b.MDToken;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(TypeSig a) {
			// ********************************************
			// IMPORTANT: This must match GetHashCode(Type)
			// ********************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			if (genericArguments is not null)
				a = genericArguments.Resolve(a);

			switch (a.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				// When comparing an ExportedType/TypeDef/TypeRef to a TypeDefOrRefSig/Class/ValueType,
				// the ET is ignored, so we must ignore it when calculating the hash.
				hash = GetHashCode((IType)(a as TypeDefOrRefSig).TypeDefOrRef);
				break;

			case ElementType.Sentinel:
				hash = HASHCODE_MAGIC_ET_SENTINEL;
				break;

			case ElementType.Ptr:
				hash = HASHCODE_MAGIC_ET_PTR + GetHashCode(a.Next);
				break;

			case ElementType.ByRef:
				hash = HASHCODE_MAGIC_ET_BYREF + GetHashCode(a.Next);
				break;

			case ElementType.SZArray:
				hash = HASHCODE_MAGIC_ET_SZARRAY + GetHashCode(a.Next);
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
				// When comparing an ExportedType/TypeDef/TypeRef to a ModifierSig/PinnedSig,
				// the ET is ignored, so we must ignore it when calculating the hash.
				hash = GetHashCode(a.Next);
				break;

			case ElementType.Array:
				// Don't include sizes and lower bounds since GetHashCode(Type) doesn't (and can't).
				// Also, if IgnoreMultiDimensionArrayLowerBoundsAndSizes is set, we shouldn't include them either.
				var ara = (ArraySig)a;
				hash = HASHCODE_MAGIC_ET_ARRAY + (int)ara.Rank + GetHashCode(ara.Next);
				break;

			case ElementType.Var:
				hash = HASHCODE_MAGIC_ET_VAR + (int)(a as GenericVar).Number;
				break;

			case ElementType.MVar:
				hash = HASHCODE_MAGIC_ET_MVAR + (int)(a as GenericMVar).Number;
				break;

			case ElementType.GenericInst:
				var gia = (GenericInstSig)a;
				hash = HASHCODE_MAGIC_ET_GENERICINST;
				if (SubstituteGenericParameters) {
					InitializeGenericArguments();
					genericArguments.PushTypeArgs(gia.GenericArguments);
					hash += GetHashCode(gia.GenericType);
					genericArguments.PopTypeArgs();
				}
				else
					hash += GetHashCode(gia.GenericType);
				hash += GetHashCode(gia.GenericArguments);
				break;

			case ElementType.FnPtr:
				hash = GetHashCode_FnPtr_SystemIntPtr();
				break;

			case ElementType.ValueArray:
				hash = HASHCODE_MAGIC_ET_VALUEARRAY + (int)(a as ValueArraySig).Size + GetHashCode(a.Next);
				break;

			case ElementType.Module:
				hash = HASHCODE_MAGIC_ET_MODULE + (int)(a as ModuleSig).Index + GetHashCode(a.Next);
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				hash = 0;
				break;
			}

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares type lists
		/// </summary>
		/// <param name="a">Type list #1</param>
		/// <param name="b">Type list #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IList<TypeSig> a, IList<TypeSig> b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.Count != b.Count)
				result = false;
			else {
				int i;
				for (i = 0; i < a.Count; i++) {
					if (!Equals(a[i], b[i]))
						break;
				}
				result = i == a.Count;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type list
		/// </summary>
		/// <param name="a">The type list</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IList<TypeSig> a) {
			//************************************************************************
			// IMPORTANT: This code must match any other GetHashCode(IList<SOME_TYPE>)
			//************************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			uint hash = 0;
			for (int i = 0; i < a.Count; i++) {
				hash += (uint)GetHashCode(a[i]);
				hash = (hash << 13) | (hash >> 19);
			}
			recursionCounter.Decrement();
			return (int)hash;
		}

		bool Equals(IList<uint> a, IList<uint> b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (a.Count != b.Count)
				return false;
			for (int i = 0; i < a.Count; i++) {
				if (a[i] != b[i])
					return false;
			}
			return true;
		}

		bool Equals(IList<int> a, IList<int> b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (a.Count != b.Count)
				return false;
			for (int i = 0; i < a.Count; i++) {
				if (a[i] != b[i])
					return false;
			}
			return true;
		}

		/// <summary>
		/// Compares signatures
		/// </summary>
		/// <param name="a">Sig #1</param>
		/// <param name="b">Sig #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(CallingConventionSig a, CallingConventionSig b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.GetCallingConvention() != b.GetCallingConvention())
				result = false;
			else {
				switch (a.GetCallingConvention() & CallingConvention.Mask) {
				case CallingConvention.Default:
				case CallingConvention.C:
				case CallingConvention.StdCall:
				case CallingConvention.ThisCall:
				case CallingConvention.FastCall:
				case CallingConvention.VarArg:
				case CallingConvention.Property:
				case CallingConvention.NativeVarArg:
				case CallingConvention.Unmanaged:
					MethodBaseSig ma = a as MethodBaseSig, mb = b as MethodBaseSig;
					result = ma is not null && mb is not null && Equals(ma, mb);
					break;

				case CallingConvention.Field:
					FieldSig fa = a as FieldSig, fb = b as FieldSig;
					result = fa is not null && fb is not null && Equals(fa, fb);
					break;

				case CallingConvention.LocalSig:
					LocalSig la = a as LocalSig, lb = b as LocalSig;
					result = la is not null && lb is not null && Equals(la, lb);
					break;

				case CallingConvention.GenericInst:
					GenericInstMethodSig ga = a as GenericInstMethodSig, gb = b as GenericInstMethodSig;
					result = ga is not null && gb is not null && Equals(ga, gb);
					break;

				default:
					result = false;
					break;
				}
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a sig
		/// </summary>
		/// <param name="a">The sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(CallingConventionSig a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			switch (a.GetCallingConvention() & CallingConvention.Mask) {
			case CallingConvention.Default:
			case CallingConvention.C:
			case CallingConvention.StdCall:
			case CallingConvention.ThisCall:
			case CallingConvention.FastCall:
			case CallingConvention.VarArg:
			case CallingConvention.Property:
			case CallingConvention.NativeVarArg:
			case CallingConvention.Unmanaged:
				var ma = a as MethodBaseSig;
				hash = ma is null ? 0 : GetHashCode(ma);
				break;

			case CallingConvention.Field:
				var fa = a as FieldSig;
				hash = fa is null ? 0 : GetHashCode(fa);
				break;

			case CallingConvention.LocalSig:
				var la = a as LocalSig;
				hash = la is null ? 0 : GetHashCode(la);
				break;

			case CallingConvention.GenericInst:
				var ga = a as GenericInstMethodSig;
				hash = ga is null ? 0 : GetHashCode(ga);
				break;

			default:
				hash = GetHashCode_CallingConvention(a);
				break;
			}

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares method/property sigs
		/// </summary>
		/// <param name="a">Method/property #1</param>
		/// <param name="b">Method/property #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBaseSig a, MethodBaseSig b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.GetCallingConvention() == b.GetCallingConvention() &&
					(DontCompareReturnType || Equals(a.RetType, b.RetType)) &&
					Equals(a.Params, b.Params) &&
					(!a.Generic || a.GenParamCount == b.GenParamCount) &&
					(!CompareSentinelParams || Equals(a.ParamsAfterSentinel, b.ParamsAfterSentinel));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a method/property sig
		/// </summary>
		/// <param name="a">The method/property sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MethodBaseSig a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a) +
					GetHashCode(a.Params);
			if (!DontCompareReturnType)
				hash += GetHashCode(a.RetType);
			if (a.Generic)
				hash += GetHashCode_ElementType_MVar((int)a.GenParamCount);
			if (CompareSentinelParams)
				hash += GetHashCode(a.ParamsAfterSentinel);

			recursionCounter.Decrement();
			return hash;
		}

		int GetHashCode_CallingConvention(CallingConventionSig a) => GetHashCode(a.GetCallingConvention());

		int GetHashCode(CallingConvention a) {
			//*******************************************************************
			// IMPORTANT: This hash must match the Reflection call conv hash code
			//*******************************************************************

			switch (a & CallingConvention.Mask) {
			case CallingConvention.Default:
			case CallingConvention.C:
			case CallingConvention.StdCall:
			case CallingConvention.ThisCall:
			case CallingConvention.FastCall:
			case CallingConvention.VarArg:
			case CallingConvention.Property:
			case CallingConvention.GenericInst:
			case CallingConvention.Unmanaged:
			case CallingConvention.NativeVarArg:
			case CallingConvention.Field:
				return (int)(a & (CallingConvention.Generic | CallingConvention.HasThis | CallingConvention.ExplicitThis));

			case CallingConvention.LocalSig:
			default:
				return (int)a;
			}
		}

		/// <summary>
		/// Compares field sigs
		/// </summary>
		/// <param name="a">Field sig #1</param>
		/// <param name="b">Field sig #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldSig a, FieldSig b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.GetCallingConvention() == b.GetCallingConvention() && Equals(a.Type, b.Type);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a field sig
		/// </summary>
		/// <param name="a">The field sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(FieldSig a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a) + GetHashCode(a.Type);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares local sigs
		/// </summary>
		/// <param name="a">Local sig #1</param>
		/// <param name="b">Local sig #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(LocalSig a, LocalSig b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.GetCallingConvention() == b.GetCallingConvention() && Equals(a.Locals, b.Locals);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a local sig
		/// </summary>
		/// <param name="a">The local sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(LocalSig a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a) + GetHashCode(a.Locals);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares generic method instance sigs
		/// </summary>
		/// <param name="a">Generic inst method #1</param>
		/// <param name="b">Generic inst method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(GenericInstMethodSig a, GenericInstMethodSig b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.GetCallingConvention() == b.GetCallingConvention() && Equals(a.GenericArguments, b.GenericArguments);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a generic instance method sig
		/// </summary>
		/// <param name="a">The generic inst method sig</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(GenericInstMethodSig a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a) + GetHashCode(a.GenericArguments);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IMethod a, IMethod b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			MethodDef mda, mdb;
			MemberRef mra, mrb;
			MethodSpec msa, msb;

			if ((mda = a as MethodDef) is not null & (mdb = b as MethodDef) is not null)
				result = Equals(mda, mdb);
			else if ((mra = a as MemberRef) is not null & (mrb = b as MemberRef) is not null)
				result = Equals(mra, mrb);
			else if ((msa = a as MethodSpec) is not null && (msb = b as MethodSpec) is not null)
				result = Equals(msa, msb);
			else if (mda is not null && mrb is not null)
				result = Equals(mda, mrb);
			else if (mra is not null && mdb is not null)
				result = Equals(mdb, mra);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a method
		/// </summary>
		/// <param name="a">The method</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IMethod a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash;
			MethodDef mda;
			MemberRef mra;
			MethodSpec msa;

			if ((mda = a as MethodDef) is not null)
				hash = GetHashCode(mda);
			else if ((mra = a as MemberRef) is not null)
				hash = GetHashCode(mra);
			else if ((msa = a as MethodSpec) is not null)
				hash = GetHashCode(msa);
			else
				hash = 0;

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, MethodDef b) => Equals(b, a);

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodDef a, MemberRef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			if (!DontProjectWinMDRefs) {
				var mra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
				if (mra is not null) {
					result = Equals(mra, b);
					goto exit;
				}
			}
			result = (PrivateScopeMethodIsComparable || !a.IsPrivateScope) &&
					Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.Class));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodDef a, MethodDef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			if (!DontProjectWinMDRefs) {
				var mra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				var mrb = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b);
				if (mra is not null || mrb is not null) {
					result = Equals((IMethod)mra ?? a, (IMethod)mrb ?? b);
					goto exit;
				}
			}
			result = Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a method
		/// </summary>
		/// <param name="a">The method</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MethodDef a) {
			// ***********************************************************************
			// IMPORTANT: This hash code must match the MemberRef/MethodBase hash code
			// ***********************************************************************
			if (a is null)
				return 0;
			if (!DontProjectWinMDRefs) {
				var mra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				if (mra is not null)
					return GetHashCode(mra);
			}

			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_MethodFieldName(a.Name) +
					GetHashCode(a.Signature);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares <c>MemberRef</c>s
		/// </summary>
		/// <param name="a"><c>MemberRef</c> #1</param>
		/// <param name="b"><c>MemberRef</c> #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, MemberRef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			if (!DontProjectWinMDRefs) {
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
				b = WinMDHelpers.ToCLR(b.Module ?? sourceModule, b) ?? b;
			}
			bool result = Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.Class, b.Class));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a <c>MemberRef</c>
		/// </summary>
		/// <param name="a">The <c>MemberRef</c></param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MemberRef a) {
			// ********************************************************************************
			// IMPORTANT: This hash code must match the MethodDef/FieldDef/MethodBase hash code
			// ********************************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;

			int hash = GetHashCode_MethodFieldName(a.Name);
			GenericInstSig git;
			if (SubstituteGenericParameters && (git = GetGenericInstanceType(a.Class)) is not null) {
				InitializeGenericArguments();
				genericArguments.PushTypeArgs(git.GenericArguments);
				hash += GetHashCode(a.Signature);
				genericArguments.PopTypeArgs();
			}
			else
				hash += GetHashCode(a.Signature);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.Class);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares <c>MethodSpec</c>s
		/// </summary>
		/// <param name="a"><c>MethodSpec</c> #1</param>
		/// <param name="b"><c>MethodSpec</c> #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodSpec a, MethodSpec b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals(a.Method, b.Method) && Equals(a.Instantiation, b.Instantiation);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a <c>MethodSpec</c>
		/// </summary>
		/// <param name="a">The <c>MethodSpec</c></param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MethodSpec a) {
			// *************************************************************
			// IMPORTANT: This hash code must match the MethodBase hash code
			// *************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			// We must do this or it won't get the same hash code as some MethodInfos
			var oldOptions = SetOptions(SigComparerOptions_SubstituteGenericParameters);
			var gim = a.GenericInstMethodSig;
			if (gim is not null) {
				InitializeGenericArguments();
				genericArguments.PushMethodArgs(gim.GenericArguments);
			}
			int hash = GetHashCode(a.Method);
			if (gim is not null)
				genericArguments.PopMethodArgs();
			RestoreOptions(oldOptions);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares <c>MemberRefParent</c>s
		/// </summary>
		/// <param name="a"><c>MemberRefParent</c> #1</param>
		/// <param name="b"><c>MemberRefParent</c> #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IMemberRefParent a, IMemberRefParent b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ITypeDefOrRef ita, itb;
			ModuleRef moda, modb;
			MethodDef ma, mb;
			TypeDef td;

			if ((ita = a as ITypeDefOrRef) is not null && (itb = b as ITypeDefOrRef) is not null)
				result = Equals((IType)ita, (IType)itb);
			else if ((moda = a as ModuleRef) is not null & (modb = b as ModuleRef) is not null) {
				ModuleDef omoda = moda.Module, omodb = modb.Module;
				result = Equals((IModule)moda, (IModule)modb) &&
						Equals(omoda?.Assembly, omodb?.Assembly);
			}
			else if ((ma = a as MethodDef) is not null && (mb = b as MethodDef) is not null)
				result = Equals(ma, mb);
			else if (modb is not null && (td = a as TypeDef) is not null)
				result = EqualsGlobal(td, modb);
			else if (moda is not null && (td = b as TypeDef) is not null)
				result = EqualsGlobal(td, moda);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a <c>MemberRefParent</c>
		/// </summary>
		/// <param name="a">The <c>MemberRefParent</c></param>
		/// <returns>The hash code</returns>
		int GetHashCode(IMemberRefParent a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash;
			ITypeDefOrRef ita;
			MethodDef ma;

			if ((ita = a as ITypeDefOrRef) is not null)
				hash = GetHashCode((IType)ita);
			else if (a is ModuleRef)
				hash = GetHashCodeGlobalType();
			else if ((ma = a as MethodDef) is not null) {
				// Only use the declaring type so we get the same hash code when hashing a MethodBase.
				hash = GetHashCode(ma.DeclaringType);
			}
			else
				hash = 0;

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IField a, IField b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			FieldDef fa, fb;
			MemberRef ma, mb;

			if ((fa = a as FieldDef) is not null & (fb = b as FieldDef) is not null)
				result = Equals(fa, fb);
			else if ((ma = a as MemberRef) is not null & (mb = b as MemberRef) is not null)
				result = Equals(ma, mb);
			else if (fa is not null && mb is not null)
				result = Equals(fa, mb);
			else if (fb is not null && ma is not null)
				result = Equals(fb, ma);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a field
		/// </summary>
		/// <param name="a">The field</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(IField a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash;
			FieldDef fa;
			MemberRef ma;

			if ((fa = a as FieldDef) is not null)
				hash = GetHashCode(fa);
			else if ((ma = a as MemberRef) is not null)
				hash = GetHashCode(ma);
			else
				hash = 0;

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, FieldDef b) => Equals(b, a);

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldDef a, MemberRef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = (PrivateScopeFieldIsComparable || !a.IsPrivateScope) &&
					Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.Class));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldDef a, FieldDef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.Signature, b.Signature) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a field
		/// </summary>
		/// <param name="a">The field</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(FieldDef a) {
			// **********************************************************************
			// IMPORTANT: This hash code must match the MemberRef/FieldInfo hash code
			// **********************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_MethodFieldName(a.Name) +
					GetHashCode(a.Signature);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares properties
		/// </summary>
		/// <param name="a">Property #1</param>
		/// <param name="b">Property #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(PropertyDef a, PropertyDef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_PropertyNames(a.Name, b.Name) &&
					Equals(a.Type, b.Type) &&
					(!ComparePropertyDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a property
		/// </summary>
		/// <param name="a">The property</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(PropertyDef a) {
			// ***************************************************************
			// IMPORTANT: This hash code must match the PropertyInfo hash code
			// ***************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			var sig = a.PropertySig;
			int hash = GetHashCode_PropertyName(a.Name) +
					GetHashCode(sig?.RetType);
			if (ComparePropertyDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares events
		/// </summary>
		/// <param name="a">Event #1</param>
		/// <param name="b">Event #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(EventDef a, EventDef b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_EventNames(a.Name, b.Name) &&
					Equals((IType)a.EventType, (IType)b.EventType) &&
					(!CompareEventDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of an event
		/// </summary>
		/// <param name="a">The event</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(EventDef a) {
			// ************************************************************
			// IMPORTANT: This hash code must match the EventInfo hash code
			// ************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_EventName(a.Name) +
					GetHashCode((IType)a.EventType);
			if (CompareEventDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		// Compares a with b, and a must be the global type
		bool EqualsGlobal(TypeDef a, ModuleRef b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = a.IsGlobalModuleType &&
				Equals((IModule)a.Module, (IModule)b) &&
				Equals(a.DefinitionAssembly, GetAssembly(b.Module));

			recursionCounter.Decrement();
			return result;
		}

		static AssemblyDef GetAssembly(ModuleDef module) => module?.Assembly;

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, IType b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IType a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeDef td;
			TypeRef tr;
			TypeSpec ts;
			TypeSig sig;
			ExportedType et;

			if ((td = a as TypeDef) is not null)
				result = Equals(td, b);
			else if ((tr = a as TypeRef) is not null)
				result = Equals(tr, b);
			else if ((ts = a as TypeSpec) is not null)
				result = Equals(ts, b);
			else if ((sig = a as TypeSig) is not null)
				result = Equals(sig, b);
			else if ((et = a as ExportedType) is not null)
				result = Equals(et, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, TypeDef b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeDef a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a is null)
				return false;
			if (b is null)
				return a.IsGlobalModuleType;
			if (!recursionCounter.Increment())
				return false;

			bool result;

			if (!DontProjectWinMDRefs) {
				var tra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				if (tra is not null) {
					result = Equals(tra, b);
					goto exit;
				}
			}
			result = !b.HasElementType &&
					Equals_TypeNames(a.Name, ReflectionExtensions.Unescape(b.Name)) &&
					Equals_TypeNamespaces(a.Namespace, b) &&
					EnclosingTypeEquals(a.DeclaringType, b.DeclaringType) &&
					(DontCompareTypeScope || Equals(a.Module, b.Module));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		bool EnclosingTypeEquals(TypeDef a, Type b) {
			// b is null doesn't mean that b is the global type
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			return Equals(a, b);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, TypeRef b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="b">Type #1</param>
		/// <param name="a">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeRef a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a is null)
				return false;
			if (b is null)
				return false;	// Must use a ModuleRef to reference the global type, so always fail
			if (!recursionCounter.Increment())
				return false;

			bool result;
			TypeRef dta;
			IModule aMod;
			AssemblyRef aAsm;
			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;

			var scope = a.ResolutionScope;

			if (!b.IsTypeDef())
				result = false;
			else if (!Equals_TypeNames(a.Name, ReflectionExtensions.Unescape(b.Name)) || !Equals_TypeNamespaces(a.Namespace, b))
				result = false;
			else if ((dta = scope as TypeRef) is not null)	// nested type
				result = Equals(dta, b.DeclaringType);	// Compare enclosing types
			else if (b.IsNested)
				result = false;	// b is nested, a isn't
			else if (DontCompareTypeScope)
				result = true;
			else if ((aMod = scope as IModule) is not null)	// 'a' is defined in the same assembly as 'b'
				result = Equals(b, aMod, a);
			else if ((aAsm = scope as AssemblyRef) is not null)
				result = Equals(b.Assembly, aAsm, a);
			else {
				result = false;
				//TODO: Handle the case where scope is null
			}

			recursionCounter.Decrement();
			return result;
		}

		bool Equals_TypeNamespaces(UTF8String a, Type b) {
			if (b.IsNested)
				return true;
			return Equals_TypeNamespaces(a, b.Namespace);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, TypeSpec b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSpec a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a is null)
				return false;
			if (b is null)
				return false;	// Must use a ModuleRef to reference the global type, so always fail
			return Equals(a.TypeSig, b);
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, TypeSig b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(TypeSig a, Type b) => Equals(a, b, false);

		bool Equals(ITypeDefOrRef a, Type b, bool treatAsGenericInst) {
			if (a is TypeSpec ts)
				return Equals(ts.TypeSig, b, treatAsGenericInst);
			return Equals(a, b);
		}

		/// <summary>
		/// Checks whether it's FnPtr&amp;, FnPtr*, FnPtr[], or FnPtr[...]
		/// </summary>
		/// <param name="a">The type</param>
		static bool IsFnPtrElementType(Type a) {
			if (a is null || !a.HasElementType)
				return false;
			var et = a.GetElementType();
			if (et is null || et.HasElementType)
				return false;
			if (et != typeof(IntPtr))	// FnPtr is mapped to System.IntPtr
				return false;
			if (!a.FullName.StartsWith("(fnptr)"))
				return false;

			return true;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <param name="treatAsGenericInst"><c>true</c> if we should treat <paramref name="b"/>
		/// as a generic instance type</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(TypeSig a, Type b, bool treatAsGenericInst) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a is null)
				return false;
			if (b is null)
				return false;	// Must use a ModuleRef to reference the global type, so always fail
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (genericArguments is not null)
				a = genericArguments.Resolve(a);

			switch (a.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
				result = Equals(((TypeDefOrRefSig)a).TypeDefOrRef, b, treatAsGenericInst);
				break;

			case ElementType.Ptr:
				if (!b.IsPointer)
					result = false;
				else if (IsFnPtrElementType(b)) {
					a = a.Next.RemoveModifiers();
					result = a is not null && a.ElementType == ElementType.FnPtr;
				}
				else
					result = Equals(a.Next, b.GetElementType());
				break;

			case ElementType.ByRef:
				if (!b.IsByRef)
					result = false;
				else if (IsFnPtrElementType(b)) {
					a = a.Next.RemoveModifiers();
					result = a is not null && a.ElementType == ElementType.FnPtr;
				}
				else
					result = Equals(a.Next, b.GetElementType());
				break;

			case ElementType.SZArray:
				if (!b.IsArray || !b.IsSZArray())
					result = false;
				else if (IsFnPtrElementType(b)) {
					a = a.Next.RemoveModifiers();
					result = a is not null && a.ElementType == ElementType.FnPtr;
				}
				else
					result = Equals(a.Next, b.GetElementType());
				break;

			case ElementType.Pinned:
				result = Equals(a.Next, b, treatAsGenericInst);
				break;

			case ElementType.Array:
				if (!b.IsArray || b.IsSZArray())
					result = false;
				else {
					var ara = a as ArraySig;
					result = ara.Rank == b.GetArrayRank() &&
						(IsFnPtrElementType(b) ?
								(a = a.Next.RemoveModifiers()) is not null && a.ElementType == ElementType.FnPtr :
								Equals(a.Next, b.GetElementType()));
				}
				break;

			case ElementType.ValueType:
			case ElementType.Class:
				result = Equals((a as ClassOrValueTypeSig).TypeDefOrRef, b, treatAsGenericInst);
				break;

			case ElementType.Var:
				result = b.IsGenericParameter &&
						b.GenericParameterPosition == (a as GenericSig).Number &&
						b.DeclaringMethod is null;
				break;

			case ElementType.MVar:
				result = b.IsGenericParameter &&
						b.GenericParameterPosition == (a as GenericSig).Number &&
						b.DeclaringMethod is not null;
				break;

			case ElementType.GenericInst:
				if (!(b.IsGenericType && !b.IsGenericTypeDefinition) && !treatAsGenericInst) {
					result = false;
					break;
				}
				var gia = (GenericInstSig)a;
				if (SubstituteGenericParameters) {
					InitializeGenericArguments();
					genericArguments.PushTypeArgs(gia.GenericArguments);
					result = Equals(gia.GenericType, b.GetGenericTypeDefinition());
					genericArguments.PopTypeArgs();
				}
				else
					result = Equals(gia.GenericType, b.GetGenericTypeDefinition());
				result = result && Equals(gia.GenericArguments, b.GetGenericArguments());
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
				result = Equals(a.Next, b, treatAsGenericInst);
				break;

			case ElementType.FnPtr:
				// At least in method sigs, this will be mapped to System.IntPtr
				result = b == typeof(IntPtr);
				break;

			case ElementType.Sentinel:
			case ElementType.ValueArray:
			case ElementType.Module:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				result = false;
				break;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="a">Type #1</param>
		/// <param name="b">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(Type a, ExportedType b) => Equals(b, a);

		/// <summary>
		/// Compares types
		/// </summary>
		/// <param name="b">Type #1</param>
		/// <param name="a">Type #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(ExportedType a, Type b) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a is null)
				return false;
			if (b is null)
				return false;	// Must use a ModuleRef to reference the global type, so always fail
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ExportedType dta;
			FileDef aFile;
			AssemblyRef aAsm;
			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;

			var scope = a.Implementation;

			if (!b.IsTypeDef())
				result = false;
			else if (!Equals_TypeNames(a.TypeName, ReflectionExtensions.Unescape(b.Name)) || !Equals_TypeNamespaces(a.TypeNamespace, b))
				result = false;
			else if ((dta = scope as ExportedType) is not null)	// nested type
				result = Equals(dta, b.DeclaringType);	// Compare enclosing types
			else if (b.IsNested)
				result = false;	// b is nested, a isn't
			else if (DontCompareTypeScope)
				result = true;
			else if ((aFile = scope as FileDef) is not null)
				result = Equals(b, aFile, a);
			else if ((aAsm = scope as AssemblyRef) is not null)
				result = Equals(b.Assembly, aAsm, a);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(Type a) => GetHashCode(a, false);

		/// <summary>
		/// Gets the hash code of a type
		/// </summary>
		/// <param name="a">The type</param>
		/// <param name="treatAsGenericInst"><c>true</c> if we should treat <paramref name="a"/>
		/// as a generic instance type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(Type a, bool treatAsGenericInst) {
			// **************************************************************************
			// IMPORTANT: This hash code must match the TypeSig/TypeDef/TypeRef hash code
			// **************************************************************************
			if (a is null)	// Could be global type
				return GetHashCode_TypeDef(a);
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			switch (treatAsGenericInst ? ElementType.GenericInst : a.GetElementType2()) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.ValueType:
			case ElementType.Class:
				hash = GetHashCode_TypeDef(a);
				break;

			case ElementType.FnPtr:
				hash = GetHashCode_FnPtr_SystemIntPtr();
				break;

			case ElementType.Sentinel:
				hash = HASHCODE_MAGIC_ET_SENTINEL;
				break;

			case ElementType.Ptr:
				hash = HASHCODE_MAGIC_ET_PTR +
					(IsFnPtrElementType(a) ? GetHashCode_FnPtr_SystemIntPtr() : GetHashCode(a.GetElementType()));
				break;

			case ElementType.ByRef:
				hash = HASHCODE_MAGIC_ET_BYREF +
					(IsFnPtrElementType(a) ? GetHashCode_FnPtr_SystemIntPtr() : GetHashCode(a.GetElementType()));
				break;

			case ElementType.SZArray:
				hash = HASHCODE_MAGIC_ET_SZARRAY +
					(IsFnPtrElementType(a) ? GetHashCode_FnPtr_SystemIntPtr() : GetHashCode(a.GetElementType()));
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Pinned:
				hash = GetHashCode(a.GetElementType());
				break;

			case ElementType.Array:
				// The type doesn't store sizes and lower bounds, so can't use them to
				// create the hash
				hash = HASHCODE_MAGIC_ET_ARRAY + a.GetArrayRank() +
					(IsFnPtrElementType(a) ? GetHashCode_FnPtr_SystemIntPtr() : GetHashCode(a.GetElementType()));
				break;

			case ElementType.Var:
				hash = HASHCODE_MAGIC_ET_VAR + a.GenericParameterPosition;
				break;

			case ElementType.MVar:
				hash = HASHCODE_MAGIC_ET_MVAR + a.GenericParameterPosition;
				break;

			case ElementType.GenericInst:
				hash = HASHCODE_MAGIC_ET_GENERICINST + GetHashCode(a.GetGenericTypeDefinition()) + GetHashCode(a.GetGenericArguments());
				break;

			case ElementType.ValueArray:
			case ElementType.Module:
			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				hash = 0;
				break;
			}

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Gets the hash code of a type list
		/// </summary>
		/// <param name="a">The type list</param>
		/// <returns>The hash code</returns>
		int GetHashCode(IList<Type> a) {
			//************************************************************************
			// IMPORTANT: This code must match any other GetHashCode(IList<SOME_TYPE>)
			//************************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			uint hash = 0;
			for (int i = 0; i < a.Count; i++) {
				hash += (uint)GetHashCode(a[i]);
				hash = (hash << 13) | (hash >> 19);
			}
			recursionCounter.Decrement();
			return (int)hash;
		}

		/// <summary>
		/// Gets the hash code of a list with only generic method parameters (<see cref="ElementType.MVar"/>)
		/// </summary>
		/// <param name="numGenericParams">Number of generic method parameters</param>
		/// <returns>Hash code</returns>
		static int GetHashCode_ElementType_MVar(int numGenericParams) => GetHashCode(numGenericParams, HASHCODE_MAGIC_ET_MVAR);

		static int GetHashCode(int numGenericParams, int etypeHashCode) {
			//************************************************************************
			// IMPORTANT: This code must match any other GetHashCode(IList<SOME_TYPE>)
			//************************************************************************
			uint hash = 0;
			for (int i = 0; i < numGenericParams; i++) {
				hash += (uint)(etypeHashCode + i);
				hash = (hash << 13) | (hash >> 19);
			}
			return (int)hash;
		}

		/// <summary>
		/// Gets the hash code of a TypeDef type
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>The hash code</returns>
		public int GetHashCode_TypeDef(Type a) {
			// ************************************************************************************
			// IMPORTANT: This hash code must match the Type/TypeRef/TypeDef/ExportedType
			// hash code and GetHashCode_FnPtr_SystemIntPtr() method
			// ************************************************************************************

			// A global method/field's declaring type is null. This is the reason we must
			// return GetHashCodeGlobalType() here.
			if (a is null)
				return GetHashCodeGlobalType();
			int hash;
			hash = GetHashCode_TypeName(ReflectionExtensions.Unescape(a.Name));
			if (a.IsNested)
				hash += HASHCODE_MAGIC_NESTED_TYPE;
			else
				hash += GetHashCode_TypeNamespace(a.Namespace);
			return hash;
		}

		/// <summary>
		/// Compares type lists
		/// </summary>
		/// <param name="a">Type list #1</param>
		/// <param name="b">Type list #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IList<TypeSig> a, IList<Type> b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.Count != b.Count)
				result = false;
			else {
				int i;
				for (i = 0; i < a.Count; i++) {
					if (!Equals(a[i], b[i]))
						break;
				}
				result = i == a.Count;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares modules
		/// </summary>
		/// <param name="a">Module #1</param>
		/// <param name="b">Module #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(ModuleDef a, Module b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals((IModule)a, b) && Equals(a.Assembly, b.Assembly);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares a file and a module
		/// </summary>
		/// <param name="a">File</param>
		/// <param name="b">Module</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(FileDef a, Module b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;

			// Use b.Name since it's the filename we want to compare, not b.ScopeName
			return UTF8String.ToSystemStringOrEmpty(a.Name).Equals(b.Name, StringComparison.OrdinalIgnoreCase);
		}

		/// <summary>
		/// Compares modules
		/// </summary>
		/// <param name="a">Module #1</param>
		/// <param name="b">Module #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IModule a, Module b) {
			if ((object)a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;

			// Use b.ScopeName and not b.Name since b.Name is just the file name w/o path
			return UTF8String.ToSystemStringOrEmpty(a.Name).Equals(b.ScopeName, StringComparison.OrdinalIgnoreCase);
		}

		/// <summary>
		/// Compares assemblies
		/// </summary>
		/// <param name="a">Assembly #1</param>
		/// <param name="b">Assembly #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IAssembly a, Assembly b) {
			if ((object)a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!MscorlibIsNotSpecial && IsCorLib(a) && IsCorLib(b))
				return true;
			if (!recursionCounter.Increment())
				return false;

			var bAsmName = b.GetName();
			bool result = UTF8String.ToSystemStringOrEmpty(a.Name).Equals(bAsmName.Name, StringComparison.OrdinalIgnoreCase) &&
				(!CompareAssemblyPublicKeyToken || PublicKeyBase.TokenEquals(a.PublicKeyOrToken, new PublicKeyToken(bAsmName.GetPublicKeyToken()))) &&
				(!CompareAssemblyVersion || Utils.Equals(a.Version, bAsmName.Version)) &&
				(!CompareAssemblyLocale || Utils.LocaleEquals(a.Culture, bAsmName.CultureInfo.Name));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares method declaring types
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool DeclaringTypeEquals(IMethod a, MethodBase b) {
			// If this is disabled, always return true, even if one is null, etc.
			if (!CompareMethodFieldDeclaringType)
				return true;

			if ((object)a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			MethodDef md;
			MemberRef mr;
			MethodSpec ms;

			if ((md = a as MethodDef) is not null)
				result = DeclaringTypeEquals(md, b);
			else if ((mr = a as MemberRef) is not null)
				result = DeclaringTypeEquals(mr, b);
			else if ((ms = a as MethodSpec) is not null)
				result = DeclaringTypeEquals(ms, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		bool DeclaringTypeEquals(MethodDef a, MethodBase b) {
			// If this is disabled, always return true, even if one is null, etc.
			if (!CompareMethodFieldDeclaringType)
				return true;
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			return Equals(a.DeclaringType, b.DeclaringType);
		}

		bool DeclaringTypeEquals(MemberRef a, MethodBase b) {
			// If this is disabled, always return true, even if one is null, etc.
			if (!CompareMethodFieldDeclaringType)
				return true;
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			return Equals(a.Class, b.DeclaringType, b.Module);
		}

		bool DeclaringTypeEquals(MethodSpec a, MethodBase b) {
			// If this is disabled, always return true, even if one is null, etc.
			if (!CompareMethodFieldDeclaringType)
				return true;
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			return DeclaringTypeEquals(a.Method, b);
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, IMethod b) => Equals(b, a);

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IMethod a, MethodBase b) {
			if ((object)a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			MethodDef md;
			MemberRef mr;
			MethodSpec ms;

			if ((md = a as MethodDef) is not null)
				result = Equals(md, b);
			else if ((mr = a as MemberRef) is not null)
				result = Equals(mr, b);
			else if ((ms = a as MethodSpec) is not null)
				result = Equals(ms, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, MethodDef b) => Equals(b, a);

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodDef a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			if (!DontProjectWinMDRefs) {
				var mra = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a);
				if (mra is not null) {
					result = Equals(mra, b);
					goto exit;
				}
			}

			var amSig = a.MethodSig;
			result = Equals_MethodFieldNames(a.Name, b.Name) &&
					amSig is not null &&
					((amSig.Generic && b.IsGenericMethodDefinition && b.IsGenericMethod) ||
					(!amSig.Generic && !b.IsGenericMethodDefinition && !b.IsGenericMethod)) &&
					Equals(amSig, b) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

exit: ;
			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares method sigs
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, MethodSig b) => Equals(b, a);

		/// <summary>
		/// Compares method sigs
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodSig a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals(a.GetCallingConvention(), b) &&
					(DontCompareReturnType || ReturnTypeEquals(a.RetType, b)) &&
					Equals(a.Params, b.GetParameters(), b.DeclaringType) &&
					(!a.Generic || a.GenParamCount == b.GetGenericArguments().Length);

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, MemberRef b) => Equals(b, a);

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (!DontProjectWinMDRefs)
				a = WinMDHelpers.ToCLR(a.Module ?? sourceModule, a) ?? a;
			if (b.IsGenericMethod && !b.IsGenericMethodDefinition) {
				// 'a' must be a method ref in a generic type. This comparison must match
				// the MethodSpec vs MethodBase comparison code.
				result = a.IsMethodRef && a.MethodSig.Generic;

				var oldOptions = ClearOptions(SigComparerOptions.CompareMethodFieldDeclaringType);
				result = result && Equals(a, b.Module.ResolveMethod(b.MetadataToken));
				RestoreOptions(oldOptions);
				result = result && DeclaringTypeEquals(a, b);

				result = result && GenericMethodArgsEquals((int)a.MethodSig.GenParamCount, b.GetGenericArguments());
			}
			else {
				var amSig = a.MethodSig;
				result = Equals_MethodFieldNames(a.Name, b.Name) &&
						amSig is not null &&
						((amSig.Generic && b.IsGenericMethodDefinition && b.IsGenericMethod) ||
						(!amSig.Generic && !b.IsGenericMethodDefinition && !b.IsGenericMethod));

				GenericInstSig git;
				if (SubstituteGenericParameters && (git = GetGenericInstanceType(a.Class)) is not null) {
					InitializeGenericArguments();
					genericArguments.PushTypeArgs(git.GenericArguments);
					result = result && Equals(amSig, b);
					genericArguments.PopTypeArgs();
				}
				else
					result = result && Equals(amSig, b);

				result = result && (!CompareMethodFieldDeclaringType || Equals(a.Class, b.DeclaringType, b.Module));
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares generic method args, making sure <paramref name="methodGenArgs"/> only
		/// contains <see cref="ElementType.MVar"/>s.
		/// </summary>
		/// <param name="numMethodArgs">Number of generic method args in method #1</param>
		/// <param name="methodGenArgs">Generic method args in method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		static bool GenericMethodArgsEquals(int numMethodArgs, IList<Type> methodGenArgs) {
			if (numMethodArgs != methodGenArgs.Count)
				return false;
			for (int i = 0; i < numMethodArgs; i++) {
				if (methodGenArgs[i].GetElementType2() != ElementType.MVar)
					return false;
			}
			return true;
		}

		bool Equals(IMemberRefParent a, Type b, Module bModule) {
			// Global methods and fields have their DeclaringType set to null. Assume
			// null always means the global type.
			if (a is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			ITypeDefOrRef ita;
			ModuleRef moda;
			MethodDef ma;
			TypeDef td;

			if ((ita = a as ITypeDefOrRef) is not null)
				result = Equals((IType)ita, b);
			else if ((moda = a as ModuleRef) is not null) {
				var omoda = moda.Module;
				result = b is null &&	// b is null => it's the global type
						Equals(moda, bModule) &&
						Equals(omoda?.Assembly, bModule.Assembly);
			}
			else if ((ma = a as MethodDef) is not null)
				result = Equals(ma.DeclaringType, b);
			else if (b is null && (td = a as TypeDef) is not null)
				result = td.IsGlobalModuleType;
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodBase a, MethodSpec b) => Equals(b, a);

		/// <summary>
		/// Compares methods
		/// </summary>
		/// <param name="a">Method #1</param>
		/// <param name="b">Method #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MethodSpec a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			// Make sure it's a MethodSpec
			bool result = b.IsGenericMethod && !b.IsGenericMethodDefinition;

			// Don't compare declaring types yet because the resolved method has the wrong
			// declaring type (its declaring type is a generic type def).
			// NOTE: We must not push generic method args when comparing a.Method
			var oldOptions = ClearOptions(SigComparerOptions.CompareMethodFieldDeclaringType);
			result = result && Equals(a.Method, b.Module.ResolveMethod(b.MetadataToken));
			RestoreOptions(oldOptions);
			result = result && DeclaringTypeEquals(a.Method, b);

			var gim = a.GenericInstMethodSig;
			result = result && gim is not null && Equals(gim.GenericArguments, b.GetGenericArguments());

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a <c>MethodBase</c>
		/// </summary>
		/// <param name="a">The <c>MethodBase</c></param>
		/// <returns>The hash code</returns>
		public int GetHashCode(MethodBase a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			// ***********************************************************************
			// IMPORTANT: This hash code must match the MemberRef/MethodSpec hash code
			// ***********************************************************************
			int hash = GetHashCode_MethodFieldName(a.Name) +
					GetHashCode_MethodSig(a);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		int GetHashCode_MethodSig(MethodBase a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(a.CallingConvention, a.IsGenericMethod) +
					GetHashCode(a.GetParameters(), a.DeclaringType);
			if (!DontCompareReturnType)
				hash += GetHashCode_ReturnType(a);
			if (a.IsGenericMethod)
				hash += GetHashCode_ElementType_MVar(a.GetGenericArguments().Length);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Gets the hash code of a parameter list
		/// </summary>
		/// <param name="a">The type list</param>
		/// <param name="declaringType">Declaring type of method that owns parameter <paramref name="a"/></param>
		/// <returns>The hash code</returns>
		int GetHashCode(IList<ParameterInfo> a, Type declaringType) {
			//************************************************************************
			// IMPORTANT: This code must match any other GetHashCode(IList<SOME_TYPE>)
			//************************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			uint hash = 0;
			for (int i = 0; i < a.Count; i++) {
				hash += (uint)GetHashCode(a[i], declaringType);
				hash = (hash << 13) | (hash >> 19);
			}
			recursionCounter.Decrement();
			return (int)hash;
		}

		int GetHashCode_ReturnType(MethodBase a) {
			var mi = a as MethodInfo;
			if (mi is not null)
				return GetHashCode(mi.ReturnParameter, a.DeclaringType);
			return GetHashCode(typeof(void));
		}

		int GetHashCode(ParameterInfo a, Type declaringType) => GetHashCode(a.ParameterType, declaringType.MustTreatTypeAsGenericInstType(a.ParameterType));
		int GetHashCode(Type a, Type declaringType) => GetHashCode(a, declaringType.MustTreatTypeAsGenericInstType(a));

		/// <summary>
		/// Compares calling conventions
		/// </summary>
		/// <param name="a">Calling convention</param>
		/// <param name="b">Method</param>
		/// <returns></returns>
		static bool Equals(CallingConvention a, MethodBase b) {
			var bc = b.CallingConvention;

			if (((a & CallingConvention.Generic) != 0) != b.IsGenericMethod)
				return false;
			if (((a & CallingConvention.HasThis) != 0) != ((bc & CallingConventions.HasThis) != 0))
				return false;
			if (((a & CallingConvention.ExplicitThis) != 0) != ((bc & CallingConventions.ExplicitThis) != 0))
				return false;

			var cca = a & CallingConvention.Mask;
			switch (bc & CallingConventions.Any) {
			case CallingConventions.Standard:
				if (cca == CallingConvention.VarArg || cca == CallingConvention.NativeVarArg)
					return false;
				break;

			case CallingConventions.VarArgs:
				if (cca != CallingConvention.VarArg && cca != CallingConvention.NativeVarArg)
					return false;
				break;

			case CallingConventions.Any:
			default:
				break;
			}

			return true;
		}

		static int GetHashCode_CallingConvention(CallingConventions a, bool isGeneric) {
			//**************************************************************
			// IMPORTANT: This hash must match the other call conv hash code
			//**************************************************************

			CallingConvention cc = 0;

			if (isGeneric)
				cc |= CallingConvention.Generic;
			if ((a & CallingConventions.HasThis) != 0)
				cc |= CallingConvention.HasThis;
			if ((a & CallingConventions.ExplicitThis) != 0)
				cc |= CallingConvention.ExplicitThis;

			return (int)cc;
		}

		/// <summary>
		/// Compares return types
		/// </summary>
		/// <param name="a">Return type #1</param>
		/// <param name="b">MethodBase</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool ReturnTypeEquals(TypeSig a, MethodBase b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			var mi = b as MethodInfo;
			if (mi is not null)
				result = Equals(a, mi.ReturnParameter, b.DeclaringType);
			else if (b is ConstructorInfo)
				result = IsSystemVoid(a);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		static bool IsSystemVoid(TypeSig a) => a.RemovePinnedAndModifiers().GetElementType() == ElementType.Void;

		/// <summary>
		/// Compares parameter lists
		/// </summary>
		/// <param name="a">Type list #1</param>
		/// <param name="b">Type list #2</param>
		/// <param name="declaringType">Declaring type of method that owns parameter <paramref name="b"/></param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(IList<TypeSig> a, IList<ParameterInfo> b, Type declaringType) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.Count != b.Count)
				result = false;
			else {
				int i;
				for (i = 0; i < a.Count; i++) {
					if (!Equals(a[i], b[i], declaringType))
						break;
				}
				result = i == a.Count;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares parameter types
		/// </summary>
		/// <param name="a">Parameter type #1</param>
		/// <param name="b">Parameter #2</param>
		/// <param name="declaringType">Declaring type of method that owns parameter <paramref name="b"/></param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		bool Equals(TypeSig a, ParameterInfo b, Type declaringType) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = ModifiersEquals(a, b.GetRequiredCustomModifiers(), b.GetOptionalCustomModifiers(), out var a2) &&
						Equals(a2, b.ParameterType, declaringType.MustTreatTypeAsGenericInstType(b.ParameterType));

			recursionCounter.Decrement();
			return result;
		}

		bool ModifiersEquals(TypeSig a, IList<Type> reqMods2, IList<Type> optMods2, out TypeSig aAfterModifiers) {
			aAfterModifiers = a;
			if (!(a is ModifierSig))
				return reqMods2.Count == 0 && optMods2.Count == 0;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			var reqMods1 = new List<ITypeDefOrRef>(reqMods2.Count);
			var optMods1 = new List<ITypeDefOrRef>(optMods2.Count);
			while (true) {
				var modifierSig = aAfterModifiers as ModifierSig;
				if (modifierSig is null)
					break;
				if (modifierSig is CModOptSig)
					optMods1.Add(modifierSig.Modifier);
				else
					reqMods1.Add(modifierSig.Modifier);

				// This can only loop forever if the user created a loop. It's not possible
				// to create a loop with invalid metadata.
				aAfterModifiers = aAfterModifiers.Next;
			}
			optMods1.Reverse();
			reqMods1.Reverse();

			result = reqMods1.Count == reqMods2.Count &&
					optMods1.Count == optMods2.Count &&
					ModifiersEquals(reqMods1, reqMods2) &&
					ModifiersEquals(optMods1, optMods2);

			recursionCounter.Decrement();
			return result;
		}

		bool ModifiersEquals(IList<ITypeDefOrRef> a, IList<Type> b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;
			bool result;

			if (a.Count != b.Count)
				result = false;
			else {
				int i;
				for (i = 0; i < b.Count; i++) {
					if (!Equals(a[i], b[i]))
						break;
				}
				result = i == b.Count;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldInfo a, IField b) => Equals(b, a);

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(IField a, FieldInfo b) {
			if ((object)a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result;
			FieldDef fa;
			MemberRef ma;

			if ((fa = a as FieldDef) is not null)
				result = Equals(fa, b);
			else if ((ma = a as MemberRef) is not null)
				result = Equals(ma, b);
			else
				result = false;

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldInfo a, FieldDef b) => Equals(b, a);

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldDef a, FieldInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_MethodFieldNames(a.Name, b.Name) &&
					Equals(a.FieldSig, b) &&
					(!CompareMethodFieldDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		bool Equals(FieldSig a, FieldInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = ModifiersEquals(a.Type, b.GetRequiredCustomModifiers(), b.GetOptionalCustomModifiers(), out var a2) &&
					Equals(a2, b.FieldType, b.DeclaringType.MustTreatTypeAsGenericInstType(b.FieldType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(FieldInfo a, MemberRef b) => Equals(b, a);

		/// <summary>
		/// Compares fields
		/// </summary>
		/// <param name="a">Field #1</param>
		/// <param name="b">Field #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(MemberRef a, FieldInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_MethodFieldNames(a.Name, b.Name);

			GenericInstSig git;
			if (SubstituteGenericParameters && (git = GetGenericInstanceType(a.Class)) is not null) {
				InitializeGenericArguments();
				genericArguments.PushTypeArgs(git.GenericArguments);
				result = result && Equals(a.FieldSig, b);
				genericArguments.PopTypeArgs();
			}
			else
				result = result && Equals(a.FieldSig, b);

			result = result && (!CompareMethodFieldDeclaringType || Equals(a.Class, b.DeclaringType, b.Module));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a field
		/// </summary>
		/// <param name="a">The field</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(FieldInfo a) {
			// ************************************************************
			// IMPORTANT: This hash code must match the MemberRef hash code
			// ************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_MethodFieldName(a.Name) +
					GetHashCode_FieldSig(a);
			if (CompareMethodFieldDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		int GetHashCode_FieldSig(FieldInfo a) {
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;
			int hash;

			hash = GetHashCode_CallingConvention(0, false) + GetHashCode(a.FieldType, a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares properties
		/// </summary>
		/// <param name="a">Property #1</param>
		/// <param name="b">Property #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(PropertyDef a, PropertyInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_PropertyNames(a.Name, b.Name) &&
					Equals(a.PropertySig, b) &&
					(!ComparePropertyDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		bool Equals(PropertySig a, PropertyInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = ModifiersEquals(a.RetType, b.GetRequiredCustomModifiers(), b.GetOptionalCustomModifiers(), out var a2) &&
					Equals(a2, b.PropertyType, b.DeclaringType.MustTreatTypeAsGenericInstType(b.PropertyType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of a property
		/// </summary>
		/// <param name="a">The property</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(PropertyInfo a) {
			// **************************************************************
			// IMPORTANT: This hash code must match the PropertyDef hash code
			// **************************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_PropertyName(a.Name) +
					GetHashCode(a.PropertyType, a.DeclaringType);
			if (ComparePropertyDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <summary>
		/// Compares events
		/// </summary>
		/// <param name="a">Event #1</param>
		/// <param name="b">Event #2</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		public bool Equals(EventDef a, EventInfo b) {
			if ((object)a == (object)b)
				return true;	// both are null
			if (a is null || b is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool result = Equals_EventNames(a.Name, b.Name) &&
					Equals(a.EventType, b.EventHandlerType, b.DeclaringType.MustTreatTypeAsGenericInstType(b.EventHandlerType)) &&
					(!CompareEventDeclaringType || Equals(a.DeclaringType, b.DeclaringType));

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Gets the hash code of an event
		/// </summary>
		/// <param name="a">The event</param>
		/// <returns>The hash code</returns>
		public int GetHashCode(EventInfo a) {
			// ***********************************************************
			// IMPORTANT: This hash code must match the EventDef hash code
			// ***********************************************************
			if (a is null)
				return 0;
			if (!recursionCounter.Increment())
				return 0;

			int hash = GetHashCode_EventName(a.Name) +
					GetHashCode(a.EventHandlerType, a.DeclaringType);
			if (CompareEventDeclaringType)
				hash += GetHashCode(a.DeclaringType);

			recursionCounter.Decrement();
			return hash;
		}

		/// <inheritdoc/>
		public override string ToString() => $"{recursionCounter} - {options}";
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Helps <see cref="SignatureReader"/> resolve types
	/// </summary>
	public interface ISignatureReaderHelper {
		/// <summary>
		/// Resolves a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="codedToken">A <c>TypeDefOrRef</c> coded token</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A <see cref="ITypeDefOrRef"/> or <c>null</c> if <paramref name="codedToken"/>
		/// is invalid</returns>
		ITypeDefOrRef ResolveTypeDefOrRef(uint codedToken, GenericParamContext gpContext);

		/// <summary>
		/// Converts the address of a <see cref="Type"/> to a <see cref="TypeSig"/>
		/// </summary>
		/// <seealso cref="Emit.MethodTableToTypeConverter"/>
		/// <param name="address">Address of <see cref="Type"/>. This is also known as the
		/// method table and has the same value as <see cref="RuntimeTypeHandle.Value"/></param>
		/// <returns>A <see cref="TypeSig"/> or <c>null</c> if not supported</returns>
		TypeSig ConvertRTInternalAddress(IntPtr address);
	}

	/// <summary>
	/// Reads signatures from the #Blob stream
	/// </summary>
	public struct SignatureReader {
		// .NET Core and .NET Framework limit arrays to 32 dimensions. Use a bigger limit
		// so it's possible to read some bad MD, but not big enough to allocate a ton of mem.
		const uint MaxArrayRank = 64;

		readonly ISignatureReaderHelper helper;
		readonly ICorLibTypes corLibTypes;
		DataReader reader;
		readonly GenericParamContext gpContext;
		RecursionCounter recursionCounter;

		/// <summary>
		/// Reads a signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD readerModule, uint sig) =>
			ReadSig(readerModule, sig, new GenericParamContext());

		/// <summary>
		/// Reads a signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD readerModule, uint sig, GenericParamContext gpContext) {
			try {
				var reader = new SignatureReader(readerModule, sig, gpContext);
				if (reader.reader.Length == 0)
					return null;
				var csig = reader.ReadSig();
				if (csig is not null)
					csig.ExtraData = reader.GetExtraData();
				return csig;
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature data</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD module, byte[] signature) =>
			ReadSig(module, module.CorLibTypes, ByteArrayDataReaderFactory.CreateReader(signature), new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD module, byte[] signature, GenericParamContext gpContext) =>
			ReadSig(module, module.CorLibTypes, ByteArrayDataReaderFactory.CreateReader(signature), gpContext);

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature reader</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD module, DataReader signature) =>
			ReadSig(module, module.CorLibTypes, signature, new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature reader</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ModuleDefMD module, DataReader signature, GenericParamContext gpContext) =>
			ReadSig(module, module.CorLibTypes, signature, gpContext);

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature) =>
			ReadSig(helper, corLibTypes, ByteArrayDataReaderFactory.CreateReader(signature), new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature, GenericParamContext gpContext) =>
			ReadSig(helper, corLibTypes, ByteArrayDataReaderFactory.CreateReader(signature), gpContext);

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, DataReader signature) =>
			ReadSig(helper, corLibTypes, signature, new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static CallingConventionSig ReadSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, DataReader signature, GenericParamContext gpContext) {
			try {
				var reader = new SignatureReader(helper, corLibTypes, ref signature, gpContext);
				if (reader.reader.Length == 0)
					return null;
				return reader.ReadSig();
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD readerModule, uint sig) =>
			ReadTypeSig(readerModule, sig, new GenericParamContext());

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD readerModule, uint sig, GenericParamContext gpContext) {
			try {
				var reader = new SignatureReader(readerModule, sig, gpContext);
				return reader.ReadType();
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD readerModule, uint sig, out byte[] extraData) =>
			ReadTypeSig(readerModule, sig, new GenericParamContext(), out extraData);

		/// <summary>
		/// Reads a type signature from the #Blob stream
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="sig"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD readerModule, uint sig, GenericParamContext gpContext, out byte[] extraData) {
			try {
				var reader = new SignatureReader(readerModule, sig, gpContext);
				TypeSig ts;
				try {
					ts = reader.ReadType();
				}
				catch (IOException) {
					reader.reader.Position = 0;
					ts = null;
				}
				extraData = reader.GetExtraData();
				return ts;
			}
			catch {
				extraData = null;
				return null;
			}
		}

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature data</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD module, byte[] signature) =>
			ReadTypeSig(module, module.CorLibTypes, ByteArrayDataReaderFactory.CreateReader(signature), new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD module, byte[] signature, GenericParamContext gpContext) =>
			ReadTypeSig(module, module.CorLibTypes, ByteArrayDataReaderFactory.CreateReader(signature), gpContext);

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature reader</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD module, DataReader signature) =>
			ReadTypeSig(module, module.CorLibTypes, signature, new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="module">The module where the signature is located in</param>
		/// <param name="signature">The signature reader</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ModuleDefMD module, DataReader signature, GenericParamContext gpContext) =>
			ReadTypeSig(module, module.CorLibTypes, signature, gpContext);

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature) =>
			ReadTypeSig(helper, corLibTypes, ByteArrayDataReaderFactory.CreateReader(signature), new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature, GenericParamContext gpContext) =>
			ReadTypeSig(helper, corLibTypes, ByteArrayDataReaderFactory.CreateReader(signature), gpContext);

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, DataReader signature) =>
			ReadTypeSig(helper, corLibTypes, signature, new GenericParamContext());

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, DataReader signature, GenericParamContext gpContext) =>
			ReadTypeSig(helper, corLibTypes, signature, gpContext, out var extraData);

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, byte[] signature, GenericParamContext gpContext, out byte[] extraData) =>
			ReadTypeSig(helper, corLibTypes, ByteArrayDataReaderFactory.CreateReader(signature), gpContext, out extraData);

		/// <summary>
		/// Reads a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="signature">The signature reader</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="extraData">If there's any extra data after the signature, it's saved
		/// here, else this will be <c>null</c></param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if
		/// <paramref name="signature"/> is invalid.</returns>
		public static TypeSig ReadTypeSig(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, DataReader signature, GenericParamContext gpContext, out byte[] extraData) {
			try {
				var reader = new SignatureReader(helper, corLibTypes, ref signature, gpContext);
				TypeSig ts;
				try {
					ts = reader.ReadType();
				}
				catch (IOException) {
					reader.reader.Position = 0;
					ts = null;
				}
				extraData = reader.GetExtraData();
				return ts;
			}
			catch {
				extraData = null;
				return null;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">Reader module</param>
		/// <param name="sig">#Blob stream offset of signature</param>
		/// <param name="gpContext">Generic parameter context</param>
		SignatureReader(ModuleDefMD readerModule, uint sig, GenericParamContext gpContext) {
			helper = readerModule;
			corLibTypes = readerModule.CorLibTypes;
			reader = readerModule.BlobStream.CreateReader(sig);
			this.gpContext = gpContext;
			recursionCounter = new RecursionCounter();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="helper">Token resolver</param>
		/// <param name="corLibTypes">A <see cref="ICorLibTypes"/> instance</param>
		/// <param name="reader">The signature data</param>
		/// <param name="gpContext">Generic parameter context</param>
		SignatureReader(ISignatureReaderHelper helper, ICorLibTypes corLibTypes, ref DataReader reader, GenericParamContext gpContext) {
			this.helper = helper;
			this.corLibTypes = corLibTypes;
			this.reader = reader;
			this.gpContext = gpContext;
			recursionCounter = new RecursionCounter();
		}

		byte[] GetExtraData() {
			if (reader.Position == reader.Length)
				return null;
			return reader.ReadRemainingBytes();
		}

		/// <summary>
		/// Reads the signature
		/// </summary>
		/// <returns>A new <see cref="CallingConventionSig"/> instance or <c>null</c> if invalid signature</returns>
		CallingConventionSig ReadSig() {
			if (!recursionCounter.Increment())
				return null;

			CallingConventionSig result;
			var callingConvention = (CallingConvention)reader.ReadByte();
			switch (callingConvention & CallingConvention.Mask) {
			case CallingConvention.Default:
			case CallingConvention.C:
			case CallingConvention.StdCall:
			case CallingConvention.ThisCall:
			case CallingConvention.FastCall:
			case CallingConvention.VarArg:
			case CallingConvention.Unmanaged:
			case CallingConvention.NativeVarArg:
				result = ReadMethod(callingConvention);
				break;

			case CallingConvention.Field:
				result = ReadField(callingConvention);
				break;

			case CallingConvention.LocalSig:
				result = ReadLocalSig(callingConvention);
				break;

			case CallingConvention.Property:
				result = ReadProperty(callingConvention);
				break;

			case CallingConvention.GenericInst:
				result = ReadGenericInstMethod(callingConvention);
				break;

			default:
				result = null;
				break;
			}

			recursionCounter.Decrement();
			return result;
		}

		/// <summary>
		/// Reads a <see cref="FieldSig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="FieldSig"/> instance</returns>
		FieldSig ReadField(CallingConvention callingConvention) => new FieldSig(callingConvention, ReadType());

		/// <summary>
		/// Reads a <see cref="MethodSig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="MethodSig"/> instance</returns>
		MethodSig ReadMethod(CallingConvention callingConvention) => ReadSig(new MethodSig(callingConvention));

		/// <summary>
		/// Reads a <see cref="PropertySig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="PropertySig"/> instance</returns>
		PropertySig ReadProperty(CallingConvention callingConvention) => ReadSig(new PropertySig(callingConvention));

		T ReadSig<T>(T methodSig) where T : MethodBaseSig {
			if (methodSig.Generic) {
				if (!reader.TryReadCompressedUInt32(out uint count))
					return null;
				methodSig.GenParamCount = count;
			}

			if (!reader.TryReadCompressedUInt32(out uint numParams))
				return null;

			methodSig.RetType = ReadType();

			var parameters = methodSig.Params;
			for (uint i = 0; i < numParams; i++) {
				var type = ReadType();
				if (type is SentinelSig) {
					if (methodSig.ParamsAfterSentinel is null)
						methodSig.ParamsAfterSentinel = parameters = new List<TypeSig>((int)(numParams - i));
					i--;
				}
				else
					parameters.Add(type);
			}

			return methodSig;
		}

		/// <summary>
		/// Reads a <see cref="LocalSig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="LocalSig"/> instance</returns>
		LocalSig ReadLocalSig(CallingConvention callingConvention) {
			if (!reader.TryReadCompressedUInt32(out uint count))
				return null;
			var sig = new LocalSig(callingConvention, count);
			var locals = sig.Locals;
			for (uint i = 0; i < count; i++)
				locals.Add(ReadType());
			return sig;
		}

		/// <summary>
		/// Reads a <see cref="GenericInstMethodSig"/>
		/// </summary>
		/// <param name="callingConvention">First byte of signature</param>
		/// <returns>A new <see cref="GenericInstMethodSig"/> instance</returns>
		GenericInstMethodSig ReadGenericInstMethod(CallingConvention callingConvention) {
			if (!reader.TryReadCompressedUInt32(out uint count))
				return null;
			var sig = new GenericInstMethodSig(callingConvention, count);
			var args = sig.GenericArguments;
			for (uint i = 0; i < count; i++)
				args.Add(ReadType());
			return sig;
		}

		/// <summary>
		/// Reads the next type
		/// </summary>
		/// <param name="allowTypeSpec"><c>true</c> if a <c>TypeSpec</c> is allowed if the next type is a class/value-type</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if invalid element type</returns>
		TypeSig ReadType(bool allowTypeSpec = false) {
			if (!recursionCounter.Increment())
				return null;

			uint num, i;
			TypeSig nextType, result = null;
			switch ((ElementType)reader.ReadByte()) {
			case ElementType.Void:		result = corLibTypes.Void; break;
			case ElementType.Boolean:	result = corLibTypes.Boolean; break;
			case ElementType.Char:		result = corLibTypes.Char; break;
			case ElementType.I1:		result = corLibTypes.SByte; break;
			case ElementType.U1:		result = corLibTypes.Byte; break;
			case ElementType.I2:		result = corLibTypes.Int16; break;
			case ElementType.U2:		result = corLibTypes.UInt16; break;
			case ElementType.I4:		result = corLibTypes.Int32; break;
			case ElementType.U4:		result = corLibTypes.UInt32; break;
			case ElementType.I8:		result = corLibTypes.Int64; break;
			case ElementType.U8:		result = corLibTypes.UInt64; break;
			case ElementType.R4:		result = corLibTypes.Single; break;
			case ElementType.R8:		result = corLibTypes.Double; break;
			case ElementType.String:	result = corLibTypes.String; break;
			case ElementType.TypedByRef:result = corLibTypes.TypedReference; break;
			case ElementType.I:			result = corLibTypes.IntPtr; break;
			case ElementType.U:			result = corLibTypes.UIntPtr; break;
			case ElementType.Object:	result = corLibTypes.Object; break;

			case ElementType.Ptr:		result = new PtrSig(ReadType()); break;
			case ElementType.ByRef:		result = new ByRefSig(ReadType()); break;
			case ElementType.ValueType:	result = new ValueTypeSig(ReadTypeDefOrRef(allowTypeSpec)); break;
			case ElementType.Class:		result = new ClassSig(ReadTypeDefOrRef(allowTypeSpec)); break;
			case ElementType.FnPtr:		result = new FnPtrSig(ReadSig()); break;
			case ElementType.SZArray:	result = new SZArraySig(ReadType()); break;
			case ElementType.CModReqd:	result = new CModReqdSig(ReadTypeDefOrRef(true), ReadType()); break;
			case ElementType.CModOpt:	result = new CModOptSig(ReadTypeDefOrRef(true), ReadType()); break;
			case ElementType.Sentinel:	result = new SentinelSig(); break;
			case ElementType.Pinned:	result = new PinnedSig(ReadType()); break;

			case ElementType.Var:
				if (!reader.TryReadCompressedUInt32(out num))
					break;
				result = new GenericVar(num, gpContext.Type);
				break;

			case ElementType.MVar:
				if (!reader.TryReadCompressedUInt32(out num))
					break;
				result = new GenericMVar(num, gpContext.Method);
				break;

			case ElementType.ValueArray:
				nextType = ReadType();
				if (!reader.TryReadCompressedUInt32(out num))
					break;
				result = new ValueArraySig(nextType, num);
				break;

			case ElementType.Module:
				if (!reader.TryReadCompressedUInt32(out num))
					break;
				result = new ModuleSig(num, ReadType());
				break;

			case ElementType.GenericInst:
				nextType = ReadType();
				if (!reader.TryReadCompressedUInt32(out num))
					break;
				var genericInstSig = new GenericInstSig(nextType as ClassOrValueTypeSig, num);
				var args = genericInstSig.GenericArguments;
				for (i = 0; i < num; i++)
					args.Add(ReadType());
				result = genericInstSig;
				break;

			case ElementType.Array:
				nextType = ReadType();
				uint rank;
				if (!reader.TryReadCompressedUInt32(out rank))
					break;
				if (rank > MaxArrayRank)
					break;
				if (rank == 0) {
					result = new ArraySig(nextType, rank);
					break;
				}
				if (!reader.TryReadCompressedUInt32(out num))
					break;
				if (num > MaxArrayRank)
					break;
				var sizes = new List<uint>((int)num);
				for (i = 0; i < num; i++) {
					if (!reader.TryReadCompressedUInt32(out uint size))
						goto exit;
					sizes.Add(size);
				}
				if (!reader.TryReadCompressedUInt32(out num))
					break;
				if (num > MaxArrayRank)
					break;
				var lowerBounds = new List<int>((int)num);
				for (i = 0; i < num; i++) {
					if (!reader.TryReadCompressedInt32(out int size))
						goto exit;
					lowerBounds.Add(size);
				}
				result = new ArraySig(nextType, rank, sizes, lowerBounds);
				break;

			case ElementType.Internal:
				IntPtr address;
				if (IntPtr.Size == 4)
					address = new IntPtr(reader.ReadInt32());
				else
					address = new IntPtr(reader.ReadInt64());
				result = helper.ConvertRTInternalAddress(address);
				break;

			case ElementType.End:
			case ElementType.R:
			default:
				result = null;
				break;
			}
exit:
			recursionCounter.Decrement();
			return result;
		}

		ITypeDefOrRef ReadTypeDefOrRef(bool allowTypeSpec) {
			if (!reader.TryReadCompressedUInt32(out uint codedToken))
				return null;
			if (!allowTypeSpec && CodedToken.TypeDefOrRef.Decode2(codedToken).Table == Table.TypeSpec)
				return null;
			return helper.ResolveTypeDefOrRef(codedToken, default);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the StandAloneSig table
	/// </summary>
	public abstract class StandAloneSig : IHasCustomAttribute, IHasCustomDebugInformation, IContainsGenericParameter {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.StandAloneSig, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 11;

		/// <summary>
		/// From column StandAloneSig.Signature
		/// </summary>
		public CallingConventionSig Signature {
			get => signature;
			set => signature = value;
		}
		/// <summary/>
		protected CallingConventionSig signature;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 11;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// Gets/sets the method sig
		/// </summary>
		public MethodSig MethodSig {
			get => signature as MethodSig;
			set => signature = value;
		}

		/// <summary>
		/// Gets/sets the locals sig
		/// </summary>
		public LocalSig LocalSig {
			get => signature as LocalSig;
			set => signature = value;
		}

		/// <inheritdoc/>
		public bool ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);
	}

	/// <summary>
	/// A StandAloneSig row created by the user and not present in the original .NET file
	/// </summary>
	public class StandAloneSigUser : StandAloneSig {
		/// <summary>
		/// Default constructor
		/// </summary>
		public StandAloneSigUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="localSig">A locals sig</param>
		public StandAloneSigUser(LocalSig localSig) => signature = localSig;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="methodSig">A method sig</param>
		public StandAloneSigUser(MethodSig methodSig) => signature = methodSig;
	}

	/// <summary>
	/// Created from a row in the StandAloneSig table
	/// </summary>
	sealed class StandAloneSigMD : StandAloneSig, IMDTokenProviderMD, IContainsGenericParameter2 {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.StandAloneSig, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>StandAloneSig</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public StandAloneSigMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.StandAloneSigTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"StandAloneSig rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			bool b = readerModule.TablesStream.TryReadStandAloneSigRow(origRid, out var row);
			Debug.Assert(b);
			signature = readerModule.ReadSignature(row.Signature, gpContext);
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Thrown if the strong name key or public key is invalid
	/// </summary>
	[Serializable]
	public class InvalidKeyException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public InvalidKeyException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		public InvalidKeyException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		/// <param name="innerException">Other exception</param>
		public InvalidKeyException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected InvalidKeyException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Type of signature algorithm. See WinCrypt.h in the Windows SDK
	/// </summary>
	public enum SignatureAlgorithm : uint {
		/// <summary>
		/// RSA signature algorithm
		/// </summary>
		CALG_RSA_SIGN = 0x00002400,
	}

	static class StrongNameUtils {
		public static byte[] ReadBytesReverse(this BinaryReader reader, int len) {
			var data = reader.ReadBytes(len);
			if (data.Length != len)
				throw new InvalidKeyException("Can't read more bytes");
			Array.Reverse(data);
			return data;
		}

		public static void WriteReverse(this BinaryWriter writer, byte[] data) {
			var d = (byte[])data.Clone();
			Array.Reverse(d);
			writer.Write(d);
		}
	}

	/// <summary>
	/// A public key
	/// </summary>
	public sealed class StrongNamePublicKey {
		const uint RSA1_SIG = 0x31415352;
		readonly SignatureAlgorithm signatureAlgorithm;
		readonly AssemblyHashAlgorithm hashAlgorithm;
		readonly byte[] modulus;
		readonly byte[] publicExponent;

		/// <summary>
		/// Gets/sets the signature algorithm
		/// </summary>
		public SignatureAlgorithm SignatureAlgorithm => signatureAlgorithm;

		/// <summary>
		/// Gets/sets the hash algorithm
		/// </summary>
		public AssemblyHashAlgorithm HashAlgorithm => hashAlgorithm;

		/// <summary>
		/// Gets/sets the modulus
		/// </summary>
		public byte[] Modulus => modulus;

		/// <summary>
		/// Gets/sets the public exponent
		/// </summary>
		public byte[] PublicExponent => publicExponent;

		/// <summary>
		/// Default constructor
		/// </summary>
		public StrongNamePublicKey() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="modulus">Modulus</param>
		/// <param name="publicExponent">Public exponent</param>
		public StrongNamePublicKey(byte[] modulus, byte[] publicExponent)
			: this(modulus, publicExponent, AssemblyHashAlgorithm.SHA1, SignatureAlgorithm.CALG_RSA_SIGN) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="modulus">Modulus</param>
		/// <param name="publicExponent">Public exponent</param>
		/// <param name="hashAlgorithm">Hash algorithm</param>
		public StrongNamePublicKey(byte[] modulus, byte[] publicExponent, AssemblyHashAlgorithm hashAlgorithm)
			: this(modulus, publicExponent, hashAlgorithm, SignatureAlgorithm.CALG_RSA_SIGN) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="modulus">Modulus</param>
		/// <param name="publicExponent">Public exponent</param>
		/// <param name="hashAlgorithm">Hash algorithm</param>
		/// <param name="signatureAlgorithm">Signature algorithm</param>
		public StrongNamePublicKey(byte[] modulus, byte[] publicExponent, AssemblyHashAlgorithm hashAlgorithm, SignatureAlgorithm signatureAlgorithm) {
			this.signatureAlgorithm = signatureAlgorithm;
			this.hashAlgorithm = hashAlgorithm;
			this.modulus = modulus;
			this.publicExponent = publicExponent;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="pk">Public key</param>
		public StrongNamePublicKey(PublicKey pk)
			: this(pk.Data) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="pk">Public key data</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNamePublicKey(byte[] pk) : this(new BinaryReader(new MemoryStream(pk))) { }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="filename">Public key file</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNamePublicKey(string filename) : this(File.ReadAllBytes(filename)) { }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Public key stream</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNamePublicKey(Stream stream) : this(new BinaryReader(stream)) { }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">Public key reader</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNamePublicKey(BinaryReader reader) {
			try {
				// Read PublicKeyBlob
				signatureAlgorithm = (SignatureAlgorithm)reader.ReadUInt32();
				hashAlgorithm = (AssemblyHashAlgorithm)reader.ReadUInt32();
				/*int pkLen = */reader.ReadInt32();

				// Read PUBLICKEYSTRUC
				if (reader.ReadByte() != 6)
					throw new InvalidKeyException("Not a public key");
				if (reader.ReadByte() != 2)
					throw new InvalidKeyException("Invalid version");
				reader.ReadUInt16();	// reserved
				if ((SignatureAlgorithm)reader.ReadUInt32() != SignatureAlgorithm.CALG_RSA_SIGN)
					throw new InvalidKeyException("Not RSA sign");

				// Read RSAPUBKEY
				if (reader.ReadUInt32() != RSA1_SIG)	// magic = RSA1
					throw new InvalidKeyException("Invalid RSA1 magic");
				uint bitLength = reader.ReadUInt32();
				publicExponent = reader.ReadBytesReverse(4);

				modulus = reader.ReadBytesReverse((int)(bitLength / 8));
			}
			catch (IOException ex) {
				throw new InvalidKeyException("Invalid public key", ex);
			}
		}

		/// <summary>
		/// Creates a public key blob
		/// </summary>
		public byte[] CreatePublicKey() => CreatePublicKey(signatureAlgorithm, hashAlgorithm, modulus, publicExponent);

		internal static byte[] CreatePublicKey(SignatureAlgorithm sigAlg, AssemblyHashAlgorithm hashAlg, byte[] modulus, byte[] publicExponent) {
			if (sigAlg != SignatureAlgorithm.CALG_RSA_SIGN)
				throw new ArgumentException("Signature algorithm must be RSA");
			var outStream = new MemoryStream();
			var writer = new BinaryWriter(outStream);
			writer.Write((uint)sigAlg);		// SigAlgID
			writer.Write((uint)hashAlg);	// HashAlgID
			writer.Write(0x14 + modulus.Length);// cbPublicKey
			writer.Write((byte)6);			// bType (public key)
			writer.Write((byte)2);			// bVersion
			writer.Write((ushort)0);		// reserved
			writer.Write((uint)sigAlg);		// aiKeyAlg
			writer.Write(RSA1_SIG);			// magic (RSA1)
			writer.Write(modulus.Length * 8);	// bitlen
			writer.WriteReverse(publicExponent);// pubexp
			writer.WriteReverse(modulus);	// modulus
			return outStream.ToArray();
		}

		/// <inheritdoc/>
		public override string ToString() => Utils.ToHex(CreatePublicKey(), false);
	}

	/// <summary>
	/// Stores a strong name key pair
	/// </summary>
	public sealed class StrongNameKey {
		const uint RSA2_SIG = 0x32415352;
		byte[] publicKey;
		readonly AssemblyHashAlgorithm hashAlg;
		readonly byte[] publicExponent;
		readonly byte[] modulus;
		readonly byte[] prime1;
		readonly byte[] prime2;
		readonly byte[] exponent1;
		readonly byte[] exponent2;
		readonly byte[] coefficient;
		readonly byte[] privateExponent;

		/// <summary>
		/// Gets the public key
		/// </summary>
		public byte[] PublicKey {
			get {
				if (publicKey is null)
					Interlocked.CompareExchange(ref publicKey, CreatePublicKey(), null);
				return publicKey;
			}
		}

		/// <summary>
		/// Gets the strong name signature size in bytes
		/// </summary>
		public int SignatureSize => modulus.Length;

		/// <summary>
		/// Gets the public key hash algorithm. It's usually <see cref="AssemblyHashAlgorithm.SHA1"/>
		/// </summary>
		public AssemblyHashAlgorithm HashAlgorithm => hashAlg;

		/// <summary>
		/// Gets the public exponent
		/// </summary>
		public byte[] PublicExponent => publicExponent;

		/// <summary>
		/// Gets the modulus
		/// </summary>
		public byte[] Modulus => modulus;

		/// <summary>
		/// Gets prime1
		/// </summary>
		public byte[] Prime1 => prime1;

		/// <summary>
		/// Gets prime2
		/// </summary>
		public byte[] Prime2 => prime2;

		/// <summary>
		/// Gets exponent1
		/// </summary>
		public byte[] Exponent1 => exponent1;

		/// <summary>
		/// Gets exponent2
		/// </summary>
		public byte[] Exponent2 => exponent2;

		/// <summary>
		/// Gets the coefficient
		/// </summary>
		public byte[] Coefficient => coefficient;

		/// <summary>
		/// Gets the private exponent
		/// </summary>
		public byte[] PrivateExponent => privateExponent;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="keyData">Strong name key data</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNameKey(byte[] keyData) : this(new BinaryReader(new MemoryStream(keyData))) { }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="filename">Strong name key file</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNameKey(string filename) : this(File.ReadAllBytes(filename)) { }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Strong name key stream</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNameKey(Stream stream) : this(new BinaryReader(stream)) { }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">Strong name key reader</param>
		/// <exception cref="InvalidKeyException">Strong name key is invalid</exception>
		public StrongNameKey(BinaryReader reader) {
			/*
			 * Links:
			 *	https://msdn.microsoft.com/en-us/library/cc250013%28v=prot.20%29.aspx
			 *	https://docs.microsoft.com/en-us/windows/desktop/SecCrypto/rsa-schannel-key-blobs
			 *
			 *	struct PublicKeyBlob {
			 *	  unsigned int SigAlgID;	// sig algorithm used to create the sig (00002400 = CALG_RSA_SIGN)
			 *	  unsigned int HashAlgID;	// hash alg used to create the sig (usually 00008004 = CALG_SHA1)
			 *	  ULONG        cbPublicKey;	// Size of the data that follows
			 *	  // the rest is here
			 *	}
			 *
			 *	typedef struct _PUBLICKEYSTRUC {
			 *	  BYTE   bType;
			 *	  BYTE   bVersion;
			 *	  WORD   reserved;
			 *	  ALG_ID aiKeyAlg;
			 *	} BLOBHEADER, PUBLICKEYSTRUC;
			 *
			 *	typedef struct _RSAPUBKEY {
			 *	  DWORD magic;
			 *	  DWORD bitlen;
			 *	  DWORD pubexp;
			 *	} RSAPUBKEY;
			 *
			 * Format of public key
			 *	PublicKeyBlob
			 *	PUBLICKEYSTRUC	publickeystruc;
			 *	RSAPUBKEY		rsapubkey;
			 *	BYTE			modulus[rsapubkey.bitlen/8]
			 *
			 * Format of public/private key pair
			 *	PUBLICKEYSTRUC	publickeystruc;
			 *	RSAPUBKEY		rsapubkey;
			 *	BYTE			modulus[rsapubkey.bitlen/8];
			 *	BYTE			prime1[rsapubkey.bitlen/16];		// aka P
			 *	BYTE			prime2[rsapubkey.bitlen/16];		// aka Q
			 *	BYTE			exponent1[rsapubkey.bitlen/16];		// aka DP
			 *	BYTE			exponent2[rsapubkey.bitlen/16];		// aka DQ
			 *	BYTE			coefficient[rsapubkey.bitlen/16];	// aka IQ
			 *	BYTE			privateExponent[rsapubkey.bitlen/8];// aka D
			 */

			try {
				publicKey = null;

				// Read PUBLICKEYSTRUC
				if (reader.ReadByte() != 7)
					throw new InvalidKeyException("Not a public/private key pair");
				if (reader.ReadByte() != 2)
					throw new InvalidKeyException("Invalid version");
				reader.ReadUInt16();	// reserved
				if ((SignatureAlgorithm)reader.ReadUInt32() != SignatureAlgorithm.CALG_RSA_SIGN)
					throw new InvalidKeyException("Not RSA sign");

				// Read RSAPUBKEY
				if (reader.ReadUInt32() != RSA2_SIG)	// magic = RSA2
					throw new InvalidKeyException("Invalid RSA2 magic");
				uint bitLength = reader.ReadUInt32();
				publicExponent = reader.ReadBytesReverse(4);

				int len8 = (int)(bitLength / 8);
				int len16 = (int)(bitLength / 16);

				// Read the rest
				modulus = reader.ReadBytesReverse(len8);
				prime1 = reader.ReadBytesReverse(len16);
				prime2 = reader.ReadBytesReverse(len16);
				exponent1 = reader.ReadBytesReverse(len16);
				exponent2 = reader.ReadBytesReverse(len16);
				coefficient = reader.ReadBytesReverse(len16);
				privateExponent = reader.ReadBytesReverse(len8);
			}
			catch (IOException ex) {
				throw new InvalidKeyException("Couldn't read strong name key", ex);
			}
		}

		StrongNameKey(AssemblyHashAlgorithm hashAlg, byte[] publicExponent, byte[] modulus, byte[] prime1, byte[] prime2, byte[] exponent1, byte[] exponent2, byte[] coefficient, byte[] privateExponent) {
			this.hashAlg = hashAlg;
			this.publicExponent = publicExponent;
			this.modulus = modulus;
			this.prime1 = prime1;
			this.prime2 = prime2;
			this.exponent1 = exponent1;
			this.exponent2 = exponent2;
			this.coefficient = coefficient;
			this.privateExponent = privateExponent;
		}

		/// <summary>
		/// Creates a strong name key with a new hash algorithm
		/// </summary>
		/// <param name="hashAlgorithm">Algorithm</param>
		/// <returns></returns>
		public StrongNameKey WithHashAlgorithm(AssemblyHashAlgorithm hashAlgorithm) {
			if (hashAlg == hashAlgorithm)
				return this;
			return new StrongNameKey(hashAlgorithm, publicExponent, modulus, prime1, prime2, exponent1, exponent2, coefficient, privateExponent);
		}

		byte[] CreatePublicKey() {
			var halg = hashAlg == 0 ? AssemblyHashAlgorithm.SHA1 : hashAlg;
			return StrongNamePublicKey.CreatePublicKey(SignatureAlgorithm.CALG_RSA_SIGN, halg, modulus, publicExponent);
		}

		/// <summary>
		/// Creates an <see cref="RSA"/> instance
		/// </summary>
		public RSA CreateRSA() {
			RSAParameters rsaParams;
			rsaParams = new RSAParameters {
				Exponent = publicExponent,
				Modulus = modulus,
				P = prime1,
				Q = prime2,
				DP = exponent1,
				DQ = exponent2,
				InverseQ = coefficient,
				D = privateExponent,
			};
			var rsa = RSA.Create();
			try {
				rsa.ImportParameters(rsaParams);
				return rsa;
			}
			catch {
				((IDisposable)rsa).Dispose();
				throw;
			}
		}

		/// <summary>
		/// Creates a strong name blob
		/// </summary>
		public byte[] CreateStrongName() {
			var outStream = new MemoryStream();
			var writer = new BinaryWriter(outStream);
			writer.Write((byte)7);			// bType (public/private key)
			writer.Write((byte)2);			// bVersion
			writer.Write((ushort)0);		// reserved
			writer.Write((uint)SignatureAlgorithm.CALG_RSA_SIGN);	// aiKeyAlg
			writer.Write(RSA2_SIG);			// magic (RSA2)
			writer.Write(modulus.Length * 8);	// bitlen
			writer.WriteReverse(publicExponent);
			writer.WriteReverse(modulus);
			writer.WriteReverse(prime1);
			writer.WriteReverse(prime2);
			writer.WriteReverse(exponent1);
			writer.WriteReverse(exponent2);
			writer.WriteReverse(coefficient);
			writer.WriteReverse(privateExponent);
			return outStream.ToArray();
		}

		/// <summary>
		/// Creates a counter signature, just like
		/// <c>sn -a IdentityPubKey.snk IdentityKey.snk SignaturePubKey.snk</c> can do.
		/// The public key <c>sn</c> prints is <paramref name="signaturePubKey"/>'s value.
		/// </summary>
		/// <param name="identityPubKey">Identity public key</param>
		/// <param name="identityKey">Identity strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		/// <returns>The counter signature as a hex string</returns>
		public static string CreateCounterSignatureAsString(StrongNamePublicKey identityPubKey, StrongNameKey identityKey, StrongNamePublicKey signaturePubKey) {
			var counterSignature = CreateCounterSignature(identityPubKey, identityKey, signaturePubKey);
			return Utils.ToHex(counterSignature, false);
		}

		/// <summary>
		/// Creates a counter signature, just like
		/// <c>sn -a IdentityPubKey.snk IdentityKey.snk SignaturePubKey.snk</c> can do.
		/// The public key <c>sn</c> prints is <paramref name="signaturePubKey"/>'s value.
		/// </summary>
		/// <param name="identityPubKey">Identity public key</param>
		/// <param name="identityKey">Identity strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		/// <returns>The counter signature</returns>
		public static byte[] CreateCounterSignature(StrongNamePublicKey identityPubKey, StrongNameKey identityKey, StrongNamePublicKey signaturePubKey) {
			var hash = AssemblyHash.Hash(signaturePubKey.CreatePublicKey(), identityPubKey.HashAlgorithm);
			using (var rsa = identityKey.CreateRSA()) {
				var rsaFmt = new RSAPKCS1SignatureFormatter(rsa);
				string hashName = identityPubKey.HashAlgorithm.GetName();
				rsaFmt.SetHashAlgorithm(hashName);
				var snSig = rsaFmt.CreateSignature(hash);
				Array.Reverse(snSig);
				return snSig;
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Strong name signs an assembly. It supports normal strong name signing and the new
	/// (.NET Framework 4.5) enhanced strong name signing.
	/// </summary>
	public readonly struct StrongNameSigner {
		readonly Stream stream;
		readonly long baseOffset;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">.NET PE file stream</param>
		public StrongNameSigner(Stream stream)
			: this(stream, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">.NET PE file stream</param>
		/// <param name="baseOffset">Offset in <paramref name="stream"/> of the first byte of
		/// the PE file.</param>
		public StrongNameSigner(Stream stream, long baseOffset) {
			this.stream = stream;
			this.baseOffset = baseOffset;
		}

		/// <summary>
		/// Calculates the strong name signature and writes it to the stream. The signature
		/// is also returned.
		/// </summary>
		/// <param name="snk">Strong name key used for signing</param>
		/// <param name="snSigOffset">Offset (relative to the start of the PE file) of the strong
		/// name signature.</param>
		/// <returns>The strong name signature</returns>
		public byte[] WriteSignature(StrongNameKey snk, long snSigOffset) {
			var sign = CalculateSignature(snk, snSigOffset);
			stream.Position = baseOffset + snSigOffset;
			stream.Write(sign, 0, sign.Length);
			return sign;
		}

		/// <summary>
		/// Calculates and returns the strong name signature
		/// </summary>
		/// <param name="snk">Strong name key used for signing</param>
		/// <param name="snSigOffset">Offset (relative to start of PE file) of the strong
		/// name signature.</param>
		/// <returns>The strong name signature</returns>
		public byte[] CalculateSignature(StrongNameKey snk, long snSigOffset) {
			uint snSigSize = (uint)snk.SignatureSize;
			var hashAlg = snk.HashAlgorithm == 0 ? AssemblyHashAlgorithm.SHA1 : snk.HashAlgorithm;
			var hash = StrongNameHashData(hashAlg, snSigOffset, snSigSize);
			var snSig = GetStrongNameSignature(snk, hashAlg, hash);
			if (snSig.Length != snSigSize)
				throw new InvalidOperationException("Invalid strong name signature size");
			return snSig;
		}

		/// <summary>
		/// Strong name hashes the .NET file
		/// </summary>
		/// <param name="hashAlg">Hash algorithm</param>
		/// <param name="snSigOffset">Strong name sig offset (relative to start of .NET PE file)</param>
		/// <param name="snSigSize">Size of strong name signature</param>
		/// <returns>The strong name hash of the .NET file</returns>
		byte[] StrongNameHashData(AssemblyHashAlgorithm hashAlg, long snSigOffset, uint snSigSize) {
			var reader = new BinaryReader(stream);

			snSigOffset += baseOffset;
			long snSigOffsetEnd = snSigOffset + snSigSize;

			using (var hasher = new AssemblyHash(hashAlg)) {
				var buffer = new byte[0x8000];

				// Hash the DOS header. It's defined to be all data from the start of
				// the file up to the NT headers.
				stream.Position = baseOffset + 0x3C;
				uint ntHeadersOffs = reader.ReadUInt32();
				stream.Position = baseOffset;
				hasher.Hash(stream, ntHeadersOffs, buffer);

				// Hash NT headers, but hash authenticode + checksum as 0s
				stream.Position += 6;
				int numSections = reader.ReadUInt16();
				stream.Position -= 8;
				hasher.Hash(stream, 0x18, buffer);	// magic + FileHeader

				bool is32bit = reader.ReadUInt16() == 0x010B;
				stream.Position -= 2;
				int optHeaderSize = is32bit ? 0x60 : 0x70;
				if (stream.Read(buffer, 0, optHeaderSize) != optHeaderSize)
					throw new IOException("Could not read data");
				// Clear checksum
				for (int i = 0; i < 4; i++)
					buffer[0x40 + i] = 0;
				hasher.Hash(buffer, 0, optHeaderSize);

				const int imageDirsSize = 16 * 8;
				if (stream.Read(buffer, 0, imageDirsSize) != imageDirsSize)
					throw new IOException("Could not read data");
				// Clear authenticode data dir
				for (int i = 0; i < 8; i++)
					buffer[4 * 8 + i] = 0;
				hasher.Hash(buffer, 0, imageDirsSize);

				// Hash section headers
				long sectHeadersOffs = stream.Position;
				hasher.Hash(stream, (uint)numSections * 0x28, buffer);

				// Hash all raw section data but make sure we don't hash the location
				// where the strong name signature will be stored.
				for (int i = 0; i < numSections; i++) {
					stream.Position = sectHeadersOffs + i * 0x28 + 0x10;
					uint sizeOfRawData = reader.ReadUInt32();
					uint pointerToRawData = reader.ReadUInt32();

					stream.Position = baseOffset + pointerToRawData;
					while (sizeOfRawData > 0) {
						var pos = stream.Position;

						if (snSigOffset <= pos && pos < snSigOffsetEnd) {
							uint skipSize = (uint)(snSigOffsetEnd - pos);
							if (skipSize >= sizeOfRawData)
								break;
							sizeOfRawData -= skipSize;
							stream.Position += skipSize;
							continue;
						}

						if (pos >= snSigOffsetEnd) {
							hasher.Hash(stream, sizeOfRawData, buffer);
							break;
						}

						uint maxLen = (uint)Math.Min(snSigOffset - pos, sizeOfRawData);
						hasher.Hash(stream, maxLen, buffer);
						sizeOfRawData -= maxLen;
					}
				}

				return hasher.ComputeHash();
			}
		}

		/// <summary>
		/// Returns the strong name signature
		/// </summary>
		/// <param name="snk">Strong name key</param>
		/// <param name="hashAlg">Hash algorithm</param>
		/// <param name="hash">Strong name hash of the .NET PE file</param>
		/// <returns>Strong name signature</returns>
		byte[] GetStrongNameSignature(StrongNameKey snk, AssemblyHashAlgorithm hashAlg, byte[] hash) {
			using (var rsa = snk.CreateRSA()) {
				var rsaFmt = new RSAPKCS1SignatureFormatter(rsa);
				string hashName = hashAlg.GetName() ?? AssemblyHashAlgorithm.SHA1.GetName();
				rsaFmt.SetHashAlgorithm(hashName);
				var snSig = rsaFmt.CreateSignature(hash);
				Array.Reverse(snSig);
				return snSig;
			}
		}
	}
}




// See coreclr/src/vm/siginfo.cpp


namespace dnlib.DotNet {
	/// <summary>
	/// <c>System.Runtime.InteropServices.TypeIdentifierAttribute</c> helper code used by <see cref="SigComparer"/>
	/// </summary>
	static class TIAHelper {
		readonly struct Info : IEquatable<Info> {
			public readonly UTF8String Scope;
			public readonly UTF8String Identifier;

			public Info(UTF8String scope, UTF8String identifier) {
				Scope = scope;
				Identifier = identifier;
			}

			public bool Equals(Info other) => stricmp(Scope, other.Scope) && UTF8String.Equals(Identifier, other.Identifier);

			static bool stricmp(UTF8String a, UTF8String b) {
				var da = a?.Data;
				var db = b?.Data;
				if (da == db)
					return true;
				if (da is null || db is null)
					return false;
				if (da.Length != db.Length)
					return false;
				for (int i = 0; i < da.Length; i++) {
					byte ba = da[i], bb = db[i];
					if ((byte)'A' <= ba && ba <= (byte)'Z')
						ba = (byte)(ba - 'A' + 'a');
					if ((byte)'A' <= bb && bb <= (byte)'Z')
						bb = (byte)(bb - 'A' + 'a');
					if (ba != bb)
						return false;
				}
				return true;
			}
		}

		static Info? GetInfo(TypeDef td) {
			if (td is null)
				return null;
			if (td.IsWindowsRuntime)
				return null;

			UTF8String scope = null, identifier = null;
			var tia = td.CustomAttributes.Find("System.Runtime.InteropServices.TypeIdentifierAttribute");
			if (tia is not null) {
				if (tia.ConstructorArguments.Count >= 2) {
					if (tia.ConstructorArguments[0].Type.GetElementType() != ElementType.String)
						return null;
					if (tia.ConstructorArguments[1].Type.GetElementType() != ElementType.String)
						return null;
					scope = tia.ConstructorArguments[0].Value as UTF8String ?? tia.ConstructorArguments[0].Value as string;
					identifier = tia.ConstructorArguments[1].Value as UTF8String ?? tia.ConstructorArguments[1].Value as string;
				}
			}
			else {
				var asm = td.Module?.Assembly;
				if (asm is null)
					return null;
				bool isTypeLib = asm.CustomAttributes.IsDefined("System.Runtime.InteropServices.ImportedFromTypeLibAttribute") ||
								asm.CustomAttributes.IsDefined("System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute");
				if (!isTypeLib)
					return null;
			}

			if (UTF8String.IsNull(identifier)) {
				CustomAttribute gca;
				if (td.IsInterface && td.IsImport)
					gca = td.CustomAttributes.Find("System.Runtime.InteropServices.GuidAttribute");
				else {
					var asm = td.Module?.Assembly;
					if (asm is null)
						return null;
					gca = asm.CustomAttributes.Find("System.Runtime.InteropServices.GuidAttribute");
				}
				if (gca is null)
					return null;
				if (gca.ConstructorArguments.Count < 1)
					return null;
				if (gca.ConstructorArguments[0].Type.GetElementType() != ElementType.String)
					return null;
				scope = gca.ConstructorArguments[0].Value as UTF8String ?? gca.ConstructorArguments[0].Value as string;
				var ns = td.Namespace;
				var name = td.Name;
				if (UTF8String.IsNullOrEmpty(ns))
					identifier = name;
				else if (UTF8String.IsNullOrEmpty(name))
					identifier = new UTF8String(Concat(ns.Data, (byte)'.', Array2.Empty<byte>()));
				else
					identifier = new UTF8String(Concat(ns.Data, (byte)'.', name.Data));
			}
			return new Info(scope, identifier);
		}

		static byte[] Concat(byte[] a, byte b, byte[] c) {
			var data = new byte[a.Length + 1 + c.Length];
			for (int i = 0; i < a.Length; i++)
				data[i] = a[i];
			data[a.Length] = b;
			for (int i = 0, j = a.Length + 1; i < c.Length; i++, j++)
				data[j] = c[i];
			return data;
		}

		internal static bool IsTypeDefEquivalent(TypeDef td) => GetInfo(td) is not null && CheckEquivalent(td);

		static bool CheckEquivalent(TypeDef td) {
			Debug.Assert(td is not null);

			for (int i = 0; td is not null && i < 1000; i++) {
				if (i != 0) {
					var info = GetInfo(td);
					if (info is null)
						return false;
				}

				bool f;
				if (td.IsInterface)
					f = td.IsImport || td.CustomAttributes.IsDefined("System.Runtime.InteropServices.ComEventInterfaceAttribute");
				else
					f = td.IsValueType || td.IsDelegate;
				if (!f)
					return false;
				if (td.GenericParameters.Count > 0)
					return false;

				var declType = td.DeclaringType;
				if (declType is null)
					return td.IsPublic;

				if (!td.IsNestedPublic)
					return false;
				td = declType;
			}

			return false;
		}

		public static bool Equivalent(TypeDef td1, TypeDef td2) {
			var info1 = GetInfo(td1);
			if (info1 is null)
				return false;
			var info2 = GetInfo(td2);
			if (info2 is null)
				return false;
			if (!CheckEquivalent(td1) || !CheckEquivalent(td2))
				return false;
			if (!info1.Value.Equals(info2.Value))
				return false;

			// Caller has already compared names of the types and any declaring types

			for (int i = 0; i < 1000; i++) {
				if (td1.IsInterface) {
					if (!td2.IsInterface)
						return false;
				}
				else {
					var bt1 = td1.BaseType;
					var bt2 = td2.BaseType;
					if (bt1 is null || bt2 is null)
						return false;
					if (td1.IsDelegate) {
						if (!td2.IsDelegate)
							return false;
						if (!DelegateEquals(td1, td2))
							return false;
					}
					else if (td1.IsValueType) {
						if (td1.IsEnum != td2.IsEnum)
							return false;
						if (!td2.IsValueType)
							return false;
						if (!ValueTypeEquals(td1, td2, td1.IsEnum))
							return false;
					}
					else
						return false;
				}

				td1 = td1.DeclaringType;
				td2 = td2.DeclaringType;
				if (td1 is null && td2 is null)
					break;
				if (td1 is null || td2 is null)
					return false;
			}

			return true;
		}

		static bool DelegateEquals(TypeDef td1, TypeDef td2) {
			var invoke1 = td1.FindMethod(InvokeString);
			var invoke2 = td2.FindMethod(InvokeString);
			if (invoke1 is null || invoke2 is null)
				return false;

			//TODO: Compare method signatures. Prevent infinite recursion...

			return true;
		}
		static readonly UTF8String InvokeString = new UTF8String("Invoke");

		static bool ValueTypeEquals(TypeDef td1, TypeDef td2, bool isEnum) {
			if (td1.Methods.Count != 0 || td2.Methods.Count != 0)
				return false;

			//TODO: Compare the fields. Prevent infinite recursion...

			return true;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// TypeDef and ExportedType flags. See CorHdr.h/CorTypeAttr
	/// </summary>
	[Flags]
	public enum TypeAttributes : uint {
		/// <summary>Use this mask to retrieve the type visibility information.</summary>
		VisibilityMask			= 0x00000007,
		/// <summary>Class is not public scope.</summary>
		NotPublic				= 0x00000000,
		/// <summary>Class is public scope.</summary>
		Public					= 0x00000001,
		/// <summary>Class is nested with public visibility.</summary>
		NestedPublic			= 0x00000002,
		/// <summary>Class is nested with private visibility.</summary>
		NestedPrivate			= 0x00000003,
		/// <summary>Class is nested with family visibility.</summary>
		NestedFamily			= 0x00000004,
		/// <summary>Class is nested with assembly visibility.</summary>
		NestedAssembly			= 0x00000005,
		/// <summary>Class is nested with family and assembly visibility.</summary>
		NestedFamANDAssem		= 0x00000006,
		/// <summary>Class is nested with family or assembly visibility.</summary>
		NestedFamORAssem		= 0x00000007,

		/// <summary>Use this mask to retrieve class layout information</summary>
		LayoutMask				= 0x00000018,
		/// <summary>Class fields are auto-laid out</summary>
		AutoLayout				= 0x00000000,
		/// <summary>Class fields are laid out sequentially</summary>
		SequentialLayout		= 0x00000008,
		/// <summary>Layout is supplied explicitly</summary>
		ExplicitLayout			= 0x00000010,

		/// <summary>Use this mask to retrieve class semantics information.</summary>
		ClassSemanticsMask		= 0x00000020,
		/// <summary>Use this mask to retrieve class semantics information.</summary>
		ClassSemanticMask		= ClassSemanticsMask,
		/// <summary>Type is a class.</summary>
		Class					= 0x00000000,
		/// <summary>Type is an interface.</summary>
		Interface				= 0x00000020,

		/// <summary>Class is abstract</summary>
		Abstract				= 0x00000080,
		/// <summary>Class is concrete and may not be extended</summary>
		Sealed					= 0x00000100,
		/// <summary>Class name is special.  Name describes how.</summary>
		SpecialName				= 0x00000400,

		/// <summary>Class / interface is imported</summary>
		Import					= 0x00001000,
		/// <summary>The class is Serializable.</summary>
		Serializable			= 0x00002000,
		/// <summary>The type is a Windows Runtime type</summary>
		WindowsRuntime			= 0x00004000,

		/// <summary>Use StringFormatMask to retrieve string information for native interop</summary>
		StringFormatMask		= 0x00030000,
		/// <summary>LPTSTR is interpreted as ANSI in this class</summary>
		AnsiClass				= 0x00000000,
		/// <summary>LPTSTR is interpreted as UNICODE</summary>
		UnicodeClass			= 0x00010000,
		/// <summary>LPTSTR is interpreted automatically</summary>
		AutoClass				= 0x00020000,
		/// <summary>A non-standard encoding specified by CustomFormatMask</summary>
		CustomFormatClass		= 0x00030000,
		/// <summary>Use this mask to retrieve non-standard encoding information for native interop. The meaning of the values of these 2 bits is unspecified.</summary>
		CustomFormatMask		= 0x00C00000,

		/// <summary>Initialize the class any time before first static field access.</summary>
		BeforeFieldInit			= 0x00100000,
		/// <summary>This ExportedType is a type forwarder.</summary>
		Forwarder				= 0x00200000,

		/// <summary>Flags reserved for runtime use.</summary>
		ReservedMask			= 0x00040800,
		/// <summary>Runtime should check name encoding.</summary>
		RTSpecialName			= 0x00000800,
		/// <summary>Class has security associate with it.</summary>
		HasSecurity				= 0x00040000,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the TypeDef table
	/// </summary>
	public abstract class TypeDef : ITypeDefOrRef, IHasCustomAttribute, IHasDeclSecurity, IMemberRefParent, ITypeOrMethodDef, IHasCustomDebugInformation, IListListener<FieldDef>, IListListener<MethodDef>, IListListener<TypeDef>, IListListener<EventDef>, IListListener<PropertyDef>, IListListener<GenericParam>, IMemberRefResolver, IMemberDef {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.TypeDef, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int TypeDefOrRefTag => 0;

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 3;

		/// <inheritdoc/>
		public int HasDeclSecurityTag => 0;

		/// <inheritdoc/>
		public int MemberRefParentTag => 0;

		/// <inheritdoc/>
		public int TypeOrMethodDefTag => 0;

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters => GenericParameters.Count;

		/// <inheritdoc/>
		string IType.TypeName => FullNameFactory.Name(this, false, null);

		/// <inheritdoc/>
		public string ReflectionName => FullNameFactory.Name(this, true, null);

		/// <inheritdoc/>
		string IType.Namespace => FullNameFactory.Namespace(this, false, null);

		/// <inheritdoc/>
		public string ReflectionNamespace => FullNameFactory.Namespace(this, true, null);

		/// <inheritdoc/>
		public string FullName => FullNameFactory.FullName(this, false, null, null);

		/// <inheritdoc/>
		public string ReflectionFullName => FullNameFactory.FullName(this, true, null, null);

		/// <inheritdoc/>
		public string AssemblyQualifiedName => FullNameFactory.AssemblyQualifiedName(this, null, null);

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly => FullNameFactory.DefinitionAssembly(this);

		/// <inheritdoc/>
		public IScope Scope => Module;

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType => this;

		/// <summary>
		/// Always returns <c>false</c> since a <see cref="TypeDef"/> does not contain any
		/// <see cref="GenericVar"/> or <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter => false;

		/// <inheritdoc/>
		public ModuleDef Module => FullNameFactory.OwnerModule(this);

		/// <summary>
		/// Gets/sets the owner module
		/// </summary>
		internal ModuleDef Module2 {
			get {
				if (!module2_isInitialized)
					InitializeModule2();
				return module2;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				module2 = value;
				module2_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ModuleDef module2;
		/// <summary/>
		protected bool module2_isInitialized;

		void InitializeModule2() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (module2_isInitialized)
				return;
			module2 = GetModule2_NoLock();
			module2_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="module2"/></summary>
		protected virtual ModuleDef GetModule2_NoLock() => null;

		bool IIsTypeOrMethod.IsType => true;
		bool IIsTypeOrMethod.IsMethod => false;
		bool IMemberRef.IsField => false;
		bool IMemberRef.IsTypeSpec => false;
		bool IMemberRef.IsTypeRef => false;
		bool IMemberRef.IsTypeDef => true;
		bool IMemberRef.IsMethodSpec => false;
		bool IMemberRef.IsMethodDef => false;
		bool IMemberRef.IsMemberRef => false;
		bool IMemberRef.IsFieldDef => false;
		bool IMemberRef.IsPropertyDef => false;
		bool IMemberRef.IsEventDef => false;
		bool IMemberRef.IsGenericParam => false;

		/// <summary>
		/// From column TypeDef.Flags
		/// </summary>
		public TypeAttributes Attributes {
			get => (TypeAttributes)attributes;
			set => attributes = (int)value;
		}
		/// <summary>Attributes</summary>
		protected int attributes;

		/// <summary>
		/// From column TypeDef.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column TypeDef.Namespace
		/// </summary>
		public UTF8String Namespace {
			get => @namespace;
			set => @namespace = value;
		}
		/// <summary>Name</summary>
		protected UTF8String @namespace;

		/// <summary>
		/// From column TypeDef.Extends
		/// </summary>
		public ITypeDefOrRef BaseType {
			get {
				if (!baseType_isInitialized)
					InitializeBaseType();
				return baseType;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				baseType = value;
				baseType_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ITypeDefOrRef baseType;
		/// <summary/>
		protected bool baseType_isInitialized;

		void InitializeBaseType() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (baseType_isInitialized)
				return;
			baseType = GetBaseType_NoLock();
			baseType_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="baseType"/></summary>
		protected virtual ITypeDefOrRef GetBaseType_NoLock() => null;

		/// <summary>Reset <see cref="BaseType"/></summary>
		protected void ResetBaseType() => baseType_isInitialized = false;

		/// <summary>
		/// From column TypeDef.FieldList
		/// </summary>
		public IList<FieldDef> Fields {
			get {
				if (fields is null)
					InitializeFields();
				return fields;
			}
		}
		/// <summary/>
		protected LazyList<FieldDef> fields;
		/// <summary>Initializes <see cref="fields"/></summary>
		protected virtual void InitializeFields() =>
			Interlocked.CompareExchange(ref fields, new LazyList<FieldDef>(this), null);

		/// <summary>
		/// From column TypeDef.MethodList
		/// </summary>
		public IList<MethodDef> Methods {
			get {
				if (methods is null)
					InitializeMethods();
				return methods;
			}
		}
		/// <summary/>
		protected LazyList<MethodDef> methods;
		/// <summary>Initializes <see cref="methods"/></summary>
		protected virtual void InitializeMethods() =>
			Interlocked.CompareExchange(ref methods, new LazyList<MethodDef>(this), null);

		/// <inheritdoc/>
		public IList<GenericParam> GenericParameters {
			get {
				if (genericParameters is null)
					InitializeGenericParameters();
				return genericParameters;
			}
		}
		/// <summary/>
		protected LazyList<GenericParam> genericParameters;
		/// <summary>Initializes <see cref="genericParameters"/></summary>
		protected virtual void InitializeGenericParameters() =>
			Interlocked.CompareExchange(ref genericParameters, new LazyList<GenericParam>(this), null);

		/// <summary>
		/// Gets the interfaces
		/// </summary>
		public IList<InterfaceImpl> Interfaces {
			get {
				if (interfaces is null)
					InitializeInterfaces();
				return interfaces;
			}
		}
		/// <summary/>
		protected IList<InterfaceImpl> interfaces;
		/// <summary>Initializes <see cref="interfaces"/></summary>
		protected virtual void InitializeInterfaces() =>
			Interlocked.CompareExchange(ref interfaces, new List<InterfaceImpl>(), null);

		/// <inheritdoc/>
		public IList<DeclSecurity> DeclSecurities {
			get {
				if (declSecurities is null)
					InitializeDeclSecurities();
				return declSecurities;
			}
		}
		/// <summary/>
		protected IList<DeclSecurity> declSecurities;
		/// <summary>Initializes <see cref="declSecurities"/></summary>
		protected virtual void InitializeDeclSecurities() =>
			Interlocked.CompareExchange(ref declSecurities, new List<DeclSecurity>(), null);

		/// <summary>
		/// Gets/sets the class layout
		/// </summary>
		public ClassLayout ClassLayout {
			get {
				if (!classLayout_isInitialized)
					InitializeClassLayout();
				return classLayout;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				classLayout = value;
				classLayout_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected ClassLayout classLayout;
		/// <summary/>
		protected bool classLayout_isInitialized;

		void InitializeClassLayout() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (classLayout_isInitialized)
				return;
			classLayout = GetClassLayout_NoLock();
			classLayout_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}
		ClassLayout GetOrCreateClassLayout() {
			var cl = ClassLayout;
			if (cl is not null)
				return cl;
			Interlocked.CompareExchange(ref classLayout, new ClassLayoutUser(0, 0), null);
			return classLayout;
		}

		/// <summary>Called to initialize <see cref="classLayout"/></summary>
		protected virtual ClassLayout GetClassLayout_NoLock() => null;

		/// <inheritdoc/>
		public bool HasDeclSecurities => DeclSecurities.Count > 0;

		/// <summary>
		/// Gets/sets the enclosing type. It's <c>null</c> if this isn't a nested class.
		/// </summary>
		public TypeDef DeclaringType {
			get {
				if (!declaringType2_isInitialized)
					InitializeDeclaringType2();
				return declaringType2;
			}
			set {
				var currentDeclaringType = DeclaringType2;
				if (currentDeclaringType == value)
					return;
				if (currentDeclaringType is not null)
					currentDeclaringType.NestedTypes.Remove(this);	// Will set DeclaringType2 = null
				if (value is not null)
					value.NestedTypes.Add(this);		// Will set DeclaringType2 = value

				// Make sure this is clear. Will be set whenever it's inserted into ModulDef.Types
				Module2 = null;
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType => DeclaringType;

		/// <summary>
		/// Called by <see cref="DeclaringType"/> and should normally not be called by any user
		/// code. Use <see cref="DeclaringType"/> instead. Only call this if you must set the
		/// declaring type without inserting it in the declaring type's method list.
		/// </summary>
		public TypeDef DeclaringType2 {
			get {
				if (!declaringType2_isInitialized)
					InitializeDeclaringType2();
				return declaringType2;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				declaringType2 = value;
				declaringType2_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected TypeDef declaringType2;
		/// <summary/>
		protected bool declaringType2_isInitialized;

		void InitializeDeclaringType2() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (declaringType2_isInitialized)
				return;
			declaringType2 = GetDeclaringType2_NoLock();
			declaringType2_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="declaringType2"/></summary>
		protected virtual TypeDef GetDeclaringType2_NoLock() => null;

		/// <summary>
		/// Gets all the nested types
		/// </summary>
		public IList<TypeDef> NestedTypes {
			get {
				if (nestedTypes is null)
					InitializeNestedTypes();
				return nestedTypes;
			}
		}
		/// <summary/>
		protected LazyList<TypeDef> nestedTypes;
		/// <summary>Initializes <see cref="nestedTypes"/></summary>
		protected virtual void InitializeNestedTypes() =>
			Interlocked.CompareExchange(ref nestedTypes, new LazyList<TypeDef>(this), null);

		/// <summary>
		/// Gets all events
		/// </summary>
		public IList<EventDef> Events {
			get {
				if (events is null)
					InitializeEvents();
				return events;
			}
		}
		/// <summary/>
		protected LazyList<EventDef> events;
		/// <summary>Initializes <see cref="events"/></summary>
		protected virtual void InitializeEvents() =>
			Interlocked.CompareExchange(ref events, new LazyList<EventDef>(this), null);

		/// <summary>
		/// Gets all properties
		/// </summary>
		public IList<PropertyDef> Properties {
			get {
				if (properties is null)
					InitializeProperties();
				return properties;
			}
		}
		/// <summary/>
		protected LazyList<PropertyDef> properties;
		/// <summary>Initializes <see cref="properties"/></summary>
		protected virtual void InitializeProperties() =>
			Interlocked.CompareExchange(ref properties, new LazyList<PropertyDef>(this), null);

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 3;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="FieldDef"/> in <see cref="Fields"/>
		/// </summary>
		public bool HasFields => Fields.Count > 0;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="MethodDef"/> in <see cref="Methods"/>
		/// </summary>
		public bool HasMethods => Methods.Count > 0;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="GenericParam"/> in <see cref="GenericParameters"/>
		/// </summary>
		public bool HasGenericParameters => GenericParameters.Count > 0;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="EventDef"/> in <see cref="Events"/>
		/// </summary>
		public bool HasEvents => Events.Count > 0;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="PropertyDef"/> in <see cref="Properties"/>
		/// </summary>
		public bool HasProperties => Properties.Count > 0;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="TypeDef"/> in <see cref="NestedTypes"/>
		/// </summary>
		public bool HasNestedTypes => NestedTypes.Count > 0;

		/// <summary>
		/// <c>true</c> if there's at least one <see cref="InterfaceImpl"/> in <see cref="Interfaces"/>
		/// </summary>
		public bool HasInterfaces => Interfaces.Count > 0;

		/// <summary>
		/// <c>true</c> if <see cref="ClassLayout"/> is not <c>null</c>
		/// </summary>
		public bool HasClassLayout => ClassLayout is not null;

		/// <summary>
		/// Gets/sets the packing size. If you write to this property but <see cref="ClassLayout"/>
		/// is <c>null</c>, it will be created. The value <see cref="ushort.MaxValue"/> is returned
		/// if <see cref="ClassLayout"/> is <c>null</c>.
		/// </summary>
		public ushort PackingSize {
			get {
				var cl = ClassLayout;
				return cl is null ? ushort.MaxValue : cl.PackingSize;
			}
			set {
				var cl = GetOrCreateClassLayout();
				cl.PackingSize = value;
			}
		}

		/// <summary>
		/// Gets/sets the class size. If you write to this property but <see cref="ClassLayout"/>
		/// is <c>null</c>, it will be created. The value <see cref="uint.MaxValue"/> is returned
		/// if <see cref="ClassLayout"/> is <c>null</c>.
		/// </summary>
		public uint ClassSize {
			get {
				var cl = ClassLayout;
				return cl is null ? uint.MaxValue : cl.ClassSize;
			}
			set {
				var cl = GetOrCreateClassLayout();
				cl.ClassSize = value;
			}
		}

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				// Don't include abstract since value types can be abstract without throwing at runtime
				// Also don't check for sealed, since the CLR doesn't throw at runtime
				if ((Attributes & TypeAttributes.ClassSemanticsMask) != TypeAttributes.Class)
					return false;
				var baseType = BaseType;
				if (baseType is null)
					return false;
				if (!baseType.DefinitionAssembly.IsCorLib())
					return false;

				// PERF: Don't allocate a System.String by calling FullName etc.
				UTF8String baseName, baseNamespace;
				if (baseType is TypeRef baseTr) {
					baseName = baseTr.Name;
					baseNamespace = baseTr.Namespace;
				}
				else {
					var baseTd = baseType as TypeDef;
					if (baseTd is null)
						return false;
					baseName = baseTd.Name;
					baseNamespace = baseTd.Namespace;
				}

				if (baseNamespace != systemString)
					return false;
				if (baseName != valueTypeString && baseName != enumString)
					return false;

				if (!DefinitionAssembly.IsCorLib())
					return true;
				return !(Name == enumString && Namespace == systemString);
			}
		}
		static readonly UTF8String systemString = new UTF8String("System");
		static readonly UTF8String enumString = new UTF8String("Enum");
		static readonly UTF8String valueTypeString = new UTF8String("ValueType");
		static readonly UTF8String multicastDelegateString = new UTF8String("MulticastDelegate");

		/// <summary>
		/// <c>true</c> if it's an enum
		/// </summary>
		public bool IsEnum {
			get {
				// Don't include abstract since value types can be abstract without throwing at runtime
				// Also don't check for sealed, since the CLR doesn't throw at runtime
				if ((Attributes & TypeAttributes.ClassSemanticsMask) != TypeAttributes.Class)
					return false;
				var baseType = BaseType;
				if (baseType is null)
					return false;
				if (!baseType.DefinitionAssembly.IsCorLib())
					return false;

				// PERF: Don't allocate a System.String by calling FullName etc.
				if (baseType is TypeRef baseTr)
					return baseTr.Namespace == systemString && baseTr.Name == enumString;
				if (baseType is TypeDef baseTd)
					return baseTd.Namespace == systemString && baseTd.Name == enumString;
				return false;
			}
		}

		/// <summary>
		/// <c>true</c> if it's a delegate (it derives from <see cref="System.MulticastDelegate"/>)
		/// </summary>
		public bool IsDelegate {
			get {
				if ((Attributes & (TypeAttributes.Abstract | TypeAttributes.ClassSemanticsMask)) != TypeAttributes.Class)
					return false;
				var baseType = BaseType;
				if (baseType is null)
					return false;
				if (!baseType.DefinitionAssembly.IsCorLib())
					return false;

				// PERF: Don't allocate a System.String by calling FullName etc.
				if (baseType is TypeRef baseTr)
					return baseTr.Namespace == systemString && baseTr.Name == multicastDelegateString;
				if (baseType is TypeDef baseTd)
					return baseTd.Namespace == systemString && baseTd.Name == multicastDelegateString;
				return false;
			}
		}

		/// <summary>
		/// <c>true</c> if this is a nested type (it has a declaring type)
		/// </summary>
		public bool IsNested => DeclaringType is not null;

		/// <inheritdoc/>
		public bool IsPrimitive => this.IsPrimitive();

		/// <summary>
		/// Checks whether this type has opted into equivalence
		/// </summary>
		public bool IsEquivalent => TIAHelper.IsTypeDefEquivalent(this);

		/// <summary>
		/// Modify <see cref="attributes"/> property: <see cref="attributes"/> =
		/// (<see cref="attributes"/> &amp; <paramref name="andMask"/>) | <paramref name="orMask"/>.
		/// </summary>
		/// <param name="andMask">Value to <c>AND</c></param>
		/// <param name="orMask">Value to OR</param>
		void ModifyAttributes(TypeAttributes andMask, TypeAttributes orMask) =>
			attributes = (attributes & (int)andMask) | (int)orMask;

		/// <summary>
		/// Set or clear flags in <see cref="attributes"/>
		/// </summary>
		/// <param name="set"><c>true</c> if flags should be set, <c>false</c> if flags should
		/// be cleared</param>
		/// <param name="flags">Flags to set or clear</param>
		void ModifyAttributes(bool set, TypeAttributes flags) {
			if (set)
				attributes |= (int)flags;
			else
				attributes &= ~(int)flags;
		}

		/// <summary>
		/// Gets/sets the visibility
		/// </summary>
		public TypeAttributes Visibility {
			get => (TypeAttributes)attributes & TypeAttributes.VisibilityMask;
			set => ModifyAttributes(~TypeAttributes.VisibilityMask, value & TypeAttributes.VisibilityMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NotPublic"/> is set
		/// </summary>
		public bool IsNotPublic => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NotPublic;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.Public"/> is set
		/// </summary>
		public bool IsPublic => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.Public;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedPublic"/> is set
		/// </summary>
		public bool IsNestedPublic => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPublic;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedPrivate"/> is set
		/// </summary>
		public bool IsNestedPrivate => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedPrivate;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamily"/> is set
		/// </summary>
		public bool IsNestedFamily => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamily;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedAssembly"/> is set
		/// </summary>
		public bool IsNestedAssembly => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedAssembly;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamANDAssem"/> is set
		/// </summary>
		public bool IsNestedFamilyAndAssembly => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamANDAssem;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.NestedFamORAssem"/> is set
		/// </summary>
		public bool IsNestedFamilyOrAssembly => ((TypeAttributes)attributes & TypeAttributes.VisibilityMask) == TypeAttributes.NestedFamORAssem;

		/// <summary>
		/// Gets/sets the layout
		/// </summary>
		public TypeAttributes Layout {
			get => (TypeAttributes)attributes & TypeAttributes.LayoutMask;
			set => ModifyAttributes(~TypeAttributes.LayoutMask, value & TypeAttributes.LayoutMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AutoLayout"/> is set
		/// </summary>
		public bool IsAutoLayout => ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.AutoLayout;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.SequentialLayout"/> is set
		/// </summary>
		public bool IsSequentialLayout => ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.SequentialLayout;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.ExplicitLayout"/> is set
		/// </summary>
		public bool IsExplicitLayout => ((TypeAttributes)attributes & TypeAttributes.LayoutMask) == TypeAttributes.ExplicitLayout;

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Interface"/> bit
		/// </summary>
		public bool IsInterface {
			get => ((TypeAttributes)attributes & TypeAttributes.Interface) != 0;
			set => ModifyAttributes(value, TypeAttributes.Interface);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Class"/> bit
		/// </summary>
		public bool IsClass {
			get => ((TypeAttributes)attributes & TypeAttributes.Interface) == 0;
			set => ModifyAttributes(!value, TypeAttributes.Interface);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Abstract"/> bit
		/// </summary>
		public bool IsAbstract {
			get => ((TypeAttributes)attributes & TypeAttributes.Abstract) != 0;
			set => ModifyAttributes(value, TypeAttributes.Abstract);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Sealed"/> bit
		/// </summary>
		public bool IsSealed {
			get => ((TypeAttributes)attributes & TypeAttributes.Sealed) != 0;
			set => ModifyAttributes(value, TypeAttributes.Sealed);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.SpecialName"/> bit
		/// </summary>
		public bool IsSpecialName {
			get => ((TypeAttributes)attributes & TypeAttributes.SpecialName) != 0;
			set => ModifyAttributes(value, TypeAttributes.SpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Import"/> bit
		/// </summary>
		public bool IsImport {
			get => ((TypeAttributes)attributes & TypeAttributes.Import) != 0;
			set => ModifyAttributes(value, TypeAttributes.Import);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Serializable"/> bit
		/// </summary>
		public bool IsSerializable {
			get => ((TypeAttributes)attributes & TypeAttributes.Serializable) != 0;
			set => ModifyAttributes(value, TypeAttributes.Serializable);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.WindowsRuntime"/> bit
		/// </summary>
		public bool IsWindowsRuntime {
			get => ((TypeAttributes)attributes & TypeAttributes.WindowsRuntime) != 0;
			set => ModifyAttributes(value, TypeAttributes.WindowsRuntime);
		}

		/// <summary>
		/// Gets/sets the string format
		/// </summary>
		public TypeAttributes StringFormat {
			get => (TypeAttributes)attributes & TypeAttributes.StringFormatMask;
			set => ModifyAttributes(~TypeAttributes.StringFormatMask, value & TypeAttributes.StringFormatMask);
		}

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AnsiClass"/> is set
		/// </summary>
		public bool IsAnsiClass => ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.AnsiClass;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.UnicodeClass"/> is set
		/// </summary>
		public bool IsUnicodeClass => ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.UnicodeClass;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.AutoClass"/> is set
		/// </summary>
		public bool IsAutoClass => ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.AutoClass;

		/// <summary>
		/// <c>true</c> if <see cref="TypeAttributes.CustomFormatClass"/> is set
		/// </summary>
		public bool IsCustomFormatClass => ((TypeAttributes)attributes & TypeAttributes.StringFormatMask) == TypeAttributes.CustomFormatClass;

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.BeforeFieldInit"/> bit
		/// </summary>
		public bool IsBeforeFieldInit {
			get => ((TypeAttributes)attributes & TypeAttributes.BeforeFieldInit) != 0;
			set => ModifyAttributes(value, TypeAttributes.BeforeFieldInit);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.Forwarder"/> bit
		/// </summary>
		public bool IsForwarder {
			get => ((TypeAttributes)attributes & TypeAttributes.Forwarder) != 0;
			set => ModifyAttributes(value, TypeAttributes.Forwarder);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.RTSpecialName"/> bit
		/// </summary>
		public bool IsRuntimeSpecialName {
			get => ((TypeAttributes)attributes & TypeAttributes.RTSpecialName) != 0;
			set => ModifyAttributes(value, TypeAttributes.RTSpecialName);
		}

		/// <summary>
		/// Gets/sets the <see cref="TypeAttributes.HasSecurity"/> bit
		/// </summary>
		public bool HasSecurity {
			get => ((TypeAttributes)attributes & TypeAttributes.HasSecurity) != 0;
			set => ModifyAttributes(value, TypeAttributes.HasSecurity);
		}

		/// <summary>
		/// <c>true</c> if this is the global (aka. &lt;Module&gt;) type
		/// </summary>
		public bool IsGlobalModuleType {
			get {
				var mod = Module;
				return mod is not null && mod.GlobalType == this;
			}
		}

		/// <summary>
		/// Gets a list of all nested types and all their nested types
		/// </summary>
		public IEnumerable<TypeDef> GetTypes() => AllTypesHelper.Types(NestedTypes);

		/// <summary>
		/// Gets an enum's underlying type or <c>null</c> if none. Should only be called
		/// if this is an enum.
		/// </summary>
		public TypeSig GetEnumUnderlyingType() {
			var fields = Fields;
			int count = fields.Count;
			for (int i = 0; i < count; i++) {
				var field = fields[i];
				if (!field.IsLiteral && !field.IsStatic) {
					var fieldSig = field.FieldSig;
					if (fieldSig is not null)
						return fieldSig.Type;
				}
			}
			return null;
		}

		/// <summary>
		/// Resolves a method or a field. <see cref="MemberRef.Class"/> (owner type) is ignored when
		/// resolving the method/field. Private scope methods/fields are not returned.
		/// </summary>
		/// <param name="memberRef">A method/field reference</param>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance or <c>null</c>
		/// if it couldn't be resolved.</returns>
		public IMemberForwarded Resolve(MemberRef memberRef) => Resolve(memberRef, 0);

		/// <summary>
		/// Resolves a method or a field. <see cref="MemberRef.Class"/> (owner type) is ignored when
		/// resolving the method/field.
		/// </summary>
		/// <param name="memberRef">A method/field reference</param>
		/// <param name="options">Method/field signature comparison options</param>
		/// <returns>A <see cref="MethodDef"/> or a <see cref="FieldDef"/> instance or <c>null</c>
		/// if it couldn't be resolved.</returns>
		public IMemberForwarded Resolve(MemberRef memberRef, SigComparerOptions options) {
			if (memberRef is null)
				return null;

			var methodSig = memberRef.MethodSig;
			if (methodSig is not null)
				return FindMethodCheckBaseType(memberRef.Name, methodSig, options, memberRef.Module);

			var fieldSig = memberRef.FieldSig;
			if (fieldSig is not null)
				return FindFieldCheckBaseType(memberRef.Name, fieldSig, options, memberRef.Module);

			return null;
		}

		/// <summary>
		/// Finds a method. Private scope methods are not returned.
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <returns>The first method that matches or <c>null</c> if none found</returns>
		public MethodDef FindMethod(UTF8String name, MethodSig sig) => FindMethod(name, sig, 0, null);

		/// <summary>
		/// Finds a method
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <param name="options">Method signature comparison options</param>
		/// <returns>The first method that matches or <c>null</c> if none found</returns>
		public MethodDef FindMethod(UTF8String name, MethodSig sig, SigComparerOptions options) => FindMethod(name, sig, options, null);

		/// <summary>
		/// Finds a method
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <param name="options">Method signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the method or <c>null</c></param>
		/// <returns>The first method that matches or <c>null</c> if none found</returns>
		public MethodDef FindMethod(UTF8String name, MethodSig sig, SigComparerOptions options, ModuleDef sourceModule) {
			if (UTF8String.IsNull(name) || sig is null)
				return null;
			var comparer = new SigComparer(options, sourceModule);
			bool allowPrivateScope = (options & SigComparerOptions.PrivateScopeMethodIsComparable) != 0;
			var methods = Methods;
			int count = methods.Count;
			for (int i = 0; i < count; i++) {
				var method = methods[i];
				if (!allowPrivateScope && method.IsPrivateScope && sourceModule != Module)
					continue;
				if (!UTF8String.Equals(method.Name, name))
					continue;
				if (comparer.Equals(method.MethodSig, sig))
					return method;
			}
			return null;
		}

		/// <summary>
		/// Finds a method by name
		/// </summary>
		/// <param name="name">Name of method</param>
		/// <returns>The <see cref="MethodDef"/> or <c>null</c> if not found</returns>
		public MethodDef FindMethod(UTF8String name) {
			var methods = Methods;
			int count = methods.Count;
			for (int i = 0; i < count; i++) {
				var method = methods[i];
				if (UTF8String.Equals(method.Name, name))
					return method;
			}
			return null;
		}

		/// <summary>
		/// Finds all methods by name
		/// </summary>
		/// <param name="name">Name of method</param>
		/// <returns>All methods with that name</returns>
		public IEnumerable<MethodDef> FindMethods(UTF8String name) {
			var methods = Methods;
			int count = methods.Count;
			for (int i = 0; i < count; i++) {
				var method = methods[i];
				if (UTF8String.Equals(method.Name, name))
					yield return method;
			}
		}

		/// <summary>
		/// Finds the class constructor (aka type initializer). It's the method named .cctor
		/// </summary>
		/// <returns>The class constructor or <c>null</c> if none found</returns>
		public MethodDef FindStaticConstructor() {
			var methods = Methods;
			int count = methods.Count;
			for (int i = 0; i < count; i++) {
				var method = methods[i];
				if (method.IsStaticConstructor)
					return method;
			}
			return null;
		}

		/// <summary>
		/// Finds the class constructor (aka type initializer). It's the method named .cctor.
		/// If it doesn't exist, it is created, inserted into <see cref="Methods"/> and returned.
		/// The created .cctor will have just one RET instruction.
		/// </summary>
		/// <returns>The class constructor</returns>
		public MethodDef FindOrCreateStaticConstructor() {
			var cctor = FindStaticConstructor();
			if (cctor is not null)
				return cctor;

			var implFlags = MethodImplAttributes.IL | MethodImplAttributes.Managed;
			var flags = MethodAttributes.Private | MethodAttributes.Static |
						MethodAttributes.HideBySig | MethodAttributes.ReuseSlot |
						MethodAttributes.SpecialName | MethodAttributes.RTSpecialName;
			var module = Module;
			cctor = module.UpdateRowId(new MethodDefUser(MethodDef.StaticConstructorName,
						MethodSig.CreateStatic(module.CorLibTypes.Void), implFlags, flags));
			var body = new CilBody();
			body.InitLocals = true;
			body.MaxStack = 8;
			body.Instructions.Add(Emit.OpCodes.Ret.ToInstruction());
			cctor.Body = body;
			Methods.Add(cctor);
			return cctor;
		}

		/// <summary>
		/// Finds all instance constructors (not class constructors)
		/// </summary>
		/// <returns>All instance constructors</returns>
		public IEnumerable<MethodDef> FindInstanceConstructors() {
			var methods = Methods;
			int count = methods.Count;
			for (int i = 0; i < count; i++) {
				var method = methods[i];
				if (method.IsInstanceConstructor)
					yield return method;
			}
		}

		/// <summary>
		/// Finds all static and instance constructors
		/// </summary>
		/// <returns>All static and instance constructors</returns>
		public IEnumerable<MethodDef> FindConstructors() {
			var methods = Methods;
			int count = methods.Count;
			for (int i = 0; i < count; i++) {
				var method = methods[i];
				if (method.IsConstructor)
					yield return method;
			}
		}

		/// <summary>
		/// Finds the default instance constructor (the one with no arguments)
		/// </summary>
		/// <returns>The default instance constructor or <c>null</c> if none</returns>
		public MethodDef FindDefaultConstructor() {
			var methods = Methods;
			int count = methods.Count;
			for (int i = 0; i < count; i++) {
				var method = methods[i];
				if (!method.IsInstanceConstructor)
					continue;
				var sig = method.MethodSig;
				if (sig is not null && sig.Params.Count == 0)
					return method;
			}
			return null;
		}

		/// <summary>
		/// Finds a field. Private scope fields are not returned.
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <returns>The first field that matches or <c>null</c> if none found</returns>
		public FieldDef FindField(UTF8String name, FieldSig sig) => FindField(name, sig, 0, null);

		/// <summary>
		/// Finds a field
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <param name="options">Field signature comparison options</param>
		/// <returns>The first field that matches or <c>null</c> if none found</returns>
		public FieldDef FindField(UTF8String name, FieldSig sig, SigComparerOptions options) => FindField(name, sig, options, null);

		/// <summary>
		/// Finds a field
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <param name="options">Field signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the field or <c>null</c></param>
		/// <returns>The first field that matches or <c>null</c> if none found</returns>
		public FieldDef FindField(UTF8String name, FieldSig sig, SigComparerOptions options, ModuleDef sourceModule) {
			if (UTF8String.IsNull(name) || sig is null)
				return null;
			var comparer = new SigComparer(options, sourceModule);
			bool allowPrivateScope = (options & SigComparerOptions.PrivateScopeFieldIsComparable) != 0;
			var fields = Fields;
			int count = fields.Count;
			for (int i = 0; i < count; i++) {
				var field = fields[i];
				if (!allowPrivateScope && field.IsPrivateScope && sourceModule != Module)
					continue;
				if (!UTF8String.Equals(field.Name, name))
					continue;
				if (comparer.Equals(field.FieldSig, sig))
					return field;
			}
			return null;
		}

		/// <summary>
		/// Finds a field by name
		/// </summary>
		/// <param name="name">Name of field</param>
		/// <returns>The <see cref="FieldDef"/> or <c>null</c> if not found</returns>
		public FieldDef FindField(UTF8String name) {
			var fields = Fields;
			int count = fields.Count;
			for (int i = 0; i < count; i++) {
				var field = fields[i];
				if (UTF8String.Equals(field.Name, name))
					return field;
			}
			return null;
		}

		/// <summary>
		/// Finds all fields by name
		/// </summary>
		/// <param name="name">Name of field</param>
		/// <returns>All fields with that name</returns>
		public IEnumerable<FieldDef> FindFields(UTF8String name) {
			var fields = Fields;
			int count = fields.Count;
			for (int i = 0; i < count; i++) {
				var field = fields[i];
				if (UTF8String.Equals(field.Name, name))
					yield return field;
			}
		}

		/// <summary>
		/// Finds an event
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <param name="type">Type of event</param>
		/// <returns>A <see cref="EventDef"/> or <c>null</c> if not found</returns>
		public EventDef FindEvent(UTF8String name, IType type) => FindEvent(name, type, 0, null);

		/// <summary>
		/// Finds an event
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <param name="type">Type of event</param>
		/// <param name="options">Event type comparison options</param>
		/// <returns>A <see cref="EventDef"/> or <c>null</c> if not found</returns>
		public EventDef FindEvent(UTF8String name, IType type, SigComparerOptions options) => FindEvent(name, type, options, null);

		/// <summary>
		/// Finds an event
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <param name="type">Type of event</param>
		/// <param name="options">Event type comparison options</param>
		/// <param name="sourceModule">The module that needs to find the event or <c>null</c></param>
		/// <returns>A <see cref="EventDef"/> or <c>null</c> if not found</returns>
		public EventDef FindEvent(UTF8String name, IType type, SigComparerOptions options, ModuleDef sourceModule) {
			if (UTF8String.IsNull(name) || type is null)
				return null;
			var comparer = new SigComparer(options, sourceModule);
			var events = Events;
			int count = events.Count;
			for (int i = 0; i < count; i++) {
				var @event = events[i];
				if (!UTF8String.Equals(@event.Name, name))
					continue;
				if (comparer.Equals(@event.EventType, type))
					return @event;
			}
			return null;
		}

		/// <summary>
		/// Finds an event by name
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <returns>The <see cref="EventDef"/> or <c>null</c> if not found</returns>
		public EventDef FindEvent(UTF8String name) {
			var events = Events;
			int count = events.Count;
			for (int i = 0; i < count; i++) {
				var @event = events[i];
				if (UTF8String.Equals(@event.Name, name))
					return @event;
			}
			return null;
		}

		/// <summary>
		/// Finds all events by name
		/// </summary>
		/// <param name="name">Name of event</param>
		/// <returns>All events with that name</returns>
		public IEnumerable<EventDef> FindEvents(UTF8String name) {
			var events = Events;
			int count = events.Count;
			for (int i = 0; i < count; i++) {
				var @event = events[i];
				if (UTF8String.Equals(@event.Name, name))
					yield return @event;
			}
		}

		/// <summary>
		/// Finds a property
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <param name="propSig">Property signature</param>
		/// <returns>A <see cref="PropertyDef"/> or <c>null</c> if not found</returns>
		public PropertyDef FindProperty(UTF8String name, CallingConventionSig propSig) => FindProperty(name, propSig, 0, null);

		/// <summary>
		/// Finds a property
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <param name="propSig">Property signature</param>
		/// <param name="options">Property signature comparison options</param>
		/// <returns>A <see cref="PropertyDef"/> or <c>null</c> if not found</returns>
		public PropertyDef FindProperty(UTF8String name, CallingConventionSig propSig, SigComparerOptions options) => FindProperty(name, propSig, options, null);

		/// <summary>
		/// Finds a property
		/// </summary>
		/// <param name="name">Name of property</param>
		/// <param name="propSig">Property signature</param>
		/// <param name="options">Property signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the property or <c>null</c></param>
		/// <returns>A <see cref="PropertyDef"/> or <c>null</c> if not found</returns>
		public PropertyDef FindProperty(UTF8String name, CallingConventionSig propSig, SigComparerOptions options, ModuleDef sourceModule) {
			if (UTF8String.IsNull(name) || propSig is null)
				return null;
			var comparer = new SigComparer(options, sourceModule);
			var properties = Properties;
			int count = properties.Count;
			for (int i = 0; i < count; i++) {
				var prop = properties[i];
				if (!UTF8String.Equals(prop.Name, name))
					continue;
				if (comparer.Equals(prop.Type, propSig))
					return prop;
			}
			return null;
		}

		/// <summary>
		/// Finds a prop by name
		/// </summary>
		/// <param name="name">Name of prop</param>
		/// <returns>The <see cref="PropertyDef"/> or <c>null</c> if not found</returns>
		public PropertyDef FindProperty(UTF8String name) {
			var properties = Properties;
			int count = properties.Count;
			for (int i = 0; i < count; i++) {
				var prop = properties[i];
				if (UTF8String.Equals(prop.Name, name))
					return prop;
			}
			return null;
		}

		/// <summary>
		/// Finds all props by name
		/// </summary>
		/// <param name="name">Name of prop</param>
		/// <returns>All props with that name</returns>
		public IEnumerable<PropertyDef> FindProperties(UTF8String name) {
			var properties = Properties;
			int count = properties.Count;
			for (int i = 0; i < count; i++) {
				var prop = properties[i];
				if (UTF8String.Equals(prop.Name, name))
					yield return prop;
			}
		}

		/// <summary>
		/// Finds a method by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <returns>The method or <c>null</c> if it wasn't found</returns>
		public MethodDef FindMethodCheckBaseType(UTF8String name, MethodSig sig) => FindMethodCheckBaseType(name, sig, 0, null);

		/// <summary>
		/// Finds a method by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <param name="options">Method signature comparison options</param>
		/// <returns>The method or <c>null</c> if it wasn't found</returns>
		public MethodDef FindMethodCheckBaseType(UTF8String name, MethodSig sig, SigComparerOptions options) => FindMethodCheckBaseType(name, sig, options, null);

		/// <summary>
		/// Finds a method by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Method name</param>
		/// <param name="sig">Method signature</param>
		/// <param name="options">Method signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the method or <c>null</c></param>
		/// <returns>The method or <c>null</c> if it wasn't found</returns>
		public MethodDef FindMethodCheckBaseType(UTF8String name, MethodSig sig, SigComparerOptions options, ModuleDef sourceModule) {
			var td = this;
			while (td is not null) {
				var md = td.FindMethod(name, sig, options, sourceModule);
				if (md is not null)
					return md;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a method by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Method name</param>
		/// <returns>The method or <c>null</c> if it wasn't found</returns>
		public MethodDef FindMethodCheckBaseType(UTF8String name) {
			var td = this;
			while (td is not null) {
				var md = td.FindMethod(name);
				if (md is not null)
					return md;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a field by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <returns>The field or <c>null</c> if it wasn't found</returns>
		public FieldDef FindFieldCheckBaseType(UTF8String name, FieldSig sig) => FindFieldCheckBaseType(name, sig, 0, null);

		/// <summary>
		/// Finds a field by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <param name="options">Field signature comparison options</param>
		/// <returns>The field or <c>null</c> if it wasn't found</returns>
		public FieldDef FindFieldCheckBaseType(UTF8String name, FieldSig sig, SigComparerOptions options) => FindFieldCheckBaseType(name, sig, options, null);

		/// <summary>
		/// Finds a field by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Field name</param>
		/// <param name="sig">Field signature</param>
		/// <param name="options">Field signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the field or <c>null</c></param>
		/// <returns>The field or <c>null</c> if it wasn't found</returns>
		public FieldDef FindFieldCheckBaseType(UTF8String name, FieldSig sig, SigComparerOptions options, ModuleDef sourceModule) {
			var td = this;
			while (td is not null) {
				var fd = td.FindField(name, sig, options, sourceModule);
				if (fd is not null)
					return fd;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a field by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Field name</param>
		/// <returns>The field or <c>null</c> if it wasn't found</returns>
		public FieldDef FindFieldCheckBaseType(UTF8String name) {
			var td = this;
			while (td is not null) {
				var fd = td.FindField(name);
				if (fd is not null)
					return fd;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds an event by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Event name</param>
		/// <param name="eventType">Event type</param>
		/// <returns>The event or <c>null</c> if it wasn't found</returns>
		public EventDef FindEventCheckBaseType(UTF8String name, ITypeDefOrRef eventType) {
			var td = this;
			while (td is not null) {
				var ed = td.FindEvent(name, eventType);
				if (ed is not null)
					return ed;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds an event by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Event name</param>
		/// <returns>The event or <c>null</c> if it wasn't found</returns>
		public EventDef FindEventCheckBaseType(UTF8String name) {
			var td = this;
			while (td is not null) {
				var ed = td.FindEvent(name);
				if (ed is not null)
					return ed;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a property by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Property name</param>
		/// <param name="sig">Property signature</param>
		/// <returns>The property or <c>null</c> if it wasn't found</returns>
		public PropertyDef FindPropertyCheckBaseType(UTF8String name, PropertySig sig) => FindPropertyCheckBaseType(name, sig, 0, null);

		/// <summary>
		/// Finds a property by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Property name</param>
		/// <param name="sig">Property signature</param>
		/// <param name="options">Property signature comparison options</param>
		/// <returns>The property or <c>null</c> if it wasn't found</returns>
		public PropertyDef FindPropertyCheckBaseType(UTF8String name, PropertySig sig, SigComparerOptions options) => FindPropertyCheckBaseType(name, sig, options, null);

		/// <summary>
		/// Finds a property by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Property name</param>
		/// <param name="sig">Property signature</param>
		/// <param name="options">Property signature comparison options</param>
		/// <param name="sourceModule">The module that needs to find the property or <c>null</c></param>
		/// <returns>The property or <c>null</c> if it wasn't found</returns>
		public PropertyDef FindPropertyCheckBaseType(UTF8String name, PropertySig sig, SigComparerOptions options, ModuleDef sourceModule) {
			var td = this;
			while (td is not null) {
				var pd = td.FindProperty(name, sig, options, sourceModule);
				if (pd is not null)
					return pd;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Finds a property by checking this type or any of its base types
		/// </summary>
		/// <param name="name">Property name</param>
		/// <returns>The property or <c>null</c> if it wasn't found</returns>
		public PropertyDef FindPropertyCheckBaseType(UTF8String name) {
			var td = this;
			while (td is not null) {
				var pd = td.FindProperty(name);
				if (pd is not null)
					return pd;
				td = td.BaseType.ResolveTypeDef();
			}
			return null;
		}

		/// <summary>
		/// Removes a method from this type. It also removes it from any properties and events.
		/// </summary>
		/// <param name="method">The method to remove</param>
		public void Remove(MethodDef method) => Remove(method, false);

		/// <summary>
		/// Removes a method from this type. It also removes it from any properties and events.
		/// </summary>
		/// <param name="method">The method to remove</param>
		/// <param name="removeEmptyPropertiesEvents"><c>true</c> if we should remove all
		/// empty properties and events.</param>
		public void Remove(MethodDef method, bool removeEmptyPropertiesEvents) {
			if (method is null)
				return;

			var properties = Properties;
			int count = properties.Count;
			for (int i = 0; i < count; i++) {
				var prop = properties[i];
				prop.GetMethods.Remove(method);
				prop.SetMethods.Remove(method);
				prop.OtherMethods.Remove(method);
			}

			var events = Events;
			count = events.Count;
			for (int i = 0; i < count; i++) {
				var evt = events[i];
				if (evt.AddMethod == method)
					evt.AddMethod = null;
				if (evt.RemoveMethod == method)
					evt.RemoveMethod = null;
				if (evt.InvokeMethod == method)
					evt.InvokeMethod = null;
				evt.OtherMethods.Remove(method);
			}

			if (removeEmptyPropertiesEvents) {
				RemoveEmptyProperties();
				RemoveEmptyEvents();
			}

			Methods.Remove(method);
		}

		void RemoveEmptyProperties() {
			var properties = Properties;
			for (int i = properties.Count - 1; i >= 0; i--) {
				if (properties[i].IsEmpty)
					properties.RemoveAt(i);
			}
		}

		void RemoveEmptyEvents() {
			var events = Events;
			for (int i = events.Count - 1; i >= 0; i--) {
				if (events[i].IsEmpty)
					events.RemoveAt(i);
			}
		}

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnLazyAdd(int index, ref FieldDef value) => OnLazyAdd2(index, ref value);

		internal virtual void OnLazyAdd2(int index, ref FieldDef value) {
#if DEBUG
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added field's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnAdd(int index, FieldDef value) {
			if (value.DeclaringType is not null)
				throw new InvalidOperationException("Field is already owned by another type. Set DeclaringType to null first.");
			value.DeclaringType2 = this;
		}

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnRemove(int index, FieldDef value) => value.DeclaringType2 = null;

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<FieldDef>.OnClear() {
			foreach (var field in fields.GetEnumerable_NoLock())
				field.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnLazyAdd(int index, ref MethodDef value) => OnLazyAdd2(index, ref value);

		internal virtual void OnLazyAdd2(int index, ref MethodDef value) {
#if DEBUG
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added method's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnAdd(int index, MethodDef value) {
			if (value.DeclaringType is not null)
				throw new InvalidOperationException("Method is already owned by another type. Set DeclaringType to null first.");
			value.DeclaringType2 = this;
			value.Parameters.UpdateThisParameterType(this);
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnRemove(int index, MethodDef value) {
			value.DeclaringType2 = null;
			value.Parameters.UpdateThisParameterType(null);
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<MethodDef>.OnClear() {
			foreach (var method in methods.GetEnumerable_NoLock()) {
				method.DeclaringType2 = null;
				method.Parameters.UpdateThisParameterType(null);
			}
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnLazyAdd(int index, ref TypeDef value) {
#if DEBUG
			if (value.Module2 is not null)
				throw new InvalidOperationException("Added nested type's Module is not null");
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added nested type's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnAdd(int index, TypeDef value) {
			if (value.DeclaringType is not null)
				throw new InvalidOperationException("Nested type is already owned by another type. Set DeclaringType to null first.");
			if (value.Module is not null)
				throw new InvalidOperationException("Type is already owned by another module. Remove it from that module's type list.");
			value.DeclaringType2 = this;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnRemove(int index, TypeDef value) {
			value.DeclaringType2 = null;
			value.Module2 = null;
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<TypeDef>.OnClear() {
			foreach (var type in nestedTypes.GetEnumerable_NoLock())
				type.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<EventDef>.OnLazyAdd(int index, ref EventDef value) => OnLazyAdd2(index, ref value);

		internal virtual void OnLazyAdd2(int index, ref EventDef value) {
#if DEBUG
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added event's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<EventDef>.OnAdd(int index, EventDef value) {
			if (value.DeclaringType is not null)
				throw new InvalidOperationException("Event is already owned by another type. Set DeclaringType to null first.");
			value.DeclaringType2 = this;
		}

		/// <inheritdoc/>
		void IListListener<EventDef>.OnRemove(int index, EventDef value) => value.DeclaringType2 = null;

		/// <inheritdoc/>
		void IListListener<EventDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<EventDef>.OnClear() {
			foreach (var @event in events.GetEnumerable_NoLock())
				@event.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnLazyAdd(int index, ref PropertyDef value) => OnLazyAdd2(index, ref value);

		internal virtual void OnLazyAdd2(int index, ref PropertyDef value) {
#if DEBUG
			if (value.DeclaringType != this)
				throw new InvalidOperationException("Added property's DeclaringType != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnAdd(int index, PropertyDef value) {
			if (value.DeclaringType is not null)
				throw new InvalidOperationException("Property is already owned by another type. Set DeclaringType to null first.");
			value.DeclaringType2 = this;
		}

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnRemove(int index, PropertyDef value) => value.DeclaringType2 = null;

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<PropertyDef>.OnClear() {
			foreach (var prop in properties.GetEnumerable_NoLock())
				prop.DeclaringType2 = null;
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnLazyAdd(int index, ref GenericParam value) => OnLazyAdd2(index, ref value);

		internal virtual void OnLazyAdd2(int index, ref GenericParam value) {
#if DEBUG
			if (value.Owner != this)
				throw new InvalidOperationException("Added generic param's Owner != this");
#endif
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnAdd(int index, GenericParam value) {
			if (value.Owner is not null)
				throw new InvalidOperationException("Generic param is already owned by another type/method. Set Owner to null first.");
			value.Owner = this;
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnRemove(int index, GenericParam value) => value.Owner = null;

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnResize(int index) {
		}

		/// <inheritdoc/>
		void IListListener<GenericParam>.OnClear() {
			foreach (var gp in genericParameters.GetEnumerable_NoLock())
				gp.Owner = null;
		}

		/// <summary>
		/// Gets all fields named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Field name</param>
		/// <returns>A list of 0 or more fields with name <paramref name="name"/></returns>
		public IList<FieldDef> GetFields(UTF8String name) {
			var result = new List<FieldDef>();
			var fields = Fields;
			int count = fields.Count;
			for (int i = 0; i < count; i++) {
				var field = fields[i];
				if (field.Name == name)
					result.Add(field);
			}
			return result;
		}

		/// <summary>
		/// Gets the first field named <paramref name="name"/>
		/// </summary>
		/// <param name="name">Field name</param>
		/// <returns>The field or <c>null</c> if none found</returns>
		public FieldDef GetField(UTF8String name) {
			var fields = Fields;
			int count = fields.Count;
			for (int i = 0; i < count; i++) {
				var field = fields[i];
				if (field.Name == name)
					return field;
			}
			return null;
		}

		internal static bool GetClassSize(TypeDef td, out uint size) {
			size = 0;
			if (td is null)
				return false;
			if (!td.IsValueType)
				return false;	// Not supported by us
			if (!td.IsSequentialLayout && !td.IsExplicitLayout) {
				if (td.Fields.Count != 1)
					return false;
				var fd = td.Fields[0];
				if (fd is null)
					return false;
				return fd.GetFieldSize(out size);
			}

			var classLayout = td.ClassLayout;
			if (classLayout is null)
				return false;
			uint classSize = classLayout.ClassSize;
			if (classSize != 0) {
				size = classSize;
				return true;
			}

			// Not supported by us
			return false;
		}

		/// <summary>
		/// FInd a method implementation method
		/// </summary>
		/// <param name="mdr">Method</param>
		/// <returns></returns>
		protected MethodDef FindMethodImplMethod(IMethodDefOrRef mdr) {
			// Check common case first
			if (mdr is MethodDef md)
				return md;

			// Must be a member ref
			var mr = mdr as MemberRef;
			if (mr is null)
				return null;

			// If Class is MethodDef, then it should be a vararg method
			var parent = mr.Class;
			md = parent as MethodDef;
			if (md is not null)
				return md;

			// If it's a TypeSpec, it must be a generic instance type
			for (int i = 0; i < 10; i++) {
				var ts = parent as TypeSpec;
				if (ts is null)
					break;

				var gis = ts.TypeSig as GenericInstSig;
				if (gis is null || gis.GenericType is null)
					return null;
				parent = gis.GenericType.TypeDefOrRef;
			}

			var td = parent as TypeDef;
			if (td is null) {
				// If it's a TypeRef, resolve it as if it is a reference to a type in the
				// current module, even if its ResolutionScope happens to be some other
				// assembly/module (that's what the CLR does)
				if (parent is TypeRef tr && Module is not null)
					td = Module.Find(tr);
			}
			if (td is null)
				return null;
			return td.FindMethod(mr.Name, mr.MethodSig);
		}

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A TypeDef row created by the user and not present in the original .NET file
	/// </summary>
	public class TypeDefUser : TypeDef {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public TypeDefUser(UTF8String name)
			: this(null, name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="namespace">Namespace</param>
		/// <param name="name">Name</param>
		public TypeDefUser(UTF8String @namespace, UTF8String name)
			: this(@namespace, name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		/// <param name="baseType">Base class or <c>null</c> if it's an interface</param>
		public TypeDefUser(UTF8String name, ITypeDefOrRef baseType)
			: this(null, name, baseType) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="namespace">Namespace</param>
		/// <param name="name">Name</param>
		/// <param name="baseType">Base class or <c>null</c> if it's an interface</param>
		public TypeDefUser(UTF8String @namespace, UTF8String name, ITypeDefOrRef baseType) {
			fields = new LazyList<FieldDef>(this);
			methods = new LazyList<MethodDef>(this);
			genericParameters = new LazyList<GenericParam>(this);
			nestedTypes = new LazyList<TypeDef>(this);
			events = new LazyList<EventDef>(this);
			properties = new LazyList<PropertyDef>(this);
			this.@namespace = @namespace;
			this.name = name;
			this.baseType = baseType;
			baseType_isInitialized = true;
		}
	}

	/// <summary>
	/// Created from a row in the TypeDef table
	/// </summary>
	sealed class TypeDefMD : TypeDef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		internal ModuleDefMD ReaderModule => readerModule;

		readonly uint origRid;
		readonly uint extendsCodedToken;
		Dictionary<uint, IList<MethodOverrideTokens>> methodRidToOverrides;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override ITypeDefOrRef GetBaseType_NoLock() => readerModule.ResolveTypeDefOrRef(extendsCodedToken, new GenericParamContext(this));

		/// <inheritdoc/>
		protected override void InitializeFields() {
			var list = readerModule.Metadata.GetFieldRidList(origRid);
			var tmp = new LazyList<FieldDef, RidList>(list.Count, this, list, (list2, index) => readerModule.ResolveField(list2[index]));
			Interlocked.CompareExchange(ref fields, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeMethods() {
			var list = readerModule.Metadata.GetMethodRidList(origRid);
			var tmp = new LazyList<MethodDef, RidList>(list.Count, this, list, (list2, index) => readerModule.ResolveMethod(list2[index]));
			Interlocked.CompareExchange(ref methods, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeGenericParameters() {
			var list = readerModule.Metadata.GetGenericParamRidList(Table.TypeDef, origRid);
			var tmp = new LazyList<GenericParam, RidList>(list.Count, this, list, (list2, index) => readerModule.ResolveGenericParam(list2[index]));
			Interlocked.CompareExchange(ref genericParameters, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeInterfaces() {
			var list = readerModule.Metadata.GetInterfaceImplRidList(origRid);
			var tmp = new LazyList<InterfaceImpl, RidList>(list.Count, list, (list2, index) => readerModule.ResolveInterfaceImpl(list2[index], new GenericParamContext(this)));
			Interlocked.CompareExchange(ref interfaces, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeDeclSecurities() {
			var list = readerModule.Metadata.GetDeclSecurityRidList(Table.TypeDef, origRid);
			var tmp = new LazyList<DeclSecurity, RidList>(list.Count, list, (list2, index) => readerModule.ResolveDeclSecurity(list2[index]));
			Interlocked.CompareExchange(ref declSecurities, tmp, null);
		}

		/// <inheritdoc/>
		protected override ClassLayout GetClassLayout_NoLock() => readerModule.ResolveClassLayout(readerModule.Metadata.GetClassLayoutRid(origRid));

		/// <inheritdoc/>
		protected override TypeDef GetDeclaringType2_NoLock() {
			if (!readerModule.TablesStream.TryReadNestedClassRow(readerModule.Metadata.GetNestedClassRid(origRid), out var row))
				return null;
			return readerModule.ResolveTypeDef(row.EnclosingClass);
		}

		TypeDef DeclaringType2_NoLock {
			get {
				if (!declaringType2_isInitialized) {
					declaringType2 = GetDeclaringType2_NoLock();
					declaringType2_isInitialized = true;
				}
				return declaringType2;
			}
		}

		/// <inheritdoc/>
		protected override void InitializeEvents() {
			var mapRid = readerModule.Metadata.GetEventMapRid(origRid);
			var list = readerModule.Metadata.GetEventRidList(mapRid);
			var tmp = new LazyList<EventDef, RidList>(list.Count, this, list, (list2, index) => readerModule.ResolveEvent(list2[index]));
			Interlocked.CompareExchange(ref events, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeProperties() {
			var mapRid = readerModule.Metadata.GetPropertyMapRid(origRid);
			var list = readerModule.Metadata.GetPropertyRidList(mapRid);
			var tmp = new LazyList<PropertyDef, RidList>(list.Count, this, list, (list2, index) => readerModule.ResolveProperty(list2[index]));
			Interlocked.CompareExchange(ref properties, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeNestedTypes() {
			var list = readerModule.Metadata.GetNestedClassRidList(origRid);
			var tmp = new LazyList<TypeDef, RidList>(list.Count, this, list, (list2, index) => readerModule.ResolveTypeDef(list2[index]));
			Interlocked.CompareExchange(ref nestedTypes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.TypeDef, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(this), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <inheritdoc/>
		protected override ModuleDef GetModule2_NoLock() => DeclaringType2_NoLock is not null ? null : readerModule;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>TypeDef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public TypeDefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.TypeDefTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"TypeDef rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			bool b = readerModule.TablesStream.TryReadTypeDefRow(origRid, out var row);
			Debug.Assert(b);
			extendsCodedToken = row.Extends;
			attributes = (int)row.Flags;
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			@namespace = readerModule.StringsStream.ReadNoNull(row.Namespace);
		}

		/// <summary>
		/// Gets all methods <paramref name="method"/> overrides
		/// </summary>
		/// <param name="method">The method</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A list (possibly empty) of all methods <paramref name="method"/> overrides</returns>
		internal IList<MethodOverride> GetMethodOverrides(MethodDefMD method, GenericParamContext gpContext) {
			if (method is null)
				return new List<MethodOverride>();

			if (methodRidToOverrides is null)
				InitializeMethodOverrides();

			if (methodRidToOverrides.TryGetValue(method.OrigRid, out var overrides)) {
				var newList = new List<MethodOverride>(overrides.Count);

				for (int i = 0; i < overrides.Count; i++) {
					var ovr = overrides[i];
					var newMethodBody = (IMethodDefOrRef)readerModule.ResolveToken(ovr.MethodBodyToken, gpContext);
					var newMethodDeclaration = (IMethodDefOrRef)readerModule.ResolveToken(ovr.MethodDeclarationToken, gpContext);
					newList.Add(new MethodOverride(newMethodBody, newMethodDeclaration));
				}
				return newList;
			}
			return new List<MethodOverride>();
		}

		readonly struct MethodOverrideTokens {
			public readonly uint MethodBodyToken;
			public readonly uint MethodDeclarationToken;

			public MethodOverrideTokens(uint methodBodyToken, uint methodDeclarationToken) {
				MethodBodyToken = methodBodyToken;
				MethodDeclarationToken = methodDeclarationToken;
			}
		}

		void InitializeMethodOverrides() {
			var newMethodRidToOverrides = new Dictionary<uint, IList<MethodOverrideTokens>>();

			var ridList = readerModule.Metadata.GetMethodImplRidList(origRid);
			for (int i = 0; i < ridList.Count; i++) {
				if (!readerModule.TablesStream.TryReadMethodImplRow(ridList[i], out var row))
					continue;

				var methodBody = readerModule.ResolveMethodDefOrRef(row.MethodBody);
				var methodDecl = readerModule.ResolveMethodDefOrRef(row.MethodDeclaration);
				if (methodBody is null || methodDecl is null)
					continue;	// Should only happen if some obfuscator added invalid metadata

				// Find the real method. This is usually methodBody since it's usually a
				// MethodDef. The CLR only allows method bodies in the current type, and
				// so shall we.
				var method = FindMethodImplMethod(methodBody);
				if (method is null || method.DeclaringType != this)
					continue;

				uint rid = method.Rid;
				if (!newMethodRidToOverrides.TryGetValue(rid, out var overrides))
					newMethodRidToOverrides[rid] = overrides = new List<MethodOverrideTokens>();
				overrides.Add(new MethodOverrideTokens(methodBody.MDToken.Raw, methodDecl.MDToken.Raw));
			}
			Interlocked.CompareExchange(ref methodRidToOverrides, newMethodRidToOverrides, null);
		}

		/// <summary>
		/// Initializes all <see cref="MethodDef.semAttrs"/>. Only those <see cref="MethodDef"/>s
		/// that are property or event handlers get updated.
		/// </summary>
		internal void InitializeMethodSemanticsAttributes() {
			var mapRid = readerModule.Metadata.GetPropertyMapRid(origRid);
			var list = readerModule.Metadata.GetPropertyRidList(mapRid);
			for (int i = 0; i < list.Count; i++) {
				var ridList = readerModule.Metadata.GetMethodSemanticsRidList(Table.Property, list[i]);
				for (int j = 0; j < ridList.Count; j++) {
					if (!readerModule.TablesStream.TryReadMethodSemanticsRow(ridList[j], out var row))
						continue;
					var method = readerModule.ResolveMethod(row.Method);
					if (method is null)
						continue;

					Interlocked.CompareExchange(ref method.semAttrs, row.Semantic | MethodDef.SEMATTRS_INITD, 0);
				}
			}

			mapRid = readerModule.Metadata.GetEventMapRid(origRid);
			list = readerModule.Metadata.GetEventRidList(mapRid);
			for (int i = 0; i < list.Count; i++) {
				var ridList = readerModule.Metadata.GetMethodSemanticsRidList(Table.Event, list[i]);
				for (int j = 0; j < ridList.Count; j++) {
					if (!readerModule.TablesStream.TryReadMethodSemanticsRow(ridList[j], out var row))
						continue;
					var method = readerModule.ResolveMethod(row.Method);
					if (method is null)
						continue;

					Interlocked.CompareExchange(ref method.semAttrs, row.Semantic | MethodDef.SEMATTRS_INITD, 0);
				}
			}
		}

		/// <summary>
		/// Initializes a property's special methods
		/// </summary>
		/// <param name="prop">The property</param>
		/// <param name="getMethods">Updated with a list of all get methods</param>
		/// <param name="setMethods">Updated with a list of all set methods</param>
		/// <param name="otherMethods">Updated with a list of all other methods</param>
		internal void InitializeProperty(PropertyDefMD prop, out IList<MethodDef> getMethods, out IList<MethodDef> setMethods, out IList<MethodDef> otherMethods) {
			getMethods = new List<MethodDef>();
			setMethods = new List<MethodDef>();
			otherMethods = new List<MethodDef>();
			if (prop is null)
				return;

			var ridList = readerModule.Metadata.GetMethodSemanticsRidList(Table.Property, prop.OrigRid);
			for (int i = 0; i < ridList.Count; i++) {
				if (!readerModule.TablesStream.TryReadMethodSemanticsRow(ridList[i], out var row))
					continue;
				var method = readerModule.ResolveMethod(row.Method);
				if (method is null || method.DeclaringType != prop.DeclaringType)
					continue;

				// It's documented to be flags, but ignore those with more than one bit set
				switch ((MethodSemanticsAttributes)row.Semantic) {
				case MethodSemanticsAttributes.Setter:
					if (!setMethods.Contains(method))
						setMethods.Add(method);
					break;

				case MethodSemanticsAttributes.Getter:
					if (!getMethods.Contains(method))
						getMethods.Add(method);
					break;

				case MethodSemanticsAttributes.Other:
					if (!otherMethods.Contains(method))
						otherMethods.Add(method);
					break;

				default:
					// Ignore anything else
					break;
				}
			}
		}

		/// <summary>
		/// Initializes an event's special methods
		/// </summary>
		/// <param name="evt">The event</param>
		/// <param name="addMethod">Updated with the addOn method or <c>null</c> if none</param>
		/// <param name="invokeMethod">Updated with the fire method or <c>null</c> if none</param>
		/// <param name="removeMethod">Updated with the removeOn method or <c>null</c> if none</param>
		/// <param name="otherMethods">Updated with a list of all other methods</param>
		internal void InitializeEvent(EventDefMD evt, out MethodDef addMethod, out MethodDef invokeMethod, out MethodDef removeMethod, out IList<MethodDef> otherMethods) {
			addMethod = null;
			invokeMethod = null;
			removeMethod = null;
			otherMethods = new List<MethodDef>();
			if (evt is null)
				return;

			var ridList = readerModule.Metadata.GetMethodSemanticsRidList(Table.Event, evt.OrigRid);
			for (int i = 0; i < ridList.Count; i++) {
				if (!readerModule.TablesStream.TryReadMethodSemanticsRow(ridList[i], out var row))
					continue;
				var method = readerModule.ResolveMethod(row.Method);
				if (method is null || method.DeclaringType != evt.DeclaringType)
					continue;

				// It's documented to be flags, but ignore those with more than one bit set
				switch ((MethodSemanticsAttributes)row.Semantic) {
				case MethodSemanticsAttributes.AddOn:
					if (addMethod is null)
						addMethod = method;
					break;

				case MethodSemanticsAttributes.RemoveOn:
					if (removeMethod is null)
						removeMethod = method;
					break;

				case MethodSemanticsAttributes.Fire:
					if (invokeMethod is null)
						invokeMethod = method;
					break;

				case MethodSemanticsAttributes.Other:
					if (!otherMethods.Contains(method))
						otherMethods.Add(method);
					break;

				default:
					// Ignore anything else
					break;
				}
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref FieldDef value) {
			if (value.DeclaringType != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadField(value.Rid).InitializeAll());
				value.DeclaringType2 = this;
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref MethodDef value) {
			if (value.DeclaringType != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadMethod(value.Rid).InitializeAll());
				value.DeclaringType2 = this;
				value.Parameters.UpdateThisParameterType(this);
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref EventDef value) {
			if (value.DeclaringType != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadEvent(value.Rid).InitializeAll());
				value.DeclaringType2 = this;
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref PropertyDef value) {
			if (value.DeclaringType != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadProperty(value.Rid).InitializeAll());
				value.DeclaringType2 = this;
			}
		}

		/// <inheritdoc/>
		internal override void OnLazyAdd2(int index, ref GenericParam value) {
			if (value.Owner != this) {
				// More than one owner... This module has invalid metadata.
				value = readerModule.ForceUpdateRowId(readerModule.ReadGenericParam(value.Rid).InitializeAll());
				value.Owner = this;
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Finds <see cref="TypeDef"/>s
	/// </summary>
	sealed class TypeDefFinder : ITypeDefFinder, IDisposable {
		const SigComparerOptions TypeComparerOptions = SigComparerOptions.DontCompareTypeScope | SigComparerOptions.TypeRefCanReferenceGlobalType;
		bool isCacheEnabled;
		readonly bool includeNestedTypes;
		Dictionary<ITypeDefOrRef, TypeDef> typeRefCache = new Dictionary<ITypeDefOrRef, TypeDef>(new TypeEqualityComparer(TypeComparerOptions));
		Dictionary<string, TypeDef> normalNameCache = new Dictionary<string, TypeDef>(StringComparer.Ordinal);
		Dictionary<string, TypeDef> reflectionNameCache = new Dictionary<string, TypeDef>(StringComparer.Ordinal);
		readonly StringBuilder sb = new StringBuilder();
		IEnumerator<TypeDef> typeEnumerator;
		readonly IEnumerable<TypeDef> rootTypes;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// <c>true</c> if the <see cref="TypeDef"/> cache is enabled. <c>false</c> if the cache
		/// is disabled and a slower <c>O(n)</c> lookup is performed.
		/// </summary>
		public bool IsCacheEnabled {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return IsCacheEnabled_NoLock;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				IsCacheEnabled_NoLock = value;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		bool IsCacheEnabled_NoLock {
			get => isCacheEnabled;
			set {
				if (isCacheEnabled == value)
					return;

				if (typeEnumerator is not null) {
					typeEnumerator.Dispose();
					typeEnumerator = null;
				}

				typeRefCache.Clear();
				normalNameCache.Clear();
				reflectionNameCache.Clear();

				if (value)
					InitializeTypeEnumerator();

				isCacheEnabled = value;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rootTypes">All root types. All their nested types are also included.</param>
		/// <exception cref="ArgumentNullException">If <paramref name="rootTypes"/> is <c>null</c></exception>
		public TypeDefFinder(IEnumerable<TypeDef> rootTypes)
			: this(rootTypes, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rootTypes">All root types</param>
		/// <param name="includeNestedTypes"><c>true</c> if all nested types that are reachable
		/// from <paramref name="rootTypes"/> should also be included.</param>
		/// <exception cref="ArgumentNullException">If <paramref name="rootTypes"/> is <c>null</c></exception>
		public TypeDefFinder(IEnumerable<TypeDef> rootTypes, bool includeNestedTypes) {
			this.rootTypes = rootTypes ?? throw new ArgumentNullException(nameof(rootTypes));
			this.includeNestedTypes = includeNestedTypes;
		}

		void InitializeTypeEnumerator() {
			if (typeEnumerator is not null) {
				typeEnumerator.Dispose();
				typeEnumerator = null;
			}
			typeEnumerator = (includeNestedTypes ? AllTypesHelper.Types(rootTypes) : rootTypes).GetEnumerator();
		}

		/// <summary>
		/// Resets the cache (clears all cached elements). Use this method if the cache is
		/// enabled but some of the types have been modified (eg. removed, added, renamed).
		/// </summary>
		public void ResetCache() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			bool old = IsCacheEnabled_NoLock;
			IsCacheEnabled_NoLock = false;
			IsCacheEnabled_NoLock = old;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public TypeDef Find(string fullName, bool isReflectionName) {
			if (fullName is null)
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (isCacheEnabled)
				return isReflectionName ? FindCacheReflection(fullName) : FindCacheNormal(fullName);
			return isReflectionName ? FindSlowReflection(fullName) : FindSlowNormal(fullName);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <inheritdoc/>
		public TypeDef Find(TypeRef typeRef) {
			if (typeRef is null)
				return null;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return isCacheEnabled ? FindCache(typeRef) : FindSlow(typeRef);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		TypeDef FindCache(TypeRef typeRef) {
			if (typeRefCache.TryGetValue(typeRef, out var cachedType))
				return cachedType;

			// Build the cache lazily
			var comparer = new SigComparer(TypeComparerOptions);
			while (true) {
				cachedType = GetNextTypeDefCache();
				if (cachedType is null || comparer.Equals(cachedType, typeRef))
					return cachedType;
			}
		}

		TypeDef FindCacheReflection(string fullName) {
			if (reflectionNameCache.TryGetValue(fullName, out var cachedType))
				return cachedType;

			// Build the cache lazily
			while (true) {
				cachedType = GetNextTypeDefCache();
				if (cachedType is null)
					return cachedType;
				sb.Length = 0;
				if (FullNameFactory.FullName(cachedType, true, null, sb) == fullName)
					return cachedType;
			}
		}

		TypeDef FindCacheNormal(string fullName) {
			if (normalNameCache.TryGetValue(fullName, out var cachedType))
				return cachedType;

			// Build the cache lazily
			while (true) {
				cachedType = GetNextTypeDefCache();
				if (cachedType is null)
					return cachedType;
				sb.Length = 0;
				if (FullNameFactory.FullName(cachedType, false, null, sb) == fullName)
					return cachedType;
			}
		}

		TypeDef FindSlow(TypeRef typeRef) {
			InitializeTypeEnumerator();
			var comparer = new SigComparer(TypeComparerOptions);
			while (true) {
				var type = GetNextTypeDef();
				if (type is null || comparer.Equals(type, typeRef))
					return type;
			}
		}

		TypeDef FindSlowReflection(string fullName) {
			InitializeTypeEnumerator();
			while (true) {
				var type = GetNextTypeDef();
				if (type is null)
					return type;
				sb.Length = 0;
				if (FullNameFactory.FullName(type, true, null, sb) == fullName)
					return type;
			}
		}

		TypeDef FindSlowNormal(string fullName) {
			InitializeTypeEnumerator();
			while (true) {
				var type = GetNextTypeDef();
				if (type is null)
					return type;
				sb.Length = 0;
				if (FullNameFactory.FullName(type, false, null, sb) == fullName)
					return type;
			}
		}

		/// <summary>
		/// Gets the next <see cref="TypeDef"/> or <c>null</c> if there are no more left
		/// </summary>
		/// <returns>The next <see cref="TypeDef"/> or <c>null</c> if none</returns>
		TypeDef GetNextTypeDef() {
			while (typeEnumerator.MoveNext()) {
				var type = typeEnumerator.Current;
				if (type is not null)
					return type;
			}
			return null;
		}

		/// <summary>
		/// Gets the next <see cref="TypeDef"/> or <c>null</c> if there are no more left.
		/// The cache is updated with the returned <see cref="TypeDef"/> before the method
		/// returns.
		/// </summary>
		/// <returns>The next <see cref="TypeDef"/> or <c>null</c> if none</returns>
		TypeDef GetNextTypeDefCache() {
			var type = GetNextTypeDef();
			if (type is null)
				return null;

			// Only insert it if another type with the exact same sig/name isn't already
			// in the cache. This should only happen with some obfuscated assemblies.

			if (!typeRefCache.ContainsKey(type))
				typeRefCache[type] = type;
			string fn;
			sb.Length = 0;
			if (!normalNameCache.ContainsKey(fn = FullNameFactory.FullName(type, false, null, sb)))
				normalNameCache[fn] = type;
			sb.Length = 0;
			if (!reflectionNameCache.ContainsKey(fn = FullNameFactory.FullName(type, true, null, sb)))
				reflectionNameCache[fn] = type;

			return type;
		}

		/// <inheritdoc/>
		public void Dispose() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (typeEnumerator is not null)
				typeEnumerator.Dispose();
			typeEnumerator = null;
			typeRefCache = null;
			normalNameCache = null;
			reflectionNameCache = null;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Various helper methods for <see cref="IType"/> classes to prevent infinite recursion
	/// </summary>
	struct TypeHelper {
		RecursionCounter recursionCounter;

		internal static bool ContainsGenericParameter(StandAloneSig ss) => ss is not null && TypeHelper.ContainsGenericParameter(ss.Signature);
		internal static bool ContainsGenericParameter(InterfaceImpl ii) => ii is not null && TypeHelper.ContainsGenericParameter(ii.Interface);
		internal static bool ContainsGenericParameter(GenericParamConstraint gpc) => gpc is not null && ContainsGenericParameter(gpc.Constraint);

		internal static bool ContainsGenericParameter(MethodSpec ms) {
			if (ms is null)
				return false;

			// A normal MethodSpec should always contain generic arguments and thus
			// its MethodDef is always a generic method with generic parameters.
			return true;
		}

		internal static bool ContainsGenericParameter(MemberRef mr) {
			if (mr is null)
				return false;

			if (ContainsGenericParameter(mr.Signature))
				return true;

			var cl = mr.Class;

			if (cl is ITypeDefOrRef tdr)
				return tdr.ContainsGenericParameter;

			if (cl is MethodDef md)
				return TypeHelper.ContainsGenericParameter(md.Signature);

			return false;
		}

		/// <summary>
		/// Checks whether <paramref name="callConv"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="callConv">Calling convention signature</param>
		/// <returns><c>true</c> if <paramref name="callConv"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(CallingConventionSig callConv) {
			if (callConv is FieldSig fs)
				return ContainsGenericParameter(fs);

			if (callConv is MethodBaseSig mbs)
				return ContainsGenericParameter(mbs);

			if (callConv is LocalSig ls)
				return ContainsGenericParameter(ls);

			if (callConv is GenericInstMethodSig gim)
				return ContainsGenericParameter(gim);

			return false;
		}

		/// <summary>
		/// Checks whether <paramref name="fieldSig"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="fieldSig">Field signature</param>
		/// <returns><c>true</c> if <paramref name="fieldSig"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(FieldSig fieldSig) => new TypeHelper().ContainsGenericParameterInternal(fieldSig);

		/// <summary>
		/// Checks whether <paramref name="methodSig"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="methodSig">Method or property signature</param>
		/// <returns><c>true</c> if <paramref name="methodSig"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(MethodBaseSig methodSig) => new TypeHelper().ContainsGenericParameterInternal(methodSig);

		/// <summary>
		/// Checks whether <paramref name="localSig"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="localSig">Local signature</param>
		/// <returns><c>true</c> if <paramref name="localSig"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(LocalSig localSig) => new TypeHelper().ContainsGenericParameterInternal(localSig);

		/// <summary>
		/// Checks whether <paramref name="gim"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="gim">Generic method signature</param>
		/// <returns><c>true</c> if <paramref name="gim"/> contains a <see cref="GenericVar"/>
		/// or a <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(GenericInstMethodSig gim) => new TypeHelper().ContainsGenericParameterInternal(gim);

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(IType type) {
			if (type is TypeDef td)
				return ContainsGenericParameter(td);

			if (type is TypeRef tr)
				return ContainsGenericParameter(tr);

			if (type is TypeSpec ts)
				return ContainsGenericParameter(ts);

			if (type is TypeSig sig)
				return ContainsGenericParameter(sig);

			if (type is ExportedType et)
				return ContainsGenericParameter(et);

			return false;
		}

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(TypeDef type) => new TypeHelper().ContainsGenericParameterInternal(type);

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(TypeRef type) => new TypeHelper().ContainsGenericParameterInternal(type);

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(TypeSpec type) => new TypeHelper().ContainsGenericParameterInternal(type);

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(TypeSig type) => new TypeHelper().ContainsGenericParameterInternal(type);

		/// <summary>
		/// Checks whether <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns><c>true</c> if <paramref name="type"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.</returns>
		public static bool ContainsGenericParameter(ExportedType type) => new TypeHelper().ContainsGenericParameterInternal(type);

		bool ContainsGenericParameterInternal(TypeDef type) => false;

		bool ContainsGenericParameterInternal(TypeRef type) => false;

		bool ContainsGenericParameterInternal(TypeSpec type) {
			if (type is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameterInternal(type.TypeSig);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(ITypeDefOrRef tdr) {
			if (tdr is null)
				return false;
			// TypeDef and TypeRef contain no generic parameters
			return ContainsGenericParameterInternal(tdr as TypeSpec);
		}

		bool ContainsGenericParameterInternal(TypeSig type) {
			if (type is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res;
			switch (type.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.ValueType:
			case ElementType.Class:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
				res = ContainsGenericParameterInternal((type as TypeDefOrRefSig).TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
				res = true;
				break;

			case ElementType.FnPtr:
				res = ContainsGenericParameterInternal((type as FnPtrSig).Signature);
				break;

			case ElementType.GenericInst:
				var gi = (GenericInstSig)type;
				res = ContainsGenericParameterInternal(gi.GenericType) ||
					ContainsGenericParameter(gi.GenericArguments);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Array:
			case ElementType.SZArray:
			case ElementType.Pinned:
			case ElementType.ValueArray:
			case ElementType.Module:
				res = ContainsGenericParameterInternal((type as NonLeafSig).Next);
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
				res = ContainsGenericParameterInternal((type as ModifierSig).Modifier) ||
					ContainsGenericParameterInternal((type as NonLeafSig).Next);
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			case ElementType.Sentinel:
			default:
				res = false;
				break;
			}

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(ExportedType type) => false;

		bool ContainsGenericParameterInternal(CallingConventionSig callConv) {
			if (callConv is FieldSig fs)
				return ContainsGenericParameterInternal(fs);

			if (callConv is MethodBaseSig mbs)
				return ContainsGenericParameterInternal(mbs);

			if (callConv is LocalSig ls)
				return ContainsGenericParameterInternal(ls);

			if (callConv is GenericInstMethodSig gim)
				return ContainsGenericParameterInternal(gim);

			return false;
		}

		bool ContainsGenericParameterInternal(FieldSig fs) {
			if (fs is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameterInternal(fs.Type);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(MethodBaseSig mbs) {
			if (mbs is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameterInternal(mbs.RetType) ||
				ContainsGenericParameter(mbs.Params) ||
				ContainsGenericParameter(mbs.ParamsAfterSentinel);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(LocalSig ls) {
			if (ls is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameter(ls.Locals);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameterInternal(GenericInstMethodSig gim) {
			if (gim is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = ContainsGenericParameter(gim.GenericArguments);

			recursionCounter.Decrement();
			return res;
		}

		bool ContainsGenericParameter(IList<TypeSig> types) {
			if (types is null)
				return false;
			if (!recursionCounter.Increment())
				return false;

			bool res = false;
			int count = types.Count;
			for (int i = 0; i < count; i++) {
				var type = types[i];
				if (ContainsGenericParameter(type)) {
					res = true;
					break;
				}
			}
			recursionCounter.Decrement();
			return res;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Thrown by <see cref="TypeNameParser"/> when it fails to parse a type name
	/// </summary>
	[Serializable]
	public class TypeNameParserException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public TypeNameParserException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public TypeNameParserException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		/// <param name="innerException">Inner exception or <c>null</c> if none</param>
		public TypeNameParserException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected TypeNameParserException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Helps <see cref="TypeNameParser"/> create types
	/// </summary>
	public interface IAssemblyRefFinder {
		/// <summary>
		/// Finds a <see cref="TypeRef"/>'s <see cref="AssemblyRef"/> when the original assembly
		/// info is missing from the full type name.
		/// </summary>
		/// <param name="nonNestedTypeRef">A non-nested <see cref="TypeRef"/></param>
		/// <returns><paramref name="nonNestedTypeRef"/>'s <see cref="AssemblyRef"/> or <c>null</c></returns>
		AssemblyRef FindAssemblyRef(TypeRef nonNestedTypeRef);
	}

	/// <summary>
	/// Parses a type name and creates an <see cref="IType"/>
	/// </summary>
	public abstract class TypeNameParser : IDisposable {
		/// <summary>Owner module</summary>
		protected ModuleDef ownerModule;
		readonly GenericParamContext gpContext;
		StringReader reader;
		readonly IAssemblyRefFinder typeNameParserHelper;
		RecursionCounter recursionCounter;

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="ITypeDefOrRef"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <returns>A new <see cref="ITypeDefOrRef"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		public static ITypeDefOrRef ParseReflectionThrow(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper) =>
			ParseReflectionThrow(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext());

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="ITypeDefOrRef"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="ITypeDefOrRef"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		public static ITypeDefOrRef ParseReflectionThrow(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			using (var parser = new ReflectionTypeNameParser(ownerModule, typeFullName, typeNameParserHelper, gpContext))
				return parser.Parse();
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="ITypeDefOrRef"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <returns>A new <see cref="ITypeDefOrRef"/> instance or <c>null</c> if parsing failed</returns>
		public static ITypeDefOrRef ParseReflection(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper) =>
			ParseReflection(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext());

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="ITypeDefOrRef"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="ITypeDefOrRef"/> instance or <c>null</c> if parsing failed</returns>
		public static ITypeDefOrRef ParseReflection(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			try {
				return ParseReflectionThrow(ownerModule, typeFullName, typeNameParserHelper, gpContext);
			}
			catch (TypeNameParserException) {
				return null;
			}
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="TypeSig"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <returns>A new <see cref="TypeSig"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		public static TypeSig ParseAsTypeSigReflectionThrow(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper) =>
			ParseAsTypeSigReflectionThrow(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext());

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="TypeSig"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		public static TypeSig ParseAsTypeSigReflectionThrow(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			using (var parser = new ReflectionTypeNameParser(ownerModule, typeFullName, typeNameParserHelper, gpContext))
				return parser.ParseAsTypeSig();
		}

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="TypeSig"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if parsing failed</returns>
		public static TypeSig ParseAsTypeSigReflection(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper) =>
			ParseAsTypeSigReflection(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext());

		/// <summary>
		/// Parses a Reflection type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="TypeSig"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="TypeSig"/> instance or <c>null</c> if parsing failed</returns>
		public static TypeSig ParseAsTypeSigReflection(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			try {
				return ParseAsTypeSigReflectionThrow(ownerModule, typeFullName, typeNameParserHelper, gpContext);
			}
			catch (TypeNameParserException) {
				return null;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="IType"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		protected TypeNameParser(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper)
			: this(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="IType"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		protected TypeNameParser(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext) {
			this.ownerModule = ownerModule;
			reader = new StringReader(typeFullName ?? string.Empty);
			this.typeNameParserHelper = typeNameParserHelper;
			this.gpContext = gpContext;
		}

		/// <summary>
		/// Parses a type name and creates a <see cref="IType"/>
		/// </summary>
		/// <returns>A new <see cref="IType"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		internal ITypeDefOrRef Parse() => ownerModule.UpdateRowId(ParseAsTypeSig().ToTypeDefOrRef());

		/// <summary>
		/// Parses a type name and creates a <see cref="TypeSig"/>
		/// </summary>
		/// <returns>A new <see cref="TypeSig"/> instance</returns>
		/// <exception cref="TypeNameParserException">If parsing failed</exception>
		internal abstract TypeSig ParseAsTypeSig();

		/// <summary>
		/// Increment recursion counter
		/// </summary>
		/// <exception cref="TypeNameParserException">If this method has been called too many times</exception>
		protected void RecursionIncrement() {
			if (!recursionCounter.Increment())
				throw new TypeNameParserException("Stack overflow");
		}

		/// <summary>
		/// Decrement recursion counter
		/// </summary>
		protected void RecursionDecrement() => recursionCounter.Decrement();

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (!disposing)
				return;
			if (reader is not null)
				reader.Dispose();
			reader = null;
		}

		internal abstract class TSpec {
			public readonly ElementType etype;

			protected TSpec(ElementType etype) => this.etype = etype;
		}

		internal sealed class SZArraySpec : TSpec {
			public static readonly SZArraySpec Instance = new SZArraySpec();
			SZArraySpec()
				: base(ElementType.SZArray) {
			}
		}

		internal sealed class ArraySpec : TSpec {
			public uint rank;
			public readonly IList<uint> sizes = new List<uint>();
			public readonly IList<int> lowerBounds = new List<int>();

			public ArraySpec()
				: base(ElementType.Array) {
			}
		}

		internal sealed class GenericInstSpec : TSpec {
			public readonly List<TypeSig> args = new List<TypeSig>();

			public GenericInstSpec()
				: base(ElementType.GenericInst) {
			}
		}

		internal sealed class ByRefSpec : TSpec {
			public static readonly ByRefSpec Instance = new ByRefSpec();
			ByRefSpec()
				: base(ElementType.ByRef) {
			}
		}

		internal sealed class PtrSpec : TSpec {
			public static readonly PtrSpec Instance = new PtrSpec();
			PtrSpec()
				: base(ElementType.Ptr) {
			}
		}

		internal GenericSig ReadGenericSig() {
			Verify(ReadChar() == '!', "Expected '!'");
			if (PeekChar() == '!') {
				ReadChar();
				return new GenericMVar(ReadUInt32(), gpContext.Method);
			}
			return new GenericVar(ReadUInt32(), gpContext.Type);
		}

		internal TypeSig CreateTypeSig(IList<TSpec> tspecs, TypeSig currentSig) {
			int count = tspecs.Count;
			for (int i = 0; i < count; i++) {
				var tspec = tspecs[i];
				switch (tspec.etype) {
				case ElementType.SZArray:
					currentSig = new SZArraySig(currentSig);
					break;

				case ElementType.Array:
					var arraySpec = (ArraySpec)tspec;
					currentSig = new ArraySig(currentSig, arraySpec.rank, arraySpec.sizes, arraySpec.lowerBounds);
					break;

				case ElementType.GenericInst:
					var ginstSpec = (GenericInstSpec)tspec;
					currentSig = new GenericInstSig(currentSig as ClassOrValueTypeSig, ginstSpec.args);
					break;

				case ElementType.ByRef:
					currentSig = new ByRefSig(currentSig);
					break;

				case ElementType.Ptr:
					currentSig = new PtrSig(currentSig);
					break;

				default:
					Verify(false, "Unknown TSpec");
					break;
				}
			}
			return currentSig;
		}

		/// <summary>
		/// Reads a <see cref="TypeRef"/> including any possible nested <see cref="TypeRef"/>s.
		/// </summary>
		/// <param name="nestedChar">Character separating nested types</param>
		/// <returns>A new <see cref="TypeRef"/> instance, which could be nested.</returns>
		protected TypeRef ReadTypeRefAndNestedNoAssembly(char nestedChar) {
			var typeRef = ReadTypeRefNoAssembly();
			while (true) {
				SkipWhite();
				if (PeekChar() != nestedChar)
					break;
				ReadChar();
				var newTypeRef = ReadTypeRefNoAssembly();
				newTypeRef.ResolutionScope = typeRef;
				typeRef = newTypeRef;
			}
			return typeRef;
		}

		/// <summary>
		/// Reads a namespace and name and creates a TypeRef. Does not read any nested types.
		/// </summary>
		/// <returns>A new <see cref="TypeRef"/> instance</returns>
		protected TypeRef ReadTypeRefNoAssembly() {
			// White space is important here. Any white space before the comma/EOF must be
			// parsed as part of the name.
			GetNamespaceAndName(ReadId(false, false), out var ns, out var name);
			return ownerModule.UpdateRowId(new TypeRefUser(ownerModule, ns, name));
		}

		static void GetNamespaceAndName(string fullName, out string ns, out string name) {
			int index = fullName.LastIndexOf('.');
			if (index < 0) {
				ns = string.Empty;
				name = fullName;
			}
			else {
				ns = fullName.Substring(0, index);
				name = fullName.Substring(index + 1);
			}
		}

		internal TypeSig ToTypeSig(ITypeDefOrRef type) {
			if (type is TypeDef td)
				return ToTypeSig(td, td.IsValueType);
			if (type is TypeRef tr)
				return ToTypeSig(tr, IsValueType(tr));
			if (type is TypeSpec ts)
				return ts.TypeSig;
			Verify(false, "Unknown type");
			return null;
		}

		static TypeSig ToTypeSig(ITypeDefOrRef type, bool isValueType) => isValueType ? (TypeSig)new ValueTypeSig(type) : new ClassSig(type);

		internal AssemblyRef FindAssemblyRef(TypeRef nonNestedTypeRef) {
			AssemblyRef asmRef = null;
			if (nonNestedTypeRef is not null && typeNameParserHelper is not null)
				asmRef = typeNameParserHelper.FindAssemblyRef(nonNestedTypeRef);
			if (asmRef is not null)
				return asmRef;
			var ownerAsm = ownerModule.Assembly;
			if (ownerAsm is not null)
				return ownerModule.UpdateRowId(ownerAsm.ToAssemblyRef());
			return AssemblyRef.CurrentAssembly;
		}

		internal bool IsValueType(TypeRef typeRef) => typeRef is not null && typeRef.IsValueType;

		internal static void Verify(bool b, string msg) {
			if (!b)
				throw new TypeNameParserException(msg);
		}

		internal void SkipWhite() {
			while (true) {
				int next = PeekChar();
				if (next == -1)
					break;
				if (!char.IsWhiteSpace((char)next))
					break;
				ReadChar();
			}
		}

		internal uint ReadUInt32() {
			SkipWhite();
			bool readInt = false;
			uint val = 0;
			while (true) {
				int c = PeekChar();
				if (c == -1 || !(c >= '0' && c <= '9'))
					break;
				ReadChar();
				uint newVal = val * 10 + (uint)(c - '0');
				Verify(newVal >= val, "Integer overflow");
				val = newVal;
				readInt = true;
			}
			Verify(readInt, "Expected an integer");
			return val;
		}

		internal int ReadInt32() {
			SkipWhite();

			bool isSigned = false;
			if (PeekChar() == '-') {
				isSigned = true;
				ReadChar();
			}

			uint val = ReadUInt32();
			if (isSigned) {
				Verify(val <= (uint)int.MaxValue + 1, "Integer overflow");
				return -(int)val;
			}
			else {
				Verify(val <= (uint)int.MaxValue, "Integer overflow");
				return (int)val;
			}
		}

		internal string ReadId() => ReadId(true, true);

		internal string ReadId(bool ignoreWhiteSpace, bool ignoreEqualSign) {
			SkipWhite();
			var sb = new StringBuilder();
			int c;
			while ((c = GetIdChar(ignoreWhiteSpace, ignoreEqualSign)) != -1)
				sb.Append((char)c);
			Verify(sb.Length > 0, "Expected an id");
			return sb.ToString();
		}

		/// <summary>
		/// Peeks the next char. -1 if no more chars.
		/// </summary>
		protected int PeekChar() => reader.Peek();

		/// <summary>
		/// Gets the next char or -1 if no more chars
		/// </summary>
		protected int ReadChar() => reader.Read();

		/// <summary>
		/// Gets the next ID char or <c>-1</c> if no more ID chars
		/// </summary>
		/// <param name="ignoreWhiteSpace"><c>true</c> if white space should be ignored</param>
		/// <param name="ignoreEqualSign"><c>true</c> if equal sign '=' should be ignored</param>
		internal abstract int GetIdChar(bool ignoreWhiteSpace, bool ignoreEqualSign);
	}

	/// <summary>
	/// Parses reflection type names. Grammar http://msdn.microsoft.com/en-us/library/yfsftwz6.aspx
	/// </summary>
	sealed class ReflectionTypeNameParser : TypeNameParser {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="IType"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		public ReflectionTypeNameParser(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper)
			: base(ownerModule, typeFullName, typeNameParserHelper, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="ownerModule">Module that will own the returned <see cref="IType"/> or <c>null</c></param>
		/// <param name="typeFullName">Full name of type</param>
		/// <param name="typeNameParserHelper">Helper class</param>
		/// <param name="gpContext">Generic parameter context</param>
		public ReflectionTypeNameParser(ModuleDef ownerModule, string typeFullName, IAssemblyRefFinder typeNameParserHelper, GenericParamContext gpContext)
			: base(ownerModule, typeFullName, typeNameParserHelper, gpContext) {
		}

		/// <summary>
		/// Parses an assembly name
		/// </summary>
		/// <param name="asmFullName">Full assembly name</param>
		/// <returns>A new <see cref="AssemblyRef"/> instance or <c>null</c> if parsing failed</returns>
		public static AssemblyRef ParseAssemblyRef(string asmFullName) => ParseAssemblyRef(asmFullName, new GenericParamContext());

		/// <summary>
		/// Parses an assembly name
		/// </summary>
		/// <param name="asmFullName">Full assembly name</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>A new <see cref="AssemblyRef"/> instance or <c>null</c> if parsing failed</returns>
		public static AssemblyRef ParseAssemblyRef(string asmFullName, GenericParamContext gpContext) {
			try {
				using (var parser = new ReflectionTypeNameParser(null, asmFullName, null, gpContext))
					return parser.ReadAssemblyRef();
			}
			catch {
				return null;
			}
		}

		/// <inheritdoc/>
		internal override TypeSig ParseAsTypeSig() {
			try {
				var type = ReadType(true);
				SkipWhite();
				Verify(PeekChar() == -1, "Extra input after type name");
				return type;
			}
			catch (TypeNameParserException) {
				throw;
			}
			catch (Exception ex) {
				throw new TypeNameParserException("Could not parse type name", ex);
			}
		}

		TypeSig ReadType(bool readAssemblyReference) {
			RecursionIncrement();
			TypeSig result;

			SkipWhite();
			if (PeekChar() == '!') {
				var currentSig = ReadGenericSig();
				var tspecs = ReadTSpecs();
				ReadOptionalAssemblyRef();
				result = CreateTypeSig(tspecs, currentSig);
			}
			else {
				var typeRef = ReadTypeRefAndNestedNoAssembly('+');
				var tspecs = ReadTSpecs();
				var nonNestedTypeRef = TypeRef.GetNonNestedTypeRef(typeRef);
				AssemblyRef asmRef;
				if (readAssemblyReference)
					asmRef = ReadOptionalAssemblyRef() ?? FindAssemblyRef(nonNestedTypeRef);
				else
					asmRef = FindAssemblyRef(nonNestedTypeRef);
				nonNestedTypeRef.ResolutionScope = asmRef;

				// Make sure the CorLib types are used whenever possible
				result = null;
				if (typeRef == nonNestedTypeRef) {
					var corLibSig = ownerModule.CorLibTypes.GetCorLibTypeSig(typeRef.Namespace, typeRef.Name, typeRef.DefinitionAssembly);
					if (corLibSig is not null)
						result = corLibSig;
				}
				if (result is null) {
					var typeDef = Resolve(asmRef, typeRef);
					result = ToTypeSig(typeDef is not null ? (ITypeDefOrRef)typeDef : typeRef);
				}

				if (tspecs.Count != 0)
					result = CreateTypeSig(tspecs, result);
			}

			RecursionDecrement();
			return result;
		}

		TypeDef Resolve(AssemblyRef asmRef, TypeRef typeRef) {
			var asm = ownerModule.Assembly;
			if (asm is null)
				return null;
			if (!(AssemblyNameComparer.CompareAll.Equals(asmRef, asm) && asmRef.IsRetargetable == asm.IsRetargetable))
				return null;
			var td = asm.Find(typeRef);
			return td is not null && td.Module == ownerModule ? td : null;
		}

		AssemblyRef ReadOptionalAssemblyRef() {
			SkipWhite();
			if (PeekChar() == ',') {
				ReadChar();
				return ReadAssemblyRef();
			}
			return null;
		}

		IList<TSpec> ReadTSpecs() {
			var tspecs = new List<TSpec>();
			while (true) {
				SkipWhite();
				switch (PeekChar()) {
				case '[':	// SZArray, Array, or GenericInst
					ReadChar();
					SkipWhite();
					var peeked = PeekChar();
					if (peeked == ']') {
						// SZ array
						Verify(ReadChar() == ']', "Expected ']'");
						tspecs.Add(SZArraySpec.Instance);
					}
					else if (peeked == '*' || peeked == ',' || peeked == '-' || char.IsDigit((char)peeked)) {
						// Array

						var arraySpec = new ArraySpec();
						arraySpec.rank = 0;
						while (true) {
							SkipWhite();
							int c = PeekChar();
							if (c == '*')
								ReadChar();
							else if (c == ',' || c == ']') {
							}
							else if (c == '-' || char.IsDigit((char)c)) {
								int lower = ReadInt32();
								uint? size;
								SkipWhite();
								Verify(ReadChar() == '.', "Expected '.'");
								Verify(ReadChar() == '.', "Expected '.'");
								if (PeekChar() == '.') {
									ReadChar();
									size = null;
								}
								else {
									SkipWhite();
									if (PeekChar() == '-') {
										int upper = ReadInt32();
										Verify(upper >= lower, "upper < lower");
										size = (uint)(upper - lower + 1);
										Verify(size.Value != 0 && size.Value <= 0x1FFFFFFF, "Invalid size");
									}
									else {
										uint upper = ReadUInt32();
										long lsize = (long)upper - (long)lower + 1;
										Verify(lsize > 0 && lsize <= 0x1FFFFFFF, "Invalid size");
										size = (uint)lsize;
									}
								}
								if (arraySpec.lowerBounds.Count == arraySpec.rank)
									arraySpec.lowerBounds.Add(lower);
								if (size.HasValue && arraySpec.sizes.Count == arraySpec.rank)
									arraySpec.sizes.Add(size.Value);
							}
							else
								Verify(false, "Unknown char");

							arraySpec.rank++;
							SkipWhite();
							if (PeekChar() != ',')
								break;
							ReadChar();
						}

						Verify(ReadChar() == ']', "Expected ']'");
						tspecs.Add(arraySpec);
					}
					else {
						// Generic args

						var ginstSpec = new GenericInstSpec();
						while (true) {
							SkipWhite();
							peeked = PeekChar();
							bool needSeperators = peeked == '[';
							if (peeked == ']')
								break;
							Verify(!needSeperators || ReadChar() == '[', "Expected '['");
							ginstSpec.args.Add(ReadType(needSeperators));
							SkipWhite();
							Verify(!needSeperators || ReadChar() == ']', "Expected ']'");
							SkipWhite();
							if (PeekChar() != ',')
								break;
							ReadChar();
						}

						Verify(ReadChar() == ']', "Expected ']'");
						tspecs.Add(ginstSpec);
					}
					break;

				case '&':	// ByRef
					ReadChar();
					tspecs.Add(ByRefSpec.Instance);
					break;

				case '*':	// Ptr
					ReadChar();
					tspecs.Add(PtrSpec.Instance);
					break;

				default:
					return tspecs;
				}
			}
		}

		AssemblyRef ReadAssemblyRef() {
			var asmRef = new AssemblyRefUser();
			if (ownerModule is not null)
				ownerModule.UpdateRowId(asmRef);

			asmRef.Name = ReadAssemblyNameId();
			SkipWhite();
			if (PeekChar() != ',')
				return asmRef;
			ReadChar();

			while (true) {
				SkipWhite();
				int c = PeekChar();
				if (c == -1 || c == ']')
					break;
				if (c == ',') {
					ReadChar();
					continue;
				}

				string key = ReadId();
				SkipWhite();
				if (PeekChar() != '=')
					continue;
				ReadChar();
				string value = ReadId();

				switch (key.ToUpperInvariant()) {
				case "VERSION":
					asmRef.Version = Utils.ParseVersion(value);
					break;

				case "CONTENTTYPE":
					if (value.Equals("WindowsRuntime", StringComparison.OrdinalIgnoreCase))
						asmRef.ContentType = AssemblyAttributes.ContentType_WindowsRuntime;
					else
						asmRef.ContentType = AssemblyAttributes.ContentType_Default;
					break;

				case "RETARGETABLE":
					if (value.Equals("Yes", StringComparison.OrdinalIgnoreCase))
						asmRef.IsRetargetable = true;
					else
						asmRef.IsRetargetable = false;
					break;

				case "PUBLICKEY":
					if (value.Equals("null", StringComparison.OrdinalIgnoreCase) ||
						value.Equals("neutral", StringComparison.OrdinalIgnoreCase))
						asmRef.PublicKeyOrToken = new PublicKey();
					else
						asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKey(Utils.ParseBytes(value));
					break;

				case "PUBLICKEYTOKEN":
					if (value.Equals("null", StringComparison.OrdinalIgnoreCase) ||
						value.Equals("neutral", StringComparison.OrdinalIgnoreCase))
						asmRef.PublicKeyOrToken = new PublicKeyToken();
					else
						asmRef.PublicKeyOrToken = PublicKeyBase.CreatePublicKeyToken(Utils.ParseBytes(value));
					break;

				case "CULTURE":
				case "LANGUAGE":
					if (value.Equals("neutral", StringComparison.OrdinalIgnoreCase))
						asmRef.Culture = UTF8String.Empty;
					else
						asmRef.Culture = value;
					break;
				}
			}

			return asmRef;
		}

		string ReadAssemblyNameId() {
			SkipWhite();
			var sb = new StringBuilder();
			int c;
			while ((c = GetAsmNameChar()) != -1)
				sb.Append((char)c);
			var name = sb.ToString().Trim();
			Verify(name.Length > 0, "Expected an assembly name");
			return name;
		}

		int GetAsmNameChar() {
			int c = PeekChar();
			if (c == -1)
				return -1;
			switch (c) {
			case '\\':
				ReadChar();
				return ReadChar();

			case ']':
			case ',':
				return -1;

			default:
				return ReadChar();
			}
		}

		internal override int GetIdChar(bool ignoreWhiteSpace, bool ignoreEqualSign) {
			int c = PeekChar();
			if (c == -1)
				return -1;
			if (ignoreWhiteSpace && char.IsWhiteSpace((char)c))
				return -1;
			switch (c) {
			case '\\':
				ReadChar();
				return ReadChar();

			case ',':
			case '+':
			case '&':
			case '*':
			case '[':
			case ']':
			case '=' when ignoreEqualSign:
				return -1;

			default:
				return ReadChar();
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the TypeRef table
	/// </summary>
	public abstract class TypeRef : ITypeDefOrRef, IHasCustomAttribute, IMemberRefParent, IHasCustomDebugInformation, IResolutionScope {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

		/// <summary>
		/// The owner module
		/// </summary>
		protected ModuleDef module;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.TypeRef, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int TypeDefOrRefTag => 1;

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 2;

		/// <inheritdoc/>
		public int MemberRefParentTag => 1;

		/// <inheritdoc/>
		public int ResolutionScopeTag => 3;

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters => 0;

		/// <inheritdoc/>
		string IType.TypeName => FullNameFactory.Name(this, false, null);

		/// <inheritdoc/>
		public string ReflectionName => FullNameFactory.Name(this, true, null);

		/// <inheritdoc/>
		string IType.Namespace => FullNameFactory.Namespace(this, false, null);

		/// <inheritdoc/>
		public string ReflectionNamespace => FullNameFactory.Namespace(this, true, null);

		/// <inheritdoc/>
		public string FullName => FullNameFactory.FullName(this, false, null, null);

		/// <inheritdoc/>
		public string ReflectionFullName => FullNameFactory.FullName(this, true, null, null);

		/// <inheritdoc/>
		public string AssemblyQualifiedName => FullNameFactory.AssemblyQualifiedName(this, null, null);

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly => FullNameFactory.DefinitionAssembly(this);

		/// <inheritdoc/>
		public IScope Scope => FullNameFactory.Scope(this);

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType => this;

		/// <summary>
		/// Always returns <c>false</c> since a <see cref="TypeRef"/> does not contain any
		/// <see cref="GenericVar"/> or <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter => false;

		/// <inheritdoc/>
		public ModuleDef Module => module;

		/// <summary>
		/// From column TypeRef.ResolutionScope
		/// </summary>
		public IResolutionScope ResolutionScope {
			get {
				if (!resolutionScope_isInitialized)
					InitializeResolutionScope();
				return resolutionScope;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				resolutionScope = value;
				resolutionScope_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary/>
		protected IResolutionScope resolutionScope;
		/// <summary/>
		protected bool resolutionScope_isInitialized;

		void InitializeResolutionScope() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (resolutionScope_isInitialized)
				return;
			resolutionScope = GetResolutionScope_NoLock();
			resolutionScope_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="resolutionScope"/></summary>
		protected virtual IResolutionScope GetResolutionScope_NoLock() => null;

		/// <summary>
		/// From column TypeRef.Name
		/// </summary>
		public UTF8String Name {
			get => name;
			set => name = value;
		}
		/// <summary>Name</summary>
		protected UTF8String name;

		/// <summary>
		/// From column TypeRef.Namespace
		/// </summary>
		public UTF8String Namespace {
			get => @namespace;
			set => @namespace = value;
		}
		/// <summary>Name</summary>
		protected UTF8String @namespace;

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 2;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);

		/// <summary>
		/// <c>true</c> if it's nested within another <see cref="TypeRef"/>
		/// </summary>
		public bool IsNested => DeclaringType is not null;

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				var td = Resolve();
				return td is not null && td.IsValueType;
			}
		}

		/// <inheritdoc/>
		public bool IsPrimitive => this.IsPrimitive();

		/// <summary>
		/// Gets the declaring type, if any
		/// </summary>
		public TypeRef DeclaringType => ResolutionScope as TypeRef;

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType => DeclaringType;

		bool IIsTypeOrMethod.IsType => true;
		bool IIsTypeOrMethod.IsMethod => false;
		bool IMemberRef.IsField => false;
		bool IMemberRef.IsTypeSpec => false;
		bool IMemberRef.IsTypeRef => true;
		bool IMemberRef.IsTypeDef => false;
		bool IMemberRef.IsMethodSpec => false;
		bool IMemberRef.IsMethodDef => false;
		bool IMemberRef.IsMemberRef => false;
		bool IMemberRef.IsFieldDef => false;
		bool IMemberRef.IsPropertyDef => false;
		bool IMemberRef.IsEventDef => false;
		bool IMemberRef.IsGenericParam => false;

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public TypeDef Resolve() => Resolve(null);

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance or <c>null</c> if it couldn't be resolved</returns>
		public TypeDef Resolve(ModuleDef sourceModule) {
			if (module is null)
				return null;
			return module.Context.Resolver.Resolve(this, sourceModule ?? module);
		}

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public TypeDef ResolveThrow() => ResolveThrow(null);

		/// <summary>
		/// Resolves the type
		/// </summary>
		/// <param name="sourceModule">The module that needs to resolve the type or <c>null</c></param>
		/// <returns>A <see cref="TypeDef"/> instance</returns>
		/// <exception cref="TypeResolveException">If the type couldn't be resolved</exception>
		public TypeDef ResolveThrow(ModuleDef sourceModule) {
			var type = Resolve(sourceModule);
			if (type is not null)
				return type;
			throw new TypeResolveException($"Could not resolve type: {this} ({DefinitionAssembly})");
		}

		/// <summary>
		/// Gets the top-most (non-nested) <see cref="TypeRef"/>
		/// </summary>
		/// <param name="typeRef">Input</param>
		/// <returns>The non-nested <see cref="TypeRef"/> or <c>null</c></returns>
		internal static TypeRef GetNonNestedTypeRef(TypeRef typeRef) {
			if (typeRef is null)
				return null;
			for (int i = 0; i < 1000; i++) {
				var next = typeRef.ResolutionScope as TypeRef;
				if (next is null)
					return typeRef;
				typeRef = next;
			}
			return null;	// Here if eg. the TypeRef has an infinite loop
		}

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A TypeRef row created by the user and not present in the original .NET file
	/// </summary>
	public class TypeRefUser : TypeRef {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="name">Type name</param>
		public TypeRefUser(ModuleDef module, UTF8String name)
			: this(module, UTF8String.Empty, name) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="namespace">Type namespace</param>
		/// <param name="name">Type name</param>
		public TypeRefUser(ModuleDef module, UTF8String @namespace, UTF8String name)
			: this(module, @namespace, name, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="namespace">Type namespace</param>
		/// <param name="name">Type name</param>
		/// <param name="resolutionScope">Resolution scope (a <see cref="ModuleDef"/>,
		/// <see cref="ModuleRef"/>, <see cref="AssemblyRef"/> or <see cref="TypeRef"/>)</param>
		public TypeRefUser(ModuleDef module, UTF8String @namespace, UTF8String name, IResolutionScope resolutionScope) {
			this.module = module;
			this.resolutionScope = resolutionScope;
			resolutionScope_isInitialized = true;
			this.name = name;
			this.@namespace = @namespace;
		}
	}

	/// <summary>
	/// Created from a row in the TypeRef table
	/// </summary>
	sealed class TypeRefMD : TypeRef, IMDTokenProviderMD {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly uint resolutionScopeCodedToken;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override IResolutionScope GetResolutionScope_NoLock() => readerModule.ResolveResolutionScope(resolutionScopeCodedToken);

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.TypeRef, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), new GenericParamContext(), list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>TypeRef</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public TypeRefMD(ModuleDefMD readerModule, uint rid) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.TypeRefTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"TypeRef rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			module = readerModule;
			bool b = readerModule.TablesStream.TryReadTypeRefRow(origRid, out var row);
			Debug.Assert(b);
			name = readerModule.StringsStream.ReadNoNull(row.Name);
			@namespace = readerModule.StringsStream.ReadNoNull(row.Namespace);
			resolutionScopeCodedToken = row.ResolutionScope;
		}
	}
}





/*
All TypeSig classes:

TypeSig								base class
	LeafSig							base class for leaf types
		TypeDefOrRefSig				contains a ITypeDefOrRef instance
			CorLibTypeSig			simple corlib types (eg. System.Int32)
			ClassOrValueTypeSig		base class for Class/ValueType element types
				ValueTypeSig		ValueType
				ClassSig			Class
		GenericSig					base class for generic vars
			GenericVar				Generic type parameter
			GenericMVar				Generic method parameter
		SentinelSig					Sentinel
		FnPtrSig					Function pointer sig
		GenericInstSig				Generic instance type (contains a generic type + all generic args)
	NonLeafSig						base class for non-leaf types
		PtrSig						Pointer
		ByRefSig					By ref
		ArraySigBase				Array base class
			ArraySig				Array
			SZArraySig				Single dimension, zero lower limit array (i.e., THETYPE[])
		ModifierSig					C modifier base class
			CModReqdSig				C required modifier
			CModOptSig				C optional modifier
		PinnedSig					Pinned
		ValueArraySig				Value array (undocumented/not implemented by the CLR so don't use it)
		ModuleSig					Module (undocumented/not implemented by the CLR so don't use it)
*/

namespace dnlib.DotNet {
	/// <summary>
	/// Type sig base class
	/// </summary>
	public abstract class TypeSig : IType {
		uint rid;

		/// <summary>
		/// Returns the wrapped element type. Can only be <c>null</c> if it was an invalid sig or
		/// if it's a <see cref="LeafSig"/>
		/// </summary>
		public abstract TypeSig Next { get; }

		/// <summary>
		/// Gets the element type
		/// </summary>
		public abstract ElementType ElementType { get; }

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.TypeSpec, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		bool IIsTypeOrMethod.IsMethod => false;

		/// <inheritdoc/>
		bool IIsTypeOrMethod.IsType => true;

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get {
				var type = this.RemovePinnedAndModifiers() as GenericInstSig;
				return type is null ? 0 : type.GenericArguments.Count;
			}
		}

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				var t = this.RemovePinnedAndModifiers();
				if (t is null)
					return false;
				if (t.ElementType == ElementType.GenericInst) {
					var gis = (GenericInstSig)t;
					t = gis.GenericType;
					if (t is null)
						return false;
				}
				return t.ElementType.IsValueType();
			}
		}

		/// <inheritdoc/>
		public bool IsPrimitive => ElementType.IsPrimitive();

		/// <inheritdoc/>
		public string TypeName => FullNameFactory.Name(this, false, null);

		/// <inheritdoc/>
		UTF8String IFullName.Name {
			get => new UTF8String(FullNameFactory.Name(this, false, null));
			set => throw new NotSupportedException();
		}

		/// <inheritdoc/>
		public string ReflectionName => FullNameFactory.Name(this, true, null);

		/// <inheritdoc/>
		public string Namespace => FullNameFactory.Namespace(this, false, null);

		/// <inheritdoc/>
		public string ReflectionNamespace => FullNameFactory.Namespace(this, true, null);

		/// <inheritdoc/>
		public string FullName => FullNameFactory.FullName(this, false, null, null, null, null);

		/// <inheritdoc/>
		public string ReflectionFullName => FullNameFactory.FullName(this, true, null, null, null, null);

		/// <inheritdoc/>
		public string AssemblyQualifiedName => FullNameFactory.AssemblyQualifiedName(this, null, null);

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly => FullNameFactory.DefinitionAssembly(this);

		/// <inheritdoc/>
		public IScope Scope => FullNameFactory.Scope(this);

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType => FullNameFactory.ScopeType(this);

		/// <inheritdoc/>
		public ModuleDef Module => FullNameFactory.OwnerModule(this);

		/// <summary>
		/// <c>true</c> if it's a <see cref="TypeDefOrRefSig"/>
		/// </summary>
		public bool IsTypeDefOrRef => this is TypeDefOrRefSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="CorLibTypeSig"/>
		/// </summary>
		public bool IsCorLibType => this is CorLibTypeSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="ClassSig"/>
		/// </summary>
		public bool IsClassSig => this is ClassSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="ValueTypeSig"/>
		/// </summary>
		public bool IsValueTypeSig => this is ValueTypeSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericSig"/>
		/// </summary>
		public bool IsGenericParameter => this is GenericSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericVar"/>
		/// </summary>
		public bool IsGenericTypeParameter => this is GenericVar;

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericMVar"/>
		/// </summary>
		public bool IsGenericMethodParameter => this is GenericMVar;

		/// <summary>
		/// <c>true</c> if it's a <see cref="SentinelSig"/>
		/// </summary>
		public bool IsSentinel => this is SentinelSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="FnPtrSig"/>
		/// </summary>
		public bool IsFunctionPointer => this is FnPtrSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="GenericInstSig"/>
		/// </summary>
		public bool IsGenericInstanceType => this is GenericInstSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="PtrSig"/>
		/// </summary>
		public bool IsPointer => this is PtrSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="ByRefSig"/>
		/// </summary>
		public bool IsByRef => this is ByRefSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="ArraySig"/> or a <see cref="SZArraySig"/>
		/// </summary>
		public bool IsSingleOrMultiDimensionalArray => this is ArraySigBase;

		/// <summary>
		/// <c>true</c> if it's a <see cref="ArraySig"/>
		/// </summary>
		public bool IsArray => this is ArraySig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="SZArraySig"/>
		/// </summary>
		public bool IsSZArray => this is SZArraySig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="ModifierSig"/>
		/// </summary>
		public bool IsModifier => this is ModifierSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="CModReqdSig"/>
		/// </summary>
		public bool IsRequiredModifier => this is CModReqdSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="CModOptSig"/>
		/// </summary>
		public bool IsOptionalModifier => this is CModOptSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="PinnedSig"/>
		/// </summary>
		public bool IsPinned => this is PinnedSig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="ValueArraySig"/>
		/// </summary>
		public bool IsValueArray => this is ValueArraySig;

		/// <summary>
		/// <c>true</c> if it's a <see cref="ModuleSig"/>
		/// </summary>
		public bool IsModuleSig => this is ModuleSig;

		/// <summary>
		/// <c>true</c> if this <see cref="TypeSig"/> contains a <see cref="GenericVar"/> or a
		/// <see cref="GenericMVar"/>.
		/// </summary>
		public bool ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);

		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	public static partial class Extensions {
		/// <summary>
		/// Removes all C optional/required modifiers
		/// </summary>
		/// <param name="a">A <see cref="TypeSig"/> instance</param>
		/// <returns>Input after all modifiers</returns>
		public static TypeSig RemoveModifiers(this TypeSig a) {
			if (a is null)
				return null;
			while (true) {
				var modifier = a as ModifierSig;
				if (modifier is null)
					return a;
				a = a.Next;
			}
		}

		/// <summary>
		/// Removes pinned signature
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>Input after pinned signature</returns>
		public static TypeSig RemovePinned(this TypeSig a) {
			var pinned = a as PinnedSig;
			if (pinned is null)
				return a;
			return pinned.Next;
		}

		/// <summary>
		/// Removes all modifiers and pinned sig
		/// </summary>
		/// <param name="a">The type</param>
		/// <returns>Inputer after modifiers and pinned signature</returns>
		public static TypeSig RemovePinnedAndModifiers(this TypeSig a) {
			a = a.RemoveModifiers();
			a = a.RemovePinned();
			a = a.RemoveModifiers();
			return a;
		}

		/// <summary>
		/// Returns a <see cref="TypeDefOrRefSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="TypeDefOrRefSig"/> or <c>null</c> if it's not a
		/// <see cref="TypeDefOrRefSig"/></returns>
		public static TypeDefOrRefSig ToTypeDefOrRefSig(this TypeSig type) => type.RemovePinnedAndModifiers() as TypeDefOrRefSig;

		/// <summary>
		/// Returns a <see cref="ClassOrValueTypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ClassOrValueTypeSig"/> or <c>null</c> if it's not a
		/// <see cref="ClassOrValueTypeSig"/></returns>
		public static ClassOrValueTypeSig ToClassOrValueTypeSig(this TypeSig type) => type.RemovePinnedAndModifiers() as ClassOrValueTypeSig;

		/// <summary>
		/// Returns a <see cref="ValueTypeSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ValueTypeSig"/> or <c>null</c> if it's not a
		/// <see cref="ValueTypeSig"/></returns>
		public static ValueTypeSig ToValueTypeSig(this TypeSig type) => type.RemovePinnedAndModifiers() as ValueTypeSig;

		/// <summary>
		/// Returns a <see cref="ClassSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ClassSig"/> or <c>null</c> if it's not a
		/// <see cref="ClassSig"/></returns>
		public static ClassSig ToClassSig(this TypeSig type) => type.RemovePinnedAndModifiers() as ClassSig;

		/// <summary>
		/// Returns a <see cref="GenericSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericSig"/> or <c>null</c> if it's not a
		/// <see cref="GenericSig"/></returns>
		public static GenericSig ToGenericSig(this TypeSig type) => type.RemovePinnedAndModifiers() as GenericSig;

		/// <summary>
		/// Returns a <see cref="GenericVar"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericVar"/> or <c>null</c> if it's not a
		/// <see cref="GenericVar"/></returns>
		public static GenericVar ToGenericVar(this TypeSig type) => type.RemovePinnedAndModifiers() as GenericVar;

		/// <summary>
		/// Returns a <see cref="GenericMVar"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericMVar"/> or <c>null</c> if it's not a
		/// <see cref="GenericMVar"/></returns>
		public static GenericMVar ToGenericMVar(this TypeSig type) => type.RemovePinnedAndModifiers() as GenericMVar;

		/// <summary>
		/// Returns a <see cref="GenericInstSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="GenericInstSig"/> or <c>null</c> if it's not a
		/// <see cref="GenericInstSig"/></returns>
		public static GenericInstSig ToGenericInstSig(this TypeSig type) => type.RemovePinnedAndModifiers() as GenericInstSig;

		/// <summary>
		/// Returns a <see cref="PtrSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="PtrSig"/> or <c>null</c> if it's not a
		/// <see cref="PtrSig"/></returns>
		public static PtrSig ToPtrSig(this TypeSig type) => type.RemovePinnedAndModifiers() as PtrSig;

		/// <summary>
		/// Returns a <see cref="ByRefSig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ByRefSig"/> or <c>null</c> if it's not a
		/// <see cref="ByRefSig"/></returns>
		public static ByRefSig ToByRefSig(this TypeSig type) => type.RemovePinnedAndModifiers() as ByRefSig;

		/// <summary>
		/// Returns a <see cref="ArraySig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="ArraySig"/> or <c>null</c> if it's not a
		/// <see cref="ArraySig"/></returns>
		public static ArraySig ToArraySig(this TypeSig type) => type.RemovePinnedAndModifiers() as ArraySig;

		/// <summary>
		/// Returns a <see cref="SZArraySig"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="SZArraySig"/> or <c>null</c> if it's not a
		/// <see cref="SZArraySig"/></returns>
		public static SZArraySig ToSZArraySig(this TypeSig type) => type.RemovePinnedAndModifiers() as SZArraySig;

		/// <summary>
		/// Gets the next field or <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static TypeSig GetNext(this TypeSig self) => self?.Next;

		/// <summary>
		/// Gets the <see cref="TypeSig.IsValueType"/> value or <c>false</c> if
		/// <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static bool GetIsValueType(this TypeSig self) => self is null ? false : self.IsValueType;

		/// <summary>
		/// Gets the <see cref="TypeSig.IsPrimitive"/> value or <c>false</c> if
		/// <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static bool GetIsPrimitive(this TypeSig self) => self is null ? false : self.IsPrimitive;

		/// <summary>
		/// Gets the element type
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>The element type</returns>
		public static ElementType GetElementType(this TypeSig a) => a is null ? ElementType.End : a.ElementType;

		/// <summary>
		/// Gets the full name of the type
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>Full name of the type</returns>
		public static string GetFullName(this TypeSig a) => a is null ? string.Empty : a.FullName;

		/// <summary>
		/// Gets the name of the type
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>Name of the type</returns>
		public static string GetName(this TypeSig a) => a is null ? string.Empty : a.TypeName;

		/// <summary>
		/// Gets the namespace of the type
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>Namespace of the type</returns>
		public static string GetNamespace(this TypeSig a) => a is null ? string.Empty : a.Namespace;

		/// <summary>
		/// Returns the <see cref="ITypeDefOrRef"/> if it is a <see cref="TypeDefOrRefSig"/>.
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>A <see cref="ITypeDefOrRef"/> or <c>null</c> if none found</returns>
		public static ITypeDefOrRef TryGetTypeDefOrRef(this TypeSig a) => (a.RemovePinnedAndModifiers() as TypeDefOrRefSig)?.TypeDefOrRef;

		/// <summary>
		/// Returns the <see cref="TypeRef"/> if it is a <see cref="TypeDefOrRefSig"/>.
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>A <see cref="TypeRef"/> or <c>null</c> if none found</returns>
		public static TypeRef TryGetTypeRef(this TypeSig a) => (a.RemovePinnedAndModifiers() as TypeDefOrRefSig)?.TypeRef;

		/// <summary>
		/// Returns the <see cref="TypeDef"/> if it is a <see cref="TypeDefOrRefSig"/>.
		/// Nothing is resolved.
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if none found</returns>
		public static TypeDef TryGetTypeDef(this TypeSig a) => (a.RemovePinnedAndModifiers() as TypeDefOrRefSig)?.TypeDef;

		/// <summary>
		/// Returns the <see cref="TypeSpec"/> if it is a <see cref="TypeDefOrRefSig"/>.
		/// </summary>
		/// <param name="a">this</param>
		/// <returns>A <see cref="TypeSpec"/> or <c>null</c> if none found</returns>
		public static TypeSpec TryGetTypeSpec(this TypeSig a) => (a.RemovePinnedAndModifiers() as TypeDefOrRefSig)?.TypeSpec;
	}

	/// <summary>
	/// Base class for element types that are last in a type sig, ie.,
	/// <see cref="TypeDefOrRefSig"/>, <see cref="GenericSig"/>, <see cref="SentinelSig"/>,
	/// <see cref="FnPtrSig"/>, <see cref="GenericInstSig"/>
	/// </summary>
	public abstract class LeafSig : TypeSig {
		/// <inheritdoc/>
		public sealed override TypeSig Next => null;
	}

	/// <summary>
	/// Wraps a <see cref="ITypeDefOrRef"/>
	/// </summary>
	public abstract class TypeDefOrRefSig : LeafSig {
		readonly ITypeDefOrRef typeDefOrRef;

		/// <summary>
		/// Gets the the <c>TypeDefOrRef</c>
		/// </summary>
		public ITypeDefOrRef TypeDefOrRef => typeDefOrRef;

		/// <summary>
		/// Returns <c>true</c> if <see cref="TypeRef"/> != <c>null</c>
		/// </summary>
		public bool IsTypeRef => TypeRef is not null;

		/// <summary>
		/// Returns <c>true</c> if <see cref="TypeDef"/> != <c>null</c>
		/// </summary>
		public bool IsTypeDef => TypeDef is not null;

		/// <summary>
		/// Returns <c>true</c> if <see cref="TypeSpec"/> != <c>null</c>
		/// </summary>
		public bool IsTypeSpec => TypeSpec is not null;

		/// <summary>
		/// Gets the <see cref="TypeRef"/> or <c>null</c> if it's not a <see cref="TypeRef"/>
		/// </summary>
		public TypeRef TypeRef => typeDefOrRef as TypeRef;

		/// <summary>
		/// Gets the <see cref="TypeDef"/> or <c>null</c> if it's not a <see cref="TypeDef"/>
		/// </summary>
		public TypeDef TypeDef => typeDefOrRef as TypeDef;

		/// <summary>
		/// Gets the <see cref="TypeSpec"/> or <c>null</c> if it's not a <see cref="TypeSpec"/>
		/// </summary>
		public TypeSpec TypeSpec => typeDefOrRef as TypeSpec;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeDefOrRef">A <see cref="TypeRef"/>, <see cref="TypeDef"/> or
		/// a <see cref="TypeSpec"/></param>
		protected TypeDefOrRefSig(ITypeDefOrRef typeDefOrRef) => this.typeDefOrRef = typeDefOrRef;
	}

	/// <summary>
	/// A core library type
	/// </summary>
	public sealed class CorLibTypeSig : TypeDefOrRefSig {
		readonly ElementType elementType;

		/// <summary>
		/// Gets the element type
		/// </summary>
		public override ElementType ElementType => elementType;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="corType">The type which must be a <see cref="TypeRef"/> or a
		/// <see cref="TypeDef"/>. <see cref="TypeSpec"/> and <c>null</c> are not allowed.</param>
		/// <param name="elementType">The type's element type</param>
		public CorLibTypeSig(ITypeDefOrRef corType, ElementType elementType)
			: base(corType) {
			if (!(corType is TypeRef) && !(corType is TypeDef))
				throw new ArgumentException("corType must be a TypeDef or a TypeRef. null and TypeSpec are invalid inputs.");
			this.elementType = elementType;
		}
	}

	/// <summary>
	/// Base class for class/valuetype element types
	/// </summary>
	public abstract class ClassOrValueTypeSig : TypeDefOrRefSig {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeDefOrRef">A <see cref="ITypeDefOrRef"/></param>
		protected ClassOrValueTypeSig(ITypeDefOrRef typeDefOrRef)
			: base(typeDefOrRef) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.ValueType"/>
	/// </summary>
	public sealed class ValueTypeSig : ClassOrValueTypeSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.ValueType;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeDefOrRef">A <see cref="ITypeDefOrRef"/></param>
		public ValueTypeSig(ITypeDefOrRef typeDefOrRef)
			: base(typeDefOrRef) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Class"/>
	/// </summary>
	public sealed class ClassSig : ClassOrValueTypeSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.Class;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeDefOrRef">A <see cref="ITypeDefOrRef"/></param>
		public ClassSig(ITypeDefOrRef typeDefOrRef)
			: base(typeDefOrRef) {
		}
	}

	/// <summary>
	/// Generic method/type var base class
	/// </summary>
	public abstract class GenericSig : LeafSig {
		readonly bool isTypeVar;
		readonly uint number;
		readonly ITypeOrMethodDef genericParamProvider;

		/// <summary>
		/// <c>true</c> if it has an owner <see cref="TypeDef"/> or <see cref="MethodDef"/>
		/// </summary>
		public bool HasOwner => genericParamProvider is not null;

		/// <summary>
		/// <c>true</c> if it has an owner <see cref="TypeDef"/> (<see cref="OwnerType"/> is
		/// not <c>null</c>)
		/// </summary>
		public bool HasOwnerType => OwnerType is not null;

		/// <summary>
		/// <c>true</c> if it has an owner <see cref="MethodDef"/> (<see cref="OwnerMethod"/> is
		/// not <c>null</c>)
		/// </summary>
		public bool HasOwnerMethod => OwnerMethod is not null;

		/// <summary>
		/// Gets the owner type or <c>null</c> if the owner is a <see cref="MethodDef"/> or if it
		/// has no owner.
		/// </summary>
		public TypeDef OwnerType => genericParamProvider as TypeDef;

		/// <summary>
		/// Gets the owner method or <c>null</c> if the owner is a <see cref="TypeDef"/> or if it
		/// has no owner.
		/// </summary>
		public MethodDef OwnerMethod => genericParamProvider as MethodDef;

		/// <summary>
		/// Gets the generic param number
		/// </summary>
		public uint Number => number;

		/// <summary>
		/// Gets the corresponding <see cref="dnlib.DotNet.GenericParam"/> or <c>null</c> if none exists.
		/// </summary>
		public GenericParam GenericParam {
			get {
				var gpp = genericParamProvider;
				if (gpp is null)
					return null;
				var gps = gpp.GenericParameters;
				int count = gps.Count;
				for (int i = 0; i < count; i++) {
					var gp = gps[i];
					if (gp.Number == number)
						return gp;
				}
				return null;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isTypeVar"><c>true</c> if it's a <c>Var</c>, <c>false</c> if it's a <c>MVar</c></param>
		/// <param name="number">Generic param number</param>
		protected GenericSig(bool isTypeVar, uint number)
			: this(isTypeVar, number, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="isTypeVar"><c>true</c> if it's a <c>Var</c>, <c>false</c> if it's a <c>MVar</c></param>
		/// <param name="number">Generic param number</param>
		/// <param name="genericParamProvider">Owner method/type or <c>null</c></param>
		protected GenericSig(bool isTypeVar, uint number, ITypeOrMethodDef genericParamProvider) {
			this.isTypeVar = isTypeVar;
			this.number = number;
			this.genericParamProvider = genericParamProvider;
		}

		/// <summary>
		/// Returns <c>true</c> if it's a <c>MVar</c> element type
		/// </summary>
		public bool IsMethodVar => !isTypeVar;

		/// <summary>
		/// Returns <c>true</c> if it's a <c>Var</c> element type
		/// </summary>
		public bool IsTypeVar => isTypeVar;
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Var"/>
	/// </summary>
	public sealed class GenericVar : GenericSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.Var;

		/// <inheritdoc/>
		public GenericVar(uint number)
			: base(true, number) {
		}

		/// <inheritdoc/>
		public GenericVar(int number)
			: base(true, (uint)number) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">Generic parameter number</param>
		/// <param name="genericParamProvider">Owner type or <c>null</c></param>
		public GenericVar(uint number, TypeDef genericParamProvider)
			: base(true, number, genericParamProvider) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">Generic parameter number</param>
		/// <param name="genericParamProvider">Owner type or <c>null</c></param>
		public GenericVar(int number, TypeDef genericParamProvider)
			: base(true, (uint)number, genericParamProvider) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.MVar"/>
	/// </summary>
	public sealed class GenericMVar : GenericSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.MVar;

		/// <inheritdoc/>
		public GenericMVar(uint number)
			: base(false, number) {
		}

		/// <inheritdoc/>
		public GenericMVar(int number)
			: base(false, (uint)number) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">Generic parameter number</param>
		/// <param name="genericParamProvider">Owner method or <c>null</c></param>
		public GenericMVar(uint number, MethodDef genericParamProvider)
			: base(false, number, genericParamProvider) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="number">Generic parameter number</param>
		/// <param name="genericParamProvider">Owner method or <c>null</c></param>
		public GenericMVar(int number, MethodDef genericParamProvider)
			: base(false, (uint)number, genericParamProvider) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Sentinel"/>
	/// </summary>
	public sealed class SentinelSig : LeafSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.Sentinel;
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.FnPtr"/>
	/// </summary>
	public sealed class FnPtrSig : LeafSig {
		readonly CallingConventionSig signature;

		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.FnPtr;

		/// <summary>
		/// Gets the signature
		/// </summary>
		public CallingConventionSig Signature => signature;

		/// <summary>
		/// Gets the <see cref="MethodSig"/>
		/// </summary>
		public MethodSig MethodSig => signature as MethodSig;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="signature">The method signature</param>
		public FnPtrSig(CallingConventionSig signature) => this.signature = signature;
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.GenericInst"/>
	/// </summary>
	public sealed class GenericInstSig : LeafSig {
		ClassOrValueTypeSig genericType;
		readonly IList<TypeSig> genericArgs;

		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.GenericInst;

		/// <summary>
		/// Gets the generic type
		/// </summary>
		public ClassOrValueTypeSig GenericType {
			get => genericType;
			set => genericType = value;
		}

		/// <summary>
		/// Gets the generic arguments (it's never <c>null</c>)
		/// </summary>
		public IList<TypeSig> GenericArguments => genericArgs;

		/// <summary>
		/// Default constructor
		/// </summary>
		public GenericInstSig() => genericArgs = new List<TypeSig>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		public GenericInstSig(ClassOrValueTypeSig genericType) {
			this.genericType = genericType;
			genericArgs = new List<TypeSig>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArgCount">Number of generic arguments</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, uint genArgCount) {
			this.genericType = genericType;
			genericArgs = new List<TypeSig>((int)genArgCount);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArgCount">Number of generic arguments</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, int genArgCount)
			: this(genericType, (uint)genArgCount) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArg1">Generic argument #1</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, TypeSig genArg1) {
			this.genericType = genericType;
			genericArgs = new List<TypeSig> { genArg1 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArg1">Generic argument #1</param>
		/// <param name="genArg2">Generic argument #2</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, TypeSig genArg1, TypeSig genArg2) {
			this.genericType = genericType;
			genericArgs = new List<TypeSig> { genArg1, genArg2 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArg1">Generic argument #1</param>
		/// <param name="genArg2">Generic argument #2</param>
		/// <param name="genArg3">Generic argument #3</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, TypeSig genArg1, TypeSig genArg2, TypeSig genArg3) {
			this.genericType = genericType;
			genericArgs = new List<TypeSig> { genArg1, genArg2, genArg3 };
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArgs">Generic arguments</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, params TypeSig[] genArgs) {
			this.genericType = genericType;
			genericArgs = new List<TypeSig>(genArgs);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="genericType">The generic type</param>
		/// <param name="genArgs">Generic arguments</param>
		public GenericInstSig(ClassOrValueTypeSig genericType, IList<TypeSig> genArgs) {
			this.genericType = genericType;
			genericArgs = new List<TypeSig>(genArgs);
		}
	}

	/// <summary>
	/// Base class of non-leaf element types
	/// </summary>
	public abstract class NonLeafSig : TypeSig {
		readonly TypeSig nextSig;

		/// <inheritdoc/>
		public sealed override TypeSig Next => nextSig;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">Next sig</param>
		protected NonLeafSig(TypeSig nextSig) => this.nextSig = nextSig;
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Ptr"/>
	/// </summary>
	public sealed class PtrSig : NonLeafSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.Ptr;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		public PtrSig(TypeSig nextSig)
			: base(nextSig) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.ByRef"/>
	/// </summary>
	public sealed class ByRefSig : NonLeafSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.ByRef;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		public ByRefSig(TypeSig nextSig)
			: base(nextSig) {
		}
	}

	/// <summary>
	/// Array base class
	/// </summary>
	public abstract class ArraySigBase : NonLeafSig {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		protected ArraySigBase(TypeSig arrayType)
			: base(arrayType) {
		}

		/// <summary>
		/// <c>true</c> if it's a multi-dimensional array (i.e., <see cref="ArraySig"/>),
		/// and <c>false</c> if it's a single-dimensional array (i.e., <see cref="SZArraySig"/>)
		/// </summary>
		/// <seealso cref="IsSingleDimensional"/>
		public bool IsMultiDimensional => ElementType == ElementType.Array;

		/// <summary>
		/// <c>true</c> if it's a single-dimensional array (i.e., <see cref="SZArraySig"/>),
		/// and <c>false</c> if it's a multi-dimensional array (i.e., <see cref="ArraySig"/>)
		/// </summary>
		/// <see cref="IsMultiDimensional"/>
		public bool IsSingleDimensional => ElementType == ElementType.SZArray;

		/// <summary>
		/// Gets/sets the rank (number of dimensions). This can only be set if
		/// <see cref="IsMultiDimensional"/> is <c>true</c>
		/// </summary>
		public abstract uint Rank { get; set; }

		/// <summary>
		/// Gets all sizes. If it's a <see cref="SZArraySig"/>, then it will be an empty temporary
		/// list that is re-created every time this method is called.
		/// </summary>
		/// <returns>A list of sizes</returns>
		public abstract IList<uint> GetSizes();

		/// <summary>
		/// Gets all lower bounds. If it's a <see cref="SZArraySig"/>, then it will be an empty
		/// temporary list that is re-created every time this method is called.
		/// </summary>
		/// <returns>A list of lower bounds</returns>
		public abstract IList<int> GetLowerBounds();
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Array"/>
	/// </summary>
	/// <seealso cref="SZArraySig"/>
	public sealed class ArraySig : ArraySigBase {
		uint rank;
		readonly IList<uint> sizes;
		readonly IList<int> lowerBounds;

		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.Array;

		/// <summary>
		/// Gets/sets the rank (max value is <c>0x1FFFFFFF</c>)
		/// </summary>
		public override uint Rank {
			get => rank;
			set => rank = value;
		}

		/// <summary>
		/// Gets all sizes (max elements is <c>0x1FFFFFFF</c>)
		/// </summary>
		public IList<uint> Sizes => sizes;

		/// <summary>
		/// Gets all lower bounds (max elements is <c>0x1FFFFFFF</c>)
		/// </summary>
		public IList<int> LowerBounds => lowerBounds;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		public ArraySig(TypeSig arrayType)
			: base(arrayType) {
			sizes = new List<uint>();
			lowerBounds = new List<int>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		public ArraySig(TypeSig arrayType, uint rank)
			: base(arrayType) {
			this.rank = rank;
			sizes = new List<uint>();
			lowerBounds = new List<int>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		public ArraySig(TypeSig arrayType, int rank)
			: this(arrayType, (uint)rank) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		/// <param name="sizes">Sizes list. <c>This instance will be the owner of this list.</c></param>
		/// <param name="lowerBounds">Lower bounds list. <c>This instance will be the owner of this list.</c></param>
		public ArraySig(TypeSig arrayType, uint rank, IEnumerable<uint> sizes, IEnumerable<int> lowerBounds)
			: base(arrayType) {
			this.rank = rank;
			this.sizes = new List<uint>(sizes);
			this.lowerBounds = new List<int>(lowerBounds);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		/// <param name="sizes">Sizes list. <c>This instance will be the owner of this list.</c></param>
		/// <param name="lowerBounds">Lower bounds list. <c>This instance will be the owner of this list.</c></param>
		public ArraySig(TypeSig arrayType, int rank, IEnumerable<uint> sizes, IEnumerable<int> lowerBounds)
			: this(arrayType, (uint)rank, sizes, lowerBounds) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="arrayType">Array type</param>
		/// <param name="rank">Array rank</param>
		/// <param name="sizes">Sizes list. <c>This instance will be the owner of this list.</c></param>
		/// <param name="lowerBounds">Lower bounds list. <c>This instance will be the owner of this list.</c></param>
		internal ArraySig(TypeSig arrayType, uint rank, IList<uint> sizes, IList<int> lowerBounds)
			: base(arrayType) {
			this.rank = rank;
			this.sizes = sizes;
			this.lowerBounds = lowerBounds;
		}

		/// <inheritdoc/>
		public override IList<uint> GetSizes() => sizes;

		/// <inheritdoc/>
		public override IList<int> GetLowerBounds() => lowerBounds;
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.SZArray"/> (single dimension, zero lower bound array)
	/// </summary>
	/// <seealso cref="ArraySig"/>
	public sealed class SZArraySig : ArraySigBase {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.SZArray;

		/// <inheritdoc/>
		public override uint Rank {
			get => 1;
			set => throw new NotSupportedException();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		public SZArraySig(TypeSig nextSig)
			: base(nextSig) {
		}

		/// <inheritdoc/>
		public override IList<uint> GetSizes() => Array2.Empty<uint>();

		/// <inheritdoc/>
		public override IList<int> GetLowerBounds() => Array2.Empty<int>();
	}

	/// <summary>
	/// Base class for modifier type sigs
	/// </summary>
	public abstract class ModifierSig : NonLeafSig {
		readonly ITypeDefOrRef modifier;

		/// <summary>
		/// Returns the modifier type
		/// </summary>
		public ITypeDefOrRef Modifier => modifier;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="modifier">Modifier type</param>
		/// <param name="nextSig">The next element type</param>
		protected ModifierSig(ITypeDefOrRef modifier, TypeSig nextSig)
			: base(nextSig) => this.modifier = modifier;
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.CModReqd"/>
	/// </summary>
	public sealed class CModReqdSig : ModifierSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.CModReqd;

		/// <inheritdoc/>
		public CModReqdSig(ITypeDefOrRef modifier, TypeSig nextSig)
			: base(modifier, nextSig) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.CModOpt"/>
	/// </summary>
	public sealed class CModOptSig : ModifierSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.CModOpt;

		/// <inheritdoc/>
		public CModOptSig(ITypeDefOrRef modifier, TypeSig nextSig)
			: base(modifier, nextSig) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Pinned"/>
	/// </summary>
	public sealed class PinnedSig : NonLeafSig {
		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.Pinned;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		public PinnedSig(TypeSig nextSig)
			: base(nextSig) {
		}
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.ValueArray"/>
	/// </summary>
	public sealed class ValueArraySig : NonLeafSig {
		uint size;

		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.ValueArray;

		/// <summary>
		/// Gets/sets the size
		/// </summary>
		public uint Size {
			get => size;
			set => size = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="nextSig">The next element type</param>
		/// <param name="size">Size of the array</param>
		public ValueArraySig(TypeSig nextSig, uint size)
			: base(nextSig) => this.size = size;
	}

	/// <summary>
	/// Represents a <see cref="dnlib.DotNet.ElementType.Module"/>
	/// </summary>
	public sealed class ModuleSig : NonLeafSig {
		uint index;

		/// <inheritdoc/>
		public override ElementType ElementType => ElementType.Module;

		/// <summary>
		/// Gets/sets the index
		/// </summary>
		public uint Index {
			get => index;
			set => index = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="index">Index</param>
		/// <param name="nextSig">The next element type</param>
		public ModuleSig(uint index, TypeSig nextSig)
			: base(nextSig) => this.index = index;
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// A high-level representation of a row in the TypeSpec table
	/// </summary>
	public abstract class TypeSpec : ITypeDefOrRef, IHasCustomAttribute, IMemberRefParent, IHasCustomDebugInformation {
		/// <summary>
		/// The row id in its table
		/// </summary>
		protected uint rid;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public MDToken MDToken => new MDToken(Table.TypeSpec, rid);

		/// <inheritdoc/>
		public uint Rid {
			get => rid;
			set => rid = value;
		}

		/// <inheritdoc/>
		public int TypeDefOrRefTag => 2;

		/// <inheritdoc/>
		public int HasCustomAttributeTag => 13;

		/// <inheritdoc/>
		public int MemberRefParentTag => 4;

		/// <inheritdoc/>
		int IGenericParameterProvider.NumberOfGenericParameters {
			get {
				var ts = TypeSig;
				return ts is null ? 0 : ((IGenericParameterProvider)ts).NumberOfGenericParameters;
			}
		}

		/// <inheritdoc/>
		UTF8String IFullName.Name {
			get {
				var mr = ScopeType;
				return mr is null ? UTF8String.Empty : mr.Name;
			}
			set {
				var mr = ScopeType;
				if (mr is not null)
					mr.Name = value;
			}
		}

		/// <inheritdoc/>
		ITypeDefOrRef IMemberRef.DeclaringType {
			get {
				var sig = TypeSig.RemovePinnedAndModifiers();

				if (sig is GenericInstSig gis)
					sig = gis.GenericType;

				if (sig is TypeDefOrRefSig tdr) {
					if (tdr.IsTypeDef || tdr.IsTypeRef)
						return tdr.TypeDefOrRef.DeclaringType;
					return null;	// If it's another TypeSpec, just stop. Don't want possible inf recursion.
				}

				return null;
			}
		}

		bool IIsTypeOrMethod.IsType => true;
		bool IIsTypeOrMethod.IsMethod => false;
		bool IMemberRef.IsField => false;
		bool IMemberRef.IsTypeSpec => true;
		bool IMemberRef.IsTypeRef => false;
		bool IMemberRef.IsTypeDef => false;
		bool IMemberRef.IsMethodSpec => false;
		bool IMemberRef.IsMethodDef => false;
		bool IMemberRef.IsMemberRef => false;
		bool IMemberRef.IsFieldDef => false;
		bool IMemberRef.IsPropertyDef => false;
		bool IMemberRef.IsEventDef => false;
		bool IMemberRef.IsGenericParam => false;

		/// <inheritdoc/>
		public bool IsValueType {
			get {
				var sig = TypeSig;
				return sig is not null && sig.IsValueType;
			}
		}

		/// <inheritdoc/>
		public bool IsPrimitive {
			get {
				var sig = TypeSig;
				return sig is not null && sig.IsPrimitive;
			}
		}

		/// <inheritdoc/>
		public string TypeName => FullNameFactory.Name(this, false, null);

		/// <inheritdoc/>
		public string ReflectionName => FullNameFactory.Name(this, true, null);

		/// <inheritdoc/>
		string IType.Namespace => FullNameFactory.Namespace(this, false, null);

		/// <inheritdoc/>
		public string ReflectionNamespace => FullNameFactory.Namespace(this, true, null);

		/// <inheritdoc/>
		public string FullName => FullNameFactory.FullName(this, false, null, null);

		/// <inheritdoc/>
		public string ReflectionFullName => FullNameFactory.FullName(this, true, null, null);

		/// <inheritdoc/>
		public string AssemblyQualifiedName => FullNameFactory.AssemblyQualifiedName(this, null, null);

		/// <inheritdoc/>
		public IAssembly DefinitionAssembly => FullNameFactory.DefinitionAssembly(this);

		/// <inheritdoc/>
		public IScope Scope => FullNameFactory.Scope(this);

		/// <inheritdoc/>
		public ITypeDefOrRef ScopeType => FullNameFactory.ScopeType(this);

		/// <inheritdoc/>
		public bool ContainsGenericParameter => TypeHelper.ContainsGenericParameter(this);

		/// <inheritdoc/>
		public ModuleDef Module => FullNameFactory.OwnerModule(this);

		/// <summary>
		/// From column TypeSpec.Signature
		/// </summary>
		public TypeSig TypeSig {
			get {
				if (!typeSigAndExtraData_isInitialized)
					InitializeTypeSigAndExtraData();
				return typeSig;
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				typeSig = value;
				if (!typeSigAndExtraData_isInitialized)
					GetTypeSigAndExtraData_NoLock(out extraData);
				typeSigAndExtraData_isInitialized = true;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}
		/// <summary>
		/// Gets/sets the extra data that was found after the signature
		/// </summary>
		public byte[] ExtraData {
			get {
				if (!typeSigAndExtraData_isInitialized)
					InitializeTypeSigAndExtraData();
				return extraData;
			}
			set {
				if (!typeSigAndExtraData_isInitialized)
					InitializeTypeSigAndExtraData();
				extraData = value;
			}
		}
		/// <summary/>
		protected TypeSig typeSig;
		/// <summary/>
		protected byte[] extraData;
		/// <summary/>
		protected bool typeSigAndExtraData_isInitialized;

		void InitializeTypeSigAndExtraData() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (typeSigAndExtraData_isInitialized)
				return;
			typeSig = GetTypeSigAndExtraData_NoLock(out extraData);
			typeSigAndExtraData_isInitialized = true;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>Called to initialize <see cref="typeSig"/></summary>
		protected virtual TypeSig GetTypeSigAndExtraData_NoLock(out byte[] extraData) {
			extraData = null;
			return null;
		}

		/// <summary>
		/// Gets all custom attributes
		/// </summary>
		public CustomAttributeCollection CustomAttributes {
			get {
				if (customAttributes is null)
					InitializeCustomAttributes();
				return customAttributes;
			}
		}
		/// <summary/>
		protected CustomAttributeCollection customAttributes;
		/// <summary>Initializes <see cref="customAttributes"/></summary>
		protected virtual void InitializeCustomAttributes() =>
			Interlocked.CompareExchange(ref customAttributes, new CustomAttributeCollection(), null);

		/// <inheritdoc/>
		public bool HasCustomAttributes => CustomAttributes.Count > 0;


		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 13;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos {
			get {
				if (customDebugInfos is null)
					InitializeCustomDebugInfos();
				return customDebugInfos;
			}
		}
		/// <summary/>
		protected IList<PdbCustomDebugInfo> customDebugInfos;
		/// <summary>Initializes <see cref="customDebugInfos"/></summary>
		protected virtual void InitializeCustomDebugInfos() =>
			Interlocked.CompareExchange(ref customDebugInfos, new List<PdbCustomDebugInfo>(), null);
		/// <inheritdoc/>
		public override string ToString() => FullName;
	}

	/// <summary>
	/// A TypeSpec row created by the user and not present in the original .NET file
	/// </summary>
	public class TypeSpecUser : TypeSpec {
		/// <summary>
		/// Default constructor
		/// </summary>
		public TypeSpecUser() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeSig">A type sig</param>
		public TypeSpecUser(TypeSig typeSig) {
			this.typeSig = typeSig;
			extraData = null;
			typeSigAndExtraData_isInitialized = true;
		}
	}

	/// <summary>
	/// Created from a row in the TypeSpec table
	/// </summary>
	sealed class TypeSpecMD : TypeSpec, IMDTokenProviderMD, IContainsGenericParameter2 {
		/// <summary>The module where this instance is located</summary>
		readonly ModuleDefMD readerModule;

		readonly uint origRid;
		readonly GenericParamContext gpContext;
		readonly uint signatureOffset;

		/// <inheritdoc/>
		public uint OrigRid => origRid;

		/// <inheritdoc/>
		protected override TypeSig GetTypeSigAndExtraData_NoLock(out byte[] extraData) {
			var sig = readerModule.ReadTypeSignature(signatureOffset, gpContext, out extraData);
			if (sig is not null)
				sig.Rid = origRid;
			return sig;
		}

		/// <inheritdoc/>
		protected override void InitializeCustomAttributes() {
			var list = readerModule.Metadata.GetCustomAttributeRidList(Table.TypeSpec, origRid);
			var tmp = new CustomAttributeCollection(list.Count, list, (list2, index) => readerModule.ReadCustomAttribute(list[index]));
			Interlocked.CompareExchange(ref customAttributes, tmp, null);
		}

		/// <inheritdoc/>
		protected override void InitializeCustomDebugInfos() {
			var list = new List<PdbCustomDebugInfo>();
			readerModule.InitializeCustomDebugInfos(new MDToken(MDToken.Table, origRid), gpContext, list);
			Interlocked.CompareExchange(ref customDebugInfos, list, null);
		}

		bool IContainsGenericParameter2.ContainsGenericParameter => !gpContext.IsEmpty && ContainsGenericParameter;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="readerModule">The module which contains this <c>TypeSpec</c> row</param>
		/// <param name="rid">Row ID</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <exception cref="ArgumentNullException">If <paramref name="readerModule"/> is <c>null</c></exception>
		/// <exception cref="ArgumentException">If <paramref name="rid"/> is invalid</exception>
		public TypeSpecMD(ModuleDefMD readerModule, uint rid, GenericParamContext gpContext) {
#if DEBUG
			if (readerModule is null)
				throw new ArgumentNullException("readerModule");
			if (readerModule.TablesStream.TypeSpecTable.IsInvalidRID(rid))
				throw new BadImageFormatException($"TypeSpec rid {rid} does not exist");
#endif
			origRid = rid;
			this.rid = rid;
			this.readerModule = readerModule;
			this.gpContext = gpContext;
			bool b = readerModule.TablesStream.TryReadTypeSpecRow(origRid, out var row);
			Debug.Assert(b);
			signatureOffset = row.Signature;
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Compares <see cref="UTF8String"/>s
	/// </summary>
	public sealed class UTF8StringEqualityComparer : IEqualityComparer<UTF8String> {
		/// <summary>
		/// The default instance
		/// </summary>
		public static readonly UTF8StringEqualityComparer Instance = new UTF8StringEqualityComparer();

		/// <inheritdoc/>
		public bool Equals(UTF8String x, UTF8String y) => UTF8String.Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(UTF8String obj) => UTF8String.GetHashCode(obj);
	}

	/// <summary>
	/// A UTF-8 encoded string where the original data is kept in memory to avoid conversions
	/// when the data is not really valid UTF-8 encoded data
	/// </summary>
	/// <remarks>When comparing strings, a byte compare is performed. The reason is that this
	/// is what the CLR does when comparing strings in the #Strings stream.</remarks>
	[DebuggerDisplay("{String}")]
	public sealed class UTF8String : IEquatable<UTF8String>, IComparable<UTF8String> {
		/// <summary>
		/// An empty <see cref="UTF8String"/>
		/// </summary>
		public static readonly UTF8String Empty = new UTF8String(string.Empty);

		readonly byte[] data;
		string asString;

		/// <summary>
		/// Gets the value as a UTF8 decoded string. Only use it for display purposes,
		/// not for serialization.
		/// </summary>
		public string String {
			get {
				if (asString is null)
					asString = ConvertFromUTF8(data);
				return asString;
			}
		}

		/// <summary>
		/// Gets the original encoded data. Don't modify this data.
		/// </summary>
		public byte[] Data => data;

		/// <summary>
		/// Gets the length of the this as a <see cref="string"/>. I.e., it's the same as
		/// <c>String.Length</c>.
		/// </summary>
		/// <seealso cref="DataLength"/>
		public int Length => String.Length;

		/// <summary>
		/// Gets the length of the raw data. It's the same as <c>Data.Length</c>
		/// </summary>
		/// <seealso cref="Length"/>
		public int DataLength => data is null ? 0 : data.Length;

		/// <summary>
		/// Checks whether <paramref name="utf8"/> is <c>null</c> or if its data is <c>null</c>.
		/// </summary>
		/// <param name="utf8">The instance to check</param>
		/// <returns><c>true</c> if <c>null</c> or empty, <c>false</c> otherwise</returns>
		public static bool IsNull(UTF8String utf8) => utf8 is null || utf8.data is null;

		/// <summary>
		/// Checks whether <paramref name="utf8"/> is <c>null</c> or if its data is <c>null</c> or the
		/// data is zero length.
		/// </summary>
		/// <param name="utf8">The instance to check</param>
		/// <returns><c>true</c> if <c>null</c> or empty, <c>false</c> otherwise</returns>
		public static bool IsNullOrEmpty(UTF8String utf8) => utf8 is null || utf8.data is null || utf8.data.Length == 0;

		/// <summary>Implicit conversion from <see cref="UTF8String"/> to <see cref="string"/></summary>
		public static implicit operator string(UTF8String s) => UTF8String.ToSystemString(s);

		/// <summary>Implicit conversion from <see cref="string"/> to <see cref="UTF8String"/></summary>
		public static implicit operator UTF8String(string s) => s is null ? null : new UTF8String(s);

		/// <summary>
		/// Converts it to a <see cref="string"/>
		/// </summary>
		/// <param name="utf8">The UTF-8 string instace or <c>null</c></param>
		/// <returns>A <see cref="string"/> or <c>null</c> if <paramref name="utf8"/> is <c>null</c></returns>
		public static string ToSystemString(UTF8String utf8) {
			if (utf8 is null || utf8.data is null)
				return null;
			if (utf8.data.Length == 0)
				return string.Empty;
			return utf8.String;
		}

		/// <summary>
		/// Converts it to a <see cref="string"/> or an empty string if <paramref name="utf8"/> is <c>null</c>
		/// </summary>
		/// <param name="utf8">The UTF-8 string instace or <c>null</c></param>
		/// <returns>A <see cref="string"/> (never <c>null</c>)</returns>
		public static string ToSystemStringOrEmpty(UTF8String utf8) => ToSystemString(utf8) ?? string.Empty;

		/// <summary>
		/// Gets the hash code of a <see cref="UTF8String"/>
		/// </summary>
		/// <param name="utf8">Input</param>
		public static int GetHashCode(UTF8String utf8) {
			if (IsNullOrEmpty(utf8))
				return 0;
			return Utils.GetHashCode(utf8.data);
		}

		/// <inheritdoc/>
		public int CompareTo(UTF8String other) => CompareTo(this, other);

		/// <summary>
		/// Compares two <see cref="UTF8String"/> instances (case sensitive)
		/// </summary>
		/// <param name="a">Instance #1 or <c>null</c></param>
		/// <param name="b">Instance #2 or <c>null</c></param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public static int CompareTo(UTF8String a, UTF8String b) => Utils.CompareTo(a?.data, b?.data);

		/// <summary>
		/// Compares two <see cref="UTF8String"/> instances (case insensitive)
		/// </summary>
		/// <param name="a">Instance #1 or <c>null</c></param>
		/// <param name="b">Instance #2 or <c>null</c></param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public static int CaseInsensitiveCompareTo(UTF8String a, UTF8String b) {
			if ((object)a == (object)b)
				return 0;
			var sa = ToSystemString(a);
			var sb = ToSystemString(b);
			if ((object)sa == (object)sb)
				return 0;
			if (sa is null)
				return -1;
			if (sb is null)
				return 1;
			return StringComparer.OrdinalIgnoreCase.Compare(sa, sb);
		}

		/// <summary>
		/// Compares two <see cref="UTF8String"/> instances (case insensitive)
		/// </summary>
		/// <param name="a">Instance #1 or <c>null</c></param>
		/// <param name="b">Instance #2 or <c>null</c></param>
		/// <returns><c>true</c> if equals, <c>false</c> otherwise</returns>
		public static bool CaseInsensitiveEquals(UTF8String a, UTF8String b) => CaseInsensitiveCompareTo(a, b) == 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(UTF8String left, UTF8String right) => CompareTo(left, right) == 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(UTF8String left, string right) => ToSystemString(left) == right;

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(string left, UTF8String right) => left == ToSystemString(right);

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(UTF8String left, UTF8String right) => CompareTo(left, right) != 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(UTF8String left, string right) => ToSystemString(left) != right;

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(string left, UTF8String right) => left != ToSystemString(right);

		/// <summary>Overloaded operator</summary>
		public static bool operator >(UTF8String left, UTF8String right) => CompareTo(left, right) > 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator <(UTF8String left, UTF8String right) => CompareTo(left, right) < 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator >=(UTF8String left, UTF8String right) => CompareTo(left, right) >= 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator <=(UTF8String left, UTF8String right) => CompareTo(left, right) <= 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">UTF-8 data that this instance now owns</param>
		public UTF8String(byte[] data) => this.data = data;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="s">The string</param>
		public UTF8String(string s)
			: this(s is null ? null : Encoding.UTF8.GetBytes(s)) {
		}

		static string ConvertFromUTF8(byte[] data) {
			if (data is null)
				return null;
			try {
				return Encoding.UTF8.GetString(data);
			}
			catch {
			}
			return null;
		}

		/// <summary>
		/// Compares two instances
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if equals, <c>false</c> otherwise</returns>
		public static bool Equals(UTF8String a, UTF8String b) => CompareTo(a, b) == 0;

		/// <inheritdoc/>
		public bool Equals(UTF8String other) => CompareTo(this, other) == 0;

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			var other = obj as UTF8String;
			if (other is null)
				return false;
			return CompareTo(this, other) == 0;
		}

		/// <summary>
		/// Checks whether <paramref name="value"/> exists in this string
		/// </summary>
		/// <param name="value">Value to find</param>
		/// <returns><c>true</c> if <paramref name="value"/> exists in string or is the
		/// empty string, else <c>false</c></returns>
		public bool Contains(string value) => String.Contains(value);

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the end of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public bool EndsWith(string value) => String.EndsWith(value);

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the end of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="ignoreCase"><c>true</c> to ignore case</param>
		/// <param name="culture">Culture info</param>
		/// <returns></returns>
		public bool EndsWith(string value, bool ignoreCase, CultureInfo culture) => String.EndsWith(value, ignoreCase, culture);

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the end of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns></returns>
		public bool EndsWith(string value, StringComparison comparisonType) => String.EndsWith(value, comparisonType);

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the beginning of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public bool StartsWith(string value) => String.StartsWith(value);

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the beginning of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="ignoreCase"><c>true</c> to ignore case</param>
		/// <param name="culture">Culture info</param>
		/// <returns></returns>
		public bool StartsWith(string value, bool ignoreCase, CultureInfo culture) => String.StartsWith(value, ignoreCase, culture);

		/// <summary>
		/// Checks whether <paramref name="value"/> matches the beginning of this string
		/// </summary>
		/// <param name="value">Value</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns></returns>
		public bool StartsWith(string value, StringComparison comparisonType) => String.StartsWith(value, comparisonType);

		/// <summary>
		/// Compares this instance with <paramref name="strB"/>
		/// </summary>
		/// <param name="strB">Other string</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		public int CompareTo(string strB) => String.CompareTo(strB);

		/// <summary>
		/// Returns the index of the first character <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">Character</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(char value) => String.IndexOf(value);

		/// <summary>
		/// Returns the index of the first character <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">Character</param>
		/// <param name="startIndex">Start index</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(char value, int startIndex) => String.IndexOf(value, startIndex);

		/// <summary>
		/// Returns the index of the first character <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">Character</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(char value, int startIndex, int count) => String.IndexOf(value, startIndex, count);

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">String</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value) => String.IndexOf(value);

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, int startIndex) => String.IndexOf(value, startIndex);

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, int startIndex, int count) => String.IndexOf(value, startIndex, count);

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType) => String.IndexOf(value, startIndex, count, comparisonType);

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, int startIndex, StringComparison comparisonType) => String.IndexOf(value, startIndex, comparisonType);

		/// <summary>
		/// Returns the index of the first sub string <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int IndexOf(string value, StringComparison comparisonType) => String.IndexOf(value, comparisonType);

		/// <summary>
		/// Returns the index of the last character <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">Character</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(char value) => String.LastIndexOf(value);

		/// <summary>
		/// Returns the index of the last character <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">Character</param>
		/// <param name="startIndex">Start index</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(char value, int startIndex) => String.LastIndexOf(value, startIndex);

		/// <summary>
		/// Returns the index of the last character <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">Character</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(char value, int startIndex, int count) => String.LastIndexOf(value, startIndex, count);

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">String</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value) => String.LastIndexOf(value);

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, int startIndex) => String.LastIndexOf(value, startIndex);

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, int startIndex, int count) => String.LastIndexOf(value, startIndex, count);

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/> for max <paramref name="count"/>
		/// characters.
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Max number of chars to scan</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType) => String.LastIndexOf(value, startIndex, count, comparisonType);

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// starting from index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="startIndex">Start index</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, int startIndex, StringComparison comparisonType) => String.LastIndexOf(value, startIndex, comparisonType);

		/// <summary>
		/// Returns the index of the last sub string <paramref name="value"/> in this string
		/// </summary>
		/// <param name="value">String</param>
		/// <param name="comparisonType">Comparison type</param>
		/// <returns>The index of <paramref name="value"/> or <c>-1</c> if not found</returns>
		public int LastIndexOf(string value, StringComparison comparisonType) => String.LastIndexOf(value, comparisonType);

		/// <summary>
		/// Inserts string <paramref name="value"/> at a index <paramref name="startIndex"/>
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <param name="value">Value to insert</param>
		/// <returns>A new instance with the <paramref name="value"/> inserted at position
		/// <paramref name="startIndex"/></returns>
		public UTF8String Insert(int startIndex, string value) => new UTF8String(String.Insert(startIndex, value));

		/// <summary>
		/// Removes all characters starting from position <paramref name="startIndex"/>
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <returns>A new instance</returns>
		public UTF8String Remove(int startIndex) => new UTF8String(String.Remove(startIndex));

		/// <summary>
		/// Removes <paramref name="count"/> characters starting from position
		/// <paramref name="startIndex"/>
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <param name="count">Number of characters to remove</param>
		/// <returns>A new instance</returns>
		public UTF8String Remove(int startIndex, int count) => new UTF8String(String.Remove(startIndex, count));

		/// <summary>
		/// Replaces all characters <paramref name="oldChar"/> with <paramref name="newChar"/>
		/// </summary>
		/// <param name="oldChar">Character to find</param>
		/// <param name="newChar">Character to replace all <paramref name="oldChar"/></param>
		/// <returns>A new instance</returns>
		public UTF8String Replace(char oldChar, char newChar) => new UTF8String(String.Replace(oldChar, newChar));

		/// <summary>
		/// Replaces all sub strings <paramref name="oldValue"/> with <paramref name="newValue"/>
		/// </summary>
		/// <param name="oldValue">Sub string to find</param>
		/// <param name="newValue">Sub string to replace all <paramref name="oldValue"/></param>
		/// <returns>A new instance</returns>
		public UTF8String Replace(string oldValue, string newValue) => new UTF8String(String.Replace(oldValue, newValue));

		/// <summary>
		/// Returns a sub string of this string starting at offset <paramref name="startIndex"/>
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <returns>A new instance</returns>
		public UTF8String Substring(int startIndex) => new UTF8String(String.Substring(startIndex));

		/// <summary>
		/// Returns a sub string of this string starting at offset <paramref name="startIndex"/>.
		/// Length of sub string is <paramref name="length"/>.
		/// </summary>
		/// <param name="startIndex">Start index</param>
		/// <param name="length">Length of sub string</param>
		/// <returns>A new instance</returns>
		public UTF8String Substring(int startIndex, int length) => new UTF8String(String.Substring(startIndex, length));

		/// <summary>
		/// Returns the lower case version of this string
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String ToLower() => new UTF8String(String.ToLower());

		/// <summary>
		/// Returns the lower case version of this string
		/// </summary>
		/// <param name="culture">Culture info</param>
		/// <returns>A new instance</returns>
		public UTF8String ToLower(CultureInfo culture) => new UTF8String(String.ToLower(culture));

		/// <summary>
		/// Returns the lower case version of this string using the invariant culture
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String ToLowerInvariant() => new UTF8String(String.ToLowerInvariant());

		/// <summary>
		/// Returns the upper case version of this string
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String ToUpper() => new UTF8String(String.ToUpper());

		/// <summary>
		/// Returns the upper case version of this string
		/// </summary>
		/// <param name="culture">Culture info</param>
		/// <returns>A new instance</returns>
		public UTF8String ToUpper(CultureInfo culture) => new UTF8String(String.ToUpper(culture));

		/// <summary>
		/// Returns the upper case version of this string using the invariant culture
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String ToUpperInvariant() => new UTF8String(String.ToUpperInvariant());

		/// <summary>
		/// Removes all leading and trailing whitespace characters
		/// </summary>
		/// <returns>A new instance</returns>
		public UTF8String Trim() => new UTF8String(String.Trim());

		/// <inheritdoc/>
		public override int GetHashCode() => UTF8String.GetHashCode(this);

		/// <inheritdoc/>
		public override string ToString() => String;
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Compares byte arrays
	/// </summary>
	sealed class ByteArrayEqualityComparer : IEqualityComparer<byte[]> {
		/// <summary>
		/// Default instance
		/// </summary>
		public static readonly ByteArrayEqualityComparer Instance = new ByteArrayEqualityComparer();

		/// <inheritdoc/>
		public bool Equals(byte[] x, byte[] y) => Utils.Equals(x, y);

		/// <inheritdoc/>
		public int GetHashCode(byte[] obj) => Utils.GetHashCode(obj);
	}

	static class Utils {
		/// <summary>
		/// Returns an assembly name string
		/// </summary>
		/// <param name="name">Simple assembly name</param>
		/// <param name="version">Version or <c>null</c></param>
		/// <param name="culture">Culture or <c>null</c></param>
		/// <param name="publicKey">Public key / public key token or <c>null</c></param>
		/// <param name="attributes">Assembly attributes</param>
		/// <returns>An assembly name string</returns>
		internal static string GetAssemblyNameString(UTF8String name, Version version, UTF8String culture, PublicKeyBase publicKey, AssemblyAttributes attributes) {
			var sb = new StringBuilder();

			foreach (var c in UTF8String.ToSystemStringOrEmpty(name)) {
				if (c == ',' || c == '=')
					sb.Append('\\');
				sb.Append(c);
			}

			if (version is not null) {
				sb.Append(", Version=");
				sb.Append(CreateVersionWithNoUndefinedValues(version).ToString());
			}

			if (culture is not null) {
				sb.Append(", Culture=");
				sb.Append(UTF8String.IsNullOrEmpty(culture) ? "neutral" : culture.String);
			}

			sb.Append(", ");
			sb.Append(publicKey is null || publicKey is PublicKeyToken ? "PublicKeyToken=" : "PublicKey=");
			sb.Append(publicKey is null ? "null" : publicKey.ToString());

			if ((attributes & AssemblyAttributes.Retargetable) != 0)
				sb.Append(", Retargetable=Yes");

			if ((attributes & AssemblyAttributes.ContentType_Mask) == AssemblyAttributes.ContentType_WindowsRuntime)
				sb.Append(", ContentType=WindowsRuntime");

			return sb.ToString();
		}

		/// <summary>
		/// Convert a byte[] to a <see cref="string"/>
		/// </summary>
		/// <param name="bytes">All bytes</param>
		/// <param name="upper"><c>true</c> if output should be in upper case hex</param>
		/// <returns><paramref name="bytes"/> as a hex string</returns>
		internal static string ToHex(byte[] bytes, bool upper) {
			if (bytes is null)
				return "";
			var chars = new char[bytes.Length * 2];
			for (int i = 0, j = 0; i < bytes.Length; i++) {
				byte b = bytes[i];
				chars[j++] = ToHexChar(b >> 4, upper);
				chars[j++] = ToHexChar(b & 0x0F, upper);
			}
			return new string(chars);
		}

		static char ToHexChar(int val, bool upper) {
			if (0 <= val && val <= 9)
				return (char)(val + (int)'0');
			return (char)(val - 10 + (upper ? (int)'A' : (int)'a'));
		}

		/// <summary>
		/// Converts a hex string to a byte[]
		/// </summary>
		/// <param name="hexString">A string with an even number of hex characters</param>
		/// <returns><paramref name="hexString"/> converted to a byte[] or <c>null</c>
		/// if <paramref name="hexString"/> is invalid</returns>
		internal static byte[] ParseBytes(string hexString) {
			try {
				if (hexString.Length % 2 != 0)
					return null;
				var bytes = new byte[hexString.Length / 2];
				for (int i = 0; i < hexString.Length; i += 2) {
					int upper = TryParseHexChar(hexString[i]);
					int lower = TryParseHexChar(hexString[i + 1]);
					if (upper < 0 || lower < 0)
						return null;
					bytes[i / 2] = (byte)((upper << 4) | lower);
				}
				return bytes;
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Converts a character to a hex digit
		/// </summary>
		/// <param name="c">Hex character</param>
		/// <returns><c>0x00</c>-<c>0x0F</c> if successful, <c>-1</c> if <paramref name="c"/> is not
		/// a valid hex digit</returns>
		static int TryParseHexChar(char c) {
			if ('0' <= c && c <= '9')
				return (ushort)c - (ushort)'0';
			if ('a' <= c && c <= 'f')
				return 10 + (ushort)c - (ushort)'a';
			if ('A' <= c && c <= 'F')
				return 10 + (ushort)c - (ushort)'A';
			return -1;
		}

		/// <summary>
		/// Compares two byte arrays
		/// </summary>
		/// <param name="a">Byte array #1</param>
		/// <param name="b">Byte array #2</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		internal static int CompareTo(byte[] a, byte[] b) {
			if (a == b)
				return 0;
			if (a is null)
				return -1;
			if (b is null)
				return 1;
			int count = Math.Min(a.Length, b.Length);
			for (int i = 0; i < count; i++) {
				var ai = a[i];
				var bi = b[i];
				if (ai < bi)
					return -1;
				if (ai > bi)
					return 1;
			}
			return a.Length.CompareTo(b.Length);
		}

		/// <summary>
		/// Checks whether two byte arrays are equal
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal static bool Equals(byte[] a, byte[] b) {
			if (a == b)
				return true;
			if (a is null || b is null)
				return false;
			if (a.Length != b.Length)
				return false;
			for (int i = 0; i < a.Length; i++) {
				if (a[i] != b[i])
					return false;
			}
			return true;
		}

		/// <summary>
		/// Gets the hash code of a byte array
		/// </summary>
		/// <param name="a">Byte array</param>
		/// <returns>The hash code</returns>
		internal static int GetHashCode(byte[] a) {
			if (a is null || a.Length == 0)
				return 0;
			int count = Math.Min(a.Length / 2, 20);
			if (count == 0)
				count = 1;
			uint hash = 0;
			for (int i = 0, j = a.Length - 1; i < count; i++, j--) {
				hash ^= a[i] | ((uint)a[j] << 8);
				hash = (hash << 13) | (hash >> 19);
			}
			return (int)hash;
		}

		/// <summary>
		/// Compares two versions
		/// </summary>
		/// <remarks>This differs from <see cref="System.Version.CompareTo(Version)"/> if the build
		/// and/or revision numbers haven't been initialized or if one of the args is <c>null</c>.
		/// </remarks>
		/// <param name="a">Version #1 or <c>null</c> to be treated as v0.0.0.0</param>
		/// <param name="b">Version #2 or <c>null</c> to be treated as v0.0.0.0</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		internal static int CompareTo(Version a, Version b) {
			if (a is null)
				a = new Version();
			if (b is null)
				b = new Version();
			if (a.Major != b.Major)
				return a.Major.CompareTo(b.Major);
			if (a.Minor != b.Minor)
				return a.Minor.CompareTo(b.Minor);
			if (GetDefaultVersionValue(a.Build) != GetDefaultVersionValue(b.Build))
				return GetDefaultVersionValue(a.Build).CompareTo(GetDefaultVersionValue(b.Build));
			return GetDefaultVersionValue(a.Revision).CompareTo(GetDefaultVersionValue(b.Revision));
		}

		/// <summary>
		/// Checks whether two versions are the same
		/// </summary>
		/// <remarks>This differs from <see cref="System.Version.Equals(Version)"/> if the build
		/// and/or revision numbers haven't been initialized or if one of the args is <c>null</c>.
		/// </remarks>
		/// <param name="a">Version #1 or <c>null</c> to be treated as v0.0.0.0</param>
		/// <param name="b">Version #2 or <c>null</c> to be treated as v0.0.0.0</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal static bool Equals(Version a, Version b) => CompareTo(a, b) == 0;

		/// <summary>
		/// Creates a new <see cref="Version"/> instance with no undefined version values (eg.
		/// the build and revision values won't be -1).
		/// </summary>
		/// <param name="a">A <see cref="Version"/> instance</param>
		/// <returns>A new <see cref="Version"/> instance</returns>
		internal static Version CreateVersionWithNoUndefinedValues(Version a) {
			if (a is null)
				return new Version(0, 0, 0, 0);
			return new Version(a.Major, a.Minor, GetDefaultVersionValue(a.Build), GetDefaultVersionValue(a.Revision));
		}

		static int GetDefaultVersionValue(int val) => val == -1 ? 0 : val;

		/// <summary>
		/// Parses a version string
		/// </summary>
		/// <param name="versionString">Version string</param>
		/// <returns>A new <see cref="Version"/> or <c>null</c> if <paramref name="versionString"/>
		/// is an invalid version</returns>
		internal static Version ParseVersion(string versionString) {
			try {
				return Utils.CreateVersionWithNoUndefinedValues(new Version(versionString));
			}
			catch {
				return null;
			}
		}

		/// <summary>
		/// Compares two locales (cultures)
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		internal static int LocaleCompareTo(UTF8String a, UTF8String b) => GetCanonicalLocale(a).CompareTo(GetCanonicalLocale(b));

		/// <summary>
		/// Compares two locales (cultures)
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal static bool LocaleEquals(UTF8String a, UTF8String b) => LocaleCompareTo(a, b) == 0;

		/// <summary>
		/// Compares two locales (cultures)
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns>&lt; 0 if a &lt; b, 0 if a == b, &gt; 0 if a &gt; b</returns>
		internal static int LocaleCompareTo(UTF8String a, string b) => GetCanonicalLocale(a).CompareTo(GetCanonicalLocale(b));

		/// <summary>
		/// Compares two locales (cultures)
		/// </summary>
		/// <param name="a">First</param>
		/// <param name="b">Second</param>
		/// <returns><c>true</c> if same, <c>false</c> otherwise</returns>
		internal static bool LocaleEquals(UTF8String a, string b) => LocaleCompareTo(a, b) == 0;

		/// <summary>
		/// Gets the hash code of a locale
		/// </summary>
		/// <param name="a">Value</param>
		/// <returns>The hash code</returns>
		internal static int GetHashCodeLocale(UTF8String a) => GetCanonicalLocale(a).GetHashCode();

		static string GetCanonicalLocale(UTF8String locale) => GetCanonicalLocale(UTF8String.ToSystemStringOrEmpty(locale));

		static string GetCanonicalLocale(string locale) {
			var s = locale.ToUpperInvariant();
			if (s == "NEUTRAL")
				s = string.Empty;
			return s;
		}

		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="v">Value</param>
		/// <param name="alignment">Alignment</param>
		public static uint AlignUp(uint v, uint alignment) => (v + alignment - 1) & ~(alignment - 1);

		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="v">Value</param>
		/// <param name="alignment">Alignment</param>
		public static int AlignUp(int v, uint alignment) => (int)AlignUp((uint)v, alignment);
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// Variant type (<c>VT_XXX</c> in the Windows SDK)
	/// </summary>
	public enum VariantType : uint {
		/// <summary/>
		Empty			= 0,
		/// <summary/>
		None			= 0,
		/// <summary/>
		Null			= 1,
		/// <summary/>
		I2				= 2,
		/// <summary/>
		I4				= 3,
		/// <summary/>
		R4				= 4,
		/// <summary/>
		R8				= 5,
		/// <summary/>
		CY				= 6,
		/// <summary/>
		Date			= 7,
		/// <summary/>
		BStr			= 8,
		/// <summary/>
		Dispatch		= 9,
		/// <summary/>
		Error			= 10,
		/// <summary/>
		Bool			= 11,
		/// <summary/>
		Variant			= 12,
		/// <summary/>
		Unknown			= 13,
		/// <summary/>
		Decimal			= 14,
		/// <summary/>
		I1				= 16,
		/// <summary/>
		UI1				= 17,
		/// <summary/>
		UI2				= 18,
		/// <summary/>
		UI4				= 19,
		/// <summary/>
		I8				= 20,
		/// <summary/>
		UI8				= 21,
		/// <summary/>
		Int				= 22,
		/// <summary/>
		UInt			= 23,
		/// <summary/>
		Void			= 24,
		/// <summary/>
		HResult			= 25,
		/// <summary/>
		Ptr				= 26,
		/// <summary/>
		SafeArray		= 27,
		/// <summary/>
		CArray			= 28,
		/// <summary/>
		UserDefined		= 29,
		/// <summary/>
		LPStr			= 30,
		/// <summary/>
		LPWStr			= 31,
		/// <summary/>
		Record			= 36,
		/// <summary/>
		IntPtr			= 37,
		/// <summary/>
		UIntPtr			= 38,
		/// <summary/>
		FileTime		= 64,
		/// <summary/>
		Blob			= 65,
		/// <summary/>
		Stream			= 66,
		/// <summary/>
		Storage			= 67,
		/// <summary/>
		StreamedObject	= 68,
		/// <summary/>
		StoredObject	= 69,
		/// <summary/>
		BlobObject		= 70,
		/// <summary/>
		CF				= 71,
		/// <summary/>
		CLSID			= 72,
		/// <summary/>
		VersionedStream	= 73,
		/// <summary/>
		BStrBlob		= 0x0FFF,
		/// <summary/>
		Vector			= 0x1000,
		/// <summary/>
		Array			= 0x2000,
		/// <summary/>
		ByRef			= 0x4000,
		/// <summary/>
		Reserved		= 0x8000,
		/// <summary/>
		Illegal			= 0xFFFF,
		/// <summary/>
		IllegalMasked	= 0x0FFF,
		/// <summary/>
		TypeMask		= 0x0FFF,
		/// <summary>This wasn't present in the blob</summary>
		NotInitialized	= 0xFFFFFFFF,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// All native vtables
	/// </summary>
	[DebuggerDisplay("RVA = {RVA}, Count = {VTables.Count}")]
	public sealed class VTableFixups : IEnumerable<VTable> {
		RVA rva;
		IList<VTable> vtables;

		/// <summary>
		/// Gets/sets the RVA of the vtable fixups
		/// </summary>
		public RVA RVA {
			get => rva;
			set => rva = value;
		}

		/// <summary>
		/// Gets all <see cref="VTable"/>s
		/// </summary>
		public IList<VTable> VTables => vtables;

		/// <summary>
		/// Default constructor
		/// </summary>
		public VTableFixups() => vtables = new List<VTable>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module</param>
		public VTableFixups(ModuleDefMD module) => Initialize(module);

		void Initialize(ModuleDefMD module) {
			var info = module.Metadata.ImageCor20Header.VTableFixups;
			if (info.VirtualAddress == 0 || info.Size == 0) {
				vtables = new List<VTable>();
				return;
			}
			rva = info.VirtualAddress;
			vtables = new List<VTable>((int)info.Size / 8);

			var peImage = module.Metadata.PEImage;
			var reader = peImage.CreateReader();
			reader.Position = (uint)peImage.ToFileOffset(info.VirtualAddress);
			ulong endPos = (ulong)reader.Position + info.Size;
			while ((ulong)reader.Position + 8 <= endPos && reader.CanRead(8U)) {
				var tableRva = (RVA)reader.ReadUInt32();
				int numSlots = reader.ReadUInt16();
				var flags = (VTableFlags)reader.ReadUInt16();
				var vtable = new VTable(tableRva, flags, numSlots);
				vtables.Add(vtable);

				var pos = reader.Position;
				reader.Position = (uint)peImage.ToFileOffset(tableRva);
				uint slotSize = vtable.Is64Bit ? 8U : 4;
				while (numSlots-- > 0 && reader.CanRead(slotSize)) {
					vtable.Methods.Add(module.ResolveToken(reader.ReadUInt32()) as IMethod);
					if (slotSize == 8)
						reader.ReadUInt32();
				}
				reader.Position = pos;
			}
		}

		/// <inheritdoc/>
		public IEnumerator<VTable> GetEnumerator() => vtables.GetEnumerator();

		/// <inheritdoc/>
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();
	}

	/// <summary>
	/// See COR_VTABLE_XXX in CorHdr.h
	/// </summary>
	[Flags]
	public enum VTableFlags : ushort {
		/// <summary>
		/// 32-bit vtable slots
		/// </summary>
		Bit32				= 0x01,

		/// <summary>
		/// 64-bit vtable slots
		/// </summary>
		Bit64				= 0x02,

		/// <summary>
		/// Transition from unmanaged code
		/// </summary>
		FromUnmanaged		= 0x04,

		/// <summary>
		/// Also retain app domain
		/// </summary>
		FromUnmanagedRetainAppDomain = 0x08,

		/// <summary>
		/// Call most derived method
		/// </summary>
		CallMostDerived		= 0x10,
	}

	/// <summary>
	/// One VTable accessed by native code
	/// </summary>
	public sealed class VTable : IEnumerable<IMethod> {
		RVA rva;
		VTableFlags flags;
		readonly IList<IMethod> methods;

		/// <summary>
		/// Gets/sets the <see cref="RVA"/> of this vtable
		/// </summary>
		public RVA RVA {
			get => rva;
			set => rva = value;
		}

		/// <summary>
		/// Gets/sets the flags
		/// </summary>
		public VTableFlags Flags {
			get => flags;
			set => flags = value;
		}

		/// <summary>
		/// <c>true</c> if each vtable slot is 32 bits in size
		/// </summary>
		public bool Is32Bit => (flags & VTableFlags.Bit32) != 0;

		/// <summary>
		/// <c>true</c> if each vtable slot is 64 bits in size
		/// </summary>
		public bool Is64Bit => (flags & VTableFlags.Bit64) != 0;

		/// <summary>
		/// Gets the vtable methods
		/// </summary>
		public IList<IMethod> Methods => methods;

		/// <summary>
		/// Default constructor
		/// </summary>
		public VTable() => methods = new List<IMethod>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Flags</param>
		public VTable(VTableFlags flags) {
			this.flags = flags;
			methods = new List<IMethod>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rva">RVA of this vtable</param>
		/// <param name="flags">Flgas</param>
		/// <param name="numSlots">Number of methods in vtable</param>
		public VTable(RVA rva, VTableFlags flags, int numSlots) {
			this.rva = rva;
			this.flags = flags;
			methods = new List<IMethod>(numSlots);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rva">RVA of this vtable</param>
		/// <param name="flags">Flgas</param>
		/// <param name="methods">Vtable methods</param>
		public VTable(RVA rva, VTableFlags flags, IEnumerable<IMethod> methods) {
			this.rva = rva;
			this.flags = flags;
			this.methods = new List<IMethod>(methods);
		}

		/// <inheritdoc/>
		public IEnumerator<IMethod> GetEnumerator() => methods.GetEnumerator();

		/// <inheritdoc/>
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();

		/// <inheritdoc/>
		public override string ToString() {
			if (methods.Count == 0)
				return $"{methods.Count} {(uint)rva:X8}";
			return $"{methods.Count} {(uint)rva:X8} {methods[0]}";
		}
	}
}





namespace dnlib.DotNet {
	enum ClrAssembly {
		Mscorlib,
		SystemNumericsVectors,
		SystemObjectModel,
		SystemRuntime,
		SystemRuntimeInteropServicesWindowsRuntime,
		SystemRuntimeWindowsRuntime,
		SystemRuntimeWindowsRuntimeUIXaml,
	}

	static class WinMDHelpers {
		readonly struct ClassName : IEquatable<ClassName> {
			public readonly UTF8String Namespace;
			public readonly UTF8String Name;
			// Not used when comparing for equality etc
			public readonly bool IsValueType;

			public ClassName(UTF8String ns, UTF8String name, bool isValueType = false) {
				Namespace = ns;
				Name = name;
				IsValueType = isValueType;
			}

			public ClassName(string ns, string name, bool isValueType = false) {
				Namespace = ns;
				Name = name;
				IsValueType = isValueType;
			}

			public static bool operator ==(ClassName a, ClassName b) => a.Equals(b);
			public static bool operator !=(ClassName a, ClassName b) => !a.Equals(b);

			public bool Equals(ClassName other) =>
				// Don't check IsValueType
				UTF8String.Equals(Namespace, other.Namespace) && UTF8String.Equals(Name, other.Name);

			public override bool Equals(object obj) {
				if (!(obj is ClassName))
					return false;
				return Equals((ClassName)obj);
			}

			public override int GetHashCode() =>
				// Don't use IsValueType
				UTF8String.GetHashCode(Namespace) ^ UTF8String.GetHashCode(Name);

			public override string ToString() => $"{Namespace}.{Name}";
		}

		sealed class ProjectedClass {
			public readonly ClassName WinMDClass;
			public readonly ClassName ClrClass;
			public readonly ClrAssembly ClrAssembly;
			public readonly ClrAssembly ContractAssembly;

			public ProjectedClass(string mdns, string mdname, string clrns, string clrname, ClrAssembly clrAsm, ClrAssembly contractAsm, bool winMDValueType, bool clrValueType) {
				WinMDClass = new ClassName(mdns, mdname, winMDValueType);
				ClrClass = new ClassName(clrns, clrname, clrValueType);
				ClrAssembly = clrAsm;
				ContractAssembly = contractAsm;
			}

			public override string ToString() => $"{WinMDClass} <-> {ClrClass}, {CreateAssembly(null, ContractAssembly)}";
		}

		// See https://github.com/dotnet/coreclr/blob/master/src/inc/winrtprojectedtypes.h
		// To generate this code replace the contents of src/inc/winrtprojectedtypes.h with:
		//	DEFINE_PROJECTED_ENUM
		//	=>	DEFINE_PROJECTED_STRUCT
		//	^DEFINE_PROJECTED\w*_STRUCT\s*\(("[^"]+"),\s*("[^"]+"),\s*("[^"]+"),\s*("[^"]+"),\s*(\w+),\s*(\w+).*$
		//	=>	\t\t\tnew ProjectedClass(\1, \2, \3, \4, ClrAssembly.\5, ClrAssembly.\6, true, true),
		//	^DEFINE_PROJECTED\w+\s*\(("[^"]+"),\s*("[^"]+"),\s*("[^"]+"),\s*("[^"]+"),\s*(\w+),\s*(\w+).*$
		//	=>	\t\t\tnew ProjectedClass(\1, \2, \3, \4, ClrAssembly.\5, ClrAssembly.\6, false, false),
		// Sometimes the types aren't both structs or both classes. Known cases:
		//		IReference`1 (class)	vs	Nullable`1 (struct)
		//		IKeyValuePair`2 (class)	vs	KeyValuePair`2 (struct)
		//		TypeName (struct)		vs	Type (class)
		//		HResult (struct)		vs	Exception (class)
		// See md/winmd/adapter.cpp WinMDAdapter::RewriteTypeInSignature() or check the types
		// in a decompiler.
		static readonly ProjectedClass[] ProjectedClasses = new ProjectedClass[] {
			new ProjectedClass("Windows.Foundation.Metadata", "AttributeUsageAttribute", "System", "AttributeUsageAttribute", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Metadata", "AttributeTargets", "System", "AttributeTargets", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, true),

			new ProjectedClass("Windows.UI", "Color", "Windows.UI", "Color", ClrAssembly.SystemRuntimeWindowsRuntime, ClrAssembly.SystemRuntimeWindowsRuntime, true, true),

			new ProjectedClass("Windows.Foundation", "DateTime", "System", "DateTimeOffset", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "EventHandler`1", "System", "EventHandler`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation", "EventRegistrationToken", "System.Runtime.InteropServices.WindowsRuntime", "EventRegistrationToken", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntimeInteropServicesWindowsRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "HResult", "System", "Exception", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, false),
			new ProjectedClass("Windows.Foundation", "IReference`1", "System", "Nullable`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, true),
			new ProjectedClass("Windows.Foundation", "Point", "Windows.Foundation", "Point", ClrAssembly.SystemRuntimeWindowsRuntime, ClrAssembly.SystemRuntimeWindowsRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "Rect", "Windows.Foundation", "Rect", ClrAssembly.SystemRuntimeWindowsRuntime, ClrAssembly.SystemRuntimeWindowsRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "Size", "Windows.Foundation", "Size", ClrAssembly.SystemRuntimeWindowsRuntime, ClrAssembly.SystemRuntimeWindowsRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "TimeSpan", "System", "TimeSpan", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, true),
			new ProjectedClass("Windows.Foundation", "Uri", "System", "Uri", ClrAssembly.SystemRuntime, ClrAssembly.SystemRuntime, false, false),

			new ProjectedClass("Windows.Foundation", "IClosable", "System", "IDisposable", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),

			new ProjectedClass("Windows.Foundation.Collections", "IIterable`1", "System.Collections.Generic", "IEnumerable`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IVector`1", "System.Collections.Generic", "IList`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IVectorView`1", "System.Collections.Generic", "IReadOnlyList`1", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IMap`2", "System.Collections.Generic", "IDictionary`2", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IMapView`2", "System.Collections.Generic", "IReadOnlyDictionary`2", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.Foundation.Collections", "IKeyValuePair`2", "System.Collections.Generic", "KeyValuePair`2", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, true),

			new ProjectedClass("Windows.UI.Xaml.Input", "ICommand", "System.Windows.Input", "ICommand", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),

			new ProjectedClass("Windows.UI.Xaml.Interop", "IBindableIterable", "System.Collections", "IEnumerable", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),
			new ProjectedClass("Windows.UI.Xaml.Interop", "IBindableVector", "System.Collections", "IList", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, false, false),

			new ProjectedClass("Windows.UI.Xaml.Interop", "INotifyCollectionChanged", "System.Collections.Specialized", "INotifyCollectionChanged", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Interop", "NotifyCollectionChangedEventHandler", "System.Collections.Specialized", "NotifyCollectionChangedEventHandler", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Interop", "NotifyCollectionChangedEventArgs", "System.Collections.Specialized", "NotifyCollectionChangedEventArgs", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Interop", "NotifyCollectionChangedAction", "System.Collections.Specialized", "NotifyCollectionChangedAction", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, true, true),

			new ProjectedClass("Windows.UI.Xaml.Data", "INotifyPropertyChanged", "System.ComponentModel", "INotifyPropertyChanged", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Data", "PropertyChangedEventHandler", "System.ComponentModel", "PropertyChangedEventHandler", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),
			new ProjectedClass("Windows.UI.Xaml.Data", "PropertyChangedEventArgs", "System.ComponentModel", "PropertyChangedEventArgs", ClrAssembly.SystemObjectModel, ClrAssembly.SystemObjectModel, false, false),

			new ProjectedClass("Windows.UI.Xaml", "CornerRadius", "Windows.UI.Xaml", "CornerRadius", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "Duration", "Windows.UI.Xaml", "Duration", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "DurationType", "Windows.UI.Xaml", "DurationType", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "GridLength", "Windows.UI.Xaml", "GridLength", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "GridUnitType", "Windows.UI.Xaml", "GridUnitType", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml", "Thickness", "Windows.UI.Xaml", "Thickness", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.UI.Xaml.Interop", "TypeName", "System", "Type", ClrAssembly.Mscorlib, ClrAssembly.SystemRuntime, true, false),

			new ProjectedClass("Windows.UI.Xaml.Controls.Primitives", "GeneratorPosition", "Windows.UI.Xaml.Controls.Primitives", "GeneratorPosition", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.UI.Xaml.Media", "Matrix", "Windows.UI.Xaml.Media", "Matrix", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.UI.Xaml.Media.Animation", "KeyTime", "Windows.UI.Xaml.Media.Animation", "KeyTime", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml.Media.Animation", "RepeatBehavior", "Windows.UI.Xaml.Media.Animation", "RepeatBehavior", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),
			new ProjectedClass("Windows.UI.Xaml.Media.Animation", "RepeatBehaviorType", "Windows.UI.Xaml.Media.Animation", "RepeatBehaviorType", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.UI.Xaml.Media.Media3D", "Matrix3D", "Windows.UI.Xaml.Media.Media3D", "Matrix3D", ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml, true, true),

			new ProjectedClass("Windows.Foundation.Numerics", "Vector2", "System.Numerics", "Vector2", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Vector3", "System.Numerics", "Vector3", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Vector4", "System.Numerics", "Vector4", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Matrix3x2", "System.Numerics", "Matrix3x2", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Matrix4x4", "System.Numerics", "Matrix4x4", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Plane", "System.Numerics", "Plane", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
			new ProjectedClass("Windows.Foundation.Numerics", "Quaternion", "System.Numerics", "Quaternion", ClrAssembly.SystemNumericsVectors, ClrAssembly.SystemNumericsVectors, true, true),
		};

		static readonly Dictionary<ClassName, ProjectedClass> winMDToCLR = new Dictionary<ClassName, ProjectedClass>();

		static WinMDHelpers() {
			foreach (var projClass in ProjectedClasses)
				winMDToCLR.Add(projClass.WinMDClass, projClass);
		}

		static AssemblyRef ToCLR(ModuleDef module, ref UTF8String ns, ref UTF8String name) {
			if (!winMDToCLR.TryGetValue(new ClassName(ns, name), out var pc))
				return null;

			ns = pc.ClrClass.Namespace;
			name = pc.ClrClass.Name;
			return CreateAssembly(module, pc.ContractAssembly);
		}

		static AssemblyRef CreateAssembly(ModuleDef module, ClrAssembly clrAsm) {
			var mscorlib = module?.CorLibTypes.AssemblyRef;
			var asm = new AssemblyRefUser(GetName(clrAsm), contractAsmVersion, new PublicKeyToken(GetPublicKeyToken(clrAsm)), UTF8String.Empty);

			if (mscorlib is not null && mscorlib.Name == mscorlibName && IsValidMscorlibVersion(mscorlib.Version))
				asm.Version = mscorlib.Version;
			if (module is ModuleDefMD mod) {
				Version ver = null;
				foreach (var asmRef in mod.GetAssemblyRefs()) {
					if (asmRef.IsContentTypeWindowsRuntime)
						continue;
					if (asmRef.Name != asm.Name)
						continue;
					if (asmRef.Culture != asm.Culture)
						continue;
					if (!PublicKeyBase.TokenEquals(asmRef.PublicKeyOrToken, asm.PublicKeyOrToken))
						continue;
					if (!IsValidMscorlibVersion(asmRef.Version))
						continue;

					if (ver is null || asmRef.Version > ver)
						ver = asmRef.Version;
				}
				if (ver is not null)
					asm.Version = ver;
			}

			return asm;
		}
		static readonly Version contractAsmVersion = new Version(4, 0, 0, 0);
		static readonly UTF8String mscorlibName = new UTF8String("mscorlib");

		// Silverlight uses 5.0.5.0
		static bool IsValidMscorlibVersion(Version version) => version is not null && (uint)version.Major <= 5;

		static UTF8String GetName(ClrAssembly clrAsm) =>
			clrAsm switch {
				ClrAssembly.Mscorlib => clrAsmName_Mscorlib,
				ClrAssembly.SystemNumericsVectors => clrAsmName_SystemNumericsVectors,
				ClrAssembly.SystemObjectModel => clrAsmName_SystemObjectModel,
				ClrAssembly.SystemRuntime => clrAsmName_SystemRuntime,
				ClrAssembly.SystemRuntimeInteropServicesWindowsRuntime => clrAsmName_SystemRuntimeInteropServicesWindowsRuntime,
				ClrAssembly.SystemRuntimeWindowsRuntime => clrAsmName_SystemRuntimeWindowsRuntime,
				ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml => clrAsmName_SystemRuntimeWindowsRuntimeUIXaml,
				_ => throw new InvalidOperationException(),
			};
		static readonly UTF8String clrAsmName_Mscorlib = new UTF8String("mscorlib");
		static readonly UTF8String clrAsmName_SystemNumericsVectors = new UTF8String("System.Numerics.Vectors");
		static readonly UTF8String clrAsmName_SystemObjectModel = new UTF8String("System.ObjectModel");
		static readonly UTF8String clrAsmName_SystemRuntime = new UTF8String("System.Runtime");
		static readonly UTF8String clrAsmName_SystemRuntimeInteropServicesWindowsRuntime = new UTF8String("System.Runtime.InteropServices.WindowsRuntime");
		static readonly UTF8String clrAsmName_SystemRuntimeWindowsRuntime = new UTF8String("System.Runtime.WindowsRuntime");
		static readonly UTF8String clrAsmName_SystemRuntimeWindowsRuntimeUIXaml = new UTF8String("System.Runtime.WindowsRuntime.UI.Xaml");

		static byte[] GetPublicKeyToken(ClrAssembly clrAsm) =>
			clrAsm switch {
				ClrAssembly.Mscorlib => neutralPublicKey,
				ClrAssembly.SystemNumericsVectors => contractPublicKeyToken,
				ClrAssembly.SystemObjectModel => contractPublicKeyToken,
				ClrAssembly.SystemRuntime => contractPublicKeyToken,
				ClrAssembly.SystemRuntimeInteropServicesWindowsRuntime => contractPublicKeyToken,
				ClrAssembly.SystemRuntimeWindowsRuntime => neutralPublicKey,
				ClrAssembly.SystemRuntimeWindowsRuntimeUIXaml => neutralPublicKey,
				_ => throw new InvalidOperationException(),
			};
		static readonly byte[] contractPublicKeyToken = new byte[] { 0xB0, 0x3F, 0x5F, 0x7F, 0x11, 0xD5, 0x0A, 0x3A };
		static readonly byte[] neutralPublicKey = new byte[] { 0xb7, 0x7a, 0x5c, 0x56, 0x19, 0x34, 0xe0, 0x89 };

		/// <summary>
		/// Converts WinMD type <paramref name="td"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="td">Type</param>
		/// <returns></returns>
		public static TypeRef ToCLR(ModuleDef module, TypeDef td) => ToCLR(module, td, out bool isClrValueType);

		/// <summary>
		/// Converts WinMD type <paramref name="td"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="td">Type</param>
		/// <param name="isClrValueType"><c>true</c> if the returned type is a value type</param>
		/// <returns></returns>
		public static TypeRef ToCLR(ModuleDef module, TypeDef td, out bool isClrValueType) {
			isClrValueType = false;
			if (td is null || !td.IsWindowsRuntime)
				return null;
			var asm = td.DefinitionAssembly;
			if (asm is null || !asm.IsContentTypeWindowsRuntime)
				return null;

			if (!winMDToCLR.TryGetValue(new ClassName(td.Namespace, td.Name), out var pc))
				return null;

			isClrValueType = pc.ClrClass.IsValueType;
			return new TypeRefUser(module, pc.ClrClass.Namespace, pc.ClrClass.Name, CreateAssembly(module, pc.ContractAssembly));
		}

		/// <summary>
		/// Converts WinMD type <paramref name="tr"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="tr">Type</param>
		/// <returns></returns>
		public static TypeRef ToCLR(ModuleDef module, TypeRef tr) => ToCLR(module, tr, out bool isClrValueType);

		/// <summary>
		/// Converts WinMD type <paramref name="tr"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="tr">Type</param>
		/// <param name="isClrValueType"><c>true</c> if the returned type is a value type</param>
		/// <returns></returns>
		public static TypeRef ToCLR(ModuleDef module, TypeRef tr, out bool isClrValueType) {
			isClrValueType = false;
			if (tr is null)
				return null;
			var defAsm = tr.DefinitionAssembly;
			if (defAsm is null || !defAsm.IsContentTypeWindowsRuntime)
				return null;
			if (tr.DeclaringType is not null)
				return null;

			if (!winMDToCLR.TryGetValue(new ClassName(tr.Namespace, tr.Name), out var pc))
				return null;

			isClrValueType = pc.ClrClass.IsValueType;
			return new TypeRefUser(module, pc.ClrClass.Namespace, pc.ClrClass.Name, CreateAssembly(module, pc.ContractAssembly));
		}

		/// <summary>
		/// Converts WinMD type <paramref name="et"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="et">Type</param>
		/// <returns></returns>
		public static ExportedType ToCLR(ModuleDef module, ExportedType et) {
			if (et is null)
				return null;
			var defAsm = et.DefinitionAssembly;
			if (defAsm is null || !defAsm.IsContentTypeWindowsRuntime)
				return null;
			if (et.DeclaringType is not null)
				return null;

			if (!winMDToCLR.TryGetValue(new ClassName(et.TypeNamespace, et.TypeName), out var pc))
				return null;

			return new ExportedTypeUser(module, 0, pc.ClrClass.Namespace, pc.ClrClass.Name, et.Attributes, CreateAssembly(module, pc.ContractAssembly));
		}

		/// <summary>
		/// Converts WinMD type <paramref name="ts"/> to a CLR type. Returns <c>null</c>
		/// if it's not a CLR compatible WinMD type.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="ts">Type</param>
		/// <returns></returns>
		public static TypeSig ToCLR(ModuleDef module, TypeSig ts) {
			if (ts is null)
				return null;
			var et = ts.ElementType;
			if (et != ElementType.Class && et != ElementType.ValueType)
				return null;

			var tdr = ((ClassOrValueTypeSig)ts).TypeDefOrRef;

			TypeRef tr, newTr;
			bool isClrValueType;
			if (tdr is TypeDef td) {
				newTr = ToCLR(module, td, out isClrValueType);
				if (newTr is null)
					return null;
			}
			else if ((tr = tdr as TypeRef) is not null) {
				newTr = ToCLR(module, tr, out isClrValueType);
				if (newTr is null)
					return null;
			}
			else
				return null;

			return isClrValueType ?
				(TypeSig)new ValueTypeSig(newTr) :
				new ClassSig(newTr);
		}

		/// <summary>
		/// Converts WinMD member reference <paramref name="mr"/> to a CLR member reference. Returns
		/// <c>null</c> if it's not a CLR compatible WinMD member reference.
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="mr">Member reference</param>
		/// <returns></returns>
		public static MemberRef ToCLR(ModuleDef module, MemberRef mr) {
			// See WinMDAdapter::CheckIfMethodImplImplementsARedirectedInterface
			// in coreclr: md/winmd/adapter.cpp
			if (mr is null)
				return null;
			if (mr.Name != CloseName)
				return null;

			var msig = mr.MethodSig;
			if (msig is null)
				return null;

			var cl = mr.Class;
			IMemberRefParent newCl;
			TypeSpec ts;
			if (cl is TypeRef tr) {
				var newTr = ToCLR(module, tr);
				if (newTr is null || !IsIDisposable(newTr))
					return null;

				newCl = newTr;
			}
			else if ((ts = cl as TypeSpec) is not null) {
				var gis = ts.TypeSig as GenericInstSig;
				if (gis is null || !(gis.GenericType is ClassSig))
					return null;
				tr = gis.GenericType.TypeRef;
				if (tr is null)
					return null;

				var newTr = ToCLR(module, tr, out bool isClrValueType);
				if (newTr is null || !IsIDisposable(newTr))
					return null;

				newCl = new TypeSpecUser(new GenericInstSig(isClrValueType ?
								(ClassOrValueTypeSig)new ValueTypeSig(newTr) :
								new ClassSig(newTr), gis.GenericArguments));
			}
			else
				return null;

			return new MemberRefUser(mr.Module, DisposeName, msig, newCl);
		}
		static readonly UTF8String CloseName = new UTF8String("Close");
		static readonly UTF8String DisposeName = new UTF8String("Dispose");

		static bool IsIDisposable(TypeRef tr) => tr.Name == IDisposableName && tr.Namespace == IDisposableNamespace;
		static readonly UTF8String IDisposableNamespace = new UTF8String("System");
		static readonly UTF8String IDisposableName = new UTF8String("IDisposable");

		/// <summary>
		/// Converts WinMD method <paramref name="md"/> to a CLR member reference. Returns
		/// <c>null</c> if it's not a CLR compatible WinMD method
		/// </summary>
		/// <param name="module">Owner module or <c>null</c></param>
		/// <param name="md">Method</param>
		/// <returns></returns>
		public static MemberRef ToCLR(ModuleDef module, MethodDef md) {
			if (md is null)
				return null;
			if (md.Name != CloseName)
				return null;
			var declType = md.DeclaringType;
			if (declType is null)
				return null;

			var tr = ToCLR(module, declType);
			if (tr is null || !IsIDisposable(tr))
				return null;

			return new MemberRefUser(md.Module, DisposeName, md.MethodSig, tr);
		}
	}
}




namespace dnlib.DotNet {
	/// <summary>
	/// WinMD status
	/// </summary>
	public enum WinMDStatus {
		/// <summary>
		/// This is not a WinMD file
		/// </summary>
		None,

		/// <summary>
		/// This is a pure WinMD file (not managed)
		/// </summary>
		Pure,

		/// <summary>
		/// This is a managed WinMD file (created by eg. winmdexp.exe)
		/// </summary>
		Managed,
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Returns types without getting stuck in an infinite loop
	/// </summary>
	readonly struct AllTypesHelper {
		/// <summary>
		/// Gets a list of all types and nested types
		/// </summary>
		/// <param name="types">A list of types</param>
		public static IEnumerable<TypeDef> Types(IEnumerable<TypeDef> types) {
			var visited = new Dictionary<TypeDef, bool>();
			var stack = new Stack<IEnumerator<TypeDef>>();
			if (types is not null)
				stack.Push(types.GetEnumerator());
			while (stack.Count > 0) {
				var enumerator = stack.Pop();
				while (enumerator.MoveNext()) {
					var type = enumerator.Current;
					if (visited.ContainsKey(type))
						continue;
					visited[type] = true;
					yield return type;
					if (type.NestedTypes.Count > 0) {
						stack.Push(enumerator);
						enumerator = type.NestedTypes.GetEnumerator();
					}
				}
			}
		}
	}
}





namespace dnlib.DotNet {
	/// <summary>
	/// Assembly flags from Assembly.Flags column.
	/// </summary>
	/// <remarks>See CorHdr.h/CorAssemblyFlags</remarks>
	[Flags]
	public enum AssemblyAttributes : uint {
		/// <summary>No flags set</summary>
		None						= 0,

		/// <summary>The assembly ref holds the full (unhashed) public key.</summary>
		PublicKey					= 1,

		/// <summary>Processor Architecture unspecified</summary>
		PA_None						= 0x0000,
		/// <summary>Processor Architecture: neutral (PE32)</summary>
		PA_MSIL						= 0x0010,
		/// <summary>Processor Architecture: x86 (PE32)</summary>
		PA_x86						= 0x0020,
		/// <summary>Processor Architecture: Itanium (PE32+)</summary>
		PA_IA64						= 0x0030,
		/// <summary>Processor Architecture: AMD X64 (PE32+)</summary>
		PA_AMD64					= 0x0040,
		/// <summary>Processor Architecture: ARM (PE32)</summary>
		PA_ARM						= 0x0050,
		/// <summary>Processor Architecture: ARM64 (PE32+)</summary>
		PA_ARM64					= 0x0060,
		/// <summary>applies to any platform but cannot run on any (e.g. reference assembly), should not have "specified" set</summary>
		PA_NoPlatform				= 0x0070,
		/// <summary>Propagate PA flags to AssemblyRef record</summary>
		PA_Specified				= 0x0080,
		/// <summary>Bits describing the processor architecture</summary>
		PA_Mask						= 0x0070,
		/// <summary>Bits describing the PA incl. Specified</summary>
		PA_FullMask					= 0x00F0,
		/// <summary>NOT A FLAG, shift count in PA flags &lt;--&gt; index conversion</summary>
		PA_Shift					= 0x0004,

		/// <summary>From "DebuggableAttribute".</summary>
		EnableJITcompileTracking	= 0x8000,
		/// <summary>From "DebuggableAttribute".</summary>
		DisableJITcompileOptimizer	= 0x4000,

		/// <summary>The assembly can be retargeted (at runtime) to an assembly from a different publisher.</summary>
		Retargetable				= 0x0100,

		/// <summary/>
		ContentType_Default			= 0x0000,
		/// <summary/>
		ContentType_WindowsRuntime	= 0x0200,
		/// <summary>Bits describing ContentType</summary>
		ContentType_Mask			= 0x0E00,
	}
}




namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class Extensions {
	}
}




namespace dnlib.DotNet.Emit {
	/// <summary>
	/// CIL opcode flow control
	/// </summary>
	public enum FlowControl {
		/// <summary/>
		Branch,
		/// <summary/>
		Break,
		/// <summary/>
		Call,
		/// <summary/>
		Cond_Branch,
		/// <summary/>
		Meta,
		/// <summary/>
		Next,
		/// <summary/>
		Phi,
		/// <summary/>
		Return,
		/// <summary/>
		Throw,
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A CIL instruction (opcode + operand)
	/// </summary>
	public sealed class Instruction {
		/// <summary>
		/// The opcode
		/// </summary>
		public OpCode OpCode;

		/// <summary>
		/// The opcode operand
		/// </summary>
		public object Operand;

		/// <summary>
		/// Offset of the instruction in the method body
		/// </summary>
		public uint Offset;

		/// <summary>
		/// PDB sequence point or <c>null</c> if none
		/// </summary>
		public SequencePoint SequencePoint;

		/// <summary>
		/// Default constructor
		/// </summary>
		public Instruction() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opCode">Opcode</param>
		public Instruction(OpCode opCode) => OpCode = opCode;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opCode">Opcode</param>
		/// <param name="operand">The operand</param>
		public Instruction(OpCode opCode, object operand) {
			OpCode = opCode;
			Operand = operand;
		}

		/// <summary>
		/// Creates a new instruction with no operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode) {
			if (opCode.OperandType != OperandType.InlineNone)
				throw new ArgumentException("Must be a no-operand opcode", nameof(opCode));
			return new Instruction(opCode);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="byte"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, byte value) {
			if (opCode.Code != Code.Unaligned)
				throw new ArgumentException("Opcode does not have a byte operand", nameof(opCode));
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="sbyte"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, sbyte value) {
			if (opCode.Code != Code.Ldc_I4_S)
				throw new ArgumentException("Opcode does not have a sbyte operand", nameof(opCode));
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with an <see cref="int"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, int value) {
			if (opCode.OperandType != OperandType.InlineI)
				throw new ArgumentException("Opcode does not have an int32 operand", nameof(opCode));
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="long"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, long value) {
			if (opCode.OperandType != OperandType.InlineI8)
				throw new ArgumentException("Opcode does not have an int64 operand", nameof(opCode));
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="float"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, float value) {
			if (opCode.OperandType != OperandType.ShortInlineR)
				throw new ArgumentException("Opcode does not have a real4 operand", nameof(opCode));
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a <see cref="double"/> operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, double value) {
			if (opCode.OperandType != OperandType.InlineR)
				throw new ArgumentException("Opcode does not have a real8 operand", nameof(opCode));
			return new Instruction(opCode, value);
		}

		/// <summary>
		/// Creates a new instruction with a string operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="s">The string</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, string s) {
			if (opCode.OperandType != OperandType.InlineString)
				throw new ArgumentException("Opcode does not have a string operand", nameof(opCode));
			return new Instruction(opCode, s);
		}

		/// <summary>
		/// Creates a new instruction with an instruction target operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="target">Target instruction</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, Instruction target) {
			if (opCode.OperandType != OperandType.ShortInlineBrTarget && opCode.OperandType != OperandType.InlineBrTarget)
				throw new ArgumentException("Opcode does not have an instruction operand", nameof(opCode));
			return new Instruction(opCode, target);
		}

		/// <summary>
		/// Creates a new instruction with an instruction target list operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="targets">The targets</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, IList<Instruction> targets) {
			if (opCode.OperandType != OperandType.InlineSwitch)
				throw new ArgumentException("Opcode does not have a targets array operand", nameof(opCode));
			return new Instruction(opCode, targets);
		}

		/// <summary>
		/// Creates a new instruction with a type operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="type">The type</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, ITypeDefOrRef type) {
			if (opCode.OperandType != OperandType.InlineType && opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a type operand", nameof(opCode));
			return new Instruction(opCode, type);
		}

		/// <summary>
		/// Creates a new instruction with a type operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="type">The type</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, CorLibTypeSig type) => Create(opCode, type.TypeDefOrRef);

		/// <summary>
		/// Creates a new instruction with a method/field operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="mr">The method/field</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, MemberRef mr) {
			if (opCode.OperandType != OperandType.InlineField && opCode.OperandType != OperandType.InlineMethod && opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a field operand", nameof(opCode));
			return new Instruction(opCode, mr);
		}

		/// <summary>
		/// Creates a new instruction with a field operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="field">The field</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, IField field) {
			if (opCode.OperandType != OperandType.InlineField && opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a field operand", nameof(opCode));
			return new Instruction(opCode, field);
		}

		/// <summary>
		/// Creates a new instruction with a method operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="method">The method</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, IMethod method) {
			if (opCode.OperandType != OperandType.InlineMethod && opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a method operand", nameof(opCode));
			return new Instruction(opCode, method);
		}

		/// <summary>
		/// Creates a new instruction with a token operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="token">The token</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, ITokenOperand token) {
			if (opCode.OperandType != OperandType.InlineTok)
				throw new ArgumentException("Opcode does not have a token operand", nameof(opCode));
			return new Instruction(opCode, token);
		}

		/// <summary>
		/// Creates a new instruction with a method signature operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="methodSig">The method signature</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, MethodSig methodSig) {
			if (opCode.OperandType != OperandType.InlineSig)
				throw new ArgumentException("Opcode does not have a method sig operand", nameof(opCode));
			return new Instruction(opCode, methodSig);
		}

		/// <summary>
		/// Creates a new instruction with a method parameter operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="parameter">The method parameter</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, Parameter parameter) {
			if (opCode.OperandType != OperandType.ShortInlineVar && opCode.OperandType != OperandType.InlineVar)
				throw new ArgumentException("Opcode does not have a method parameter operand", nameof(opCode));
			return new Instruction(opCode, parameter);
		}

		/// <summary>
		/// Creates a new instruction with a method local operand
		/// </summary>
		/// <param name="opCode">The opcode</param>
		/// <param name="local">The method local</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction Create(OpCode opCode, Local local) {
			if (opCode.OperandType != OperandType.ShortInlineVar && opCode.OperandType != OperandType.InlineVar)
				throw new ArgumentException("Opcode does not have a method local operand", nameof(opCode));
			return new Instruction(opCode, local);
		}

		/// <summary>
		/// Creates a <c>ldci4</c> instruction
		/// </summary>
		/// <param name="value">Operand value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public static Instruction CreateLdcI4(int value) {
			switch (value) {
			case -1:return OpCodes.Ldc_I4_M1.ToInstruction();
			case 0: return OpCodes.Ldc_I4_0.ToInstruction();
			case 1: return OpCodes.Ldc_I4_1.ToInstruction();
			case 2: return OpCodes.Ldc_I4_2.ToInstruction();
			case 3: return OpCodes.Ldc_I4_3.ToInstruction();
			case 4: return OpCodes.Ldc_I4_4.ToInstruction();
			case 5: return OpCodes.Ldc_I4_5.ToInstruction();
			case 6: return OpCodes.Ldc_I4_6.ToInstruction();
			case 7: return OpCodes.Ldc_I4_7.ToInstruction();
			case 8: return OpCodes.Ldc_I4_8.ToInstruction();
			}
			if (sbyte.MinValue <= value && value <= sbyte.MaxValue)
				return new Instruction(OpCodes.Ldc_I4_S, (sbyte)value);
			return new Instruction(OpCodes.Ldc_I4, value);
		}

		/// <summary>
		/// Gets the size in bytes of the instruction
		/// </summary>
		/// <returns></returns>
		public int GetSize() {
			var opCode = OpCode;
			switch (opCode.OperandType) {
			case OperandType.InlineBrTarget:
			case OperandType.InlineField:
			case OperandType.InlineI:
			case OperandType.InlineMethod:
			case OperandType.InlineSig:
			case OperandType.InlineString:
			case OperandType.InlineTok:
			case OperandType.InlineType:
			case OperandType.ShortInlineR:
				return opCode.Size + 4;

			case OperandType.InlineI8:
			case OperandType.InlineR:
				return opCode.Size + 8;

			case OperandType.InlineNone:
			case OperandType.InlinePhi:
			default:
				return opCode.Size;

			case OperandType.InlineSwitch:
				var targets = Operand as IList<Instruction>;
				return opCode.Size + 4 + (targets is null ? 0 : targets.Count * 4);

			case OperandType.InlineVar:
				return opCode.Size + 2;

			case OperandType.ShortInlineBrTarget:
			case OperandType.ShortInlineI:
			case OperandType.ShortInlineVar:
				return opCode.Size + 1;
			}
		}

		static bool IsSystemVoid(TypeSig type) => type.RemovePinnedAndModifiers().GetElementType() == ElementType.Void;

		/// <summary>
		/// Updates <paramref name="stack"/> with the new stack size
		/// </summary>
		/// <param name="stack">Current stack size</param>
		public void UpdateStack(ref int stack) => UpdateStack(ref stack, false);

		/// <summary>
		/// Updates <paramref name="stack"/> with the new stack size
		/// </summary>
		/// <param name="stack">Current stack size</param>
		/// <param name="methodHasReturnValue"><c>true</c> if the method has a return value,
		/// <c>false</c> otherwise</param>
		public void UpdateStack(ref int stack, bool methodHasReturnValue) {
			CalculateStackUsage(methodHasReturnValue, out int pushes, out int pops);
			if (pops == -1)
				stack = 0;
			else
				stack += pushes - pops;
		}

		/// <summary>
		/// Calculates stack usage
		/// </summary>
		/// <param name="pushes">Updated with number of stack pushes</param>
		/// <param name="pops">Updated with number of stack pops or <c>-1</c> if the stack should
		/// be cleared.</param>
		public void CalculateStackUsage(out int pushes, out int pops) => CalculateStackUsage(false, out pushes, out pops);

		/// <summary>
		/// Calculates stack usage
		/// </summary>
		/// <param name="methodHasReturnValue"><c>true</c> if method has a return value</param>
		/// <param name="pushes">Updated with number of stack pushes</param>
		/// <param name="pops">Updated with number of stack pops or <c>-1</c> if the stack should
		/// be cleared.</param>
		public void CalculateStackUsage(bool methodHasReturnValue, out int pushes, out int pops) {
			var opCode = OpCode;
			if (opCode.FlowControl == FlowControl.Call)
				CalculateStackUsageCall(opCode.Code, out pushes, out pops);
			else
				CalculateStackUsageNonCall(opCode, methodHasReturnValue, out pushes, out pops);
		}

		void CalculateStackUsageCall(Code code, out int pushes, out int pops) {
			pushes = 0;
			pops = 0;

			// It doesn't push or pop anything. The stack should be empty when JMP is executed.
			if (code == Code.Jmp)
				return;

			MethodSig sig;
			var op = Operand;
			if (op is IMethod method)
				sig = method.MethodSig;
			else
				sig = op as MethodSig;	// calli instruction
			if (sig is null)
				return;
			bool implicitThis = sig.ImplicitThis;
			if (!IsSystemVoid(sig.RetType) || (code == Code.Newobj && sig.HasThis))
				pushes++;

			pops += sig.Params.Count;
			var paramsAfterSentinel = sig.ParamsAfterSentinel;
			if (paramsAfterSentinel is not null)
				pops += paramsAfterSentinel.Count;
			if (implicitThis && code != Code.Newobj)
				pops++;
			if (code == Code.Calli)
				pops++;
		}

		void CalculateStackUsageNonCall(OpCode opCode, bool hasReturnValue, out int pushes, out int pops) {
			switch (opCode.StackBehaviourPush) {
			case StackBehaviour.Push0:
				pushes = 0;
				break;

			case StackBehaviour.Push1:
			case StackBehaviour.Pushi:
			case StackBehaviour.Pushi8:
			case StackBehaviour.Pushr4:
			case StackBehaviour.Pushr8:
			case StackBehaviour.Pushref:
				pushes = 1;
				break;

			case StackBehaviour.Push1_push1:
				pushes = 2;
				break;

			case StackBehaviour.Varpush:	// only call, calli, callvirt which are handled elsewhere
			default:
				pushes = 0;
				break;
			}

			switch (opCode.StackBehaviourPop) {
			case StackBehaviour.Pop0:
				pops = 0;
				break;

			case StackBehaviour.Pop1:
			case StackBehaviour.Popi:
			case StackBehaviour.Popref:
				pops = 1;
				break;

			case StackBehaviour.Pop1_pop1:
			case StackBehaviour.Popi_pop1:
			case StackBehaviour.Popi_popi:
			case StackBehaviour.Popi_popi8:
			case StackBehaviour.Popi_popr4:
			case StackBehaviour.Popi_popr8:
			case StackBehaviour.Popref_pop1:
			case StackBehaviour.Popref_popi:
				pops = 2;
				break;

			case StackBehaviour.Popi_popi_popi:
			case StackBehaviour.Popref_popi_popi:
			case StackBehaviour.Popref_popi_popi8:
			case StackBehaviour.Popref_popi_popr4:
			case StackBehaviour.Popref_popi_popr8:
			case StackBehaviour.Popref_popi_popref:
			case StackBehaviour.Popref_popi_pop1:
				pops = 3;
				break;

			case StackBehaviour.PopAll:
				pops = -1;
				break;

			case StackBehaviour.Varpop:	// call, calli, callvirt, newobj (all handled elsewhere), and ret
				if (hasReturnValue)
					pops = 1;
				else
					pops = 0;
				break;

			default:
				pops = 0;
				break;
			}
		}

		/// <summary>
		/// Checks whether it's one of the <c>leave</c> instructions
		/// </summary>
		public bool IsLeave() => OpCode == OpCodes.Leave || OpCode == OpCodes.Leave_S;

		/// <summary>
		/// Checks whether it's one of the <c>br</c> instructions
		/// </summary>
		public bool IsBr() => OpCode == OpCodes.Br || OpCode == OpCodes.Br_S;

		/// <summary>
		/// Checks whether it's one of the <c>brfalse</c> instructions
		/// </summary>
		public bool IsBrfalse() => OpCode == OpCodes.Brfalse || OpCode == OpCodes.Brfalse_S;

		/// <summary>
		/// Checks whether it's one of the <c>brtrue</c> instructions
		/// </summary>
		public bool IsBrtrue() => OpCode == OpCodes.Brtrue || OpCode == OpCodes.Brtrue_S;

		/// <summary>
		/// Checks whether it's one of the conditional branch instructions (bcc, brtrue, brfalse)
		/// </summary>
		public bool IsConditionalBranch() {
			switch (OpCode.Code) {
			case Code.Bge:
			case Code.Bge_S:
			case Code.Bge_Un:
			case Code.Bge_Un_S:
			case Code.Blt:
			case Code.Blt_S:
			case Code.Blt_Un:
			case Code.Blt_Un_S:
			case Code.Bgt:
			case Code.Bgt_S:
			case Code.Bgt_Un:
			case Code.Bgt_Un_S:
			case Code.Ble:
			case Code.Ble_S:
			case Code.Ble_Un:
			case Code.Ble_Un_S:
			case Code.Brfalse:
			case Code.Brfalse_S:
			case Code.Brtrue:
			case Code.Brtrue_S:
			case Code.Beq:
			case Code.Beq_S:
			case Code.Bne_Un:
			case Code.Bne_Un_S:
				return true;

			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether this is one of the <c>ldc.i4</c> instructions
		/// </summary>
		public bool IsLdcI4() {
			switch (OpCode.Code) {
			case Code.Ldc_I4_M1:
			case Code.Ldc_I4_0:
			case Code.Ldc_I4_1:
			case Code.Ldc_I4_2:
			case Code.Ldc_I4_3:
			case Code.Ldc_I4_4:
			case Code.Ldc_I4_5:
			case Code.Ldc_I4_6:
			case Code.Ldc_I4_7:
			case Code.Ldc_I4_8:
			case Code.Ldc_I4_S:
			case Code.Ldc_I4:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Returns a <c>ldc.i4</c> instruction's operand
		/// </summary>
		/// <returns>The integer value</returns>
		/// <exception cref="InvalidOperationException"><see cref="OpCode"/> isn't one of the
		/// <c>ldc.i4</c> opcodes</exception>
		public int GetLdcI4Value() =>
			OpCode.Code switch {
				Code.Ldc_I4_M1 => -1,
				Code.Ldc_I4_0 => 0,
				Code.Ldc_I4_1 => 1,
				Code.Ldc_I4_2 => 2,
				Code.Ldc_I4_3 => 3,
				Code.Ldc_I4_4 => 4,
				Code.Ldc_I4_5 => 5,
				Code.Ldc_I4_6 => 6,
				Code.Ldc_I4_7 => 7,
				Code.Ldc_I4_8 => 8,
				Code.Ldc_I4_S => (sbyte)Operand,
				Code.Ldc_I4 => (int)Operand,
				_ => throw new InvalidOperationException($"Not a ldc.i4 instruction: {this}"),
			};

		/// <summary>
		/// Checks whether it's one of the <c>ldarg</c> instructions, but does <c>not</c> check
		/// whether it's one of the <c>ldarga</c> instructions.
		/// </summary>
		public bool IsLdarg() {
			switch (OpCode.Code) {
			case Code.Ldarg:
			case Code.Ldarg_S:
			case Code.Ldarg_0:
			case Code.Ldarg_1:
			case Code.Ldarg_2:
			case Code.Ldarg_3:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether it's one of the <c>ldloc</c> instructions, but does <c>not</c> check
		/// whether it's one of the <c>ldloca</c> instructions.
		/// </summary>
		public bool IsLdloc() {
			switch (OpCode.Code) {
			case Code.Ldloc:
			case Code.Ldloc_0:
			case Code.Ldloc_1:
			case Code.Ldloc_2:
			case Code.Ldloc_3:
			case Code.Ldloc_S:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether it's one of the <c>starg</c> instructions
		/// </summary>
		public bool IsStarg() {
			switch (OpCode.Code) {
			case Code.Starg:
			case Code.Starg_S:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks whether it's one of the <c>stloc</c> instructions
		/// </summary>
		public bool IsStloc() {
			switch (OpCode.Code) {
			case Code.Stloc:
			case Code.Stloc_0:
			case Code.Stloc_1:
			case Code.Stloc_2:
			case Code.Stloc_3:
			case Code.Stloc_S:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Returns the local if it's a <c>ldloc</c>, <c>stloc</c> or <c>ldloca</c> instruction
		/// </summary>
		/// <param name="locals">The locals</param>
		/// <returns>The local or <c>null</c> if it's not a <c>ldloc</c>, <c>stloc</c> or <c>ldloca</c>
		/// instruction or if the local doesn't exist.</returns>
		public Local GetLocal(IList<Local> locals) {
			int index;
			var code = OpCode.Code;
			switch (code) {
			case Code.Ldloc:
			case Code.Ldloc_S:
			case Code.Stloc:
			case Code.Stloc_S:
			case Code.Ldloca:
			case Code.Ldloca_S:
				return Operand as Local;

			case Code.Ldloc_0:
			case Code.Ldloc_1:
			case Code.Ldloc_2:
			case Code.Ldloc_3:
				index = code - Code.Ldloc_0;
				break;

			case Code.Stloc_0:
			case Code.Stloc_1:
			case Code.Stloc_2:
			case Code.Stloc_3:
				index = code - Code.Stloc_0;
				break;

			default:
				return null;
			}

			if ((uint)index < (uint)locals.Count)
				return locals[index];
			return null;
		}

		/// <summary>
		/// Gets the index of the instruction's parameter operand or <c>-1</c> if the parameter
		/// is missing or if it's not an instruction with a parameter operand.
		/// </summary>
		public int GetParameterIndex() {
			switch (OpCode.Code) {
			case Code.Ldarg_0: return 0;
			case Code.Ldarg_1: return 1;
			case Code.Ldarg_2: return 2;
			case Code.Ldarg_3: return 3;

			case Code.Starg:
			case Code.Starg_S:
			case Code.Ldarga:
			case Code.Ldarga_S:
			case Code.Ldarg:
			case Code.Ldarg_S:
				var parameter = Operand as Parameter;
				if (parameter is not null)
					return parameter.Index;
				break;
			}

			return -1;
		}

		/// <summary>
		/// Returns a method parameter
		/// </summary>
		/// <param name="parameters">All parameters</param>
		/// <returns>A parameter or <c>null</c> if it doesn't exist</returns>
		public Parameter GetParameter(IList<Parameter> parameters) {
			int i = GetParameterIndex();
			if ((uint)i < (uint)parameters.Count)
				return parameters[i];
			return null;
		}

		/// <summary>
		/// Returns an argument type
		/// </summary>
		/// <param name="methodSig">Method signature</param>
		/// <param name="declaringType">Declaring type (only needed if it's an instance method)</param>
		/// <returns>The type or <c>null</c> if it doesn't exist</returns>
		public TypeSig GetArgumentType(MethodSig methodSig, ITypeDefOrRef declaringType) {
			if (methodSig is null)
				return null;
			int index = GetParameterIndex();
			if (index == 0 && methodSig.ImplicitThis)
				return declaringType?.IsValueType == true ? new ByRefSig(declaringType.ToTypeSig()) : declaringType.ToTypeSig();
			if (methodSig.ImplicitThis)
				index--;
			if ((uint)index < (uint)methodSig.Params.Count)
				return methodSig.Params[index];
			return null;
		}

		/// <summary>
		/// Clone this instance. The <see cref="Operand"/> and <see cref="SequencePoint"/> fields
		/// are shared by this instance and the created instance.
		/// </summary>
		public Instruction Clone() =>
			new Instruction {
				Offset = Offset,
				OpCode = OpCode,
				Operand = Operand,
				SequencePoint = SequencePoint,
			};

		/// <inheritdoc/>
		public override string ToString() => InstructionPrinter.ToString(this);
	}

	static partial class Extensions {
		/// <summary>
		/// Gets the opcode or <see cref="OpCodes.UNKNOWN1"/> if <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static OpCode GetOpCode(this Instruction self) => self?.OpCode ?? OpCodes.UNKNOWN1;

		/// <summary>
		/// Gets the operand or <c>null</c> if <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static object GetOperand(this Instruction self) => self?.Operand;

		/// <summary>
		/// Gets the offset or 0 if <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static uint GetOffset(this Instruction self) => self?.Offset ?? 0;

		/// <summary>
		/// Gets the sequence point or <c>null</c> if <paramref name="self"/> is <c>null</c>
		/// </summary>
		/// <param name="self">this</param>
		/// <returns></returns>
		public static dnlib.DotNet.Pdb.SequencePoint GetSequencePoint(this Instruction self) => self?.SequencePoint;
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Converts instructions to strings
	/// </summary>
	public static class InstructionPrinter {
		/// <summary>
		/// Converts an instruction to a string
		/// </summary>
		/// <param name="instr">The instruction</param>
		/// <returns>The result</returns>
		public static string ToString(Instruction instr) {
			if (instr is null)
				return string.Empty;

			var sb = new StringBuilder();

			sb.Append($"IL_{instr.Offset:X4}: ");
			sb.Append(instr.OpCode.Name);
			AddOperandString(sb, instr, " ");

			return sb.ToString();
		}

		/// <summary>
		/// Gets the instruction's operand as a string
		/// </summary>
		/// <param name="instr">The instruction</param>
		/// <returns>The operand as a string</returns>
		public static string GetOperandString(Instruction instr) {
			var sb = new StringBuilder();
			AddOperandString(sb, instr, string.Empty);
			return sb.ToString();
		}

		/// <summary>
		/// Add an instruction's operand to <paramref name="sb"/>
		/// </summary>
		/// <param name="sb">Place result here</param>
		/// <param name="instr">The instruction</param>
		public static void AddOperandString(StringBuilder sb, Instruction instr) => AddOperandString(sb, instr, string.Empty);

		/// <summary>
		/// Add an instruction's operand to <paramref name="sb"/>
		/// </summary>
		/// <param name="sb">Place result here</param>
		/// <param name="instr">The instruction</param>
		/// <param name="extra">A string that will be added before the operand, if there's
		/// an operand.</param>
		public static void AddOperandString(StringBuilder sb, Instruction instr, string extra) {
			var op = instr.Operand;
			switch (instr.OpCode.OperandType) {
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				sb.Append(extra);
				AddInstructionTarget(sb, op as Instruction);
				break;

			case OperandType.InlineField:
			case OperandType.InlineMethod:
			case OperandType.InlineTok:
			case OperandType.InlineType:
				sb.Append(extra);
				if (op is IFullName)
					sb.Append((op as IFullName).FullName);
				else if (op is not null)
					sb.Append(op.ToString());
				else
					sb.Append("null");
				break;

			case OperandType.InlineI:
			case OperandType.InlineI8:
			case OperandType.InlineR:
			case OperandType.ShortInlineI:
			case OperandType.ShortInlineR:
				sb.Append($"{extra}{op}");
				break;

			case OperandType.InlineSig:
				sb.Append(extra);
				sb.Append(FullNameFactory.MethodFullName(null, (UTF8String)null, op as MethodSig, null, null, null, null));
				break;

			case OperandType.InlineString:
				sb.Append(extra);
				EscapeString(sb, op as string, true);
				break;

			case OperandType.InlineSwitch:
				var targets = op as IList<Instruction>;
				if (targets is null)
					sb.Append("null");
				else {
					sb.Append('(');
					for (int i = 0; i < targets.Count; i++) {
						if (i != 0)
							sb.Append(',');
						AddInstructionTarget(sb, targets[i]);
					}
					sb.Append(')');
				}
				break;

			case OperandType.InlineVar:
			case OperandType.ShortInlineVar:
				sb.Append(extra);
				if (op is null)
					sb.Append("null");
				else
					sb.Append(op.ToString());
				break;

			case OperandType.InlineNone:
			case OperandType.InlinePhi:
			default:
				break;
			}
		}

		static void AddInstructionTarget(StringBuilder sb, Instruction targetInstr) {
			if (targetInstr is null)
				sb.Append("null");
			else
				sb.Append($"IL_{targetInstr.Offset:X4}");
		}

		static void EscapeString(StringBuilder sb, string s, bool addQuotes) {
			if (s is null) {
				sb.Append("null");
				return;
			}

			if (addQuotes)
				sb.Append('"');

			foreach (var c in s) {
				if ((int)c < 0x20) {
					switch (c) {
					case '\a': sb.Append(@"\a"); break;
					case '\b': sb.Append(@"\b"); break;
					case '\f': sb.Append(@"\f"); break;
					case '\n': sb.Append(@"\n"); break;
					case '\r': sb.Append(@"\r"); break;
					case '\t': sb.Append(@"\t"); break;
					case '\v': sb.Append(@"\v"); break;
					default:
						sb.Append($@"\u{(int)c:X4}");
						break;
					}
				}
				else if (c == '\\' || c == '"') {
					sb.Append('\\');
					sb.Append(c);
				}
				else
					sb.Append(c);
			}

			if (addQuotes)
				sb.Append('"');
		}
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Thrown when invalid data is detected while parsing a .NET method
	/// </summary>
	[Serializable]
	public class InvalidMethodException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public InvalidMethodException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">Error message</param>
		public InvalidMethodException(string msg)
			: base(msg) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">Error message</param>
		/// <param name="innerException">The inner exception or <c>null</c> if none</param>
		public InvalidMethodException(string msg, Exception innerException)
			: base(msg, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected InvalidMethodException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A collection of <see cref="Local"/>s
	/// </summary>
	[DebuggerDisplay("Count = {Count}")]
	[DebuggerTypeProxy(typeof(LocalList_CollectionDebugView))]
	public sealed class LocalList : IListListener<Local>, IList<Local> {
		readonly LazyList<Local> locals;

		/// <summary>
		/// Gets the number of locals
		/// </summary>
		public int Count => locals.Count;

		/// <summary>
		/// Gets the list of locals
		/// </summary>
		public IList<Local> Locals => locals;

		/// <summary>
		/// Gets the N'th local
		/// </summary>
		/// <param name="index">The local index</param>
		public Local this[int index] {
			get => locals[index];
			set => locals[index] = value;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public LocalList() => locals = new LazyList<Local>(this);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="locals">All locals that will be owned by this instance</param>
		public LocalList(IList<Local> locals) {
			this.locals = new LazyList<Local>(this);
			for (int i = 0; i < locals.Count; i++)
				this.locals.Add(locals[i]);
		}

		/// <summary>
		/// Adds a new local and then returns it
		/// </summary>
		/// <param name="local">The local that should be added to the list</param>
		/// <returns>The input is always returned</returns>
		public Local Add(Local local) {
			locals.Add(local);
			return local;
		}

		/// <inheritdoc/>
		void IListListener<Local>.OnLazyAdd(int index, ref Local value) {
		}

		/// <inheritdoc/>
		void IListListener<Local>.OnAdd(int index, Local value) => value.Index = index;

		/// <inheritdoc/>
		void IListListener<Local>.OnRemove(int index, Local value) => value.Index = -1;

		/// <inheritdoc/>
		void IListListener<Local>.OnResize(int index) {
			for (int i = index; i < locals.Count_NoLock; i++)
				locals.Get_NoLock(i).Index = i;
		}

		/// <inheritdoc/>
		void IListListener<Local>.OnClear() {
			foreach (var local in locals.GetEnumerable_NoLock())
				local.Index = -1;
		}

		/// <inheritdoc/>
		public int IndexOf(Local item) => locals.IndexOf(item);

		/// <inheritdoc/>
		public void Insert(int index, Local item) => locals.Insert(index, item);

		/// <inheritdoc/>
		public void RemoveAt(int index) => locals.RemoveAt(index);

		void ICollection<Local>.Add(Local item) => locals.Add(item);

		/// <inheritdoc/>
		public void Clear() => locals.Clear();

		/// <inheritdoc/>
		public bool Contains(Local item) => locals.Contains(item);

		/// <inheritdoc/>
		public void CopyTo(Local[] array, int arrayIndex) => locals.CopyTo(array, arrayIndex);

		/// <inheritdoc/>
		public bool IsReadOnly => false;

		/// <inheritdoc/>
		public bool Remove(Local item) => locals.Remove(item);

		/// <inheritdoc/>
		public LazyList<Local>.Enumerator GetEnumerator() => locals.GetEnumerator();
		IEnumerator<Local> IEnumerable<Local>.GetEnumerator() => locals.GetEnumerator();
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => ((IEnumerable<Local>)this).GetEnumerator();
	}

	/// <summary>
	/// A method local
	/// </summary>
	public sealed class Local : IVariable {
		TypeSig typeSig;
		int index;
		string name;
		PdbLocalAttributes attributes;

		/// <summary>
		/// Gets/sets the type of the local
		/// </summary>
		public TypeSig Type {
			get => typeSig;
			set => typeSig = value;
		}

		/// <summary>
		/// Local index
		/// </summary>
		public int Index {
			get => index;
			internal set => index = value;
		}

		/// <summary>
		/// Gets the name. This property is obsolete, use <see cref="PdbLocal"/> to get/set the name stored in the PDB file.
		/// </summary>
		public string Name {
			get => name;
			set => name = value;
		}

		/// <summary>
		/// Gets the attributes. This property is obsolete, use <see cref="PdbLocal"/> to get/set the attributes stored in the PDB file.
		/// </summary>
		public PdbLocalAttributes Attributes {
			get => attributes;
			set => attributes = value;
		}

		internal void SetName(string name) => this.name = name;
		internal void SetAttributes(PdbLocalAttributes attributes) => this.attributes = attributes;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeSig">The type</param>
		public Local(TypeSig typeSig) => this.typeSig = typeSig;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeSig">The type</param>
		/// <param name="name">Name of local</param>
		public Local(TypeSig typeSig, string name) {
			this.typeSig = typeSig;
			this.name = name;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="typeSig">The type</param>
		/// <param name="name">Name of local</param>
		/// <param name="index">Index, should only be used if you don't add it to the locals list</param>
		public Local(TypeSig typeSig, string name, int index) {
			this.typeSig = typeSig;
			this.name = name;
			this.index = index;
		}

		/// <inheritdoc/>
		public override string ToString() {
			var n = name;
			if (string.IsNullOrEmpty(n))
				return $"V_{Index}";
			return n;
		}
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Method body base class
	/// </summary>
	public abstract class MethodBody {
	}

	/// <summary>
	/// A native method body
	/// </summary>
	public sealed class NativeMethodBody : MethodBody {
		RVA rva;

		/// <summary>
		/// Gets/sets the RVA of the native method body
		/// </summary>
		public RVA RVA {
			get => rva;
			set => rva = value;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public NativeMethodBody() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rva">RVA of method body</param>
		public NativeMethodBody(RVA rva) => this.rva = rva;
	}

	/// <summary>
	/// CIL (managed code) body
	/// </summary>
	public sealed class CilBody : MethodBody {
		bool keepOldMaxStack;
		bool initLocals;
		byte headerSize;
		ushort maxStack;
		uint localVarSigTok;
		readonly IList<Instruction> instructions;
		readonly IList<ExceptionHandler> exceptionHandlers;
		readonly LocalList localList;

		/// <summary>
		/// Size of a small header
		/// </summary>
		public const byte SMALL_HEADER_SIZE = 1;

		/// <summary>
		/// Gets/sets a flag indicating whether the original max stack value should be used.
		/// </summary>
		public bool KeepOldMaxStack {
			get => keepOldMaxStack;
			set => keepOldMaxStack = value;
		}

		/// <summary>
		/// Gets/sets the init locals flag. This is only valid if the method has any locals.
		/// </summary>
		public bool InitLocals {
			get => initLocals;
			set => initLocals = value;
		}

		/// <summary>
		/// Gets/sets the size in bytes of the method body header. The instructions immediately follow
		/// the header.
		/// </summary>
		public byte HeaderSize {
			get => headerSize;
			set => headerSize = value;
		}

		/// <summary>
		/// <c>true</c> if it was a small body header (<see cref="HeaderSize"/> is <c>1</c>)
		/// </summary>
		public bool IsSmallHeader => headerSize == SMALL_HEADER_SIZE;

		/// <summary>
		/// <c>true</c> if it was a big body header
		/// </summary>
		public bool IsBigHeader => headerSize != SMALL_HEADER_SIZE;

		/// <summary>
		/// Gets/sets max stack value from the fat method header.
		/// </summary>
		public ushort MaxStack {
			get => maxStack;
			set => maxStack = value;
		}

		/// <summary>
		/// Gets/sets the locals metadata token
		/// </summary>
		public uint LocalVarSigTok {
			get => localVarSigTok;
			set => localVarSigTok = value;
		}

		/// <summary>
		/// <c>true</c> if <see cref="Instructions"/> is not empty
		/// </summary>
		public bool HasInstructions => instructions.Count > 0;

		/// <summary>
		/// Gets the instructions
		/// </summary>
		public IList<Instruction> Instructions => instructions;

		/// <summary>
		/// <c>true</c> if <see cref="ExceptionHandlers"/> is not empty
		/// </summary>
		public bool HasExceptionHandlers => exceptionHandlers.Count > 0;

		/// <summary>
		/// Gets the exception handlers
		/// </summary>
		public IList<ExceptionHandler> ExceptionHandlers => exceptionHandlers;

		/// <summary>
		/// <c>true</c> if <see cref="Variables"/> is not empty
		/// </summary>
		public bool HasVariables => localList.Count > 0;

		/// <summary>
		/// Gets the locals
		/// </summary>
		public LocalList Variables => localList;

		/// <summary>
		/// Gets/sets the PDB method. This is <c>null</c> if no PDB has been loaded or if there's
		/// no PDB info for this method.
		/// </summary>
		public PdbMethod PdbMethod {
			get => pdbMethod;
			set => pdbMethod = value;
		}
		PdbMethod pdbMethod;

		/// <summary>
		/// <c>true</c> if <see cref="PdbMethod"/> is not <c>null</c>
		/// </summary>
		public bool HasPdbMethod => PdbMethod is not null;

		/// <summary>
		/// Gets the total size of the body in the PE file, including header, IL bytes, and exception handlers.
		/// This property returns 0 if the size is unknown.
		/// </summary>
		internal uint MetadataBodySize { get; set; }

		/// <summary>
		/// Default constructor
		/// </summary>
		public CilBody() {
			initLocals = true;
			instructions = new List<Instruction>();
			exceptionHandlers = new List<ExceptionHandler>();
			localList = new LocalList();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="initLocals">Init locals flag</param>
		/// <param name="instructions">All instructions. This instance will own the list.</param>
		/// <param name="exceptionHandlers">All exception handlers. This instance will own the list.</param>
		/// <param name="locals">All locals. This instance will own the locals in the list.</param>
		public CilBody(bool initLocals, IList<Instruction> instructions, IList<ExceptionHandler> exceptionHandlers, IList<Local> locals) {
			this.initLocals = initLocals;
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
			localList = new LocalList(locals);
		}

		/// <summary>
		/// Shorter instructions are converted to the longer form, eg. <c>Ldc_I4_1</c> is
		/// converted to <c>Ldc_I4</c> with a <c>1</c> as the operand.
		/// </summary>
		/// <param name="parameters">All method parameters, including the hidden 'this' parameter
		/// if it's an instance method. Use <see cref="MethodDef.Parameters"/>.</param>
		public void SimplifyMacros(IList<Parameter> parameters) => instructions.SimplifyMacros(localList, parameters);

		/// <summary>
		/// Optimizes instructions by using the shorter form if possible. Eg. <c>Ldc_I4</c> <c>1</c>
		/// will be replaced with <c>Ldc_I4_1</c>.
		/// </summary>
		public void OptimizeMacros() => instructions.OptimizeMacros();

		/// <summary>
		/// Short branch instructions are converted to the long form, eg. <c>Beq_S</c> is
		/// converted to <c>Beq</c>.
		/// </summary>
		public void SimplifyBranches() => instructions.SimplifyBranches();

		/// <summary>
		/// Optimizes branches by using the smallest possible branch
		/// </summary>
		public void OptimizeBranches() => instructions.OptimizeBranches();

		/// <summary>
		/// Updates each instruction's offset
		/// </summary>
		/// <returns>Total size in bytes of all instructions</returns>
		public uint UpdateInstructionOffsets() => instructions.UpdateInstructionOffsets();
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Reads strings from #US heap
	/// </summary>
	public interface IStringResolver {
		/// <summary>
		/// Reads a string from the #US heap
		/// </summary>
		/// <param name="token">String token</param>
		/// <returns>A string</returns>
		string ReadUserString(uint token);
	}

	/// <summary>
	/// Resolves instruction operands
	/// </summary>
	public interface IInstructionOperandResolver : ITokenResolver, IStringResolver {
	}

	public static partial class Extensions {
		/// <summary>
		/// Resolves a token
		/// </summary>
		/// <param name="self">An <see cref="IInstructionOperandResolver"/> object</param>
		/// <param name="token">The metadata token</param>
		/// <returns>A <see cref="IMDTokenProvider"/> or <c>null</c> if <paramref name="token"/> is invalid</returns>
		public static IMDTokenProvider ResolveToken(this IInstructionOperandResolver self, uint token) =>
			self.ResolveToken(token, new GenericParamContext());
	}

	/// <summary>
	/// Reads a .NET method body (header, locals, instructions, exception handlers)
	/// </summary>
	public sealed class MethodBodyReader : MethodBodyReaderBase {
		readonly IInstructionOperandResolver opResolver;
		bool hasReadHeader;
		byte headerSize;
		ushort flags;
		ushort maxStack;
		uint codeSize;
		uint localVarSigTok;
		uint startOfHeader;
		uint totalBodySize;
		DataReader? exceptionsReader;
		readonly GenericParamContext gpContext;

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="method">Use parameters from this method</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, DataReader reader, MethodDef method) =>
			CreateCilBody(opResolver, reader, null, method.Parameters, new GenericParamContext());

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="method">Use parameters from this method</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, DataReader reader, MethodDef method, GenericParamContext gpContext) =>
			CreateCilBody(opResolver, reader, null, method.Parameters, gpContext);

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="parameters">Method parameters</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, DataReader reader, IList<Parameter> parameters) =>
			CreateCilBody(opResolver, reader, null, parameters, new GenericParamContext());

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, DataReader reader, IList<Parameter> parameters, GenericParamContext gpContext) =>
			CreateCilBody(opResolver, reader, null, parameters, gpContext);

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="reader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="context">The module context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, DataReader reader, IList<Parameter> parameters, GenericParamContext gpContext, ModuleContext context) =>
			CreateCilBody(opResolver, reader, null, parameters, gpContext, context);

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
		/// a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="code">All code</param>
		/// <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
		/// <paramref name="code"/></param>
		/// <param name="parameters">Method parameters</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, byte[] code, byte[] exceptions, IList<Parameter> parameters) =>
			CreateCilBody(opResolver, ByteArrayDataReaderFactory.CreateReader(code), exceptions is null ? (DataReader?)null : ByteArrayDataReaderFactory.CreateReader(exceptions), parameters, new GenericParamContext());

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
		/// a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="code">All code</param>
		/// <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
		/// <paramref name="code"/></param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, byte[] code, byte[] exceptions, IList<Parameter> parameters, GenericParamContext gpContext) =>
			CreateCilBody(opResolver, ByteArrayDataReaderFactory.CreateReader(code), exceptions is null ? (DataReader?)null : ByteArrayDataReaderFactory.CreateReader(exceptions), parameters, gpContext);

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="codeReader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, DataReader codeReader, DataReader? ehReader, IList<Parameter> parameters) =>
			CreateCilBody(opResolver, codeReader, ehReader, parameters, new GenericParamContext());

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="codeReader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, DataReader codeReader, DataReader? ehReader, IList<Parameter> parameters, GenericParamContext gpContext) =>
			CreateCilBody(opResolver, codeReader, ehReader, parameters, gpContext, null);

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="codeReader"/> doesn't
		/// point to the start of a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="context">The module context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, DataReader codeReader, DataReader? ehReader, IList<Parameter> parameters, GenericParamContext gpContext, ModuleContext context) {
			var mbReader = new MethodBodyReader(opResolver, codeReader, ehReader, parameters, gpContext, context);
			if (!mbReader.Read())
				return new CilBody();
			return mbReader.CreateCilBody();
		}

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
		/// a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="code">All code</param>
		/// <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
		/// <paramref name="code"/></param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="flags">Method header flags, eg. 2 if tiny method</param>
		/// <param name="maxStack">Max stack</param>
		/// <param name="codeSize">Code size</param>
		/// <param name="localVarSigTok">Local variable signature token or 0 if none</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, byte[] code, byte[] exceptions, IList<Parameter> parameters, ushort flags, ushort maxStack, uint codeSize, uint localVarSigTok) =>
			CreateCilBody(opResolver, code, exceptions, parameters, flags, maxStack, codeSize, localVarSigTok, new GenericParamContext());

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
		/// a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="code">All code</param>
		/// <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
		/// <paramref name="code"/></param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="flags">Method header flags, eg. 2 if tiny method</param>
		/// <param name="maxStack">Max stack</param>
		/// <param name="codeSize">Code size</param>
		/// <param name="localVarSigTok">Local variable signature token or 0 if none</param>
		/// <param name="gpContext">Generic parameter context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, byte[] code, byte[] exceptions, IList<Parameter> parameters, ushort flags, ushort maxStack, uint codeSize, uint localVarSigTok, GenericParamContext gpContext) =>
			CreateCilBody(opResolver, code, exceptions, parameters, flags, maxStack, codeSize, localVarSigTok, gpContext, null);

		/// <summary>
		/// Creates a CIL method body or returns an empty one if <paramref name="code"/> is not
		/// a valid CIL method body.
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="code">All code</param>
		/// <param name="exceptions">Exceptions or <c>null</c> if all exception handlers are in
		/// <paramref name="code"/></param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="flags">Method header flags, eg. 2 if tiny method</param>
		/// <param name="maxStack">Max stack</param>
		/// <param name="codeSize">Code size</param>
		/// <param name="localVarSigTok">Local variable signature token or 0 if none</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="context">The module context</param>
		public static CilBody CreateCilBody(IInstructionOperandResolver opResolver, byte[] code, byte[] exceptions, IList<Parameter> parameters, ushort flags, ushort maxStack, uint codeSize, uint localVarSigTok, GenericParamContext gpContext, ModuleContext context) {
			var codeReader = ByteArrayDataReaderFactory.CreateReader(code);
			var ehReader = exceptions is null ? (DataReader?)null : ByteArrayDataReaderFactory.CreateReader(exceptions);
			var mbReader = new MethodBodyReader(opResolver, codeReader, ehReader, parameters, gpContext, context);
			mbReader.SetHeader(flags, maxStack, codeSize, localVarSigTok);
			if (!mbReader.Read())
				return new CilBody();
			return mbReader.CreateCilBody();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="method">Use parameters from this method</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, DataReader reader, MethodDef method)
			: this(opResolver, reader, null, method.Parameters, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="method">Use parameters from this method</param>
		/// <param name="gpContext">Generic parameter context</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, DataReader reader, MethodDef method, GenericParamContext gpContext)
			: this(opResolver, reader, null, method.Parameters, gpContext) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="parameters">Method parameters</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, DataReader reader, IList<Parameter> parameters)
			: this(opResolver, reader, null, parameters, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="reader">A reader positioned at the start of a .NET method body</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, DataReader reader, IList<Parameter> parameters, GenericParamContext gpContext)
			: this(opResolver, reader, null, parameters, gpContext) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, DataReader codeReader, DataReader? ehReader, IList<Parameter> parameters)
			: this(opResolver, codeReader, ehReader, parameters, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, DataReader codeReader, DataReader? ehReader, IList<Parameter> parameters, GenericParamContext gpContext)
			: this(opResolver, codeReader, ehReader, parameters, gpContext, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="opResolver">The operand resolver</param>
		/// <param name="codeReader">A reader positioned at the start of a .NET method body</param>
		/// <param name="ehReader">Exception handler reader or <c>null</c> if exceptions aren't
		/// present or if <paramref name="codeReader"/> contains the exception handlers</param>
		/// <param name="parameters">Method parameters</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="context">Module context</param>
		public MethodBodyReader(IInstructionOperandResolver opResolver, DataReader codeReader, DataReader? ehReader, IList<Parameter> parameters, GenericParamContext gpContext, ModuleContext context)
			: base(codeReader, parameters, context) {
			this.opResolver = opResolver;
			exceptionsReader = ehReader;
			this.gpContext = gpContext;
			startOfHeader = uint.MaxValue;
		}

		/// <summary>
		/// Initializes the method header
		/// </summary>
		/// <param name="flags">Header flags, eg. 2 if it's a tiny method</param>
		/// <param name="maxStack">Max stack</param>
		/// <param name="codeSize">Code size</param>
		/// <param name="localVarSigTok">Local variable signature token</param>
		void SetHeader(ushort flags, ushort maxStack, uint codeSize, uint localVarSigTok) {
			hasReadHeader = true;
			this.flags = flags;
			this.maxStack = maxStack;
			this.codeSize = codeSize;
			this.localVarSigTok = localVarSigTok;
		}

		/// <summary>
		/// Reads the method body header, locals, all instructions, and the exception handlers (if any)
		/// </summary>
		/// <returns><c>true</c> if it worked, and <c>false</c> if something failed</returns>
		public bool Read() {
			try {
				if (!ReadHeader())
					return false;
				SetLocals(ReadLocals());
				ReadInstructions();
				ReadExceptionHandlers(out totalBodySize);
				return true;
			}
			catch (InvalidMethodException) {
				return false;
			}
			catch (IOException) {
				return false;
			}
		}

		/// <summary>
		/// Reads the method header
		/// </summary>
		bool ReadHeader() {
			if (hasReadHeader)
				return true;
			hasReadHeader = true;

			startOfHeader = reader.Position;
			byte b = reader.ReadByte();
			switch (b & 7) {
			case 2:
			case 6:
				// Tiny header. [7:2] = code size, max stack is 8, no locals or exception handlers
				flags = 2;
				maxStack = 8;
				codeSize = (uint)(b >> 2);
				localVarSigTok = 0;
				headerSize = 1;
				break;

			case 3:
				// Fat header. Can have locals and exception handlers
				flags = (ushort)((reader.ReadByte() << 8) | b);
				headerSize = (byte)(flags >> 12);
				maxStack = reader.ReadUInt16();
				codeSize = reader.ReadUInt32();
				localVarSigTok = reader.ReadUInt32();

				// The CLR allows the code to start inside the method header. But if it does,
				// the CLR doesn't read any exceptions.
				reader.Position = reader.Position - 12 + headerSize * 4U;
				if (headerSize < 3)
					flags &= 0xFFF7;
				headerSize *= 4;
				break;

			default:
				return false;
			}

			if ((ulong)reader.Position + codeSize > reader.Length)
				return false;

			return true;
		}

		/// <summary>
		/// Reads the locals
		/// </summary>
		/// <returns>All locals or <c>null</c> if there are none</returns>
		IList<TypeSig> ReadLocals() {
			var standAloneSig = opResolver.ResolveToken(localVarSigTok, gpContext) as StandAloneSig;
			if (standAloneSig is null)
				return null;
			var localSig = standAloneSig.LocalSig;
			if (localSig is null)
				return null;
			return localSig.Locals;
		}

		/// <summary>
		/// Reads all instructions
		/// </summary>
		void ReadInstructions() => ReadInstructionsNumBytes(codeSize);

		/// <inheritdoc/>
		protected override IField ReadInlineField(Instruction instr) => opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as IField;

		/// <inheritdoc/>
		protected override IMethod ReadInlineMethod(Instruction instr) => opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as IMethod;

		/// <inheritdoc/>
		protected override MethodSig ReadInlineSig(Instruction instr) {
			var standAloneSig = opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as StandAloneSig;
			if (standAloneSig is null)
				return null;
			var sig = standAloneSig.MethodSig;
			if (sig is not null)
				sig.OriginalToken = standAloneSig.MDToken.Raw;
			return sig;
		}

		/// <inheritdoc/>
		protected override string ReadInlineString(Instruction instr) => opResolver.ReadUserString(reader.ReadUInt32()) ?? string.Empty;

		/// <inheritdoc/>
		protected override ITokenOperand ReadInlineTok(Instruction instr) => opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITokenOperand;

		/// <inheritdoc/>
		protected override ITypeDefOrRef ReadInlineType(Instruction instr) => opResolver.ResolveToken(reader.ReadUInt32(), gpContext) as ITypeDefOrRef;

		/// <summary>
		/// Reads all exception handlers
		/// </summary>
		void ReadExceptionHandlers(out uint totalBodySize) {
			if ((flags & 8) == 0) {
				totalBodySize = startOfHeader == uint.MaxValue ? 0 : reader.Position - startOfHeader;
				return;
			}
			bool canSaveTotalBodySize;
			DataReader ehReader;
			if (exceptionsReader is not null) {
				canSaveTotalBodySize = false;
				ehReader = exceptionsReader.Value;
			}
			else {
				canSaveTotalBodySize = true;
				ehReader = reader;
				ehReader.Position = (ehReader.Position + 3) & ~3U;
			}
			// Only read the first one. Any others aren't used.
			byte b = ehReader.ReadByte();
			if ((b & 0x3F) != 1) {
				totalBodySize = startOfHeader == uint.MaxValue ? 0 : reader.Position - startOfHeader;
				return;	// Not exception handler clauses
			}
			if ((b & 0x40) != 0)
				ReadFatExceptionHandlers(ref ehReader);
			else
				ReadSmallExceptionHandlers(ref ehReader);
			if (canSaveTotalBodySize)
				totalBodySize = startOfHeader == uint.MaxValue ? 0 : ehReader.Position - startOfHeader;
			else
				totalBodySize = 0;
		}

		void ReadFatExceptionHandlers(ref DataReader ehReader) {
			ehReader.Position--;
			int num = (int)((ehReader.ReadUInt32() >> 8) / 24);
			for (int i = 0; i < num; i++) {
				var eh = new ExceptionHandler((ExceptionHandlerType)ehReader.ReadUInt32());
				uint offs = ehReader.ReadUInt32();
				eh.TryStart = GetInstruction(offs);
				eh.TryEnd = GetInstruction(offs + ehReader.ReadUInt32());
				offs = ehReader.ReadUInt32();
				eh.HandlerStart = GetInstruction(offs);
				eh.HandlerEnd = GetInstruction(offs + ehReader.ReadUInt32());
				if (eh.IsCatch)
					eh.CatchType = opResolver.ResolveToken(ehReader.ReadUInt32(), gpContext) as ITypeDefOrRef;
				else if (eh.IsFilter)
					eh.FilterStart = GetInstruction(ehReader.ReadUInt32());
				else
					ehReader.ReadUInt32();
				Add(eh);
			}
		}

		void ReadSmallExceptionHandlers(ref DataReader ehReader) {
			int num = (int)((uint)ehReader.ReadByte() / 12);
			ehReader.Position += 2;
			for (int i = 0; i < num; i++) {
				var eh = new ExceptionHandler((ExceptionHandlerType)ehReader.ReadUInt16());
				uint offs = ehReader.ReadUInt16();
				eh.TryStart = GetInstruction(offs);
				eh.TryEnd = GetInstruction(offs + ehReader.ReadByte());
				offs = ehReader.ReadUInt16();
				eh.HandlerStart = GetInstruction(offs);
				eh.HandlerEnd = GetInstruction(offs + ehReader.ReadByte());
				if (eh.IsCatch)
					eh.CatchType = opResolver.ResolveToken(ehReader.ReadUInt32(), gpContext) as ITypeDefOrRef;
				else if (eh.IsFilter)
					eh.FilterStart = GetInstruction(ehReader.ReadUInt32());
				else
					ehReader.ReadUInt32();
				Add(eh);
			}
		}

		/// <summary>
		/// Creates a CIL body. Must be called after <see cref="Read()"/>, and can only be
		/// called once.
		/// </summary>
		/// <returns>A new <see cref="CilBody"/> instance</returns>
		public CilBody CreateCilBody() {
			// Set init locals if it's a tiny method or if the init locals bit is set (fat header)
			bool initLocals = flags == 2 || (flags & 0x10) != 0;
			var cilBody = new CilBody(initLocals, instructions, exceptionHandlers, locals);
			cilBody.HeaderSize = headerSize;
			cilBody.MaxStack = maxStack;
			cilBody.LocalVarSigTok = localVarSigTok;
			cilBody.MetadataBodySize = totalBodySize;
			instructions = null;
			exceptionHandlers = null;
			locals = null;
			return cilBody;
		}
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Method body reader base class
	/// </summary>
	public abstract class MethodBodyReaderBase {
		/// <summary>The method reader</summary>
		protected DataReader reader;
		/// <summary>All parameters</summary>
		protected IList<Parameter> parameters;
		/// <summary>All locals</summary>
		protected IList<Local> locals = new List<Local>();
		/// <summary>All instructions</summary>
		protected IList<Instruction> instructions;
		/// <summary>All exception handlers</summary>
		protected IList<ExceptionHandler> exceptionHandlers = new List<ExceptionHandler>();
		uint currentOffset;
		/// <summary>First byte after the end of the code</summary>
		protected uint codeEndOffs;
		/// <summary>Start offset of method</summary>
		protected uint codeStartOffs;
		readonly ModuleContext context;

		/// <summary>
		/// Gets all parameters
		/// </summary>
		public IList<Parameter> Parameters => parameters;

		/// <summary>
		/// Gets all locals
		/// </summary>
		public IList<Local> Locals => locals;

		/// <summary>
		/// Gets all instructions
		/// </summary>
		public IList<Instruction> Instructions => instructions;

		/// <summary>
		/// Gets all exception handlers
		/// </summary>
		public IList<ExceptionHandler> ExceptionHandlers => exceptionHandlers;

		/// <summary>
		/// Constructor
		/// </summary>
		protected MethodBodyReaderBase() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="context">The module context</param>
		protected MethodBodyReaderBase(ModuleContext context) {
			this.context = context;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">The reader</param>
		protected MethodBodyReaderBase(DataReader reader)
			: this(reader, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">The reader</param>
		/// <param name="parameters">Method parameters or <c>null</c> if they're not known yet</param>
		protected MethodBodyReaderBase(DataReader reader, IList<Parameter> parameters)
			: this(reader, parameters, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">The reader</param>
		/// <param name="parameters">Method parameters or <c>null</c> if they're not known yet</param>
		/// <param name="context">The module context</param>
		protected MethodBodyReaderBase(DataReader reader, IList<Parameter> parameters, ModuleContext context) {
			this.reader = reader;
			this.parameters = parameters;
			this.context = context;
		}

		/// <summary>
		/// Sets new locals
		/// </summary>
		/// <param name="newLocals">A list of types of all locals or <c>null</c> if none</param>
		protected void SetLocals(IList<TypeSig> newLocals) {
			var locals = this.locals;
			locals.Clear();
			if (newLocals is null)
				return;
			int count = newLocals.Count;
			for (int i = 0; i < count; i++)
				locals.Add(new Local(newLocals[i]));
		}

		/// <summary>
		/// Sets new locals
		/// </summary>
		/// <param name="newLocals">A list of types of all locals or <c>null</c> if none</param>
		protected void SetLocals(IList<Local> newLocals) {
			var locals = this.locals;
			locals.Clear();
			if (newLocals is null)
				return;
			int count = newLocals.Count;
			for (int i = 0; i < count; i++)
				locals.Add(new Local(newLocals[i].Type));
		}

		/// <summary>
		/// Reads all instructions
		/// </summary>
		/// <param name="numInstrs">Number of instructions to read</param>
		protected void ReadInstructions(int numInstrs) {
			codeStartOffs = reader.Position;
			codeEndOffs = reader.Length;	// We don't know the end pos so use the last one
			this.instructions = new List<Instruction>(numInstrs);
			currentOffset = 0;
			var instructions = this.instructions;
			for (int i = 0; i < numInstrs && reader.Position < codeEndOffs; i++)
				instructions.Add(ReadOneInstruction());
			FixBranches();
		}

		/// <summary>
		/// Reads all instructions
		/// </summary>
		/// <param name="codeSize">Size of code</param>
		protected void ReadInstructionsNumBytes(uint codeSize) {
			codeStartOffs = reader.Position;
			codeEndOffs = reader.Position + codeSize;
			if (codeEndOffs < codeStartOffs || codeEndOffs > reader.Length)
				throw new InvalidMethodException("Invalid code size");

			this.instructions = new List<Instruction>();	//TODO: Estimate number of instructions based on codeSize
			currentOffset = 0;
			var instructions = this.instructions;
			while (reader.Position < codeEndOffs)
				instructions.Add(ReadOneInstruction());
			reader.Position = codeEndOffs;
			FixBranches();
		}

		/// <summary>
		/// Fixes all branch instructions so their operands are set to an <see cref="Instruction"/>
		/// instead of an offset.
		/// </summary>
		void FixBranches() {
			var instructions = this.instructions;
			int count = instructions.Count;
			for (int i = 0; i < count; i++) {
				var instr = instructions[i];
				switch (instr.OpCode.OperandType) {
				case OperandType.InlineBrTarget:
				case OperandType.ShortInlineBrTarget:
					instr.Operand = GetInstruction((uint)instr.Operand);
					break;

				case OperandType.InlineSwitch:
					var uintTargets = (IList<uint>)instr.Operand;
					var targets = new Instruction[uintTargets.Count];
					for (int j = 0; j < uintTargets.Count; j++)
						targets[j] = GetInstruction(uintTargets[j]);
					instr.Operand = targets;
					break;
				}
			}
		}

		/// <summary>
		/// Finds an instruction
		/// </summary>
		/// <param name="offset">Offset of instruction</param>
		/// <returns>The instruction or <c>null</c> if there's no instruction at <paramref name="offset"/>.</returns>
		protected Instruction GetInstruction(uint offset) {
			// The instructions are sorted and all Offset fields are correct. Do a binary search.
			var instructions = this.instructions;
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}

		/// <summary>
		/// Finds an instruction and throws if it's not present
		/// </summary>
		/// <param name="offset">Offset of instruction</param>
		/// <returns>The instruction</returns>
		/// <exception cref="InvalidOperationException">There's no instruction at
		/// <paramref name="offset"/></exception>
		protected Instruction GetInstructionThrow(uint offset) {
			var instr = GetInstruction(offset);
			if (instr is not null)
				return instr;
			throw new InvalidOperationException($"There's no instruction @ {offset:X4}");
		}

		/// <summary>
		/// Reads the next instruction
		/// </summary>
		Instruction ReadOneInstruction() {
			var instr = new Instruction();
			instr.Offset = currentOffset;
			instr.OpCode = ReadOpCode();
			instr.Operand = ReadOperand(instr);

			if (instr.OpCode.Code == Code.Switch) {
				var targets = (IList<uint>)instr.Operand;
				currentOffset += (uint)(instr.OpCode.Size + 4 + 4 * targets.Count);
			}
			else
				currentOffset += (uint)instr.GetSize();
			if (currentOffset < instr.Offset)
				reader.Position = codeEndOffs;
			return instr;
		}

		/// <summary>
		/// Reads the next OpCode from the current position
		/// </summary>
		OpCode ReadOpCode() {
			var op = reader.ReadByte();
			if (op == 0xFE)
				return OpCodes.TwoByteOpCodes[reader.ReadByte()];
			if (op >= 0xF0 && op <= 0xFB && context is not null && reader.BytesLeft >= 1) {
				if (context.GetExperimentalOpCode(op, reader.ReadByte()) is OpCode opCode)
					return opCode;
				else
					reader.Position--;
			}
			return OpCodes.OneByteOpCodes[op];
		}

		/// <summary>
		/// Reads the instruction operand (if any)
		/// </summary>
		/// <param name="instr">The instruction</param>
		object ReadOperand(Instruction instr) =>
			instr.OpCode.OperandType switch {
				OperandType.InlineBrTarget => ReadInlineBrTarget(instr),
				OperandType.InlineField => ReadInlineField(instr),
				OperandType.InlineI => ReadInlineI(instr),
				OperandType.InlineI8 => ReadInlineI8(instr),
				OperandType.InlineMethod => ReadInlineMethod(instr),
				OperandType.InlineNone => ReadInlineNone(instr),
				OperandType.InlinePhi => ReadInlinePhi(instr),
				OperandType.InlineR => ReadInlineR(instr),
				OperandType.InlineSig => ReadInlineSig(instr),
				OperandType.InlineString => ReadInlineString(instr),
				OperandType.InlineSwitch => ReadInlineSwitch(instr),
				OperandType.InlineTok => ReadInlineTok(instr),
				OperandType.InlineType => ReadInlineType(instr),
				OperandType.InlineVar => ReadInlineVar(instr),
				OperandType.ShortInlineBrTarget => ReadShortInlineBrTarget(instr),
				OperandType.ShortInlineI => ReadShortInlineI(instr),
				OperandType.ShortInlineR => ReadShortInlineR(instr),
				OperandType.ShortInlineVar => ReadShortInlineVar(instr),
				_ => throw new InvalidOperationException("Invalid OpCode.OperandType"),
			};

		/// <summary>
		/// Reads a <see cref="OperandType.InlineBrTarget"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual uint ReadInlineBrTarget(Instruction instr) => instr.Offset + (uint)instr.GetSize() + reader.ReadUInt32();

		/// <summary>
		/// Reads a <see cref="OperandType.InlineField"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract IField ReadInlineField(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineI"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual int ReadInlineI(Instruction instr) => reader.ReadInt32();

		/// <summary>
		/// Reads a <see cref="OperandType.InlineI8"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual long ReadInlineI8(Instruction instr) => reader.ReadInt64();

		/// <summary>
		/// Reads a <see cref="OperandType.InlineMethod"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract IMethod ReadInlineMethod(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineNone"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual object ReadInlineNone(Instruction instr) => null;

		/// <summary>
		/// Reads a <see cref="OperandType.InlinePhi"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual object ReadInlinePhi(Instruction instr) => null;

		/// <summary>
		/// Reads a <see cref="OperandType.InlineR"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual double ReadInlineR(Instruction instr) => reader.ReadDouble();

		/// <summary>
		/// Reads a <see cref="OperandType.InlineSig"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract MethodSig ReadInlineSig(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineString"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract string ReadInlineString(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineSwitch"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual IList<uint> ReadInlineSwitch(Instruction instr) {
			var num = reader.ReadUInt32();
			long offsetAfterInstr = (long)instr.Offset + (long)instr.OpCode.Size + 4L + (long)num * 4;
			if (offsetAfterInstr > uint.MaxValue || codeStartOffs + offsetAfterInstr > codeEndOffs) {
				reader.Position = codeEndOffs;
				return Array2.Empty<uint>();
			}

			var targets = new uint[num];
			uint offset = (uint)offsetAfterInstr;
			for (int i = 0; i < targets.Length; i++)
				targets[i] = offset + reader.ReadUInt32();
			return targets;
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineTok"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract ITokenOperand ReadInlineTok(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineType"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected abstract ITypeDefOrRef ReadInlineType(Instruction instr);

		/// <summary>
		/// Reads a <see cref="OperandType.InlineVar"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual IVariable ReadInlineVar(Instruction instr) {
			if (IsArgOperandInstruction(instr))
				return ReadInlineVarArg(instr);
			return ReadInlineVarLocal(instr);
		}

		/// <summary>
		/// Reads a <see cref="OperandType.InlineVar"/> (a parameter) operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual Parameter ReadInlineVarArg(Instruction instr) => GetParameter(reader.ReadUInt16());

		/// <summary>
		/// Reads a <see cref="OperandType.InlineVar"/> (a local) operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual Local ReadInlineVarLocal(Instruction instr) => GetLocal(reader.ReadUInt16());

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineBrTarget"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual uint ReadShortInlineBrTarget(Instruction instr) => instr.Offset + (uint)instr.GetSize() + (uint)reader.ReadSByte();

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineI"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual object ReadShortInlineI(Instruction instr) {
			if (instr.OpCode.Code == Code.Ldc_I4_S)
				return reader.ReadSByte();
			return reader.ReadByte();
		}

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineR"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual float ReadShortInlineR(Instruction instr) => reader.ReadSingle();

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineVar"/> operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual IVariable ReadShortInlineVar(Instruction instr) {
			if (IsArgOperandInstruction(instr))
				return ReadShortInlineVarArg(instr);
			return ReadShortInlineVarLocal(instr);
		}

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineVar"/> (a parameter) operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual Parameter ReadShortInlineVarArg(Instruction instr) => GetParameter(reader.ReadByte());

		/// <summary>
		/// Reads a <see cref="OperandType.ShortInlineVar"/> (a local) operand
		/// </summary>
		/// <param name="instr">The current instruction</param>
		/// <returns>The operand</returns>
		protected virtual Local ReadShortInlineVarLocal(Instruction instr) => GetLocal(reader.ReadByte());

		/// <summary>
		/// Returns <c>true</c> if it's one of the ldarg/starg instructions that have an operand
		/// </summary>
		/// <param name="instr">The instruction to check</param>
		protected static bool IsArgOperandInstruction(Instruction instr) {
			switch (instr.OpCode.Code) {
			case Code.Ldarg:
			case Code.Ldarg_S:
			case Code.Ldarga:
			case Code.Ldarga_S:
			case Code.Starg:
			case Code.Starg_S:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Returns a parameter
		/// </summary>
		/// <param name="index">A parameter index</param>
		/// <returns>A <see cref="Parameter"/> or <c>null</c> if <paramref name="index"/> is invalid</returns>
		protected Parameter GetParameter(int index) {
			var parameters = this.parameters;
			if ((uint)index < (uint)parameters.Count)
				return parameters[index];
			return null;
		}

		/// <summary>
		/// Returns a local
		/// </summary>
		/// <param name="index">A local index</param>
		/// <returns>A <see cref="Local"/> or <c>null</c> if <paramref name="index"/> is invalid</returns>
		protected Local GetLocal(int index) {
			var locals = this.locals;
			if ((uint)index < (uint)locals.Count)
				return locals[index];
			return null;
		}

		/// <summary>
		/// Add an exception handler if it appears valid
		/// </summary>
		/// <param name="eh">The exception handler</param>
		/// <returns><c>true</c> if it was added, <c>false</c> otherwise</returns>
		protected bool Add(ExceptionHandler eh) {
			uint tryStart = GetOffset(eh.TryStart);
			uint tryEnd = GetOffset(eh.TryEnd);
			if (tryEnd <= tryStart)
				return false;

			uint handlerStart = GetOffset(eh.HandlerStart);
			uint handlerEnd = GetOffset(eh.HandlerEnd);
			if (handlerEnd <= handlerStart)
				return false;

			if (eh.IsFilter) {
				if (eh.FilterStart is null)
					return false;
				if (eh.FilterStart.Offset >= handlerStart)
					return false;
			}

			if (handlerStart <= tryStart && tryStart < handlerEnd)
				return false;
			if (handlerStart < tryEnd && tryEnd <= handlerEnd)
				return false;

			if (tryStart <= handlerStart && handlerStart < tryEnd)
				return false;
			if (tryStart < handlerEnd && handlerEnd <= tryEnd)
				return false;

			// It's probably valid, so let's add it.
			exceptionHandlers.Add(eh);
			return true;
		}

		/// <summary>
		/// Gets the offset of an instruction
		/// </summary>
		/// <param name="instr">The instruction or <c>null</c> if the offset is the first offset
		/// at the end of the method.</param>
		/// <returns>The instruction offset</returns>
		uint GetOffset(Instruction instr) {
			if (instr is not null)
				return instr.Offset;
			var instructions = this.instructions;
			if (instructions.Count == 0)
				return 0;
			return instructions[instructions.Count - 1].Offset;
		}

		/// <summary>
		/// Restores a <see cref="MethodDef"/>'s body with the parsed method instructions
		/// and exception handlers
		/// </summary>
		/// <param name="method">The method that gets updated with the instructions, locals, and
		/// exception handlers.</param>
		public virtual void RestoreMethod(MethodDef method) {
			var body = method.Body;

			body.Variables.Clear();
			var locals = this.locals;
			if (locals is not null) {
				int count = locals.Count;
				for (int i = 0; i < count; i++)
					body.Variables.Add(locals[i]);
			}

			body.Instructions.Clear();
			var instructions = this.instructions;
			if (instructions is not null) {
				int count = instructions.Count;
				for (int i = 0; i < count; i++)
					body.Instructions.Add(instructions[i]);
			}

			body.ExceptionHandlers.Clear();
			var exceptionHandlers = this.exceptionHandlers;
			if (exceptionHandlers is not null) {
				int count = exceptionHandlers.Count;
				for (int i = 0; i < count; i++)
					body.ExceptionHandlers.Add(exceptionHandlers[i]);
			}
		}
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Converts a type address to a <see cref="Type"/>. The address can be found in
	/// <c>RuntimeTypeHandle.Value</c> and it's the same address you use with the WinDbg SOS command
	/// !dumpmt.
	/// </summary>
	static class MethodTableToTypeConverter {
		const string METHOD_NAME = "m";
		static readonly MethodInfo setMethodBodyMethodInfo = typeof(MethodBuilder).GetMethod("SetMethodBody", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo localSignatureFieldInfo = typeof(ILGenerator).GetField("m_localSignature", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo sigDoneFieldInfo = typeof(SignatureHelper).GetField("m_sigDone", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo currSigFieldInfo = typeof(SignatureHelper).GetField("m_currSig", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo signatureFieldInfo = typeof(SignatureHelper).GetField("m_signature", BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
		static readonly FieldInfo ptrFieldInfo = typeof(RuntimeTypeHandle).GetField("m_ptr", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public);
		static readonly Dictionary<IntPtr, Type> addrToType = new Dictionary<IntPtr, Type>();
		static ModuleBuilder moduleBuilder;
		static int numNewTypes;
		static object lockObj = new object();

		static MethodTableToTypeConverter() {
			if (ptrFieldInfo is null) {
#if NETSTANDARD
				var asmb = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("DynAsm"), AssemblyBuilderAccess.Run);
#else
				var asmb = AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName("DynAsm"), AssemblyBuilderAccess.Run);
#endif
				moduleBuilder = asmb.DefineDynamicModule("DynMod");
			}
		}

		/// <summary>
		/// Converts <paramref name="address"/> to a <see cref="Type"/>.
		/// </summary>
		/// <param name="address">Address of type</param>
		/// <returns>The <see cref="Type"/> or <c>null</c></returns>
		public static Type Convert(IntPtr address) {
			lock (lockObj) {
				if (addrToType.TryGetValue(address, out var type))
					return type;

				type = GetTypeNET20(address) ?? GetTypeUsingTypeBuilder(address);
				addrToType[address] = type;
				return type;
			}
		}

		static Type GetTypeUsingTypeBuilder(IntPtr address) {
			if (moduleBuilder is null)
				return null;

			var tb = moduleBuilder.DefineType(GetNextTypeName());
			var mb = tb.DefineMethod(METHOD_NAME, SR.MethodAttributes.Static, typeof(void), Array2.Empty<Type>());

			try {
				if (setMethodBodyMethodInfo is not null)
					return GetTypeNET45(tb, mb, address);
				else
					return GetTypeNET40(tb, mb, address);
			}
			catch {
				moduleBuilder = null;
				return null;
			}
		}

		// .NET Framework 4.5 and later have the documented SetMethodBody() method.
		static Type GetTypeNET45(TypeBuilder tb, MethodBuilder mb, IntPtr address) {
			var code = new byte[1] { 0x2A };
			int maxStack = 8;
			var locals = GetLocalSignature(address);
			setMethodBodyMethodInfo.Invoke(mb, new object[5] { code, maxStack, locals, null, null });
#if NETSTANDARD
			var type = tb.CreateTypeInfo();
#else
			var type = tb.CreateType();
#endif
			var createdMethod = type.GetMethod(METHOD_NAME, BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			return createdMethod.GetMethodBody().LocalVariables[0].LocalType;
		}

		// This code works with .NET Framework 4.0+ but will throw an exception if .NET Framework 2.0 is used
		// ("operation could destabilize the runtime")
		static Type GetTypeNET40(TypeBuilder tb, MethodBuilder mb, IntPtr address) {
			var ilg = mb.GetILGenerator();
			ilg.Emit(SR.Emit.OpCodes.Ret);

			// We need at least one local to make sure the SignatureHelper from ILGenerator is used.
			ilg.DeclareLocal(typeof(int));

			var locals = GetLocalSignature(address);
			var sigHelper = (SignatureHelper)localSignatureFieldInfo.GetValue(ilg);
			sigDoneFieldInfo.SetValue(sigHelper, true);
			currSigFieldInfo.SetValue(sigHelper, locals.Length);
			signatureFieldInfo.SetValue(sigHelper, locals);
#if NETSTANDARD
			var type = tb.CreateTypeInfo();
#else
			var type = tb.CreateType();
#endif
			var createdMethod = type.GetMethod(METHOD_NAME, BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
			return createdMethod.GetMethodBody().LocalVariables[0].LocalType;
		}

		// .NET Framework 2.0 - 3.5
		static Type GetTypeNET20(IntPtr address) {
			if (ptrFieldInfo is null)
				return null;
			object th = new RuntimeTypeHandle();
			ptrFieldInfo.SetValue(th, address);
			return Type.GetTypeFromHandle((RuntimeTypeHandle)th);
		}

		static string GetNextTypeName() => "Type" + numNewTypes++.ToString();

		static byte[] GetLocalSignature(IntPtr mtAddr) {
			ulong mtValue = (ulong)mtAddr.ToInt64();
			if (IntPtr.Size == 4) {
				return new byte[] {
					0x07,
					0x01,
					(byte)ElementType.Internal,
					(byte)mtValue,
					(byte)(mtValue >> 8),
					(byte)(mtValue >> 16),
					(byte)(mtValue >> 24),
				};
			}
			else {
				return new byte[] {
					0x07,
					0x01,
					(byte)ElementType.Internal,
					(byte)mtValue,
					(byte)(mtValue >> 8),
					(byte)(mtValue >> 16),
					(byte)(mtValue >> 24),
					(byte)(mtValue >> 32),
					(byte)(mtValue >> 40),
					(byte)(mtValue >> 48),
					(byte)(mtValue >> 56),
				};
			}
		}
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Instruction utility methods
	/// </summary>
	public static class MethodUtils {
		/// <summary>
		/// Shorter instructions are converted to the longer form, eg. <c>Ldc_I4_1</c> is
		/// converted to <c>Ldc_I4</c> with a <c>1</c> as the operand.
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <param name="locals">All locals</param>
		/// <param name="parameters">All method parameters, including the hidden 'this' parameter
		/// if it's an instance method. Use <see cref="MethodDef.Parameters"/>.</param>
		public static void SimplifyMacros(this IList<Instruction> instructions, IList<Local> locals, IList<Parameter> parameters) {
			int count = instructions.Count;
			for (int i = 0; i < count; i++) {
				var instr = instructions[i];
				switch (instr.OpCode.Code) {
				case Code.Beq_S:
					instr.OpCode = OpCodes.Beq;
					break;

				case Code.Bge_S:
					instr.OpCode = OpCodes.Bge;
					break;

				case Code.Bge_Un_S:
					instr.OpCode = OpCodes.Bge_Un;
					break;

				case Code.Bgt_S:
					instr.OpCode = OpCodes.Bgt;
					break;

				case Code.Bgt_Un_S:
					instr.OpCode = OpCodes.Bgt_Un;
					break;

				case Code.Ble_S:
					instr.OpCode = OpCodes.Ble;
					break;

				case Code.Ble_Un_S:
					instr.OpCode = OpCodes.Ble_Un;
					break;

				case Code.Blt_S:
					instr.OpCode = OpCodes.Blt;
					break;

				case Code.Blt_Un_S:
					instr.OpCode = OpCodes.Blt_Un;
					break;

				case Code.Bne_Un_S:
					instr.OpCode = OpCodes.Bne_Un;
					break;

				case Code.Br_S:
					instr.OpCode = OpCodes.Br;
					break;

				case Code.Brfalse_S:
					instr.OpCode = OpCodes.Brfalse;
					break;

				case Code.Brtrue_S:
					instr.OpCode = OpCodes.Brtrue;
					break;

				case Code.Ldarg_0:
					instr.OpCode = OpCodes.Ldarg;
					instr.Operand = ReadList(parameters, 0);
					break;

				case Code.Ldarg_1:
					instr.OpCode = OpCodes.Ldarg;
					instr.Operand = ReadList(parameters, 1);
					break;

				case Code.Ldarg_2:
					instr.OpCode = OpCodes.Ldarg;
					instr.Operand = ReadList(parameters, 2);
					break;

				case Code.Ldarg_3:
					instr.OpCode = OpCodes.Ldarg;
					instr.Operand = ReadList(parameters, 3);
					break;

				case Code.Ldarg_S:
					instr.OpCode = OpCodes.Ldarg;
					break;

				case Code.Ldarga_S:
					instr.OpCode = OpCodes.Ldarga;
					break;

				case Code.Ldc_I4_0:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 0;
					break;

				case Code.Ldc_I4_1:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 1;
					break;

				case Code.Ldc_I4_2:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 2;
					break;

				case Code.Ldc_I4_3:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 3;
					break;

				case Code.Ldc_I4_4:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 4;
					break;

				case Code.Ldc_I4_5:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 5;
					break;

				case Code.Ldc_I4_6:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 6;
					break;

				case Code.Ldc_I4_7:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 7;
					break;

				case Code.Ldc_I4_8:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = 8;
					break;

				case Code.Ldc_I4_M1:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = -1;
					break;

				case Code.Ldc_I4_S:
					instr.OpCode = OpCodes.Ldc_I4;
					instr.Operand = (int)(sbyte)instr.Operand;
					break;

				case Code.Ldloc_0:
					instr.OpCode = OpCodes.Ldloc;
					instr.Operand = ReadList(locals, 0);
					break;

				case Code.Ldloc_1:
					instr.OpCode = OpCodes.Ldloc;
					instr.Operand = ReadList(locals, 1);
					break;

				case Code.Ldloc_2:
					instr.OpCode = OpCodes.Ldloc;
					instr.Operand = ReadList(locals, 2);
					break;

				case Code.Ldloc_3:
					instr.OpCode = OpCodes.Ldloc;
					instr.Operand = ReadList(locals, 3);
					break;

				case Code.Ldloc_S:
					instr.OpCode = OpCodes.Ldloc;
					break;

				case Code.Ldloca_S:
					instr.OpCode = OpCodes.Ldloca;
					break;

				case Code.Leave_S:
					instr.OpCode = OpCodes.Leave;
					break;

				case Code.Starg_S:
					instr.OpCode = OpCodes.Starg;
					break;

				case Code.Stloc_0:
					instr.OpCode = OpCodes.Stloc;
					instr.Operand = ReadList(locals, 0);
					break;

				case Code.Stloc_1:
					instr.OpCode = OpCodes.Stloc;
					instr.Operand = ReadList(locals, 1);
					break;

				case Code.Stloc_2:
					instr.OpCode = OpCodes.Stloc;
					instr.Operand = ReadList(locals, 2);
					break;

				case Code.Stloc_3:
					instr.OpCode = OpCodes.Stloc;
					instr.Operand = ReadList(locals, 3);
					break;

				case Code.Stloc_S:
					instr.OpCode = OpCodes.Stloc;
					break;
				}
			}
		}

		static T ReadList<T>(IList<T> list, int index) {
			if (list is null)
				return default;
			if ((uint)index < (uint)list.Count)
				return list[index];
			return default;
		}

		/// <summary>
		/// Optimizes instructions by using the shorter form if possible. Eg. <c>Ldc_I4</c> <c>1</c>
		/// will be replaced with <c>Ldc_I4_1</c>.
		/// </summary>
		/// <param name="instructions">All instructions</param>
		public static void OptimizeMacros(this IList<Instruction> instructions) {
			int count = instructions.Count;
			for (int i = 0; i < count; i++) {
				var instr = instructions[i];
				Parameter arg;
				Local local;
				switch (instr.OpCode.Code) {
				case Code.Ldarg:
				case Code.Ldarg_S:
					arg = instr.Operand as Parameter;
					if (arg is null)
						break;
					if (arg.Index == 0) {
						instr.OpCode = OpCodes.Ldarg_0;
						instr.Operand = null;
					}
					else if (arg.Index == 1) {
						instr.OpCode = OpCodes.Ldarg_1;
						instr.Operand = null;
					}
					else if (arg.Index == 2) {
						instr.OpCode = OpCodes.Ldarg_2;
						instr.Operand = null;
					}
					else if (arg.Index == 3) {
						instr.OpCode = OpCodes.Ldarg_3;
						instr.Operand = null;
					}
					else if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Ldarg_S;
					break;

				case Code.Ldarga:
					arg = instr.Operand as Parameter;
					if (arg is null)
						break;
					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Ldarga_S;
					break;

				case Code.Ldc_I4:
				case Code.Ldc_I4_S:
					int i4;
					if (instr.Operand is int)
						i4 = (int)instr.Operand;
					else if (instr.Operand is sbyte)
						i4 = (sbyte)instr.Operand;
					else
						break;
					switch (i4) {
					case 0:
						instr.OpCode = OpCodes.Ldc_I4_0;
						instr.Operand = null;
						break;

					case 1:
						instr.OpCode = OpCodes.Ldc_I4_1;
						instr.Operand = null;
						break;

					case 2:
						instr.OpCode = OpCodes.Ldc_I4_2;
						instr.Operand = null;
						break;

					case 3:
						instr.OpCode = OpCodes.Ldc_I4_3;
						instr.Operand = null;
						break;

					case 4:
						instr.OpCode = OpCodes.Ldc_I4_4;
						instr.Operand = null;
						break;

					case 5:
						instr.OpCode = OpCodes.Ldc_I4_5;
						instr.Operand = null;
						break;

					case 6:
						instr.OpCode = OpCodes.Ldc_I4_6;
						instr.Operand = null;
						break;

					case 7:
						instr.OpCode = OpCodes.Ldc_I4_7;
						instr.Operand = null;
						break;

					case 8:
						instr.OpCode = OpCodes.Ldc_I4_8;
						instr.Operand = null;
						break;

					case -1:
						instr.OpCode = OpCodes.Ldc_I4_M1;
						instr.Operand = null;
						break;

					default:
						if (sbyte.MinValue <= i4 && i4 <= sbyte.MaxValue) {
							instr.OpCode = OpCodes.Ldc_I4_S;
							instr.Operand = (sbyte)i4;
						}
						break;
					}
					break;

				case Code.Ldloc:
				case Code.Ldloc_S:
					local = instr.Operand as Local;
					if (local is null)
						break;
					if (local.Index == 0) {
						instr.OpCode = OpCodes.Ldloc_0;
						instr.Operand = null;
					}
					else if (local.Index == 1) {
						instr.OpCode = OpCodes.Ldloc_1;
						instr.Operand = null;
					}
					else if (local.Index == 2) {
						instr.OpCode = OpCodes.Ldloc_2;
						instr.Operand = null;
					}
					else if (local.Index == 3) {
						instr.OpCode = OpCodes.Ldloc_3;
						instr.Operand = null;
					}
					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Ldloc_S;
					break;

				case Code.Ldloca:
					local = instr.Operand as Local;
					if (local is null)
						break;
					if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Ldloca_S;
					break;

				case Code.Starg:
					arg = instr.Operand as Parameter;
					if (arg is null)
						break;
					if (byte.MinValue <= arg.Index && arg.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Starg_S;
					break;

				case Code.Stloc:
				case Code.Stloc_S:
					local = instr.Operand as Local;
					if (local is null)
						break;
					if (local.Index == 0) {
						instr.OpCode = OpCodes.Stloc_0;
						instr.Operand = null;
					}
					else if (local.Index == 1) {
						instr.OpCode = OpCodes.Stloc_1;
						instr.Operand = null;
					}
					else if (local.Index == 2) {
						instr.OpCode = OpCodes.Stloc_2;
						instr.Operand = null;
					}
					else if (local.Index == 3) {
						instr.OpCode = OpCodes.Stloc_3;
						instr.Operand = null;
					}
					else if (byte.MinValue <= local.Index && local.Index <= byte.MaxValue)
						instr.OpCode = OpCodes.Stloc_S;
					break;
				}
			}

			OptimizeBranches(instructions);
		}

		/// <summary>
		/// Short branch instructions are converted to the long form, eg. <c>Beq_S</c> is
		/// converted to <c>Beq</c>.
		/// </summary>
		/// <param name="instructions">All instructions</param>
		public static void SimplifyBranches(this IList<Instruction> instructions) {
			int count = instructions.Count;
			for (int i = 0; i < count; i++) {
				var instr = instructions[i];
				switch (instr.OpCode.Code) {
				case Code.Beq_S:	instr.OpCode = OpCodes.Beq; break;
				case Code.Bge_S:	instr.OpCode = OpCodes.Bge; break;
				case Code.Bgt_S:	instr.OpCode = OpCodes.Bgt; break;
				case Code.Ble_S:	instr.OpCode = OpCodes.Ble; break;
				case Code.Blt_S:	instr.OpCode = OpCodes.Blt; break;
				case Code.Bne_Un_S:	instr.OpCode = OpCodes.Bne_Un; break;
				case Code.Bge_Un_S:	instr.OpCode = OpCodes.Bge_Un; break;
				case Code.Bgt_Un_S:	instr.OpCode = OpCodes.Bgt_Un; break;
				case Code.Ble_Un_S:	instr.OpCode = OpCodes.Ble_Un; break;
				case Code.Blt_Un_S:	instr.OpCode = OpCodes.Blt_Un; break;
				case Code.Br_S:		instr.OpCode = OpCodes.Br; break;
				case Code.Brfalse_S:instr.OpCode = OpCodes.Brfalse; break;
				case Code.Brtrue_S:	instr.OpCode = OpCodes.Brtrue; break;
				case Code.Leave_S:	instr.OpCode = OpCodes.Leave; break;
				}
			}
		}

		/// <summary>
		/// Optimizes branches by using the smallest possible branch
		/// </summary>
		/// <param name="instructions">All instructions</param>
		public static void OptimizeBranches(this IList<Instruction> instructions) {
			while (true) {
				UpdateInstructionOffsets(instructions);

				bool modified = false;
				int count = instructions.Count;
				for (int i = 0; i < count; i++) {
					var instr = instructions[i];
					OpCode shortOpCode;
					switch (instr.OpCode.Code) {
					case Code.Beq:		shortOpCode = OpCodes.Beq_S; break;
					case Code.Bge:		shortOpCode = OpCodes.Bge_S; break;
					case Code.Bge_Un:	shortOpCode = OpCodes.Bge_Un_S; break;
					case Code.Bgt:		shortOpCode = OpCodes.Bgt_S; break;
					case Code.Bgt_Un:	shortOpCode = OpCodes.Bgt_Un_S; break;
					case Code.Ble:		shortOpCode = OpCodes.Ble_S; break;
					case Code.Ble_Un:	shortOpCode = OpCodes.Ble_Un_S; break;
					case Code.Blt:		shortOpCode = OpCodes.Blt_S; break;
					case Code.Blt_Un:	shortOpCode = OpCodes.Blt_Un_S; break;
					case Code.Bne_Un:	shortOpCode = OpCodes.Bne_Un_S; break;
					case Code.Br:		shortOpCode = OpCodes.Br_S; break;
					case Code.Brfalse:	shortOpCode = OpCodes.Brfalse_S; break;
					case Code.Brtrue:	shortOpCode = OpCodes.Brtrue_S; break;
					case Code.Leave:	shortOpCode = OpCodes.Leave_S; break;
					default: continue;
					}
					var targetInstr = instr.Operand as Instruction;
					if (targetInstr is null)
						continue;

					int afterShortInstr;
					if (targetInstr.Offset >= instr.Offset) {
						// Target is >= this instruction so use the offset after
						// current instruction
						afterShortInstr = (int)instr.Offset + instr.GetSize();
					}
					else {
						// Target is < this instruction so use the offset after
						// the short instruction
						const int operandSize = 1;
						afterShortInstr = (int)instr.Offset + shortOpCode.Size + operandSize;
					}

					int displ = (int)targetInstr.Offset - afterShortInstr;
					if (sbyte.MinValue <= displ && displ <= sbyte.MaxValue) {
						instr.OpCode = shortOpCode;
						modified = true;
					}
				}
				if (!modified)
					break;
			}
		}

		/// <summary>
		/// Updates each instruction's offset
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <returns>Total size in bytes of all instructions</returns>
		public static uint UpdateInstructionOffsets(this IList<Instruction> instructions) {
			uint offset = 0;
			int count = instructions.Count;
			for (int i = 0; i < count; i++) {
				var instr = instructions[i];
				instr.Offset = offset;
				offset += (uint)instr.GetSize();
			}
			return offset;
		}
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A CIL opcode
	/// </summary>
	public sealed class OpCode {
		/// <summary>
		/// The opcode name
		/// </summary>
		public readonly string Name;

		/// <summary>
		/// The opcode as a <see cref="Code"/> enum
		/// </summary>
		public readonly Code Code;

		/// <summary>
		/// Operand type
		/// </summary>
		public readonly OperandType OperandType;

		/// <summary>
		/// Flow control info
		/// </summary>
		public readonly FlowControl FlowControl;

		/// <summary>
		/// Opcode type
		/// </summary>
		public readonly OpCodeType OpCodeType;

		/// <summary>
		/// Push stack behavior
		/// </summary>
		public readonly StackBehaviour StackBehaviourPush;

		/// <summary>
		/// Pop stack behavior
		/// </summary>
		public readonly StackBehaviour StackBehaviourPop;

		/// <summary>
		/// Gets the value which is compatible with <see cref="System.Reflection.Emit.OpCode.Value"/>
		/// </summary>
		public short Value => (short)Code;

		/// <summary>
		/// Gets the size of the opcode. It's either 1 or 2 bytes.
		/// </summary>
		public int Size => Code < (Code)0x100 || Code == Code.UNKNOWN1 ? 1 : 2;

		/// <summary>
		/// Constructs an experimental opcode.
		/// </summary>
		public OpCode(string name, byte first, byte second, OperandType operandType, FlowControl flowControl, StackBehaviour push, StackBehaviour pop)
			: this(name, (Code)((first << 8) | second), operandType, flowControl, OpCodeType.Experimental, push, pop, true) {
		}

		internal OpCode(string name, Code code, OperandType operandType, FlowControl flowControl, OpCodeType opCodeType, StackBehaviour push, StackBehaviour pop, bool experimental = false) {
			Name = name;
			Code = code;
			OperandType = operandType;
			FlowControl = flowControl;
			OpCodeType = opCodeType;
			StackBehaviourPush = push;
			StackBehaviourPop = pop;
			if (!experimental) {
				if (((ushort)code >> 8) == 0)
					OpCodes.OneByteOpCodes[(byte)code] = this;
				else if (((ushort)code >> 8) == 0xFE)
					OpCodes.TwoByteOpCodes[(byte)code] = this;
			}
		}

		/// <summary>
		/// Creates a new instruction with no operand
		/// </summary>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction() => Instruction.Create(this);

		/// <summary>
		/// Creates a new instruction with a <see cref="byte"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(byte value) => Instruction.Create(this, value);

		/// <summary>
		/// Creates a new instruction with a <see cref="sbyte"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(sbyte value) => Instruction.Create(this, value);

		/// <summary>
		/// Creates a new instruction with an <see cref="int"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(int value) => Instruction.Create(this, value);

		/// <summary>
		/// Creates a new instruction with a <see cref="long"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(long value) => Instruction.Create(this, value);

		/// <summary>
		/// Creates a new instruction with a <see cref="float"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(float value) => Instruction.Create(this, value);

		/// <summary>
		/// Creates a new instruction with a <see cref="double"/> operand
		/// </summary>
		/// <param name="value">The value</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(double value) => Instruction.Create(this, value);

		/// <summary>
		/// Creates a new instruction with a string operand
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(string s) => Instruction.Create(this, s);

		/// <summary>
		/// Creates a new instruction with an instruction target operand
		/// </summary>
		/// <param name="target">Target instruction</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(Instruction target) => Instruction.Create(this, target);

		/// <summary>
		/// Creates a new instruction with an instruction target list operand
		/// </summary>
		/// <param name="targets">The targets</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(IList<Instruction> targets) => Instruction.Create(this, targets);

		/// <summary>
		/// Creates a new instruction with a type operand
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(ITypeDefOrRef type) => Instruction.Create(this, type);

		/// <summary>
		/// Creates a new instruction with a type operand
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(CorLibTypeSig type) => Instruction.Create(this, type.TypeDefOrRef);

		/// <summary>
		/// Creates a new instruction with a method/field operand
		/// </summary>
		/// <param name="mr">The method/field</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(MemberRef mr) => Instruction.Create(this, mr);

		/// <summary>
		/// Creates a new instruction with a field operand
		/// </summary>
		/// <param name="field">The field</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(IField field) => Instruction.Create(this, field);

		/// <summary>
		/// Creates a new instruction with a method operand
		/// </summary>
		/// <param name="method">The method</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(IMethod method) => Instruction.Create(this, method);

		/// <summary>
		/// Creates a new instruction with a token operand
		/// </summary>
		/// <param name="token">The token</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(ITokenOperand token) => Instruction.Create(this, token);

		/// <summary>
		/// Creates a new instruction with a method signature operand
		/// </summary>
		/// <param name="methodSig">The method signature</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(MethodSig methodSig) => Instruction.Create(this, methodSig);

		/// <summary>
		/// Creates a new instruction with a method parameter operand
		/// </summary>
		/// <param name="parameter">The method parameter</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(Parameter parameter) => Instruction.Create(this, parameter);

		/// <summary>
		/// Creates a new instruction with a method local operand
		/// </summary>
		/// <param name="local">The method local</param>
		/// <returns>A new <see cref="Instruction"/> instance</returns>
		public Instruction ToInstruction(Local local) => Instruction.Create(this, local);

		/// <inheritdoc/>
		public override string ToString() => Name;
	}
}




namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Contains all valid CIL opcodes
	/// </summary>
	public static class OpCodes {
		/// <summary>
		/// All one-byte opcodes
		/// </summary>
		public static readonly OpCode[] OneByteOpCodes = new OpCode[0x100];

		/// <summary>
		/// All two-byte opcodes (first byte is <c>0xFE</c>)
		/// </summary>
		public static readonly OpCode[] TwoByteOpCodes = new OpCode[0x100];

#pragma warning disable 1591	// disable XML doc warning
		public static readonly OpCode UNKNOWN1		= new OpCode("UNKNOWN1",		Code.UNKNOWN1, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode UNKNOWN2		= new OpCode("UNKNOWN2",		Code.UNKNOWN2, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Nop			= new OpCode("nop",				Code.Nop, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Break			= new OpCode("break",			Code.Break, OperandType.InlineNone, FlowControl.Break, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Ldarg_0		= new OpCode("ldarg.0",			Code.Ldarg_0, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarg_1		= new OpCode("ldarg.1",			Code.Ldarg_1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarg_2		= new OpCode("ldarg.2",			Code.Ldarg_2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarg_3		= new OpCode("ldarg.3",			Code.Ldarg_3, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloc_0		= new OpCode("ldloc.0",			Code.Ldloc_0, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloc_1		= new OpCode("ldloc.1",			Code.Ldloc_1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloc_2		= new OpCode("ldloc.2",			Code.Ldloc_2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloc_3		= new OpCode("ldloc.3",			Code.Ldloc_3, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Stloc_0		= new OpCode("stloc.0",			Code.Stloc_0, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Stloc_1		= new OpCode("stloc.1",			Code.Stloc_1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Stloc_2		= new OpCode("stloc.2",			Code.Stloc_2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Stloc_3		= new OpCode("stloc.3",			Code.Stloc_3, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Ldarg_S		= new OpCode("ldarg.s",			Code.Ldarg_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarga_S		= new OpCode("ldarga.s",		Code.Ldarga_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Starg_S		= new OpCode("starg.s",			Code.Starg_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Ldloc_S		= new OpCode("ldloc.s",			Code.Ldloc_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloca_S		= new OpCode("ldloca.s",		Code.Ldloca_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Stloc_S		= new OpCode("stloc.s",			Code.Stloc_S, OperandType.ShortInlineVar, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Ldnull		= new OpCode("ldnull",			Code.Ldnull, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushref, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_M1		= new OpCode("ldc.i4.m1",		Code.Ldc_I4_M1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_0		= new OpCode("ldc.i4.0",		Code.Ldc_I4_0, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_1		= new OpCode("ldc.i4.1",		Code.Ldc_I4_1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_2		= new OpCode("ldc.i4.2",		Code.Ldc_I4_2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_3		= new OpCode("ldc.i4.3",		Code.Ldc_I4_3, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_4		= new OpCode("ldc.i4.4",		Code.Ldc_I4_4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_5		= new OpCode("ldc.i4.5",		Code.Ldc_I4_5, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_6		= new OpCode("ldc.i4.6",		Code.Ldc_I4_6, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_7		= new OpCode("ldc.i4.7",		Code.Ldc_I4_7, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_8		= new OpCode("ldc.i4.8",		Code.Ldc_I4_8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4_S		= new OpCode("ldc.i4.s",		Code.Ldc_I4_S, OperandType.ShortInlineI, FlowControl.Next, OpCodeType.Macro, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I4		= new OpCode("ldc.i4",			Code.Ldc_I4, OperandType.InlineI, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_I8		= new OpCode("ldc.i8",			Code.Ldc_I8, OperandType.InlineI8, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_R4		= new OpCode("ldc.r4",			Code.Ldc_R4, OperandType.ShortInlineR, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr4, StackBehaviour.Pop0);
		public static readonly OpCode Ldc_R8		= new OpCode("ldc.r8",			Code.Ldc_R8, OperandType.InlineR, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Pop0);
		public static readonly OpCode Dup			= new OpCode("dup",				Code.Dup, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1_push1, StackBehaviour.Pop1);
		public static readonly OpCode Pop			= new OpCode("pop",				Code.Pop, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Jmp			= new OpCode("jmp",				Code.Jmp, OperandType.InlineMethod, FlowControl.Call, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Call			= new OpCode("call",			Code.Call, OperandType.InlineMethod, FlowControl.Call, OpCodeType.Primitive, StackBehaviour.Varpush, StackBehaviour.Varpop);
		public static readonly OpCode Calli			= new OpCode("calli",			Code.Calli, OperandType.InlineSig, FlowControl.Call, OpCodeType.Primitive, StackBehaviour.Varpush, StackBehaviour.Varpop);
		public static readonly OpCode Ret			= new OpCode("ret",				Code.Ret, OperandType.InlineNone, FlowControl.Return, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Varpop);
		public static readonly OpCode Br_S			= new OpCode("br.s",			Code.Br_S, OperandType.ShortInlineBrTarget, FlowControl.Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Brfalse_S		= new OpCode("brfalse.s",		Code.Brfalse_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Brtrue_S		= new OpCode("brtrue.s",		Code.Brtrue_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Beq_S			= new OpCode("beq.s",			Code.Beq_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bge_S			= new OpCode("bge.s",			Code.Bge_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bgt_S			= new OpCode("bgt.s",			Code.Bgt_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ble_S			= new OpCode("ble.s",			Code.Ble_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Blt_S			= new OpCode("blt.s",			Code.Blt_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bne_Un_S		= new OpCode("bne.un.s",		Code.Bne_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bge_Un_S		= new OpCode("bge.un.s",		Code.Bge_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bgt_Un_S		= new OpCode("bgt.un.s",		Code.Bgt_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ble_Un_S		= new OpCode("ble.un.s",		Code.Ble_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Blt_Un_S		= new OpCode("blt.un.s",		Code.Blt_Un_S, OperandType.ShortInlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Br			= new OpCode("br",				Code.Br, OperandType.InlineBrTarget, FlowControl.Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Brfalse		= new OpCode("brfalse",			Code.Brfalse, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Brtrue		= new OpCode("brtrue",			Code.Brtrue, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Beq			= new OpCode("beq",				Code.Beq, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bge			= new OpCode("bge",				Code.Bge, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bgt			= new OpCode("bgt",				Code.Bgt, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ble			= new OpCode("ble",				Code.Ble, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Blt			= new OpCode("blt",				Code.Blt, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bne_Un		= new OpCode("bne.un",			Code.Bne_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bge_Un		= new OpCode("bge.un",			Code.Bge_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Bgt_Un		= new OpCode("bgt.un",			Code.Bgt_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ble_Un		= new OpCode("ble.un",			Code.Ble_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Blt_Un		= new OpCode("blt.un",			Code.Blt_Un, OperandType.InlineBrTarget, FlowControl.Cond_Branch, OpCodeType.Macro, StackBehaviour.Push0, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Switch		= new OpCode("switch",			Code.Switch, OperandType.InlineSwitch, FlowControl.Cond_Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I1		= new OpCode("ldind.i1",		Code.Ldind_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_U1		= new OpCode("ldind.u1",		Code.Ldind_U1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I2		= new OpCode("ldind.i2",		Code.Ldind_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_U2		= new OpCode("ldind.u2",		Code.Ldind_U2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I4		= new OpCode("ldind.i4",		Code.Ldind_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_U4		= new OpCode("ldind.u4",		Code.Ldind_U4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I8		= new OpCode("ldind.i8",		Code.Ldind_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Popi);
		public static readonly OpCode Ldind_I		= new OpCode("ldind.i",			Code.Ldind_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Ldind_R4		= new OpCode("ldind.r4",		Code.Ldind_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr4, StackBehaviour.Popi);
		public static readonly OpCode Ldind_R8		= new OpCode("ldind.r8",		Code.Ldind_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Popi);
		public static readonly OpCode Ldind_Ref		= new OpCode("ldind.ref",		Code.Ldind_Ref, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushref, StackBehaviour.Popi);
		public static readonly OpCode Stind_Ref		= new OpCode("stind.ref",		Code.Stind_Ref, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Stind_I1		= new OpCode("stind.i1",		Code.Stind_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Stind_I2		= new OpCode("stind.i2",		Code.Stind_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Stind_I4		= new OpCode("stind.i4",		Code.Stind_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Stind_I8		= new OpCode("stind.i8",		Code.Stind_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi8);
		public static readonly OpCode Stind_R4		= new OpCode("stind.r4",		Code.Stind_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popr4);
		public static readonly OpCode Stind_R8		= new OpCode("stind.r8",		Code.Stind_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popr8);
		public static readonly OpCode Add			= new OpCode("add",				Code.Add, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Sub			= new OpCode("sub",				Code.Sub, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Mul			= new OpCode("mul",				Code.Mul, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Div			= new OpCode("div",				Code.Div, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Div_Un		= new OpCode("div.un",			Code.Div_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Rem			= new OpCode("rem",				Code.Rem, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Rem_Un		= new OpCode("rem.un",			Code.Rem_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode And			= new OpCode("and",				Code.And, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Or			= new OpCode("or",				Code.Or, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Xor			= new OpCode("xor",				Code.Xor, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Shl			= new OpCode("shl",				Code.Shl, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Shr			= new OpCode("shr",				Code.Shr, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Shr_Un		= new OpCode("shr.un",			Code.Shr_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Neg			= new OpCode("neg",				Code.Neg, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1);
		public static readonly OpCode Not			= new OpCode("not",				Code.Not, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I1		= new OpCode("conv.i1",			Code.Conv_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I2		= new OpCode("conv.i2",			Code.Conv_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I4		= new OpCode("conv.i4",			Code.Conv_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I8		= new OpCode("conv.i8",			Code.Conv_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_R4		= new OpCode("conv.r4",			Code.Conv_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr4, StackBehaviour.Pop1);
		public static readonly OpCode Conv_R8		= new OpCode("conv.r8",			Code.Conv_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_U4		= new OpCode("conv.u4",			Code.Conv_U4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_U8		= new OpCode("conv.u8",			Code.Conv_U8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Callvirt		= new OpCode("callvirt",		Code.Callvirt, OperandType.InlineMethod, FlowControl.Call, OpCodeType.Objmodel, StackBehaviour.Varpush, StackBehaviour.Varpop);
		public static readonly OpCode Cpobj			= new OpCode("cpobj",			Code.Cpobj, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Ldobj			= new OpCode("ldobj",			Code.Ldobj, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Popi);
		public static readonly OpCode Ldstr			= new OpCode("ldstr",			Code.Ldstr, OperandType.InlineString, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Pop0);
		public static readonly OpCode Newobj		= new OpCode("newobj",			Code.Newobj, OperandType.InlineMethod, FlowControl.Call, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Varpop);
		public static readonly OpCode Castclass		= new OpCode("castclass",		Code.Castclass, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Popref);
		public static readonly OpCode Isinst		= new OpCode("isinst",			Code.Isinst, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Conv_R_Un		= new OpCode("conv.r.un",		Code.Conv_R_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Pop1);
		public static readonly OpCode Unbox			= new OpCode("unbox",			Code.Unbox, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Throw			= new OpCode("throw",			Code.Throw, OperandType.InlineNone, FlowControl.Throw, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref);
		public static readonly OpCode Ldfld			= new OpCode("ldfld",			Code.Ldfld, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Popref);
		public static readonly OpCode Ldflda		= new OpCode("ldflda",			Code.Ldflda, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Stfld			= new OpCode("stfld",			Code.Stfld, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_pop1);
		public static readonly OpCode Ldsfld		= new OpCode("ldsfld",			Code.Ldsfld, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldsflda		= new OpCode("ldsflda",			Code.Ldsflda, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Stsfld		= new OpCode("stsfld",			Code.Stsfld, OperandType.InlineField, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Stobj			= new OpCode("stobj",			Code.Stobj, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_pop1);
		public static readonly OpCode Conv_Ovf_I1_Un= new OpCode("conv.ovf.i1.un",	Code.Conv_Ovf_I1_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I2_Un= new OpCode("conv.ovf.i2.un",	Code.Conv_Ovf_I2_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I4_Un= new OpCode("conv.ovf.i4.un",	Code.Conv_Ovf_I4_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I8_Un= new OpCode("conv.ovf.i8.un",	Code.Conv_Ovf_I8_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U1_Un= new OpCode("conv.ovf.u1.un",	Code.Conv_Ovf_U1_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U2_Un= new OpCode("conv.ovf.u2.un",	Code.Conv_Ovf_U2_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U4_Un= new OpCode("conv.ovf.u4.un",	Code.Conv_Ovf_U4_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U8_Un= new OpCode("conv.ovf.u8.un",	Code.Conv_Ovf_U8_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I_Un	= new OpCode("conv.ovf.i.un",	Code.Conv_Ovf_I_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U_Un	= new OpCode("conv.ovf.u.un",	Code.Conv_Ovf_U_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Box			= new OpCode("box",				Code.Box, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushref, StackBehaviour.Pop1);
		public static readonly OpCode Newarr		= new OpCode("newarr",			Code.Newarr, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Popi);
		public static readonly OpCode Ldlen			= new OpCode("ldlen",			Code.Ldlen, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Ldelema		= new OpCode("ldelema",			Code.Ldelema, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I1		= new OpCode("ldelem.i1",		Code.Ldelem_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_U1		= new OpCode("ldelem.u1",		Code.Ldelem_U1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I2		= new OpCode("ldelem.i2",		Code.Ldelem_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_U2		= new OpCode("ldelem.u2",		Code.Ldelem_U2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I4		= new OpCode("ldelem.i4",		Code.Ldelem_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_U4		= new OpCode("ldelem.u4",		Code.Ldelem_U4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I8		= new OpCode("ldelem.i8",		Code.Ldelem_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi8, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_I		= new OpCode("ldelem.i",		Code.Ldelem_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushi, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_R4		= new OpCode("ldelem.r4",		Code.Ldelem_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushr4, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_R8		= new OpCode("ldelem.r8",		Code.Ldelem_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushr8, StackBehaviour.Popref_popi);
		public static readonly OpCode Ldelem_Ref	= new OpCode("ldelem.ref",		Code.Ldelem_Ref, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Pushref, StackBehaviour.Popref_popi);
		public static readonly OpCode Stelem_I		= new OpCode("stelem.i",		Code.Stelem_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi);
		public static readonly OpCode Stelem_I1		= new OpCode("stelem.i1",		Code.Stelem_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi);
		public static readonly OpCode Stelem_I2		= new OpCode("stelem.i2",		Code.Stelem_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi);
		public static readonly OpCode Stelem_I4		= new OpCode("stelem.i4",		Code.Stelem_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi);
		public static readonly OpCode Stelem_I8		= new OpCode("stelem.i8",		Code.Stelem_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popi8);
		public static readonly OpCode Stelem_R4		= new OpCode("stelem.r4",		Code.Stelem_R4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popr4);
		public static readonly OpCode Stelem_R8		= new OpCode("stelem.r8",		Code.Stelem_R8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popr8);
		public static readonly OpCode Stelem_Ref	= new OpCode("stelem.ref",		Code.Stelem_Ref, OperandType.InlineNone, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_popref);
		public static readonly OpCode Ldelem		= new OpCode("ldelem",			Code.Ldelem, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Popref_popi);
		public static readonly OpCode Stelem		= new OpCode("stelem",			Code.Stelem, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popref_popi_pop1);
		public static readonly OpCode Unbox_Any		= new OpCode("unbox.any",		Code.Unbox_Any, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push1, StackBehaviour.Popref);
		public static readonly OpCode Conv_Ovf_I1	= new OpCode("conv.ovf.i1",		Code.Conv_Ovf_I1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U1	= new OpCode("conv.ovf.u1",		Code.Conv_Ovf_U1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I2	= new OpCode("conv.ovf.i2",		Code.Conv_Ovf_I2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U2	= new OpCode("conv.ovf.u2",		Code.Conv_Ovf_U2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I4	= new OpCode("conv.ovf.i4",		Code.Conv_Ovf_I4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U4	= new OpCode("conv.ovf.u4",		Code.Conv_Ovf_U4, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I8	= new OpCode("conv.ovf.i8",		Code.Conv_Ovf_I8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U8	= new OpCode("conv.ovf.u8",		Code.Conv_Ovf_U8, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi8, StackBehaviour.Pop1);
		public static readonly OpCode Refanyval		= new OpCode("refanyval",		Code.Refanyval, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Ckfinite		= new OpCode("ckfinite",		Code.Ckfinite, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushr8, StackBehaviour.Pop1);
		public static readonly OpCode Mkrefany		= new OpCode("mkrefany",		Code.Mkrefany, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Popi);
		public static readonly OpCode Ldtoken		= new OpCode("ldtoken",			Code.Ldtoken, OperandType.InlineTok, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Conv_U2		= new OpCode("conv.u2",			Code.Conv_U2, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_U1		= new OpCode("conv.u1",			Code.Conv_U1, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_I		= new OpCode("conv.i",			Code.Conv_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_I	= new OpCode("conv.ovf.i",		Code.Conv_Ovf_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Conv_Ovf_U	= new OpCode("conv.ovf.u",		Code.Conv_Ovf_U, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Add_Ovf		= new OpCode("add.ovf",			Code.Add_Ovf, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Add_Ovf_Un	= new OpCode("add.ovf.un",		Code.Add_Ovf_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Mul_Ovf		= new OpCode("mul.ovf",			Code.Mul_Ovf, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Mul_Ovf_Un	= new OpCode("mul.ovf.un",		Code.Mul_Ovf_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Sub_Ovf		= new OpCode("sub.ovf",			Code.Sub_Ovf, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Sub_Ovf_Un	= new OpCode("sub.ovf.un",		Code.Sub_Ovf_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Endfinally	= new OpCode("endfinally",		Code.Endfinally, OperandType.InlineNone, FlowControl.Return, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.PopAll);
		public static readonly OpCode Leave			= new OpCode("leave",			Code.Leave, OperandType.InlineBrTarget, FlowControl.Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.PopAll);
		public static readonly OpCode Leave_S		= new OpCode("leave.s",			Code.Leave_S, OperandType.ShortInlineBrTarget, FlowControl.Branch, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.PopAll);
		public static readonly OpCode Stind_I		= new OpCode("stind.i",			Code.Stind_I, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi);
		public static readonly OpCode Conv_U		= new OpCode("conv.u",			Code.Conv_U, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Prefix7		= new OpCode("prefix7",			Code.Prefix7, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix6		= new OpCode("prefix6",			Code.Prefix6, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix5		= new OpCode("prefix5",			Code.Prefix5, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix4		= new OpCode("prefix4",			Code.Prefix4, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix3		= new OpCode("prefix3",			Code.Prefix3, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix2		= new OpCode("prefix2",			Code.Prefix2, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefix1		= new OpCode("prefix1",			Code.Prefix1, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Prefixref		= new OpCode("prefixref",		Code.Prefixref, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Nternal, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Arglist		= new OpCode("arglist",			Code.Arglist, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ceq			= new OpCode("ceq",				Code.Ceq, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Cgt			= new OpCode("cgt",				Code.Cgt, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Cgt_Un		= new OpCode("cgt.un",			Code.Cgt_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Clt			= new OpCode("clt",				Code.Clt, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Clt_Un		= new OpCode("clt.un",			Code.Clt_Un, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1_pop1);
		public static readonly OpCode Ldftn			= new OpCode("ldftn",			Code.Ldftn, OperandType.InlineMethod, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Ldvirtftn		= new OpCode("ldvirtftn",		Code.Ldvirtftn, OperandType.InlineMethod, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popref);
		public static readonly OpCode Ldarg			= new OpCode("ldarg",			Code.Ldarg, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldarga		= new OpCode("ldarga",			Code.Ldarga, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Starg			= new OpCode("starg",			Code.Starg, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Ldloc			= new OpCode("ldloc",			Code.Ldloc, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push1, StackBehaviour.Pop0);
		public static readonly OpCode Ldloca		= new OpCode("ldloca",			Code.Ldloca, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Stloc			= new OpCode("stloc",			Code.Stloc, OperandType.InlineVar, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Pop1);
		public static readonly OpCode Localloc		= new OpCode("localloc",		Code.Localloc, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Popi);
		public static readonly OpCode Endfilter		= new OpCode("endfilter",		Code.Endfilter, OperandType.InlineNone, FlowControl.Return, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Unaligned		= new OpCode("unaligned.",		Code.Unaligned, OperandType.ShortInlineI, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Volatile		= new OpCode("volatile.",		Code.Volatile, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Tailcall		= new OpCode("tail.",			Code.Tailcall, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Initobj		= new OpCode("initobj",			Code.Initobj, OperandType.InlineType, FlowControl.Next, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Popi);
		public static readonly OpCode Constrained	= new OpCode("constrained.",	Code.Constrained, OperandType.InlineType, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Cpblk			= new OpCode("cpblk",			Code.Cpblk, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi_popi);
		public static readonly OpCode Initblk		= new OpCode("initblk",			Code.Initblk, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Push0, StackBehaviour.Popi_popi_popi);
		public static readonly OpCode No			= new OpCode("no.",				Code.No, OperandType.ShortInlineI, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Rethrow		= new OpCode("rethrow",			Code.Rethrow, OperandType.InlineNone, FlowControl.Throw, OpCodeType.Objmodel, StackBehaviour.Push0, StackBehaviour.Pop0);
		public static readonly OpCode Sizeof		= new OpCode("sizeof",			Code.Sizeof, OperandType.InlineType, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop0);
		public static readonly OpCode Refanytype	= new OpCode("refanytype",		Code.Refanytype, OperandType.InlineNone, FlowControl.Next, OpCodeType.Primitive, StackBehaviour.Pushi, StackBehaviour.Pop1);
		public static readonly OpCode Readonly		= new OpCode("readonly.",		Code.Readonly, OperandType.InlineNone, FlowControl.Meta, OpCodeType.Prefix, StackBehaviour.Push0, StackBehaviour.Pop0);
#pragma warning restore

		static OpCodes() {
			// The OpCode ctor copies itself to one of these arrays. Whatever are still null
			// are unsupported opcodes. Set them all to UNKNOWN1 or UNKNOWN2.
			for (int i = 0; i < OneByteOpCodes.Length; i++) {
				if (OneByteOpCodes[i] is null)
					OneByteOpCodes[i] = UNKNOWN1;
			}
			for (int i = 0; i < TwoByteOpCodes.Length; i++) {
				if (TwoByteOpCodes[i] is null)
					TwoByteOpCodes[i] = UNKNOWN2;
			}
		}
	}
}




namespace dnlib.DotNet.Emit {
	/// <summary>
	/// CIL opcode type
	/// </summary>
	public enum OpCodeType : byte {
		/// <summary/>
		Annotation,
		/// <summary/>
		Macro,
		/// <summary/>
		Nternal,
		/// <summary/>
		Objmodel,
		/// <summary/>
		Prefix,
		/// <summary/>
		Primitive,
		/// <summary/>
		Experimental,
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// CIL opcode operand type
	/// </summary>
	public enum OperandType : byte {
		/// <summary>4-byte relative instruction offset</summary>
		InlineBrTarget,
		/// <summary>4-byte field token (<see cref="Table.Field"/> or <see cref="Table.MemberRef"/>)</summary>
		InlineField,
		/// <summary>int32</summary>
		InlineI,
		/// <summary>int64</summary>
		InlineI8,
		/// <summary>4-byte method token (<see cref="Table.Method"/>, <see cref="Table.MemberRef"/>
		/// or <see cref="Table.MethodSpec"/>)</summary>
		InlineMethod,
		/// <summary>No operand</summary>
		InlineNone,
		/// <summary>Never used</summary>
		InlinePhi,
		/// <summary>64-bit real</summary>
		InlineR,
		/// <summary/>
		NOT_USED_8,
		/// <summary>4-byte method sig token (<see cref="Table.StandAloneSig"/>)</summary>
		InlineSig,
		/// <summary>4-byte string token (<c>0x70xxxxxx</c>)</summary>
		InlineString,
		/// <summary>4-byte count N followed by N 4-byte relative instruction offsets</summary>
		InlineSwitch,
		/// <summary>4-byte token (<see cref="Table.Field"/>, <see cref="Table.MemberRef"/>,
		/// <see cref="Table.Method"/>, <see cref="Table.MethodSpec"/>, <see cref="Table.TypeDef"/>,
		/// <see cref="Table.TypeRef"/> or <see cref="Table.TypeSpec"/>)</summary>
		InlineTok,
		/// <summary>4-byte type token (<see cref="Table.TypeDef"/>, <see cref="Table.TypeRef"/> or
		/// <see cref="Table.TypeSpec"/>)</summary>
		InlineType,
		/// <summary>2-byte param/local index</summary>
		InlineVar,
		/// <summary>1-byte relative instruction offset</summary>
		ShortInlineBrTarget,
		/// <summary>1-byte sbyte (<see cref="Code.Ldc_I4_S"/>) or byte (the rest)</summary>
		ShortInlineI,
		/// <summary>32-bit real</summary>
		ShortInlineR,
		/// <summary>1-byte param/local index</summary>
		ShortInlineVar,
	}
}




namespace dnlib.DotNet.Emit {
	/// <summary>
	/// CIL opcode stack behavior
	/// </summary>
	public enum StackBehaviour : byte {
		/// <summary/>
		Pop0,
		/// <summary/>
		Pop1,
		/// <summary/>
		Pop1_pop1,
		/// <summary/>
		Popi,
		/// <summary/>
		Popi_pop1,
		/// <summary/>
		Popi_popi,
		/// <summary/>
		Popi_popi8,
		/// <summary/>
		Popi_popi_popi,
		/// <summary/>
		Popi_popr4,
		/// <summary/>
		Popi_popr8,
		/// <summary/>
		Popref,
		/// <summary/>
		Popref_pop1,
		/// <summary/>
		Popref_popi,
		/// <summary/>
		Popref_popi_popi,
		/// <summary/>
		Popref_popi_popi8,
		/// <summary/>
		Popref_popi_popr4,
		/// <summary/>
		Popref_popi_popr8,
		/// <summary/>
		Popref_popi_popref,
		/// <summary/>
		Push0,
		/// <summary/>
		Push1,
		/// <summary/>
		Push1_push1,
		/// <summary/>
		Pushi,
		/// <summary/>
		Pushi8,
		/// <summary/>
		Pushr4,
		/// <summary/>
		Pushr8,
		/// <summary/>
		Pushref,
		/// <summary/>
		Varpop,
		/// <summary/>
		Varpush,
		/// <summary/>
		Popref_popi_pop1,
		/// <summary/>
		PopAll = 0xFF,
	}
}




namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A CIL opcode. If the high byte is 0 or if it's <see cref="UNKNOWN1"/>, it's a 1-byte opcode,
	/// else it's a two-byte opcode and the highest byte is the first byte of the opcode.
	/// </summary>
	public enum Code : ushort {
#pragma warning disable 1591	// disable XML doc warning
		UNKNOWN1		= 0x0100,
		UNKNOWN2		= 0x0101,
		Add				= 0x0058,
		Add_Ovf			= 0x00D6,
		Add_Ovf_Un		= 0x00D7,
		And				= 0x005F,
		Arglist			= 0xFE00,
		Beq				= 0x003B,
		Beq_S			= 0x002E,
		Bge				= 0x003C,
		Bge_S			= 0x002F,
		Bge_Un			= 0x0041,
		Bge_Un_S		= 0x0034,
		Bgt				= 0x003D,
		Bgt_S			= 0x0030,
		Bgt_Un			= 0x0042,
		Bgt_Un_S		= 0x0035,
		Ble				= 0x003E,
		Ble_S			= 0x0031,
		Ble_Un			= 0x0043,
		Ble_Un_S		= 0x0036,
		Blt				= 0x003F,
		Blt_S			= 0x0032,
		Blt_Un			= 0x0044,
		Blt_Un_S		= 0x0037,
		Bne_Un			= 0x0040,
		Bne_Un_S		= 0x0033,
		Box				= 0x008C,
		Br				= 0x0038,
		Br_S			= 0x002B,
		Break			= 0x0001,
		Brfalse			= 0x0039,
		Brfalse_S		= 0x002C,
		Brtrue			= 0x003A,
		Brtrue_S		= 0x002D,
		Call			= 0x0028,
		Calli			= 0x0029,
		Callvirt		= 0x006F,
		Castclass		= 0x0074,
		Ceq				= 0xFE01,
		Cgt				= 0xFE02,
		Cgt_Un			= 0xFE03,
		Ckfinite		= 0x00C3,
		Clt				= 0xFE04,
		Clt_Un			= 0xFE05,
		Constrained		= 0xFE16,
		Conv_I			= 0x00D3,
		Conv_I1			= 0x0067,
		Conv_I2			= 0x0068,
		Conv_I4			= 0x0069,
		Conv_I8			= 0x006A,
		Conv_Ovf_I		= 0x00D4,
		Conv_Ovf_I_Un	= 0x008A,
		Conv_Ovf_I1		= 0x00B3,
		Conv_Ovf_I1_Un	= 0x0082,
		Conv_Ovf_I2		= 0x00B5,
		Conv_Ovf_I2_Un	= 0x0083,
		Conv_Ovf_I4		= 0x00B7,
		Conv_Ovf_I4_Un	= 0x0084,
		Conv_Ovf_I8		= 0x00B9,
		Conv_Ovf_I8_Un	= 0x0085,
		Conv_Ovf_U		= 0x00D5,
		Conv_Ovf_U_Un	= 0x008B,
		Conv_Ovf_U1		= 0x00B4,
		Conv_Ovf_U1_Un	= 0x0086,
		Conv_Ovf_U2		= 0x00B6,
		Conv_Ovf_U2_Un	= 0x0087,
		Conv_Ovf_U4		= 0x00B8,
		Conv_Ovf_U4_Un	= 0x0088,
		Conv_Ovf_U8		= 0x00BA,
		Conv_Ovf_U8_Un	= 0x0089,
		Conv_R_Un		= 0x0076,
		Conv_R4			= 0x006B,
		Conv_R8			= 0x006C,
		Conv_U			= 0x00E0,
		Conv_U1			= 0x00D2,
		Conv_U2			= 0x00D1,
		Conv_U4			= 0x006D,
		Conv_U8			= 0x006E,
		Cpblk			= 0xFE17,
		Cpobj			= 0x0070,
		Div				= 0x005B,
		Div_Un			= 0x005C,
		Dup				= 0x0025,
		Endfilter		= 0xFE11,
		Endfinally		= 0x00DC,
		Initblk			= 0xFE18,
		Initobj			= 0xFE15,
		Isinst			= 0x0075,
		Jmp				= 0x0027,
		Ldarg			= 0xFE09,
		Ldarg_0			= 0x0002,
		Ldarg_1			= 0x0003,
		Ldarg_2			= 0x0004,
		Ldarg_3			= 0x0005,
		Ldarg_S			= 0x000E,
		Ldarga			= 0xFE0A,
		Ldarga_S		= 0x000F,
		Ldc_I4			= 0x0020,
		Ldc_I4_0		= 0x0016,
		Ldc_I4_1		= 0x0017,
		Ldc_I4_2		= 0x0018,
		Ldc_I4_3		= 0x0019,
		Ldc_I4_4		= 0x001A,
		Ldc_I4_5		= 0x001B,
		Ldc_I4_6		= 0x001C,
		Ldc_I4_7		= 0x001D,
		Ldc_I4_8		= 0x001E,
		Ldc_I4_M1		= 0x0015,
		Ldc_I4_S		= 0x001F,
		Ldc_I8			= 0x0021,
		Ldc_R4			= 0x0022,
		Ldc_R8			= 0x0023,
		Ldelem			= 0x00A3,
		Ldelem_I		= 0x0097,
		Ldelem_I1		= 0x0090,
		Ldelem_I2		= 0x0092,
		Ldelem_I4		= 0x0094,
		Ldelem_I8		= 0x0096,
		Ldelem_R4		= 0x0098,
		Ldelem_R8		= 0x0099,
		Ldelem_Ref		= 0x009A,
		Ldelem_U1		= 0x0091,
		Ldelem_U2		= 0x0093,
		Ldelem_U4		= 0x0095,
		Ldelema			= 0x008F,
		Ldfld			= 0x007B,
		Ldflda			= 0x007C,
		Ldftn			= 0xFE06,
		Ldind_I			= 0x004D,
		Ldind_I1		= 0x0046,
		Ldind_I2		= 0x0048,
		Ldind_I4		= 0x004A,
		Ldind_I8		= 0x004C,
		Ldind_R4		= 0x004E,
		Ldind_R8		= 0x004F,
		Ldind_Ref		= 0x0050,
		Ldind_U1		= 0x0047,
		Ldind_U2		= 0x0049,
		Ldind_U4		= 0x004B,
		Ldlen			= 0x008E,
		Ldloc			= 0xFE0C,
		Ldloc_0			= 0x0006,
		Ldloc_1			= 0x0007,
		Ldloc_2			= 0x0008,
		Ldloc_3			= 0x0009,
		Ldloc_S			= 0x0011,
		Ldloca			= 0xFE0D,
		Ldloca_S		= 0x0012,
		Ldnull			= 0x0014,
		Ldobj			= 0x0071,
		Ldsfld			= 0x007E,
		Ldsflda			= 0x007F,
		Ldstr			= 0x0072,
		Ldtoken			= 0x00D0,
		Ldvirtftn		= 0xFE07,
		Leave			= 0x00DD,
		Leave_S			= 0x00DE,
		Localloc		= 0xFE0F,
		Mkrefany		= 0x00C6,
		Mul				= 0x005A,
		Mul_Ovf			= 0x00D8,
		Mul_Ovf_Un		= 0x00D9,
		Neg				= 0x0065,
		Newarr			= 0x008D,
		Newobj			= 0x0073,
		No				= 0xFE19,
		Nop				= 0x0000,
		Not				= 0x0066,
		Or				= 0x0060,
		Pop				= 0x0026,
		Prefix1			= 0x00FE,
		Prefix2			= 0x00FD,
		Prefix3			= 0x00FC,
		Prefix4			= 0x00FB,
		Prefix5			= 0x00FA,
		Prefix6			= 0x00F9,
		Prefix7			= 0x00F8,
		Prefixref		= 0x00FF,
		Readonly		= 0xFE1E,
		Refanytype		= 0xFE1D,
		Refanyval		= 0x00C2,
		Rem				= 0x005D,
		Rem_Un			= 0x005E,
		Ret				= 0x002A,
		Rethrow			= 0xFE1A,
		Shl				= 0x0062,
		Shr				= 0x0063,
		Shr_Un			= 0x0064,
		Sizeof			= 0xFE1C,
		Starg			= 0xFE0B,
		Starg_S			= 0x0010,
		Stelem			= 0x00A4,
		Stelem_I		= 0x009B,
		Stelem_I1		= 0x009C,
		Stelem_I2		= 0x009D,
		Stelem_I4		= 0x009E,
		Stelem_I8		= 0x009F,
		Stelem_R4		= 0x00A0,
		Stelem_R8		= 0x00A1,
		Stelem_Ref		= 0x00A2,
		Stfld			= 0x007D,
		Stind_I			= 0x00DF,
		Stind_I1		= 0x0052,
		Stind_I2		= 0x0053,
		Stind_I4		= 0x0054,
		Stind_I8		= 0x0055,
		Stind_R4		= 0x0056,
		Stind_R8		= 0x0057,
		Stind_Ref		= 0x0051,
		Stloc			= 0xFE0E,
		Stloc_0			= 0x000A,
		Stloc_1			= 0x000B,
		Stloc_2			= 0x000C,
		Stloc_3			= 0x000D,
		Stloc_S			= 0x0013,
		Stobj			= 0x0081,
		Stsfld			= 0x0080,
		Sub				= 0x0059,
		Sub_Ovf			= 0x00DA,
		Sub_Ovf_Un		= 0x00DB,
		Switch			= 0x0045,
		Tailcall		= 0xFE14,
		Throw			= 0x007A,
		Unaligned		= 0xFE12,
		Unbox			= 0x0079,
		Unbox_Any		= 0x00A5,
		Volatile		= 0xFE13,
		Xor				= 0x0061,
#pragma warning restore
	}

	public static partial class Extensions {
		/// <summary>
		/// Determines whether a <see cref="Code"/> is experimental
		/// </summary>
		/// <param name="code">The code</param>
		/// <returns><c>true</c> if the <see cref="Code"/> is experimental; otherwise, <c>false</c></returns>
		public static bool IsExperimental(this Code code) {
			byte hi = (byte)((ushort)code >> 8);

			return hi >= 0xF0 && hi <= 0xFB;
		}

		/// <summary>
		/// Converts a <see cref="Code"/> to an <see cref="OpCode"/>
		/// </summary>
		/// <param name="code">The code</param>
		/// <returns>A <see cref="OpCode"/> or <c>null</c> if it's invalid</returns>
		public static OpCode ToOpCode(this Code code) {
			byte hi = (byte)((ushort)code >> 8);
			byte lo = (byte)code;
			if (hi == 0)
				return OpCodes.OneByteOpCodes[lo];
			if (hi == 0xFE)
				return OpCodes.TwoByteOpCodes[lo];
			if (code == Code.UNKNOWN1)
				return OpCodes.UNKNOWN1;
			if (code == Code.UNKNOWN2)
				return OpCodes.UNKNOWN2;
			return null;
		}

		/// <summary>
		/// Converts a <see cref="Code"/> to an <see cref="OpCode"/>, using a module context to look
		/// up potential experimental opcodes
		/// </summary>
		/// <param name="code">The code</param>
		/// <param name="context">The module context</param>
		/// <returns>A <see cref="OpCode"/> or <c>null</c> if it's invalid</returns>
		public static OpCode ToOpCode(this Code code, ModuleContext context) {
			byte hi = (byte)((ushort)code >> 8);
			byte lo = (byte)code;
			if (hi == 0)
				return OpCodes.OneByteOpCodes[lo];
			if (hi == 0xFE)
				return OpCodes.TwoByteOpCodes[lo];
			if (context.GetExperimentalOpCode(hi, lo) is OpCode op)
				return op;
			if (code == Code.UNKNOWN1)
				return OpCodes.UNKNOWN1;
			if (code == Code.UNKNOWN2)
				return OpCodes.UNKNOWN2;
			return null;
		}
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// <see cref="DynamicMethodBodyReader"/> options
	/// </summary>
	[Flags]
	public enum DynamicMethodBodyReaderOptions {
		/// <summary>
		/// No option is enabled
		/// </summary>
		None						= 0,

		/// <summary>
		/// Some fields/methods have an unknown declaring type and don't have a context with
		/// that information. If this is enabled, the reader will try to guess it but it doesn't
		/// always work. If you get an <see cref="ArgumentException"/>, try enabling this option.
		/// </summary>
		UnknownDeclaringType		= 0x00000001,
	}

	/// <summary>
	/// Reads code from a DynamicMethod
	/// </summary>
	public class DynamicMethodBodyReader : MethodBodyReaderBase, ISignatureReaderHelper {
		static readonly ReflectionFieldInfo rtdmOwnerFieldInfo = new ReflectionFieldInfo("m_owner");
		static readonly ReflectionFieldInfo dmResolverFieldInfo = new ReflectionFieldInfo("m_resolver");
		static readonly ReflectionFieldInfo rslvCodeFieldInfo = new ReflectionFieldInfo("m_code");
		static readonly ReflectionFieldInfo rslvDynamicScopeFieldInfo = new ReflectionFieldInfo("m_scope");
		static readonly ReflectionFieldInfo rslvMethodFieldInfo = new ReflectionFieldInfo("m_method");
		static readonly ReflectionFieldInfo rslvLocalsFieldInfo = new ReflectionFieldInfo("m_localSignature");
		static readonly ReflectionFieldInfo rslvMaxStackFieldInfo = new ReflectionFieldInfo("m_stackSize");
		static readonly ReflectionFieldInfo rslvExceptionsFieldInfo = new ReflectionFieldInfo("m_exceptions");
		static readonly ReflectionFieldInfo rslvExceptionHeaderFieldInfo = new ReflectionFieldInfo("m_exceptionHeader");
		static readonly ReflectionFieldInfo scopeTokensFieldInfo = new ReflectionFieldInfo("m_tokens");
		static readonly ReflectionFieldInfo gfiFieldHandleFieldInfo = new ReflectionFieldInfo("m_field", "m_fieldHandle");
		static readonly ReflectionFieldInfo gfiContextFieldInfo = new ReflectionFieldInfo("m_context");
		static readonly ReflectionFieldInfo gmiMethodHandleFieldInfo = new ReflectionFieldInfo("m_method", "m_methodHandle");
		static readonly ReflectionFieldInfo gmiContextFieldInfo = new ReflectionFieldInfo("m_context");
		static readonly ReflectionFieldInfo ehCatchAddrFieldInfo = new ReflectionFieldInfo("m_catchAddr");
		static readonly ReflectionFieldInfo ehCatchClassFieldInfo = new ReflectionFieldInfo("m_catchClass");
		static readonly ReflectionFieldInfo ehCatchEndAddrFieldInfo = new ReflectionFieldInfo("m_catchEndAddr");
		static readonly ReflectionFieldInfo ehCurrentCatchFieldInfo = new ReflectionFieldInfo("m_currentCatch");
		static readonly ReflectionFieldInfo ehTypeFieldInfo = new ReflectionFieldInfo("m_type");
		static readonly ReflectionFieldInfo ehStartAddrFieldInfo = new ReflectionFieldInfo("m_startAddr");
		static readonly ReflectionFieldInfo ehEndAddrFieldInfo = new ReflectionFieldInfo("m_endAddr");
		static readonly ReflectionFieldInfo ehEndFinallyFieldInfo = new ReflectionFieldInfo("m_endFinally");
		static readonly ReflectionFieldInfo vamMethodFieldInfo = new ReflectionFieldInfo("m_method");
		static readonly ReflectionFieldInfo vamDynamicMethodFieldInfo = new ReflectionFieldInfo("m_dynamicMethod");

		readonly ModuleDef module;
		readonly Importer importer;
		readonly GenericParamContext gpContext;
		readonly MethodDef method;
		readonly int codeSize;
		readonly int maxStack;
		readonly List<object> tokens;
		readonly IList<object> ehInfos;
		readonly byte[] ehHeader;
		readonly string methodName;
		readonly DynamicMethodBodyReaderOptions options;

		class ReflectionFieldInfo {
			SR.FieldInfo fieldInfo;
			readonly string fieldName1;
			readonly string fieldName2;

			public ReflectionFieldInfo(string fieldName) => fieldName1 = fieldName;

			public ReflectionFieldInfo(string fieldName1, string fieldName2) {
				this.fieldName1 = fieldName1;
				this.fieldName2 = fieldName2;
			}

			public object Read(object instance) {
				if (fieldInfo is null)
					InitializeField(instance.GetType());
				if (fieldInfo is null)
					throw new Exception($"Couldn't find field '{fieldName1}' or '{fieldName2}'");

				return fieldInfo.GetValue(instance);
			}

			public bool Exists(object instance) {
				InitializeField(instance.GetType());
				return fieldInfo is not null;
			}

			void InitializeField(Type type) {
				if (fieldInfo is not null)
					return;

				var flags = SR.BindingFlags.Instance | SR.BindingFlags.Public | SR.BindingFlags.NonPublic;
				fieldInfo = type.GetField(fieldName1, flags);
				if (fieldInfo is null && fieldName2 is not null)
					fieldInfo = type.GetField(fieldName2, flags);
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module that will own the method body</param>
		/// <param name="obj">This can be one of several supported types: the delegate instance
		/// created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
		/// instance or a DynamicResolver instance.</param>
		public DynamicMethodBodyReader(ModuleDef module, object obj)
			: this(module, obj, new GenericParamContext()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module that will own the method body</param>
		/// <param name="obj">This can be one of several supported types: the delegate instance
		/// created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
		/// instance or a DynamicResolver instance.</param>
		/// <param name="gpContext">Generic parameter context</param>
		public DynamicMethodBodyReader(ModuleDef module, object obj, GenericParamContext gpContext)
			: this(module, obj, new Importer(module, ImporterOptions.TryToUseDefs, gpContext), DynamicMethodBodyReaderOptions.None) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module that will own the method body</param>
		/// <param name="obj">This can be one of several supported types: the delegate instance
		/// created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
		/// instance or a DynamicResolver instance.</param>
		/// <param name="importer">Importer</param>
		public DynamicMethodBodyReader(ModuleDef module, object obj, Importer importer)
			: this(module, obj, importer, DynamicMethodBodyReaderOptions.None) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module that will own the method body</param>
		/// <param name="obj">This can be one of several supported types: the delegate instance
		/// created by DynamicMethod.CreateDelegate(), a DynamicMethod instance, a RTDynamicMethod
		/// instance or a DynamicResolver instance.</param>
		/// <param name="importer">Importer</param>
		/// <param name="options">Options</param>
		public DynamicMethodBodyReader(ModuleDef module, object obj, Importer importer, DynamicMethodBodyReaderOptions options)
			: base(module.Context) {
			this.module = module;
			this.importer = importer;
			this.options = options;
			gpContext = importer.gpContext;
			methodName = null;

			if (obj is null)
				throw new ArgumentNullException(nameof(obj));

			if (obj is Delegate del) {
				obj = del.Method;
				if (obj is null)
					throw new Exception("Delegate.Method is null");
			}

			if (obj.GetType().ToString() == "System.Reflection.Emit.DynamicMethod+RTDynamicMethod") {
				obj = rtdmOwnerFieldInfo.Read(obj) as DynamicMethod;
				if (obj is null)
					throw new Exception("RTDynamicMethod.m_owner is null or invalid");
			}

			if (obj is DynamicMethod) {
				methodName = ((DynamicMethod)obj).Name;
				obj = dmResolverFieldInfo.Read(obj);
				if (obj is null)
					throw new Exception("No resolver found");
			}

			if (obj.GetType().ToString() != "System.Reflection.Emit.DynamicResolver")
				throw new Exception("Couldn't find DynamicResolver");

			var code = rslvCodeFieldInfo.Read(obj) as byte[];
			if (code is null)
				throw new Exception("No code");
			codeSize = code.Length;
			var delMethod = rslvMethodFieldInfo.Read(obj) as SR.MethodBase;
			if (delMethod is null)
				throw new Exception("No method");
			maxStack = (int)rslvMaxStackFieldInfo.Read(obj);

			var scope = rslvDynamicScopeFieldInfo.Read(obj);
			if (scope is null)
				throw new Exception("No scope");
			var tokensList = scopeTokensFieldInfo.Read(scope) as System.Collections.IList;
			if (tokensList is null)
				throw new Exception("No tokens");
			tokens = new List<object>(tokensList.Count);
			for (int i = 0; i < tokensList.Count; i++)
				tokens.Add(tokensList[i]);

			ehInfos = (IList<object>)rslvExceptionsFieldInfo.Read(obj);
			ehHeader = rslvExceptionHeaderFieldInfo.Read(obj) as byte[];

			UpdateLocals(rslvLocalsFieldInfo.Read(obj) as byte[]);
			reader = ByteArrayDataReaderFactory.CreateReader(code);
			method = CreateMethodDef(delMethod);
			parameters = method.Parameters;
		}

		class ExceptionInfo {
			public int[] CatchAddr;
			public Type[] CatchClass;
			public int[] CatchEndAddr;
			public int CurrentCatch;
			public int[] Type;
			public int StartAddr;
			public int EndAddr;
			public int EndFinally;
		}

		static List<ExceptionInfo> CreateExceptionInfos(IList<object> ehInfos) {
			if (ehInfos is null)
				return new List<ExceptionInfo>();

			var infos = new List<ExceptionInfo>(ehInfos.Count);

			int count = ehInfos.Count;
			for (int i = 0; i < count; i++) {
				var ehInfo = ehInfos[i];
				var eh = new ExceptionInfo {
					CatchAddr = (int[])ehCatchAddrFieldInfo.Read(ehInfo),
					CatchClass = (Type[])ehCatchClassFieldInfo.Read(ehInfo),
					CatchEndAddr = (int[])ehCatchEndAddrFieldInfo.Read(ehInfo),
					CurrentCatch = (int)ehCurrentCatchFieldInfo.Read(ehInfo),
					Type = (int[])ehTypeFieldInfo.Read(ehInfo),
					StartAddr = (int)ehStartAddrFieldInfo.Read(ehInfo),
					EndAddr = (int)ehEndAddrFieldInfo.Read(ehInfo),
					EndFinally = (int)ehEndFinallyFieldInfo.Read(ehInfo),
				};
				infos.Add(eh);
			}

			return infos;
		}

		void UpdateLocals(byte[] localsSig) {
			if (localsSig is null || localsSig.Length == 0)
				return;

			var sig = SignatureReader.ReadSig(this, module.CorLibTypes, localsSig, gpContext) as LocalSig;
			if (sig is null)
				return;

			var sigLocals = sig.Locals;
			int count = sigLocals.Count;
			for (int i = 0; i < count; i++)
				locals.Add(new Local(sigLocals[i]));
		}

		MethodDef CreateMethodDef(SR.MethodBase delMethod) {
			bool isStatic = true;
			var method = new MethodDefUser();

			var retType = GetReturnType(delMethod);
			var pms = GetParameters(delMethod);
			if (isStatic)
				method.Signature = MethodSig.CreateStatic(retType, pms.ToArray());
			else
				method.Signature = MethodSig.CreateInstance(retType, pms.ToArray());

			method.Parameters.UpdateParameterTypes();
			method.ImplAttributes = MethodImplAttributes.IL;
			method.Attributes = MethodAttributes.PrivateScope;
			if (isStatic)
				method.Attributes |= MethodAttributes.Static;

			return module.UpdateRowId(method);
		}

		TypeSig GetReturnType(SR.MethodBase mb) {
			if (mb is SR.MethodInfo mi)
				return importer.ImportAsTypeSig(mi.ReturnType);
			return module.CorLibTypes.Void;
		}

		List<TypeSig> GetParameters(SR.MethodBase delMethod) {
			var pms = new List<TypeSig>();
			foreach (var param in delMethod.GetParameters())
				pms.Add(importer.ImportAsTypeSig(param.ParameterType));
			return pms;
		}

		/// <summary>
		/// Reads the code
		/// </summary>
		/// <returns></returns>
		public bool Read() {
			ReadInstructionsNumBytes((uint)codeSize);
			CreateExceptionHandlers();

			return true;
		}

		void CreateExceptionHandlers() {
			if (ehHeader is not null) {
				if (ehHeader.Length < 4)
					return;
				var reader = new BinaryReader(new MemoryStream(ehHeader));
				byte b = reader.ReadByte();
				if ((b & 0x40) == 0) { // DynamicResolver only checks bit 6
					// Calculate num ehs exactly the same way that DynamicResolver does
					int numHandlers = (ushort)((reader.ReadByte() - 2) / 12);
					reader.ReadUInt16();
					for (int i = 0; i < numHandlers; i++) {
						if (reader.BaseStream.Position + 12 > reader.BaseStream.Length)
							break;
						var eh = new ExceptionHandler();
						eh.HandlerType = (ExceptionHandlerType)reader.ReadUInt16();
						int offs = reader.ReadUInt16();
						eh.TryStart = GetInstructionThrow((uint)offs);
						eh.TryEnd = GetInstruction((uint)(reader.ReadByte() + offs));
						offs = reader.ReadUInt16();
						eh.HandlerStart = GetInstructionThrow((uint)offs);
						eh.HandlerEnd = GetInstruction((uint)(reader.ReadByte() + offs));

						if (eh.IsCatch)
							eh.CatchType = ReadToken(reader.ReadUInt32()) as ITypeDefOrRef;
						else if (eh.IsFilter)
							eh.FilterStart = GetInstruction(reader.ReadUInt32());
						else
							reader.ReadUInt32();

						exceptionHandlers.Add(eh);
					}
				}
				else {
					reader.BaseStream.Position--;
					int numHandlers = (ushort)(((reader.ReadUInt32() >> 8) - 4) / 24);
					for (int i = 0; i < numHandlers; i++) {
						if (reader.BaseStream.Position + 24 > reader.BaseStream.Length)
							break;
						var eh = new ExceptionHandler();
						eh.HandlerType = (ExceptionHandlerType)reader.ReadUInt32();
						var offs = reader.ReadUInt32();
						eh.TryStart = GetInstructionThrow((uint)offs);
						eh.TryEnd = GetInstruction((uint)(reader.ReadUInt32() + offs));
						offs = reader.ReadUInt32();
						eh.HandlerStart = GetInstructionThrow((uint)offs);
						eh.HandlerEnd = GetInstruction((uint)(reader.ReadUInt32() + offs));

						if (eh.IsCatch)
							eh.CatchType = ReadToken(reader.ReadUInt32()) as ITypeDefOrRef;
						else if (eh.IsFilter)
							eh.FilterStart = GetInstruction(reader.ReadUInt32());
						else
							reader.ReadUInt32();

						exceptionHandlers.Add(eh);
					}
				}
			}
			else if (ehInfos is not null) {
				foreach (var ehInfo in CreateExceptionInfos(ehInfos)) {
					var tryStart = GetInstructionThrow((uint)ehInfo.StartAddr);
					var tryEnd = GetInstruction((uint)ehInfo.EndAddr);
					var endFinally = ehInfo.EndFinally < 0 ? null : GetInstruction((uint)ehInfo.EndFinally);
					for (int i = 0; i < ehInfo.CurrentCatch; i++) {
						var eh = new ExceptionHandler();
						eh.HandlerType = (ExceptionHandlerType)ehInfo.Type[i];
						eh.TryStart = tryStart;
						eh.TryEnd = eh.IsFinally ? endFinally : tryEnd;
						eh.FilterStart = null;	// not supported by DynamicMethod.ILGenerator
						eh.HandlerStart = GetInstructionThrow((uint)ehInfo.CatchAddr[i]);
						eh.HandlerEnd = GetInstruction((uint)ehInfo.CatchEndAddr[i]);
						eh.CatchType = importer.Import(ehInfo.CatchClass[i]);
						exceptionHandlers.Add(eh);
					}
				}
			}
		}

		/// <summary>
		/// Returns the created method. Must be called after <see cref="Read()"/>.
		/// </summary>
		/// <returns>A new <see cref="CilBody"/> instance</returns>
		public MethodDef GetMethod() {
			bool initLocals = true;
			var cilBody = new CilBody(initLocals, instructions, exceptionHandlers, locals);
			cilBody.MaxStack = (ushort)Math.Min(maxStack, ushort.MaxValue);
			instructions = null;
			exceptionHandlers = null;
			locals = null;
			method.Body = cilBody;
			method.Name = methodName;
			return method;
		}

		/// <inheritdoc/>
		protected override IField ReadInlineField(Instruction instr) => ReadToken(reader.ReadUInt32()) as IField;

		/// <inheritdoc/>
		protected override IMethod ReadInlineMethod(Instruction instr) => ReadToken(reader.ReadUInt32()) as IMethod;

		/// <inheritdoc/>
		protected override MethodSig ReadInlineSig(Instruction instr) => ReadToken(reader.ReadUInt32()) as MethodSig;

		/// <inheritdoc/>
		protected override string ReadInlineString(Instruction instr) => ReadToken(reader.ReadUInt32()) as string ?? string.Empty;

		/// <inheritdoc/>
		protected override ITokenOperand ReadInlineTok(Instruction instr) => ReadToken(reader.ReadUInt32()) as ITokenOperand;

		/// <inheritdoc/>
		protected override ITypeDefOrRef ReadInlineType(Instruction instr) => ReadToken(reader.ReadUInt32()) as ITypeDefOrRef;

		object ReadToken(uint token) {
			uint rid = token & 0x00FFFFFF;
			switch (token >> 24) {
			case 0x02:
				return ImportType(rid);

			case 0x04:
				return ImportField(rid);

			case 0x06:
			case 0x0A:
				return ImportMethod(rid);

			case 0x11:
				return ImportSignature(rid);

			case 0x70:
				return Resolve(rid) as string;

			default:
				return null;
			}
		}

		IMethod ImportMethod(uint rid) {
			var obj = Resolve(rid);
			if (obj is null)
				return null;

			if (obj is RuntimeMethodHandle) {
				if ((options & DynamicMethodBodyReaderOptions.UnknownDeclaringType) != 0) {
					// Sometimes it's a generic type but obj != `GenericMethodInfo`, so pass in 'default' and the
					// runtime will try to figure out the declaring type. https://github.com/0xd4d/dnlib/issues/298
					return importer.Import(SR.MethodBase.GetMethodFromHandle((RuntimeMethodHandle)obj, default));
				}
				else
					return importer.Import(SR.MethodBase.GetMethodFromHandle((RuntimeMethodHandle)obj));
			}

			if (obj.GetType().ToString() == "System.Reflection.Emit.GenericMethodInfo") {
				var context = (RuntimeTypeHandle)gmiContextFieldInfo.Read(obj);
				var method = SR.MethodBase.GetMethodFromHandle((RuntimeMethodHandle)gmiMethodHandleFieldInfo.Read(obj), context);
				return importer.Import(method);
			}

			if (obj.GetType().ToString() == "System.Reflection.Emit.VarArgMethod") {
				var method = GetVarArgMethod(obj);
				if (!(method is DynamicMethod))
					return importer.Import(method);
				obj = method;
			}

			if (obj is DynamicMethod dm)
				throw new Exception("DynamicMethod calls another DynamicMethod");

			return null;
		}

		SR.MethodInfo GetVarArgMethod(object obj) {
			if (vamDynamicMethodFieldInfo.Exists(obj)) {
				// .NET Framework 4.0+
				var method = vamMethodFieldInfo.Read(obj) as SR.MethodInfo;
				var dynMethod = vamDynamicMethodFieldInfo.Read(obj) as DynamicMethod;
				return dynMethod ?? method;
			}
			else {
				// .NET Framework 2.0
				// This is either a DynamicMethod or a MethodInfo
				return vamMethodFieldInfo.Read(obj) as SR.MethodInfo;
			}
		}

		IField ImportField(uint rid) {
			var obj = Resolve(rid);
			if (obj is null)
				return null;

			if (obj is RuntimeFieldHandle) {
				if ((options & DynamicMethodBodyReaderOptions.UnknownDeclaringType) != 0) {
					// Sometimes it's a generic type but obj != `GenericFieldInfo`, so pass in 'default' and the
					// runtime will try to figure out the declaring type. https://github.com/0xd4d/dnlib/issues/298
					return importer.Import(SR.FieldInfo.GetFieldFromHandle((RuntimeFieldHandle)obj, default));
				}
				else
					return importer.Import(SR.FieldInfo.GetFieldFromHandle((RuntimeFieldHandle)obj));
			}

			if (obj.GetType().ToString() == "System.Reflection.Emit.GenericFieldInfo") {
				var context = (RuntimeTypeHandle)gfiContextFieldInfo.Read(obj);
				var field = SR.FieldInfo.GetFieldFromHandle((RuntimeFieldHandle)gfiFieldHandleFieldInfo.Read(obj), context);
				return importer.Import(field);
			}

			return null;
		}

		ITypeDefOrRef ImportType(uint rid) {
			var obj = Resolve(rid);
			if (obj is RuntimeTypeHandle)
				return importer.Import(Type.GetTypeFromHandle((RuntimeTypeHandle)obj));

			return null;
		}

		CallingConventionSig ImportSignature(uint rid) {
			var sig = Resolve(rid) as byte[];
			if (sig is null)
				return null;

			return SignatureReader.ReadSig(this, module.CorLibTypes, sig, gpContext);
		}

		object Resolve(uint index) {
			if (index >= (uint)tokens.Count)
				return null;
			return tokens[(int)index];
		}

		ITypeDefOrRef ISignatureReaderHelper.ResolveTypeDefOrRef(uint codedToken, GenericParamContext gpContext) {
			if (!CodedToken.TypeDefOrRef.Decode(codedToken, out uint token))
				return null;
			switch (MDToken.ToTable(token)) {
			case Table.TypeDef:
			case Table.TypeRef:
			case Table.TypeSpec:
				return module.ResolveToken(token) as ITypeDefOrRef;
			}
			return null;
		}

		TypeSig ISignatureReaderHelper.ConvertRTInternalAddress(IntPtr address) => importer.ImportAsTypeSig(MethodTableToTypeConverter.Convert(address));
	}
}




namespace dnlib.DotNet.Emit {
	/// <summary>
	/// A CIL method exception handler
	/// </summary>
	public sealed class ExceptionHandler {
		/// <summary>
		/// First instruction of try block
		/// </summary>
		public Instruction TryStart;

		/// <summary>
		/// One instruction past the end of try block or <c>null</c> if it ends at the end
		/// of the method.
		/// </summary>
		public Instruction TryEnd;

		/// <summary>
		/// Start of filter handler or <c>null</c> if none. The end of filter handler is
		/// always <see cref="HandlerStart"/>.
		/// </summary>
		public Instruction FilterStart;

		/// <summary>
		/// First instruction of try handler block
		/// </summary>
		public Instruction HandlerStart;

		/// <summary>
		/// One instruction past the end of try handler block or <c>null</c> if it ends at the end
		/// of the method.
		/// </summary>
		public Instruction HandlerEnd;

		/// <summary>
		/// The catch type if <see cref="IsCatch"/> is <see langword="true" />
		/// </summary>
		public ITypeDefOrRef CatchType;

		/// <summary>
		/// Type of exception handler clause
		/// </summary>
		public ExceptionHandlerType HandlerType;

		/// <summary>
		/// Checks if it's a `catch` handler
		/// </summary>
		public bool IsCatch => ((uint)HandlerType & 7) == (uint)ExceptionHandlerType.Catch;

		/// <summary>
		/// Checks if it's a `filter` handler
		/// </summary>
		public bool IsFilter => (HandlerType & ExceptionHandlerType.Filter) != 0;

		/// <summary>
		/// Checks if it's a `finally` handler
		/// </summary>
		public bool IsFinally => (HandlerType & ExceptionHandlerType.Finally) != 0;

		/// <summary>
		/// Checks if it's a `fault` handler
		/// </summary>
		public bool IsFault => (HandlerType & ExceptionHandlerType.Fault) != 0;
		
		/// <summary>
		/// Default constructor
		/// </summary>
		public ExceptionHandler() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="handlerType">Exception clause type</param>
		public ExceptionHandler(ExceptionHandlerType handlerType) => HandlerType = handlerType;
	}
}





namespace dnlib.DotNet.Emit {
	/// <summary>
	/// Type of exception handler. See CorHdr.h/CorExceptionFlag
	/// </summary>
	[Flags]
	public enum ExceptionHandlerType {
		/// <summary/>
		Catch		= 0x0000,
		/// <summary/>
		Filter		= 0x0001,
		/// <summary/>
		Finally		= 0x0002,
		/// <summary/>
		Fault		= 0x0004,
		/// <summary/>
		Duplicated	= 0x0008,
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Info about one column in a MD table
	/// </summary>
	[DebuggerDisplay("{offset} {size} {name}")]
	public sealed class ColumnInfo {
		readonly byte index;
		byte offset;
		readonly ColumnSize columnSize;
		byte size;
		readonly string name;

		/// <summary>
		/// Gets the column index
		/// </summary>
		public int Index => index;

		/// <summary>
		/// Returns the column offset within the table row
		/// </summary>
		public int Offset {
			get => offset;
			internal set => offset = (byte)value;
		}

		/// <summary>
		/// Returns the column size
		/// </summary>
		public int Size {
			get => size;
			internal set => size = (byte)value;
		}

		/// <summary>
		/// Returns the column name
		/// </summary>
		public string Name => name;

		/// <summary>
		/// Returns the ColumnSize enum value
		/// </summary>
		public ColumnSize ColumnSize => columnSize;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="index">Column index</param>
		/// <param name="name">The column name</param>
		/// <param name="columnSize">Column size</param>
		public ColumnInfo(byte index, string name, ColumnSize columnSize) {
			this.index = index;
			this.name = name;
			this.columnSize = columnSize;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="index">Column index</param>
		/// <param name="name">The column name</param>
		/// <param name="columnSize">Column size</param>
		/// <param name="offset">Offset of column</param>
		/// <param name="size">Size of column</param>
		public ColumnInfo(byte index, string name, ColumnSize columnSize, byte offset, byte size) {
			this.index = index;
			this.name = name;
			this.columnSize = columnSize;
			this.offset = offset;
			this.size = size;
		}

		/// <summary>
		/// Reads the column
		/// </summary>
		/// <param name="reader">A reader positioned on this column</param>
		/// <returns>The column value</returns>
		public uint Read(ref DataReader reader) =>
			size switch {
				1 => reader.ReadByte(),
				2 => reader.ReadUInt16(),
				4 => reader.ReadUInt32(),
				_ => throw new InvalidOperationException("Invalid column size"),
			};

		internal uint Unsafe_Read24(ref DataReader reader) {
			Debug.Assert(size == 2 || size == 4);
			return size == 2 ? reader.Unsafe_ReadUInt16() : reader.Unsafe_ReadUInt32();
		}

		/// <summary>
		/// Writes a column
		/// </summary>
		/// <param name="writer">The writer position on this column</param>
		/// <param name="value">The column value</param>
		public void Write(DataWriter writer, uint value) {
			switch (size) {
			case 1: writer.WriteByte((byte)value); break;
			case 2: writer.WriteUInt16((ushort)value); break;
			case 4: writer.WriteUInt32(value); break;
			default: throw new InvalidOperationException("Invalid column size");
			}
		}

		internal void Write24(DataWriter writer, uint value) {
			Debug.Assert(size == 2 || size == 4);
			if (size == 2)
				writer.WriteUInt16((ushort)value);
			else
				writer.WriteUInt32(value);
		}
	}
}




namespace dnlib.DotNet.MD {
	/// <summary>
	/// MD table column size
	/// </summary>
	public enum ColumnSize : byte {
		/// <summary>RID into Module table</summary>
		Module,
		/// <summary>RID into TypeRef table</summary>
		TypeRef,
		/// <summary>RID into TypeDef table</summary>
		TypeDef,
		/// <summary>RID into FieldPtr table</summary>
		FieldPtr,
		/// <summary>RID into Field table</summary>
		Field,
		/// <summary>RID into MethodPtr table</summary>
		MethodPtr,
		/// <summary>RID into Method table</summary>
		Method,
		/// <summary>RID into ParamPtr table</summary>
		ParamPtr,
		/// <summary>RID into Param table</summary>
		Param,
		/// <summary>RID into InterfaceImpl table</summary>
		InterfaceImpl,
		/// <summary>RID into MemberRef table</summary>
		MemberRef,
		/// <summary>RID into Constant table</summary>
		Constant,
		/// <summary>RID into CustomAttribute table</summary>
		CustomAttribute,
		/// <summary>RID into FieldMarshal table</summary>
		FieldMarshal,
		/// <summary>RID into DeclSecurity table</summary>
		DeclSecurity,
		/// <summary>RID into ClassLayout table</summary>
		ClassLayout,
		/// <summary>RID into FieldLayout table</summary>
		FieldLayout,
		/// <summary>RID into StandAloneSig table</summary>
		StandAloneSig,
		/// <summary>RID into EventMap table</summary>
		EventMap,
		/// <summary>RID into EventPtr table</summary>
		EventPtr,
		/// <summary>RID into Event table</summary>
		Event,
		/// <summary>RID into PropertyMap table</summary>
		PropertyMap,
		/// <summary>RID into PropertyPtr table</summary>
		PropertyPtr,
		/// <summary>RID into Property table</summary>
		Property,
		/// <summary>RID into MethodSemantics table</summary>
		MethodSemantics,
		/// <summary>RID into MethodImpl table</summary>
		MethodImpl,
		/// <summary>RID into ModuleRef table</summary>
		ModuleRef,
		/// <summary>RID into TypeSpec table</summary>
		TypeSpec,
		/// <summary>RID into ImplMap table</summary>
		ImplMap,
		/// <summary>RID into FieldRVA table</summary>
		FieldRVA,
		/// <summary>RID into ENCLog table</summary>
		ENCLog,
		/// <summary>RID into ENCMap table</summary>
		ENCMap,
		/// <summary>RID into Assembly table</summary>
		Assembly,
		/// <summary>RID into AssemblyProcessor table</summary>
		AssemblyProcessor,
		/// <summary>RID into AssemblyOS table</summary>
		AssemblyOS,
		/// <summary>RID into AssemblyRef table</summary>
		AssemblyRef,
		/// <summary>RID into AssemblyRefProcessor table</summary>
		AssemblyRefProcessor,
		/// <summary>RID into AssemblyRefOS table</summary>
		AssemblyRefOS,
		/// <summary>RID into File table</summary>
		File,
		/// <summary>RID into ExportedType table</summary>
		ExportedType,
		/// <summary>RID into ManifestResource table</summary>
		ManifestResource,
		/// <summary>RID into NestedClass table</summary>
		NestedClass,
		/// <summary>RID into GenericParam table</summary>
		GenericParam,
		/// <summary>RID into MethodSpec table</summary>
		MethodSpec,
		/// <summary>RID into GenericParamConstraint table</summary>
		GenericParamConstraint,
		/// <summary>RID into Document table</summary>
		Document = 0x30,
		/// <summary>RID into MethodDebugInformation table</summary>
		MethodDebugInformation,
		/// <summary>RID into LocalScope table</summary>
		LocalScope,
		/// <summary>RID into LocalVariable table</summary>
		LocalVariable,
		/// <summary>RID into LocalConstant table</summary>
		LocalConstant,
		/// <summary>RID into ImportScope table</summary>
		ImportScope,
		/// <summary>RID into StateMachineMethod table</summary>
		StateMachineMethod,
		/// <summary>RID into CustomDebugInformation table</summary>
		CustomDebugInformation,
		/// <summary>8-bit byte</summary>
		Byte = 0x40,
		/// <summary>16-bit signed int</summary>
		Int16,
		/// <summary>16-bit unsigned int</summary>
		UInt16,
		/// <summary>32-bit signed int</summary>
		Int32,
		/// <summary>32-bit unsigned int</summary>
		UInt32,
		/// <summary>Index into #Strings stream</summary>
		Strings,
		/// <summary>Index into #GUID stream</summary>
		GUID,
		/// <summary>Index into #Blob stream</summary>
		Blob,
		/// <summary>TypeDefOrRef encoded token</summary>
		TypeDefOrRef,
		/// <summary>HasConstant encoded token</summary>
		HasConstant,
		/// <summary>HasCustomAttribute encoded token</summary>
		HasCustomAttribute,
		/// <summary>HasFieldMarshal encoded token</summary>
		HasFieldMarshal,
		/// <summary>HasDeclSecurity encoded token</summary>
		HasDeclSecurity,
		/// <summary>MemberRefParent encoded token</summary>
		MemberRefParent,
		/// <summary>HasSemantic encoded token</summary>
		HasSemantic,
		/// <summary>MethodDefOrRef encoded token</summary>
		MethodDefOrRef,
		/// <summary>MemberForwarded encoded token</summary>
		MemberForwarded,
		/// <summary>Implementation encoded token</summary>
		Implementation,
		/// <summary>CustomAttributeType encoded token</summary>
		CustomAttributeType,
		/// <summary>ResolutionScope encoded token</summary>
		ResolutionScope,
		/// <summary>TypeOrMethodDef encoded token</summary>
		TypeOrMethodDef,
		/// <summary>HasCustomDebugInformation encoded token</summary>
		HasCustomDebugInformation,
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// See COMIMAGE_FLAGS_XXX in CorHdr.h in the Windows SDK
	/// </summary>
	[Flags]
	public enum ComImageFlags : uint {
		/// <summary>
		/// See COMIMAGE_FLAGS_ILONLY in the Windows SDK
		/// </summary>
		ILOnly = 1,

		/// <summary>
		/// See COMIMAGE_FLAGS_32BITREQUIRED in the Windows SDK
		/// </summary>
		Bit32Required = 2,

		/// <summary>
		/// Set if a native header exists (COMIMAGE_FLAGS_IL_LIBRARY)
		/// </summary>
		ILLibrary = 4,

		/// <summary>
		/// See COMIMAGE_FLAGS_STRONGNAMESIGNED in the Windows SDK
		/// </summary>
		StrongNameSigned = 8,

		/// <summary>
		/// See COMIMAGE_FLAGS_NATIVE_ENTRYPOINT in the Windows SDK
		/// </summary>
		NativeEntryPoint = 0x10,

		/// <summary>
		/// See COMIMAGE_FLAGS_TRACKDEBUGDATA in the Windows SDK
		/// </summary>
		TrackDebugData = 0x10000,

		/// <summary>
		/// See COMIMAGE_FLAGS_32BITPREFERRED in the Windows SDK
		/// </summary>
		Bit32Preferred = 0x20000,
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Used when a #~ stream is present in the metadata
	/// </summary>
	sealed class CompressedMetadata : MetadataBase {
		readonly CLRRuntimeReaderKind runtime;

		/// <inheritdoc/>
		public override bool IsCompressed => true;

		/// <inheritdoc/>
		public CompressedMetadata(IPEImage peImage, ImageCor20Header cor20Header, MetadataHeader mdHeader, CLRRuntimeReaderKind runtime)
			: base(peImage, cor20Header, mdHeader) {
			this.runtime = runtime;
		}

		/// <inheritdoc/>
		internal CompressedMetadata(MetadataHeader mdHeader, bool isStandalonePortablePdb, CLRRuntimeReaderKind runtime)
			: base(mdHeader, isStandalonePortablePdb) {
			this.runtime = runtime;
		}

		/// <inheritdoc/>
		protected override void InitializeInternal(DataReaderFactory mdReaderFactory, uint metadataBaseOffset) {
			DotNetStream dns = null;
			var newAllStreams = new List<DotNetStream>(allStreams);
			bool forceAllBig = false;
			try {
				for (int i = mdHeader.StreamHeaders.Count - 1; i >= 0; i--) {
					var sh = mdHeader.StreamHeaders[i];
					switch (sh.Name) {
					case "#Strings":
						if (stringsStream is null) {
							stringsStream = new StringsStream(mdReaderFactory, metadataBaseOffset, sh);
							newAllStreams.Add(stringsStream);
							continue;
						}
						break;

					case "#US":
						if (usStream is null) {
							usStream = new USStream(mdReaderFactory, metadataBaseOffset, sh);
							newAllStreams.Add(usStream);
							continue;
						}
						break;

					case "#Blob":
						if (blobStream is null) {
							blobStream = new BlobStream(mdReaderFactory, metadataBaseOffset, sh);
							newAllStreams.Add(blobStream);
							continue;
						}
						break;

					case "#GUID":
						if (guidStream is null) {
							guidStream = new GuidStream(mdReaderFactory, metadataBaseOffset, sh);
							newAllStreams.Add(guidStream);
							continue;
						}
						break;

					case "#~":
						if (tablesStream is null) {
							tablesStream = new TablesStream(mdReaderFactory, metadataBaseOffset, sh, runtime);
							newAllStreams.Add(tablesStream);
							continue;
						}
						break;

					case "#Pdb":
						if (isStandalonePortablePdb && pdbStream is null) {
							pdbStream = new PdbStream(mdReaderFactory, metadataBaseOffset, sh);
							newAllStreams.Add(pdbStream);
							continue;
						}
						break;

					case "#JTD":
						if (runtime == CLRRuntimeReaderKind.Mono) {
							forceAllBig = true;
							continue;
						}
						break;
					}
					dns = new CustomDotNetStream(mdReaderFactory, metadataBaseOffset, sh);
					newAllStreams.Add(dns);
					dns = null;
				}
			}
			finally {
				dns?.Dispose();
				newAllStreams.Reverse();
				allStreams = newAllStreams;
			}

			if (tablesStream is null)
				throw new BadImageFormatException("Missing MD stream");

			if (pdbStream is not null)
				tablesStream.Initialize(pdbStream.TypeSystemTableRows, forceAllBig);
			else
				tablesStream.Initialize(null, forceAllBig);
		}

		/// <inheritdoc/>
		public override RidList GetFieldRidList(uint typeDefRid) => GetRidList(tablesStream.TypeDefTable, typeDefRid, 4, tablesStream.FieldTable);

		/// <inheritdoc/>
		public override RidList GetMethodRidList(uint typeDefRid) => GetRidList(tablesStream.TypeDefTable, typeDefRid, 5, tablesStream.MethodTable);

		/// <inheritdoc/>
		public override RidList GetParamRidList(uint methodRid) => GetRidList(tablesStream.MethodTable, methodRid, 5, tablesStream.ParamTable);

		/// <inheritdoc/>
		public override RidList GetEventRidList(uint eventMapRid) => GetRidList(tablesStream.EventMapTable, eventMapRid, 1, tablesStream.EventTable);

		/// <inheritdoc/>
		public override RidList GetPropertyRidList(uint propertyMapRid) => GetRidList(tablesStream.PropertyMapTable, propertyMapRid, 1, tablesStream.PropertyTable);

		/// <inheritdoc/>
		public override RidList GetLocalVariableRidList(uint localScopeRid) => GetRidList(tablesStream.LocalScopeTable, localScopeRid, 2, tablesStream.LocalVariableTable);

		/// <inheritdoc/>
		public override RidList GetLocalConstantRidList(uint localScopeRid) => GetRidList(tablesStream.LocalScopeTable, localScopeRid, 3, tablesStream.LocalConstantTable);

		/// <summary>
		/// Gets a rid list (eg. field list)
		/// </summary>
		/// <param name="tableSource">Source table, eg. <c>TypeDef</c></param>
		/// <param name="tableSourceRid">Row ID in <paramref name="tableSource"/></param>
		/// <param name="colIndex">Column index in <paramref name="tableSource"/>, eg. 4 for <c>TypeDef.FieldList</c></param>
		/// <param name="tableDest">Destination table, eg. <c>Field</c></param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetRidList(MDTable tableSource, uint tableSourceRid, int colIndex, MDTable tableDest) {
			var column = tableSource.TableInfo.Columns[colIndex];
			if (!tablesStream.TryReadColumn24(tableSource, tableSourceRid, column, out uint startRid))
				return RidList.Empty;
			bool hasNext = tablesStream.TryReadColumn24(tableSource, tableSourceRid + 1, column, out uint nextListRid);
			uint lastRid = tableDest.Rows + 1;
			if (startRid == 0 || startRid >= lastRid)
				return RidList.Empty;
			uint endRid = !hasNext || (nextListRid == 0 && tableSourceRid + 1 == tableSource.Rows && tableDest.Rows == 0xFFFF) ? lastRid : nextListRid;
			if (endRid < startRid)
				endRid = startRid;
			if (endRid > lastRid)
				endRid = lastRid;
			return RidList.Create(startRid, endRid - startRid);
		}

		/// <inheritdoc/>
		protected override uint BinarySearch(MDTable tableSource, int keyColIndex, uint key) {
			var keyColumn = tableSource.TableInfo.Columns[keyColIndex];
			uint ridLo = 1, ridHi = tableSource.Rows;
			while (ridLo <= ridHi) {
				uint rid = (ridLo + ridHi) / 2;
				if (!tablesStream.TryReadColumn24(tableSource, rid, keyColumn, out uint key2))
					break;	// Never happens since rid is valid
				if (key == key2)
					return rid;
				if (key2 > key)
					ridHi = rid - 1;
				else
					ridLo = rid + 1;
			}

			return 0;
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// A custom .NET metadata stream
	/// </summary>
	public class CustomDotNetStream : DotNetStream {
		/// <summary>
		/// Constructor
		/// </summary>
		public CustomDotNetStream() { }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="mdReaderFactory">Data reader factory</param>
		/// <param name="metadataBaseOffset">Offset of metadata</param>
		/// <param name="streamHeader">The stream header</param>
		public CustomDotNetStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader)
			: base(mdReaderFactory, metadataBaseOffset, streamHeader) {
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// .NET metadata stream
	/// </summary>
	[DebuggerDisplay("{dataReader.Length} {streamHeader.Name}")]
	public abstract class DotNetStream : IFileSection, IDisposable {
		/// <summary>
		/// Reader that can access the whole stream.
		/// 
		/// NOTE: Always copy this field to a local variable before using it since it must be thread safe.
		/// </summary>
		protected DataReader dataReader;

		/// <summary>
		/// <c>null</c> if it wasn't present in the file
		/// </summary>
		StreamHeader streamHeader;

		DataReaderFactory mdReaderFactory;
		uint metadataBaseOffset;

		/// <inheritdoc/>
		public FileOffset StartOffset => (FileOffset)dataReader.StartOffset;

		/// <inheritdoc/>
		public FileOffset EndOffset => (FileOffset)dataReader.EndOffset;

		/// <summary>
		/// Gets the length of this stream in the metadata
		/// </summary>
		public uint StreamLength => dataReader.Length;

		/// <summary>
		/// Gets the stream header
		/// </summary>
		public StreamHeader StreamHeader => streamHeader;

		/// <summary>
		/// Gets the name of the stream
		/// </summary>
		public string Name => streamHeader is null ? string.Empty : streamHeader.Name;

		/// <summary>
		/// Gets a data reader that can read the full stream
		/// </summary>
		/// <returns></returns>
		public DataReader CreateReader() => dataReader;

		/// <summary>
		/// Default constructor
		/// </summary>
		protected DotNetStream() {
			streamHeader = null;
			dataReader = default;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="mdReaderFactory">Data reader factory</param>
		/// <param name="metadataBaseOffset">Offset of metadata</param>
		/// <param name="streamHeader">The stream header</param>
		protected DotNetStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader) {
			this.mdReaderFactory = mdReaderFactory;
			mdReaderFactory.DataReaderInvalidated += DataReaderFactory_DataReaderInvalidated;
			this.mdReaderFactory = mdReaderFactory;
			this.metadataBaseOffset = metadataBaseOffset;
			this.streamHeader = streamHeader;
			RecreateReader(mdReaderFactory, metadataBaseOffset, streamHeader, notifyThisClass: false);
		}

		void DataReaderFactory_DataReaderInvalidated(object sender, EventArgs e) => RecreateReader(mdReaderFactory, metadataBaseOffset, streamHeader, notifyThisClass: true);

		void RecreateReader(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader, bool notifyThisClass) {
			if (mdReaderFactory is null || streamHeader is null)
				dataReader = default;
			else
				dataReader = mdReaderFactory.CreateReader(metadataBaseOffset + streamHeader.Offset, streamHeader.StreamSize);
			if (notifyThisClass)
				OnReaderRecreated();
		}

		/// <summary>
		/// Called after <see cref="dataReader"/> gets recreated
		/// </summary>
		protected virtual void OnReaderRecreated() { }

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (disposing) {
				var mdReaderFactory = this.mdReaderFactory;
				if (mdReaderFactory is not null)
					mdReaderFactory.DataReaderInvalidated -= DataReaderFactory_DataReaderInvalidated;
				streamHeader = null;
				this.mdReaderFactory = null;
			}
		}

		/// <summary>
		/// Checks whether an index is valid
		/// </summary>
		/// <param name="index">The index</param>
		/// <returns><c>true</c> if the index is valid</returns>
		public virtual bool IsValidIndex(uint index) => IsValidOffset(index);

		/// <summary>
		/// Check whether an offset is within the stream
		/// </summary>
		/// <param name="offset">Stream offset</param>
		/// <returns><c>true</c> if the offset is valid</returns>
		public bool IsValidOffset(uint offset) => offset == 0 || offset < dataReader.Length;

		/// <summary>
		/// Check whether an offset is within the stream
		/// </summary>
		/// <param name="offset">Stream offset</param>
		/// <param name="size">Size of data</param>
		/// <returns><c>true</c> if the offset is valid</returns>
		public bool IsValidOffset(uint offset, int size) {
			if (size == 0)
				return IsValidOffset(offset);
			return size > 0 && (ulong)offset + (uint)size <= dataReader.Length;
		}
	}

	/// <summary>
	/// Base class of #US, #Strings, #Blob, and #GUID classes
	/// </summary>
	public abstract class HeapStream : DotNetStream {
		/// <inheritdoc/>
		protected HeapStream() {
		}

		/// <inheritdoc/>
		protected HeapStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader)
			: base(mdReaderFactory, metadataBaseOffset, streamHeader) {
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Initializes .NET table row sizes
	/// </summary>
	public sealed class DotNetTableSizes {
		bool bigStrings;
		bool bigGuid;
		bool bigBlob;
		bool forceAllBig;
		TableInfo[] tableInfos;

		internal static bool IsSystemTable(Table table) => table < Table.Document;

		/// <summary>
		/// Initializes the table sizes
		/// </summary>
		/// <param name="bigStrings"><c>true</c> if #Strings size >= 0x10000</param>
		/// <param name="bigGuid"><c>true</c> if #GUID size >= 0x10000</param>
		/// <param name="bigBlob"><c>true</c> if #Blob size >= 0x10000</param>
		/// <param name="systemRowCounts">Count of rows in each table</param>
		/// <param name="debugRowCounts">Count of rows in each table (debug tables)</param>
		public void InitializeSizes(bool bigStrings, bool bigGuid, bool bigBlob, IList<uint> systemRowCounts, IList<uint> debugRowCounts) =>
			InitializeSizes(bigStrings, bigGuid, bigBlob, systemRowCounts, debugRowCounts, false);

		/// <summary>
		/// Initializes the table sizes
		/// </summary>
		/// <param name="bigStrings"><c>true</c> if #Strings size >= 0x10000</param>
		/// <param name="bigGuid"><c>true</c> if #GUID size >= 0x10000</param>
		/// <param name="bigBlob"><c>true</c> if #Blob size >= 0x10000</param>
		/// <param name="systemRowCounts">Count of rows in each table</param>
		/// <param name="debugRowCounts">Count of rows in each table (debug tables)</param>
		/// <param name="forceAllBig">Force all columns to 4 bytes instead of 2 or 4 bytes</param>
		internal void InitializeSizes(bool bigStrings, bool bigGuid, bool bigBlob, IList<uint> systemRowCounts, IList<uint> debugRowCounts, bool forceAllBig) {
			this.bigStrings = bigStrings || forceAllBig;
			this.bigGuid = bigGuid || forceAllBig;
			this.bigBlob = bigBlob || forceAllBig;
			this.forceAllBig = forceAllBig;
			foreach (var tableInfo in tableInfos) {
				var rowCounts = IsSystemTable(tableInfo.Table) ? systemRowCounts : debugRowCounts;
				int colOffset = 0;
				foreach (var colInfo in tableInfo.Columns) {
					colInfo.Offset = colOffset;
					var colSize = GetSize(colInfo.ColumnSize, rowCounts);
					colInfo.Size = colSize;
					colOffset += colSize;
				}
				tableInfo.RowSize = colOffset;
			}
		}

		int GetSize(ColumnSize columnSize, IList<uint> rowCounts) {
			if (ColumnSize.Module <= columnSize && columnSize <= ColumnSize.CustomDebugInformation) {
				int table = (int)(columnSize - ColumnSize.Module);
				uint count = table >= rowCounts.Count ? 0 : rowCounts[table];
				return forceAllBig || count > 0xFFFF ? 4 : 2;
			}
			else if (ColumnSize.TypeDefOrRef <= columnSize && columnSize <= ColumnSize.HasCustomDebugInformation) {
				var info = columnSize switch {
					ColumnSize.TypeDefOrRef => CodedToken.TypeDefOrRef,
					ColumnSize.HasConstant => CodedToken.HasConstant,
					ColumnSize.HasCustomAttribute => CodedToken.HasCustomAttribute,
					ColumnSize.HasFieldMarshal => CodedToken.HasFieldMarshal,
					ColumnSize.HasDeclSecurity => CodedToken.HasDeclSecurity,
					ColumnSize.MemberRefParent => CodedToken.MemberRefParent,
					ColumnSize.HasSemantic => CodedToken.HasSemantic,
					ColumnSize.MethodDefOrRef => CodedToken.MethodDefOrRef,
					ColumnSize.MemberForwarded => CodedToken.MemberForwarded,
					ColumnSize.Implementation => CodedToken.Implementation,
					ColumnSize.CustomAttributeType => CodedToken.CustomAttributeType,
					ColumnSize.ResolutionScope => CodedToken.ResolutionScope,
					ColumnSize.TypeOrMethodDef => CodedToken.TypeOrMethodDef,
					ColumnSize.HasCustomDebugInformation => CodedToken.HasCustomDebugInformation,
					_ => throw new InvalidOperationException($"Invalid ColumnSize: {columnSize}"),
				};
				uint maxRows = 0;
				foreach (var tableType in info.TableTypes) {
					int index = (int)tableType;
					var tableRows = index >= rowCounts.Count ? 0 : rowCounts[index];
					if (tableRows > maxRows)
						maxRows = tableRows;
				}
				// Can't overflow since maxRows <= 0x00FFFFFF and info.Bits < 8
				uint finalRows = maxRows << info.Bits;
				return forceAllBig || finalRows > 0xFFFF ? 4 : 2;
			}
			else {
				switch (columnSize) {
				case ColumnSize.Byte:	return 1;
				case ColumnSize.Int16:	return 2;
				case ColumnSize.UInt16:	return 2;
				case ColumnSize.Int32:	return 4;
				case ColumnSize.UInt32:	return 4;
				case ColumnSize.Strings:return forceAllBig || bigStrings ? 4 : 2;
				case ColumnSize.GUID:	return forceAllBig || bigGuid ? 4 : 2;
				case ColumnSize.Blob:	return forceAllBig || bigBlob ? 4 : 2;
				}
			}
			throw new InvalidOperationException($"Invalid ColumnSize: {columnSize}");
		}

		/// <summary>
		/// Creates the table infos
		/// </summary>
		/// <param name="majorVersion">Major table version</param>
		/// <param name="minorVersion">Minor table version</param>
		/// <returns>All table infos (not completely initialized)</returns>
		public TableInfo[] CreateTables(byte majorVersion, byte minorVersion) =>
			CreateTables(majorVersion, minorVersion, out int maxPresentTables);

		internal const int normalMaxTables = (int)Table.CustomDebugInformation + 1;

		/// <summary>
		/// Creates the table infos
		/// </summary>
		/// <param name="majorVersion">Major table version</param>
		/// <param name="minorVersion">Minor table version</param>
		/// <param name="maxPresentTables">Initialized to max present tables (eg. 42 or 45)</param>
		/// <returns>All table infos (not completely initialized)</returns>
		public TableInfo[] CreateTables(byte majorVersion, byte minorVersion, out int maxPresentTables) {
			maxPresentTables = (majorVersion == 1 && minorVersion == 0) ? (int)Table.NestedClass + 1 : normalMaxTables;

			var tableInfos = new TableInfo[normalMaxTables];

			tableInfos[(int)Table.Module] = new TableInfo(Table.Module, "Module", new ColumnInfo[] {
				new ColumnInfo(0, "Generation", ColumnSize.UInt16),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Mvid", ColumnSize.GUID),
				new ColumnInfo(3, "EncId", ColumnSize.GUID),
				new ColumnInfo(4, "EncBaseId", ColumnSize.GUID),
			});
			tableInfos[(int)Table.TypeRef] = new TableInfo(Table.TypeRef, "TypeRef", new ColumnInfo[] {
				new ColumnInfo(0, "ResolutionScope", ColumnSize.ResolutionScope),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Namespace", ColumnSize.Strings),
			});
			tableInfos[(int)Table.TypeDef] = new TableInfo(Table.TypeDef, "TypeDef", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt32),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Namespace", ColumnSize.Strings),
				new ColumnInfo(3, "Extends", ColumnSize.TypeDefOrRef),
				new ColumnInfo(4, "FieldList", ColumnSize.Field),
				new ColumnInfo(5, "MethodList", ColumnSize.Method),
			});
			tableInfos[(int)Table.FieldPtr] = new TableInfo(Table.FieldPtr, "FieldPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Field", ColumnSize.Field),
			});
			tableInfos[(int)Table.Field] = new TableInfo(Table.Field, "Field", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt16),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.MethodPtr] = new TableInfo(Table.MethodPtr, "MethodPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Method", ColumnSize.Method),
			});
			tableInfos[(int)Table.Method] = new TableInfo(Table.Method, "Method", new ColumnInfo[] {
				new ColumnInfo(0, "RVA", ColumnSize.UInt32),
				new ColumnInfo(1, "ImplFlags", ColumnSize.UInt16),
				new ColumnInfo(2, "Flags", ColumnSize.UInt16),
				new ColumnInfo(3, "Name", ColumnSize.Strings),
				new ColumnInfo(4, "Signature", ColumnSize.Blob),
				new ColumnInfo(5, "ParamList", ColumnSize.Param),
			});
			tableInfos[(int)Table.ParamPtr] = new TableInfo(Table.ParamPtr, "ParamPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Param", ColumnSize.Param),
			});
			tableInfos[(int)Table.Param] = new TableInfo(Table.Param, "Param", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt16),
				new ColumnInfo(1, "Sequence", ColumnSize.UInt16),
				new ColumnInfo(2, "Name", ColumnSize.Strings),
			});
			tableInfos[(int)Table.InterfaceImpl] = new TableInfo(Table.InterfaceImpl, "InterfaceImpl", new ColumnInfo[] {
				new ColumnInfo(0, "Class", ColumnSize.TypeDef),
				new ColumnInfo(1, "Interface", ColumnSize.TypeDefOrRef),
			});
			tableInfos[(int)Table.MemberRef] = new TableInfo(Table.MemberRef, "MemberRef", new ColumnInfo[] {
				new ColumnInfo(0, "Class", ColumnSize.MemberRefParent),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.Constant] = new TableInfo(Table.Constant, "Constant", new ColumnInfo[] {
				new ColumnInfo(0, "Type", ColumnSize.Byte),
				new ColumnInfo(1, "Padding", ColumnSize.Byte),
				new ColumnInfo(2, "Parent", ColumnSize.HasConstant),
				new ColumnInfo(3, "Value", ColumnSize.Blob),
			});
			tableInfos[(int)Table.CustomAttribute] = new TableInfo(Table.CustomAttribute, "CustomAttribute", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.HasCustomAttribute),
				new ColumnInfo(1, "Type", ColumnSize.CustomAttributeType),
				new ColumnInfo(2, "Value", ColumnSize.Blob),
			});
			tableInfos[(int)Table.FieldMarshal] = new TableInfo(Table.FieldMarshal, "FieldMarshal", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.HasFieldMarshal),
				new ColumnInfo(1, "NativeType", ColumnSize.Blob),
			});
			tableInfos[(int)Table.DeclSecurity] = new TableInfo(Table.DeclSecurity, "DeclSecurity", new ColumnInfo[] {
				new ColumnInfo(0, "Action", ColumnSize.Int16),
				new ColumnInfo(1, "Parent", ColumnSize.HasDeclSecurity),
				new ColumnInfo(2, "PermissionSet", ColumnSize.Blob),
			});
			tableInfos[(int)Table.ClassLayout] = new TableInfo(Table.ClassLayout, "ClassLayout", new ColumnInfo[] {
				new ColumnInfo(0, "PackingSize", ColumnSize.UInt16),
				new ColumnInfo(1, "ClassSize", ColumnSize.UInt32),
				new ColumnInfo(2, "Parent", ColumnSize.TypeDef),
			});
			tableInfos[(int)Table.FieldLayout] = new TableInfo(Table.FieldLayout, "FieldLayout", new ColumnInfo[] {
				new ColumnInfo(0, "OffSet", ColumnSize.UInt32),
				new ColumnInfo(1, "Field", ColumnSize.Field),
			});
			tableInfos[(int)Table.StandAloneSig] = new TableInfo(Table.StandAloneSig, "StandAloneSig", new ColumnInfo[] {
				new ColumnInfo(0, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.EventMap] = new TableInfo(Table.EventMap, "EventMap", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.TypeDef),
				new ColumnInfo(1, "EventList", ColumnSize.Event),
			});
			tableInfos[(int)Table.EventPtr] = new TableInfo(Table.EventPtr, "EventPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Event", ColumnSize.Event),
			});
			tableInfos[(int)Table.Event] = new TableInfo(Table.Event, "Event", new ColumnInfo[] {
				new ColumnInfo(0, "EventFlags", ColumnSize.UInt16),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "EventType", ColumnSize.TypeDefOrRef),
			});
			tableInfos[(int)Table.PropertyMap] = new TableInfo(Table.PropertyMap, "PropertyMap", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.TypeDef),
				new ColumnInfo(1, "PropertyList", ColumnSize.Property),
			});
			tableInfos[(int)Table.PropertyPtr] = new TableInfo(Table.PropertyPtr, "PropertyPtr", new ColumnInfo[] {
				new ColumnInfo(0, "Property", ColumnSize.Property),
			});
			tableInfos[(int)Table.Property] = new TableInfo(Table.Property, "Property", new ColumnInfo[] {
				new ColumnInfo(0, "PropFlags", ColumnSize.UInt16),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "Type", ColumnSize.Blob),
			});
			tableInfos[(int)Table.MethodSemantics] = new TableInfo(Table.MethodSemantics, "MethodSemantics", new ColumnInfo[] {
				new ColumnInfo(0, "Semantic", ColumnSize.UInt16),
				new ColumnInfo(1, "Method", ColumnSize.Method),
				new ColumnInfo(2, "Association", ColumnSize.HasSemantic),
			});
			tableInfos[(int)Table.MethodImpl] = new TableInfo(Table.MethodImpl, "MethodImpl", new ColumnInfo[] {
				new ColumnInfo(0, "Class", ColumnSize.TypeDef),
				new ColumnInfo(1, "MethodBody", ColumnSize.MethodDefOrRef),
				new ColumnInfo(2, "MethodDeclaration", ColumnSize.MethodDefOrRef),
			});
			tableInfos[(int)Table.ModuleRef] = new TableInfo(Table.ModuleRef, "ModuleRef", new ColumnInfo[] {
				new ColumnInfo(0, "Name", ColumnSize.Strings),
			});
			tableInfos[(int)Table.TypeSpec] = new TableInfo(Table.TypeSpec, "TypeSpec", new ColumnInfo[] {
				new ColumnInfo(0, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.ImplMap] = new TableInfo(Table.ImplMap, "ImplMap", new ColumnInfo[] {
				new ColumnInfo(0, "MappingFlags", ColumnSize.UInt16),
				new ColumnInfo(1, "MemberForwarded", ColumnSize.MemberForwarded),
				new ColumnInfo(2, "ImportName", ColumnSize.Strings),
				new ColumnInfo(3, "ImportScope", ColumnSize.ModuleRef),
			});
			tableInfos[(int)Table.FieldRVA] = new TableInfo(Table.FieldRVA, "FieldRVA", new ColumnInfo[] {
				new ColumnInfo(0, "RVA", ColumnSize.UInt32),
				new ColumnInfo(1, "Field", ColumnSize.Field),
			});
			tableInfos[(int)Table.ENCLog] = new TableInfo(Table.ENCLog, "ENCLog", new ColumnInfo[] {
				new ColumnInfo(0, "Token", ColumnSize.UInt32),
				new ColumnInfo(1, "FuncCode", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.ENCMap] = new TableInfo(Table.ENCMap, "ENCMap", new ColumnInfo[] {
				new ColumnInfo(0, "Token", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.Assembly] = new TableInfo(Table.Assembly, "Assembly", new ColumnInfo[] {
				new ColumnInfo(0, "HashAlgId", ColumnSize.UInt32),
				new ColumnInfo(1, "MajorVersion", ColumnSize.UInt16),
				new ColumnInfo(2, "MinorVersion", ColumnSize.UInt16),
				new ColumnInfo(3, "BuildNumber", ColumnSize.UInt16),
				new ColumnInfo(4, "RevisionNumber", ColumnSize.UInt16),
				new ColumnInfo(5, "Flags", ColumnSize.UInt32),
				new ColumnInfo(6, "PublicKey", ColumnSize.Blob),
				new ColumnInfo(7, "Name", ColumnSize.Strings),
				new ColumnInfo(8, "Locale", ColumnSize.Strings),
			});
			tableInfos[(int)Table.AssemblyProcessor] = new TableInfo(Table.AssemblyProcessor, "AssemblyProcessor", new ColumnInfo[] {
				new ColumnInfo(0, "Processor", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.AssemblyOS] = new TableInfo(Table.AssemblyOS, "AssemblyOS", new ColumnInfo[] {
				new ColumnInfo(0, "OSPlatformId", ColumnSize.UInt32),
				new ColumnInfo(1, "OSMajorVersion", ColumnSize.UInt32),
				new ColumnInfo(2, "OSMinorVersion", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.AssemblyRef] = new TableInfo(Table.AssemblyRef, "AssemblyRef", new ColumnInfo[] {
				new ColumnInfo(0, "MajorVersion", ColumnSize.UInt16),
				new ColumnInfo(1, "MinorVersion", ColumnSize.UInt16),
				new ColumnInfo(2, "BuildNumber", ColumnSize.UInt16),
				new ColumnInfo(3, "RevisionNumber", ColumnSize.UInt16),
				new ColumnInfo(4, "Flags", ColumnSize.UInt32),
				new ColumnInfo(5, "PublicKeyOrToken", ColumnSize.Blob),
				new ColumnInfo(6, "Name", ColumnSize.Strings),
				new ColumnInfo(7, "Locale", ColumnSize.Strings),
				new ColumnInfo(8, "HashValue", ColumnSize.Blob),
			});
			tableInfos[(int)Table.AssemblyRefProcessor] = new TableInfo(Table.AssemblyRefProcessor, "AssemblyRefProcessor", new ColumnInfo[] {
				new ColumnInfo(0, "Processor", ColumnSize.UInt32),
				new ColumnInfo(1, "AssemblyRef", ColumnSize.AssemblyRef),
			});
			tableInfos[(int)Table.AssemblyRefOS] = new TableInfo(Table.AssemblyRefOS, "AssemblyRefOS", new ColumnInfo[] {
				new ColumnInfo(0, "OSPlatformId", ColumnSize.UInt32),
				new ColumnInfo(1, "OSMajorVersion", ColumnSize.UInt32),
				new ColumnInfo(2, "OSMinorVersion", ColumnSize.UInt32),
				new ColumnInfo(3, "AssemblyRef", ColumnSize.AssemblyRef),
			});
			tableInfos[(int)Table.File] = new TableInfo(Table.File, "File", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt32),
				new ColumnInfo(1, "Name", ColumnSize.Strings),
				new ColumnInfo(2, "HashValue", ColumnSize.Blob),
			});
			tableInfos[(int)Table.ExportedType] = new TableInfo(Table.ExportedType, "ExportedType", new ColumnInfo[] {
				new ColumnInfo(0, "Flags", ColumnSize.UInt32),
				new ColumnInfo(1, "TypeDefId", ColumnSize.UInt32),
				new ColumnInfo(2, "TypeName", ColumnSize.Strings),
				new ColumnInfo(3, "TypeNamespace", ColumnSize.Strings),
				new ColumnInfo(4, "Implementation", ColumnSize.Implementation),
			});
			tableInfos[(int)Table.ManifestResource] = new TableInfo(Table.ManifestResource, "ManifestResource", new ColumnInfo[] {
				new ColumnInfo(0, "Offset", ColumnSize.UInt32),
				new ColumnInfo(1, "Flags", ColumnSize.UInt32),
				new ColumnInfo(2, "Name", ColumnSize.Strings),
				new ColumnInfo(3, "Implementation", ColumnSize.Implementation),
			});
			tableInfos[(int)Table.NestedClass] = new TableInfo(Table.NestedClass, "NestedClass", new ColumnInfo[] {
				new ColumnInfo(0, "NestedClass", ColumnSize.TypeDef),
				new ColumnInfo(1, "EnclosingClass", ColumnSize.TypeDef),
			});
			if (majorVersion == 1 && minorVersion == 1) {
				tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam, "GenericParam", new ColumnInfo[] {
					new ColumnInfo(0, "Number", ColumnSize.UInt16),
					new ColumnInfo(1, "Flags", ColumnSize.UInt16),
					new ColumnInfo(2, "Owner", ColumnSize.TypeOrMethodDef),
					new ColumnInfo(3, "Name", ColumnSize.Strings),
					new ColumnInfo(4, "Kind", ColumnSize.TypeDefOrRef),
				});
			}
			else {
				tableInfos[(int)Table.GenericParam] = new TableInfo(Table.GenericParam, "GenericParam", new ColumnInfo[] {
					new ColumnInfo(0, "Number", ColumnSize.UInt16),
					new ColumnInfo(1, "Flags", ColumnSize.UInt16),
					new ColumnInfo(2, "Owner", ColumnSize.TypeOrMethodDef),
					new ColumnInfo(3, "Name", ColumnSize.Strings),
				});
			}
			tableInfos[(int)Table.MethodSpec] = new TableInfo(Table.MethodSpec, "MethodSpec", new ColumnInfo[] {
				new ColumnInfo(0, "Method", ColumnSize.MethodDefOrRef),
				new ColumnInfo(1, "Instantiation", ColumnSize.Blob),
			});
			tableInfos[(int)Table.GenericParamConstraint] = new TableInfo(Table.GenericParamConstraint, "GenericParamConstraint", new ColumnInfo[] {
				new ColumnInfo(0, "Owner", ColumnSize.GenericParam),
				new ColumnInfo(1, "Constraint", ColumnSize.TypeDefOrRef),
			});
			tableInfos[0x2D] = new TableInfo((Table)0x2D, string.Empty, new ColumnInfo[] { });
			tableInfos[0x2E] = new TableInfo((Table)0x2E, string.Empty, new ColumnInfo[] { });
			tableInfos[0x2F] = new TableInfo((Table)0x2F, string.Empty, new ColumnInfo[] { });
			tableInfos[(int)Table.Document] = new TableInfo(Table.Document, "Document", new ColumnInfo[] {
				new ColumnInfo(0, "Name", ColumnSize.Blob),
				new ColumnInfo(1, "HashAlgorithm", ColumnSize.GUID),
				new ColumnInfo(2, "Hash", ColumnSize.Blob),
				new ColumnInfo(3, "Language", ColumnSize.GUID),
			});
			tableInfos[(int)Table.MethodDebugInformation] = new TableInfo(Table.MethodDebugInformation, "MethodDebugInformation", new ColumnInfo[] {
				new ColumnInfo(0, "Document", ColumnSize.Document),
				new ColumnInfo(1, "SequencePoints", ColumnSize.Blob),
			});
			tableInfos[(int)Table.LocalScope] = new TableInfo(Table.LocalScope, "LocalScope", new ColumnInfo[] {
				new ColumnInfo(0, "Method", ColumnSize.Method),
				new ColumnInfo(1, "ImportScope", ColumnSize.ImportScope),
				new ColumnInfo(2, "VariableList", ColumnSize.LocalVariable),
				new ColumnInfo(3, "ConstantList", ColumnSize.LocalConstant),
				new ColumnInfo(4, "StartOffset", ColumnSize.UInt32),
				new ColumnInfo(5, "Length", ColumnSize.UInt32),
			});
			tableInfos[(int)Table.LocalVariable] = new TableInfo(Table.LocalVariable, "LocalVariable", new ColumnInfo[] {
				new ColumnInfo(0, "Attributes", ColumnSize.UInt16),
				new ColumnInfo(1, "Index", ColumnSize.UInt16),
				new ColumnInfo(2, "Name", ColumnSize.Strings),
			});
			tableInfos[(int)Table.LocalConstant] = new TableInfo(Table.LocalConstant, "LocalConstant", new ColumnInfo[] {
				new ColumnInfo(0, "Name", ColumnSize.Strings),
				new ColumnInfo(1, "Signature", ColumnSize.Blob),
			});
			tableInfos[(int)Table.ImportScope] = new TableInfo(Table.ImportScope, "ImportScope", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.ImportScope),
				new ColumnInfo(1, "Imports", ColumnSize.Blob),
			});
			tableInfos[(int)Table.StateMachineMethod] = new TableInfo(Table.StateMachineMethod, "StateMachineMethod", new ColumnInfo[] {
				new ColumnInfo(0, "MoveNextMethod", ColumnSize.Method),
				new ColumnInfo(1, "KickoffMethod", ColumnSize.Method),
			});
			tableInfos[(int)Table.CustomDebugInformation] = new TableInfo(Table.CustomDebugInformation, "CustomDebugInformation", new ColumnInfo[] {
				new ColumnInfo(0, "Parent", ColumnSize.HasCustomDebugInformation),
				new ColumnInfo(1, "Kind", ColumnSize.GUID),
				new ColumnInfo(2, "Value", ColumnSize.Blob),
			});
			return this.tableInfos = tableInfos;
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Used when a #- stream is present in the metadata
	/// </summary>
	sealed class ENCMetadata : MetadataBase {
		static readonly UTF8String DeletedName = "_Deleted";
		bool hasMethodPtr, hasFieldPtr, hasParamPtr, hasEventPtr, hasPropertyPtr;
		bool hasDeletedFields;
		bool hasDeletedNonFields;
		readonly CLRRuntimeReaderKind runtime;
		readonly Dictionary<Table, SortedTable> sortedTables = new Dictionary<Table, SortedTable>();
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public override bool IsCompressed => false;

		/// <inheritdoc/>
		public ENCMetadata(IPEImage peImage, ImageCor20Header cor20Header, MetadataHeader mdHeader, CLRRuntimeReaderKind runtime)
			: base(peImage, cor20Header, mdHeader) {
			this.runtime = runtime;
		}

		/// <inheritdoc/>
		internal ENCMetadata(MetadataHeader mdHeader, bool isStandalonePortablePdb, CLRRuntimeReaderKind runtime)
			: base(mdHeader, isStandalonePortablePdb) {
			this.runtime = runtime;
		}

		/// <inheritdoc/>
		protected override void InitializeInternal(DataReaderFactory mdReaderFactory, uint metadataBaseOffset) {
			DotNetStream dns = null;
			bool forceAllBig = false;
			try {
				if (runtime == CLRRuntimeReaderKind.Mono) {
					var newAllStreams = new List<DotNetStream>(allStreams);
					for (int i = mdHeader.StreamHeaders.Count - 1; i >= 0; i--) {
						var sh = mdHeader.StreamHeaders[i];
						switch (sh.Name) {
						case "#Strings":
							if (stringsStream is null) {
								stringsStream = new StringsStream(mdReaderFactory, metadataBaseOffset, sh);
								newAllStreams.Add(stringsStream);
								continue;
							}
							break;

						case "#US":
							if (usStream is null) {
								usStream = new USStream(mdReaderFactory, metadataBaseOffset, sh);
								newAllStreams.Add(usStream);
								continue;
							}
							break;

						case "#Blob":
							if (blobStream is null) {
								blobStream = new BlobStream(mdReaderFactory, metadataBaseOffset, sh);
								newAllStreams.Add(blobStream);
								continue;
							}
							break;

						case "#GUID":
							if (guidStream is null) {
								guidStream = new GuidStream(mdReaderFactory, metadataBaseOffset, sh);
								newAllStreams.Add(guidStream);
								continue;
							}
							break;

						case "#~":
						case "#-":
							if (tablesStream is null) {
								tablesStream = new TablesStream(mdReaderFactory, metadataBaseOffset, sh, runtime);
								newAllStreams.Add(tablesStream);
								continue;
							}
							break;

						case "#Pdb":
							if (isStandalonePortablePdb && pdbStream is null) {
								pdbStream = new PdbStream(mdReaderFactory, metadataBaseOffset, sh);
								newAllStreams.Add(pdbStream);
								continue;
							}
							break;

						case "#JTD":
							forceAllBig = true;
							continue;
						}
						dns = new CustomDotNetStream(mdReaderFactory, metadataBaseOffset, sh);
						newAllStreams.Add(dns);
						dns = null;
					}
					newAllStreams.Reverse();
					allStreams = newAllStreams;
				}
				else {
					Debug.Assert(runtime == CLRRuntimeReaderKind.CLR);
					foreach (var sh in mdHeader.StreamHeaders) {
						switch (sh.Name.ToUpperInvariant()) {
						case "#STRINGS":
							if (stringsStream is null) {
								stringsStream = new StringsStream(mdReaderFactory, metadataBaseOffset, sh);
								allStreams.Add(stringsStream);
								continue;
							}
							break;

						case "#US":
							if (usStream is null) {
								usStream = new USStream(mdReaderFactory, metadataBaseOffset, sh);
								allStreams.Add(usStream);
								continue;
							}
							break;

						case "#BLOB":
							if (blobStream is null) {
								blobStream = new BlobStream(mdReaderFactory, metadataBaseOffset, sh);
								allStreams.Add(blobStream);
								continue;
							}
							break;

						case "#GUID":
							if (guidStream is null) {
								guidStream = new GuidStream(mdReaderFactory, metadataBaseOffset, sh);
								allStreams.Add(guidStream);
								continue;
							}
							break;

						case "#~":  // Only if #Schema is used
						case "#-":
							if (tablesStream is null) {
								tablesStream = new TablesStream(mdReaderFactory, metadataBaseOffset, sh, runtime);
								allStreams.Add(tablesStream);
								continue;
							}
							break;

						case "#PDB":
							// Case sensitive comparison since it's a stream that's not read by the CLR,
							// only by other libraries eg. System.Reflection.Metadata.
							if (isStandalonePortablePdb && pdbStream is null && sh.Name == "#Pdb") {
								pdbStream = new PdbStream(mdReaderFactory, metadataBaseOffset, sh);
								allStreams.Add(pdbStream);
								continue;
							}
							break;

						case "#JTD":
							forceAllBig = true;
							continue;
						}
						dns = new CustomDotNetStream(mdReaderFactory, metadataBaseOffset, sh);
						allStreams.Add(dns);
						dns = null;
					}
				}
			}
			finally {
				dns?.Dispose();
			}

			if (tablesStream is null)
				throw new BadImageFormatException("Missing MD stream");

			if (pdbStream is not null)
				tablesStream.Initialize(pdbStream.TypeSystemTableRows, forceAllBig);
			else
				tablesStream.Initialize(null, forceAllBig);

			// The pointer tables are used iff row count != 0
			hasFieldPtr = !tablesStream.FieldPtrTable.IsEmpty;
			hasMethodPtr = !tablesStream.MethodPtrTable.IsEmpty;
			hasParamPtr = !tablesStream.ParamPtrTable.IsEmpty;
			hasEventPtr = !tablesStream.EventPtrTable.IsEmpty;
			hasPropertyPtr = !tablesStream.PropertyPtrTable.IsEmpty;

			switch (runtime) {
			case CLRRuntimeReaderKind.CLR:
				hasDeletedFields = tablesStream.HasDelete;
				hasDeletedNonFields = tablesStream.HasDelete;
				break;

			case CLRRuntimeReaderKind.Mono:
				hasDeletedFields = true;
				hasDeletedNonFields = false;
				break;

			default:
				throw new InvalidOperationException();
			}
		}

		/// <inheritdoc/>
		public override RidList GetTypeDefRidList() {
			if (!hasDeletedNonFields)
				return base.GetTypeDefRidList();
			uint rows = tablesStream.TypeDefTable.Rows;
			var list = new List<uint>((int)rows);
			for (uint rid = 1; rid <= rows; rid++) {
				if (!tablesStream.TryReadTypeDefRow(rid, out var row))
					continue;	// Should never happen since rid is valid

				// RTSpecialName is ignored by the CLR. It's only the name that indicates
				// whether it's been deleted.
				// It's not possible to delete the global type (<Module>)
				if (rid != 1 && stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
					continue;	// ignore this deleted row
				list.Add(rid);
			}
			return RidList.Create(list);
		}

		/// <inheritdoc/>
		public override RidList GetExportedTypeRidList() {
			if (!hasDeletedNonFields)
				return base.GetExportedTypeRidList();
			uint rows = tablesStream.ExportedTypeTable.Rows;
			var list = new List<uint>((int)rows);
			for (uint rid = 1; rid <= rows; rid++) {
				if (!tablesStream.TryReadExportedTypeRow(rid, out var row))
					continue;	// Should never happen since rid is valid

				// RTSpecialName is ignored by the CLR. It's only the name that indicates
				// whether it's been deleted.
				if (stringsStream.ReadNoNull(row.TypeName).StartsWith(DeletedName))
					continue;	// ignore this deleted row
				list.Add(rid);
			}
			return RidList.Create(list);
		}

		/// <summary>
		/// Converts a logical <c>Field</c> rid to a physical <c>Field</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToFieldRid(uint listRid) {
			if (!hasFieldPtr)
				return listRid;
			return tablesStream.TryReadColumn24(tablesStream.FieldPtrTable, listRid, 0, out uint listValue) ? listValue : 0;
		}

		/// <summary>
		/// Converts a logical <c>Method</c> rid to a physical <c>Method</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToMethodRid(uint listRid) {
			if (!hasMethodPtr)
				return listRid;
			return tablesStream.TryReadColumn24(tablesStream.MethodPtrTable, listRid, 0, out uint listValue) ? listValue : 0;
		}

		/// <summary>
		/// Converts a logical <c>Param</c> rid to a physical <c>Param</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToParamRid(uint listRid) {
			if (!hasParamPtr)
				return listRid;
			return tablesStream.TryReadColumn24(tablesStream.ParamPtrTable, listRid, 0, out uint listValue) ? listValue : 0;
		}

		/// <summary>
		/// Converts a logical <c>Event</c> rid to a physical <c>Event</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToEventRid(uint listRid) {
			if (!hasEventPtr)
				return listRid;
			return tablesStream.TryReadColumn24(tablesStream.EventPtrTable, listRid, 0, out uint listValue) ? listValue : 0;
		}

		/// <summary>
		/// Converts a logical <c>Property</c> rid to a physical <c>Property</c> rid
		/// </summary>
		/// <param name="listRid">A valid rid</param>
		/// <returns>Converted rid or any invalid rid value if <paramref name="listRid"/> is invalid</returns>
		uint ToPropertyRid(uint listRid) {
			if (!hasPropertyPtr)
				return listRid;
			return tablesStream.TryReadColumn24(tablesStream.PropertyPtrTable, listRid, 0, out uint listValue) ? listValue : 0;
		}

		/// <inheritdoc/>
		public override RidList GetFieldRidList(uint typeDefRid) {
			var list = GetRidList(tablesStream.TypeDefTable, typeDefRid, 4, tablesStream.FieldTable);
			if (list.Count == 0 || (!hasFieldPtr && !hasDeletedFields))
				return list;

			var destTable = tablesStream.FieldTable;
			var newList = new List<uint>(list.Count);
			for (int i = 0; i < list.Count; i++) {
				var rid = ToFieldRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				if (hasDeletedFields) {
					// It's a deleted row if RTSpecialName is set and name is "_Deleted"
					if (!tablesStream.TryReadFieldRow(rid, out var row))
						continue;	// Should never happen since rid is valid
					if (runtime == CLRRuntimeReaderKind.CLR) {
						if ((row.Flags & (uint)FieldAttributes.RTSpecialName) != 0) {
							if (stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
								continue;	// ignore this deleted row
						}
					}
					else {
						if ((row.Flags & (uint)(FieldAttributes.SpecialName | FieldAttributes.RTSpecialName)) == (uint)(FieldAttributes.SpecialName | FieldAttributes.RTSpecialName)) {
							if (stringsStream.ReadNoNull(row.Name) == DeletedName)
								continue;	// ignore this deleted row
						}
					}
				}
				// It's a valid non-deleted rid so add it
				newList.Add(rid);
			}
			return RidList.Create(newList);
		}

		/// <inheritdoc/>
		public override RidList GetMethodRidList(uint typeDefRid) {
			var list = GetRidList(tablesStream.TypeDefTable, typeDefRid, 5, tablesStream.MethodTable);
			if (list.Count == 0 || (!hasMethodPtr && !hasDeletedNonFields))
				return list;

			var destTable = tablesStream.MethodTable;
			var newList = new List<uint>(list.Count);
			for (int i = 0; i < list.Count; i++) {
				var rid = ToMethodRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				if (hasDeletedNonFields) {
					// It's a deleted row if RTSpecialName is set and name is "_Deleted"
					if (!tablesStream.TryReadMethodRow(rid, out var row))
						continue;	// Should never happen since rid is valid
					if ((row.Flags & (uint)MethodAttributes.RTSpecialName) != 0) {
						if (stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
							continue;	// ignore this deleted row
					}
				}
				// It's a valid non-deleted rid so add it
				newList.Add(rid);
			}
			return RidList.Create(newList);
		}

		/// <inheritdoc/>
		public override RidList GetParamRidList(uint methodRid) {
			var list = GetRidList(tablesStream.MethodTable, methodRid, 5, tablesStream.ParamTable);
			if (list.Count == 0 || !hasParamPtr)
				return list;

			var destTable = tablesStream.ParamTable;
			var newList = new List<uint>(list.Count);
			for (int i = 0; i < list.Count; i++) {
				var rid = ToParamRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				newList.Add(rid);
			}
			return RidList.Create(newList);
		}

		/// <inheritdoc/>
		public override RidList GetEventRidList(uint eventMapRid) {
			var list = GetRidList(tablesStream.EventMapTable, eventMapRid, 1, tablesStream.EventTable);
			if (list.Count == 0 || (!hasEventPtr && !hasDeletedNonFields))
				return list;

			var destTable = tablesStream.EventTable;
			var newList = new List<uint>(list.Count);
			for (int i = 0; i < list.Count; i++) {
				var rid = ToEventRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				if (hasDeletedNonFields) {
					// It's a deleted row if RTSpecialName is set and name is "_Deleted"
					if (!tablesStream.TryReadEventRow(rid, out var row))
						continue;	// Should never happen since rid is valid
					if ((row.EventFlags & (uint)EventAttributes.RTSpecialName) != 0) {
						if (stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
							continue;	// ignore this deleted row
					}
				}
				// It's a valid non-deleted rid so add it
				newList.Add(rid);
			}
			return RidList.Create(newList);
		}

		/// <inheritdoc/>
		public override RidList GetPropertyRidList(uint propertyMapRid) {
			var list = GetRidList(tablesStream.PropertyMapTable, propertyMapRid, 1, tablesStream.PropertyTable);
			if (list.Count == 0 || (!hasPropertyPtr && !hasDeletedNonFields))
				return list;

			var destTable = tablesStream.PropertyTable;
			var newList = new List<uint>(list.Count);
			for (int i = 0; i < list.Count; i++) {
				var rid = ToPropertyRid(list[i]);
				if (destTable.IsInvalidRID(rid))
					continue;
				if (hasDeletedNonFields) {
					// It's a deleted row if RTSpecialName is set and name is "_Deleted"
					if (!tablesStream.TryReadPropertyRow(rid, out var row))
						continue;	// Should never happen since rid is valid
					if ((row.PropFlags & (uint)PropertyAttributes.RTSpecialName) != 0) {
						if (stringsStream.ReadNoNull(row.Name).StartsWith(DeletedName))
							continue;	// ignore this deleted row
					}
				}
				// It's a valid non-deleted rid so add it
				newList.Add(rid);
			}
			return RidList.Create(newList);
		}

		/// <inheritdoc/>
		public override RidList GetLocalVariableRidList(uint localScopeRid) => GetRidList(tablesStream.LocalScopeTable, localScopeRid, 2, tablesStream.LocalVariableTable);

		/// <inheritdoc/>
		public override RidList GetLocalConstantRidList(uint localScopeRid) => GetRidList(tablesStream.LocalScopeTable, localScopeRid, 3, tablesStream.LocalConstantTable);

		/// <summary>
		/// Gets a rid list (eg. field list)
		/// </summary>
		/// <param name="tableSource">Source table, eg. <c>TypeDef</c></param>
		/// <param name="tableSourceRid">Row ID in <paramref name="tableSource"/></param>
		/// <param name="colIndex">Column index in <paramref name="tableSource"/>, eg. 4 for <c>TypeDef.FieldList</c></param>
		/// <param name="tableDest">Destination table, eg. <c>Field</c></param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		RidList GetRidList(MDTable tableSource, uint tableSourceRid, int colIndex, MDTable tableDest) {
			var column = tableSource.TableInfo.Columns[colIndex];
			if (!tablesStream.TryReadColumn24(tableSource, tableSourceRid, column, out uint startRid))
				return RidList.Empty;
			bool hasNext = tablesStream.TryReadColumn24(tableSource, tableSourceRid + 1, column, out uint nextListRid);
			uint lastRid = tableDest.Rows + 1;
			if (startRid == 0 || startRid >= lastRid)
				return RidList.Empty;
			uint endRid = hasNext && nextListRid != 0 ? nextListRid : lastRid;
			if (endRid < startRid)
				endRid = startRid;
			if (endRid > lastRid)
				endRid = lastRid;
			return RidList.Create(startRid, endRid - startRid);
		}

		/// <inheritdoc/>
		protected override uint BinarySearch(MDTable tableSource, int keyColIndex, uint key) {
			var keyColumn = tableSource.TableInfo.Columns[keyColIndex];
			uint ridLo = 1, ridHi = tableSource.Rows;
			while (ridLo <= ridHi) {
				uint rid = (ridLo + ridHi) / 2;
				if (!tablesStream.TryReadColumn24(tableSource, rid, keyColumn, out uint key2))
					break;	// Never happens since rid is valid
				if (key == key2)
					return rid;
				if (key2 > key)
					ridHi = rid - 1;
				else
					ridLo = rid + 1;
			}

			if (tableSource.Table == Table.GenericParam && !tablesStream.IsSorted(tableSource))
				return LinearSearch(tableSource, keyColIndex, key);

			return 0;
		}

		uint LinearSearch(MDTable tableSource, int keyColIndex, uint key) {
			if (tableSource is null)
				return 0;
			var keyColumn = tableSource.TableInfo.Columns[keyColIndex];
			for (uint rid = 1; rid <= tableSource.Rows; rid++) {
				if (!tablesStream.TryReadColumn24(tableSource, rid, keyColumn, out uint key2))
					break;	// Never happens since rid is valid
				if (key == key2)
					return rid;
			}
			return 0;
		}

		/// <inheritdoc/>
		protected override RidList FindAllRowsUnsorted(MDTable tableSource, int keyColIndex, uint key) {
			if (tablesStream.IsSorted(tableSource))
				return FindAllRows(tableSource, keyColIndex, key);
			SortedTable sortedTable;
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			if (!sortedTables.TryGetValue(tableSource.Table, out sortedTable))
				sortedTables[tableSource.Table] = sortedTable = new SortedTable(tableSource, keyColIndex);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
			return sortedTable.FindAllRows(key);
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the #GUID stream
	/// </summary>
	public sealed class GuidStream : HeapStream {
		/// <inheritdoc/>
		public GuidStream() {
		}

		/// <inheritdoc/>
		public GuidStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader)
			: base(mdReaderFactory, metadataBaseOffset, streamHeader) {
		}

		/// <inheritdoc/>
		public override bool IsValidIndex(uint index) => index == 0 || (index <= 0x10000000 && IsValidOffset((index - 1) * 16, 16));

		/// <summary>
		/// Read a <see cref="Guid"/>
		/// </summary>
		/// <param name="index">Index into this stream</param>
		/// <returns>A <see cref="Guid"/> or <c>null</c> if <paramref name="index"/> is 0 or invalid</returns>
		public Guid? Read(uint index) {
			if (index == 0 || !IsValidIndex(index))
				return null;
			var reader = dataReader;
			reader.Position = (index - 1) * 16;
			return reader.ReadGuid();
		}
	}
}




namespace dnlib.DotNet.MD {
	/// <summary>
	/// Heap type. The values are set in stone by MS. Don't change.
	/// </summary>
	public enum HeapType : uint {
		/// <summary>#Strings heap</summary>
		Strings	= 0,
		/// <summary>#GUID heap</summary>
		Guid	= 1,
		/// <summary>#Blob heap</summary>
		Blob	= 2,
		/// <summary>#US heap</summary>
		US		= 3,
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the IMAGE_COR20_HEADER structure
	/// </summary>
	public sealed class ImageCor20Header : FileSection {
		readonly uint cb;
		readonly ushort majorRuntimeVersion;
		readonly ushort minorRuntimeVersion;
		readonly ImageDataDirectory metadata;
		readonly ComImageFlags flags;
		readonly uint entryPointToken_or_RVA;
		readonly ImageDataDirectory resources;
		readonly ImageDataDirectory strongNameSignature;
		readonly ImageDataDirectory codeManagerTable;
		readonly ImageDataDirectory vtableFixups;
		readonly ImageDataDirectory exportAddressTableJumps;
		readonly ImageDataDirectory managedNativeHeader;

		/// <summary>
		/// Returns <c>true</c> if it has a native header
		/// </summary>
		public bool HasNativeHeader => (flags & ComImageFlags.ILLibrary) != 0;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.cb field
		/// </summary>
		public uint CB => cb;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.MajorRuntimeVersion field
		/// </summary>
		public ushort MajorRuntimeVersion => majorRuntimeVersion;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.MinorRuntimeVersion field
		/// </summary>
		public ushort MinorRuntimeVersion => minorRuntimeVersion;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.Metadata field
		/// </summary>
		public ImageDataDirectory Metadata => metadata;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.Flags field
		/// </summary>
		public ComImageFlags Flags => flags;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.EntryPointToken/EntryPointTokenRVA field
		/// </summary>
		public uint EntryPointToken_or_RVA => entryPointToken_or_RVA;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.Resources field
		/// </summary>
		public ImageDataDirectory Resources => resources;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.StrongNameSignature field
		/// </summary>
		public ImageDataDirectory StrongNameSignature => strongNameSignature;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.CodeManagerTable field
		/// </summary>
		public ImageDataDirectory CodeManagerTable => codeManagerTable;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.VTableFixups field
		/// </summary>
		public ImageDataDirectory VTableFixups => vtableFixups;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.ExportAddressTableJumps field
		/// </summary>
		public ImageDataDirectory ExportAddressTableJumps => exportAddressTableJumps;

		/// <summary>
		/// Returns the IMAGE_COR20_HEADER.ManagedNativeHeader field
		/// </summary>
		public ImageDataDirectory ManagedNativeHeader => managedNativeHeader;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageCor20Header(ref DataReader reader, bool verify) {
			SetStartOffset(ref reader);
			cb = reader.ReadUInt32();
			if (verify && cb < 0x48)
				throw new BadImageFormatException("Invalid IMAGE_COR20_HEADER.cb value");
			majorRuntimeVersion = reader.ReadUInt16();
			minorRuntimeVersion = reader.ReadUInt16();
			metadata = new ImageDataDirectory(ref reader, verify);
			flags = (ComImageFlags)reader.ReadUInt32();
			entryPointToken_or_RVA = reader.ReadUInt32();
			resources = new ImageDataDirectory(ref reader, verify);
			strongNameSignature = new ImageDataDirectory(ref reader, verify);
			codeManagerTable = new ImageDataDirectory(ref reader, verify);
			vtableFixups = new ImageDataDirectory(ref reader, verify);
			exportAddressTableJumps = new ImageDataDirectory(ref reader, verify);
			managedNativeHeader = new ImageDataDirectory(ref reader, verify);
			SetEndoffset(ref reader);
		}
	}
}




namespace dnlib.DotNet.MD {
	/// <summary>
	/// Reads metadata table columns
	/// </summary>
	public interface IColumnReader {
		/// <summary>
		/// Reads a column
		/// </summary>
		/// <param name="table">The table to read from</param>
		/// <param name="rid">Table row id</param>
		/// <param name="column">The column to read</param>
		/// <param name="value">Result</param>
		/// <returns><c>true</c> if <paramref name="value"/> was updated, <c>false</c> if
		/// the column should be read from the original table.</returns>
		bool ReadColumn(MDTable table, uint rid, ColumnInfo column, out uint value);
	}

	/// <summary>
	/// Reads table rows
	/// </summary>
	/// <typeparam name="TRow">Raw row</typeparam>
	public interface IRowReader<TRow> where TRow : struct {
		/// <summary>
		/// Reads a table row or returns false if the row should be read from the original table
		/// </summary>
		/// <param name="rid">Row id</param>
		/// <param name="row">The row</param>
		/// <returns></returns>
		bool TryReadRow(uint rid, out TRow row);
	}
}




namespace dnlib.DotNet.MD {
	/// <summary>
	/// Version strings found in the meta data header
	/// </summary>
	public static class MDHeaderRuntimeVersion {
		/// <summary>
		/// MS CLR 1.0 version string (.NET Framework 1.0)
		/// </summary>
		public const string MS_CLR_10 = "v1.0.3705";

		/// <summary>
		/// MS CLR 1.0 version string (.NET Framework 1.0). This is an incorrect version that shouldn't be used.
		/// </summary>
		public const string MS_CLR_10_X86RETAIL = "v1.x86ret";

		/// <summary>
		/// MS CLR 1.0 version string (.NET Framework 1.0). This is an incorrect version that shouldn't be used.
		/// </summary>
		public const string MS_CLR_10_RETAIL = "retail";

		/// <summary>
		/// MS CLR 1.0 version string (.NET Framework 1.0). This is an incorrect version that shouldn't be used.
		/// </summary>
		public const string MS_CLR_10_COMPLUS = "COMPLUS";

		/// <summary>
		/// MS CLR 1.1 version string (.NET Framework 1.1)
		/// </summary>
		public const string MS_CLR_11 = "v1.1.4322";

		/// <summary>
		/// MS CLR 2.0 version string (.NET Framework 2.0-3.5)
		/// </summary>
		public const string MS_CLR_20 = "v2.0.50727";

		/// <summary>
		/// MS CLR 4.0 version string (.NET Framework 4.0-4.5)
		/// </summary>
		public const string MS_CLR_40 = "v4.0.30319";

		/// <summary>
		/// MS CLR 1.0 any version
		/// </summary>
		public const string MS_CLR_10_PREFIX = "v1.0";

		/// <summary>
		/// MS CLR 1.0 any version
		/// </summary>
		public const string MS_CLR_10_PREFIX_X86RETAIL = "v1.x86";

		/// <summary>
		/// MS CLR 1.1 any version
		/// </summary>
		public const string MS_CLR_11_PREFIX = "v1.1";

		/// <summary>
		/// MS CLR 2.0 any version
		/// </summary>
		public const string MS_CLR_20_PREFIX = "v2.0";

		/// <summary>
		/// MS CLR 4.0 any version
		/// </summary>
		public const string MS_CLR_40_PREFIX = "v4.0";

		/// <summary>
		/// ECMA 2002 version string
		/// </summary>
		public const string ECMA_2002 = "Standard CLI 2002";

		/// <summary>
		/// ECMA 2005 version string
		/// </summary>
		public const string ECMA_2005 = "Standard CLI 2005";

		/// <summary>
		/// Portable PDB v1.0
		/// </summary>
		public const string PORTABLE_PDB_V1_0 = "PDB v1.0";
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// MDStream flags
	/// </summary>
	[Flags]
	public enum MDStreamFlags : byte {
		/// <summary>#Strings stream is big and requires 4 byte offsets</summary>
		BigStrings = 1,
		/// <summary>#GUID stream is big and requires 4 byte offsets</summary>
		BigGUID = 2,
		/// <summary>#Blob stream is big and requires 4 byte offsets</summary>
		BigBlob = 4,
		/// <summary/>
		Padding = 8,
		/// <summary/>
		DeltaOnly = 0x20,
		/// <summary>Extra data follows the row counts</summary>
		ExtraData = 0x40,
		/// <summary>Set if certain tables can contain deleted rows. The name column (if present) is set to "_Deleted"</summary>
		HasDelete = 0x80,
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// A MD table (eg. Method table)
	/// </summary>
	[DebuggerDisplay("DL:{dataReader.Length} R:{numRows} RS:{tableInfo.RowSize} C:{Count} {tableInfo.Name}")]
	public sealed class MDTable : IDisposable, IFileSection {
		readonly Table table;
		uint numRows;
		TableInfo tableInfo;
		DataReader dataReader;

		// Fix for VS2015 expression evaluator: "The debugger is unable to evaluate this expression"
		int Count => tableInfo.Columns.Length;

		/// <inheritdoc/>
		public FileOffset StartOffset => (FileOffset)dataReader.StartOffset;

		/// <inheritdoc/>
		public FileOffset EndOffset => (FileOffset)dataReader.EndOffset;

		/// <summary>
		/// Gets the table
		/// </summary>
		public Table Table => table;

		/// <summary>
		/// Gets the name of this table
		/// </summary>
		public string Name => tableInfo.Name;

		/// <summary>
		/// Returns total number of rows
		/// </summary>
		public uint Rows => numRows;

		/// <summary>
		/// Gets the total size in bytes of one row in this table
		/// </summary>
		public uint RowSize => (uint)tableInfo.RowSize;

		/// <summary>
		/// Returns all the columns
		/// </summary>
		public IList<ColumnInfo> Columns => tableInfo.Columns;

		/// <summary>
		/// Returns <c>true</c> if there are no valid rows
		/// </summary>
		public bool IsEmpty => numRows == 0;

		/// <summary>
		/// Returns info about this table
		/// </summary>
		public TableInfo TableInfo => tableInfo;

		internal DataReader DataReader {
			get => dataReader;
			set => dataReader = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">The table</param>
		/// <param name="numRows">Number of rows in this table</param>
		/// <param name="tableInfo">Info about this table</param>
		internal MDTable(Table table, uint numRows, TableInfo tableInfo) {
			this.table = table;
			this.numRows = numRows;
			this.tableInfo = tableInfo;

			var columns = tableInfo.Columns;
			int length = columns.Length;
			if (length > 0) Column0 = columns[0];
			if (length > 1) Column1 = columns[1];
			if (length > 2) Column2 = columns[2];
			if (length > 3) Column3 = columns[3];
			if (length > 4) Column4 = columns[4];
			if (length > 5) Column5 = columns[5];
			if (length > 6) Column6 = columns[6];
			if (length > 7) Column7 = columns[7];
			if (length > 8) Column8 = columns[8];
		}

		// So we don't have to call IList<T> indexer
		internal readonly ColumnInfo Column0;
		internal readonly ColumnInfo Column1;
		internal readonly ColumnInfo Column2;
		internal readonly ColumnInfo Column3;
		internal readonly ColumnInfo Column4;
		internal readonly ColumnInfo Column5;
		internal readonly ColumnInfo Column6;
		internal readonly ColumnInfo Column7;
		internal readonly ColumnInfo Column8;

		/// <summary>
		/// Checks whether the row <paramref name="rid"/> exists
		/// </summary>
		/// <param name="rid">Row ID</param>
		public bool IsValidRID(uint rid) => rid != 0 && rid <= numRows;

		/// <summary>
		/// Checks whether the row <paramref name="rid"/> does not exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		public bool IsInvalidRID(uint rid) => rid == 0 || rid > numRows;

		/// <inheritdoc/>
		public void Dispose() {
			numRows = 0;
			tableInfo = null;
			dataReader = default;
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Reads .NET metadata
	/// </summary>
	public abstract class Metadata : IDisposable {
		/// <summary>
		/// <c>true</c> if the compressed (normal) metadata is used, <c>false</c> if the non-compressed
		/// (Edit N' Continue) metadata is used. This can be <c>false</c> even if the table stream
		/// is <c>#~</c> but that's very uncommon.
		/// </summary>
		public abstract bool IsCompressed { get; }

		/// <summary>
		/// <c>true</c> if this is standalone Portable PDB metadata
		/// </summary>
		public abstract bool IsStandalonePortablePdb { get; }

		/// <summary>
		/// Gets the .NET header
		/// </summary>
		public abstract ImageCor20Header ImageCor20Header { get; }

		/// <summary>
		/// Gets the version found in the metadata header. The major version number is in the high 16 bits
		/// and the lower version number is in the low 16 bits.
		/// </summary>
		public abstract uint Version { get; }

		/// <summary>
		/// Gets the version string found in the metadata header
		/// </summary>
		public abstract string VersionString { get; }

		/// <summary>
		/// Gets the <see cref="IPEImage"/>
		/// </summary>
		public abstract IPEImage PEImage { get; }

		/// <summary>
		/// Gets the metadata header
		/// </summary>
		public abstract MetadataHeader MetadataHeader { get; }

		/// <summary>
		/// Returns the #Strings stream or a default empty one if it's not present
		/// </summary>
		public abstract StringsStream StringsStream { get; }

		/// <summary>
		/// Returns the #US stream or a default empty one if it's not present
		/// </summary>
		public abstract USStream USStream { get; }

		/// <summary>
		/// Returns the #Blob stream or a default empty one if it's not present
		/// </summary>
		public abstract BlobStream BlobStream { get; }

		/// <summary>
		/// Returns the #GUID stream or a default empty one if it's not present
		/// </summary>
		public abstract GuidStream GuidStream { get; }

		/// <summary>
		/// Returns the #~ or #- tables stream
		/// </summary>
		public abstract TablesStream TablesStream { get; }

		/// <summary>
		/// Returns the #Pdb stream or null if it's not a standalone portable PDB file
		/// </summary>
		public abstract PdbStream PdbStream { get; }

		/// <summary>
		/// Gets all streams
		/// </summary>
		public abstract IList<DotNetStream> AllStreams { get; }

		/// <summary>
		/// Gets a list of all the valid <c>TypeDef</c> rids. It's usually every rid in the
		/// <c>TypeDef</c> table, but could be less if a type has been deleted.
		/// </summary>
		public abstract RidList GetTypeDefRidList();

		/// <summary>
		/// Gets a list of all the valid <c>ExportedType</c> rids. It's usually every rid in the
		/// <c>ExportedType</c> table, but could be less if a type has been deleted.
		/// </summary>
		public abstract RidList GetExportedTypeRidList();

		/// <summary>
		/// Gets the <c>Field</c> rid list
		/// </summary>
		/// <param name="typeDefRid"><c>TypeDef</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		public abstract RidList GetFieldRidList(uint typeDefRid);

		/// <summary>
		/// Gets the <c>Method</c> rid list
		/// </summary>
		/// <param name="typeDefRid"><c>TypeDef</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		public abstract RidList GetMethodRidList(uint typeDefRid);

		/// <summary>
		/// Gets the <c>Param</c> rid list
		/// </summary>
		/// <param name="methodRid"><c>Method</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		public abstract RidList GetParamRidList(uint methodRid);

		/// <summary>
		/// Gets the <c>Event</c> rid list
		/// </summary>
		/// <param name="eventMapRid"><c>EventMap</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		public abstract RidList GetEventRidList(uint eventMapRid);

		/// <summary>
		/// Gets the <c>Property</c> rid list
		/// </summary>
		/// <param name="propertyMapRid"><c>PropertyMap</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		public abstract RidList GetPropertyRidList(uint propertyMapRid);

		/// <summary>
		/// Finds all <c>InterfaceImpl</c> rids owned by <paramref name="typeDefRid"/>
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>InterfaceImpl</c> rids</returns>
		public abstract RidList GetInterfaceImplRidList(uint typeDefRid);

		/// <summary>
		/// Finds all <c>GenericParam</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>TypeOrMethodDef</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>GenericParam</c> rids</returns>
		public abstract RidList GetGenericParamRidList(Table table, uint rid);

		/// <summary>
		/// Finds all <c>GenericParamConstraint</c> rids owned by <paramref name="genericParamRid"/>
		/// </summary>
		/// <param name="genericParamRid">Owner <c>GenericParam</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>GenericParamConstraint</c> rids</returns>
		public abstract RidList GetGenericParamConstraintRidList(uint genericParamRid);

		/// <summary>
		/// Finds all <c>CustomAttribute</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>HasCustomAttribute</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>CustomAttribute</c> rids</returns>
		public abstract RidList GetCustomAttributeRidList(Table table, uint rid);

		/// <summary>
		/// Finds all <c>DeclSecurity</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>HasDeclSecurity</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>DeclSecurity</c> rids</returns>
		public abstract RidList GetDeclSecurityRidList(Table table, uint rid);

		/// <summary>
		/// Finds all <c>MethodSemantics</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>HasSemantic</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>MethodSemantics</c> rids</returns>
		public abstract RidList GetMethodSemanticsRidList(Table table, uint rid);

		/// <summary>
		/// Finds all <c>MethodImpl</c> rids owned by <paramref name="typeDefRid"/>
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>MethodImpl</c> rids</returns>
		public abstract RidList GetMethodImplRidList(uint typeDefRid);

		/// <summary>
		/// Finds a <c>ClassLayout</c> rid
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>The <c>ClassLayout</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
		/// or if it has no row in the <c>ClassLayout</c> table.</returns>
		public abstract uint GetClassLayoutRid(uint typeDefRid);

		/// <summary>
		/// Finds a <c>FieldLayout</c> rid
		/// </summary>
		/// <param name="fieldRid">Owner <c>Field</c> rid</param>
		/// <returns>The <c>FieldLayout</c> rid or 0 if <paramref name="fieldRid"/> is invalid
		/// or if it has no row in the <c>FieldLayout</c> table.</returns>
		public abstract uint GetFieldLayoutRid(uint fieldRid);

		/// <summary>
		/// Finds a <c>FieldMarshal</c> rid
		/// </summary>
		/// <param name="table">A <c>HasFieldMarshal</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>The <c>FieldMarshal</c> rid or 0 if <paramref name="rid"/> is invalid
		/// or if it has no row in the <c>FieldMarshal</c> table.</returns>
		public abstract uint GetFieldMarshalRid(Table table, uint rid);

		/// <summary>
		/// Finds a <c>FieldRVA</c> rid
		/// </summary>
		/// <param name="fieldRid">Owner <c>Field</c> rid</param>
		/// <returns>The <c>FieldRVA</c> rid or 0 if <paramref name="fieldRid"/> is invalid
		/// or if it has no row in the <c>FieldRVA</c> table.</returns>
		public abstract uint GetFieldRVARid(uint fieldRid);

		/// <summary>
		/// Finds an <c>ImplMap</c> rid
		/// </summary>
		/// <param name="table">A <c>MemberForwarded</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>The <c>ImplMap</c> rid or 0 if <paramref name="rid"/> is invalid
		/// or if it has no row in the <c>ImplMap</c> table.</returns>
		public abstract uint GetImplMapRid(Table table, uint rid);

		/// <summary>
		/// Finds a <c>NestedClass</c> rid
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>The <c>NestedClass</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
		/// or if it has no row in the <c>NestedClass</c> table.</returns>
		public abstract uint GetNestedClassRid(uint typeDefRid);

		/// <summary>
		/// Finds an <c>EventMap</c> rid
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>The <c>EventMap</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
		/// or if it has no row in the <c>EventMap</c> table.</returns>
		public abstract uint GetEventMapRid(uint typeDefRid);

		/// <summary>
		/// Finds a <c>PropertyMap</c> rid
		/// </summary>
		/// <param name="typeDefRid">Owner <c>TypeDef</c> rid</param>
		/// <returns>The <c>PropertyMap</c> rid or 0 if <paramref name="typeDefRid"/> is invalid
		/// or if it has no row in the <c>PropertyMap</c> table.</returns>
		public abstract uint GetPropertyMapRid(uint typeDefRid);

		/// <summary>
		/// Finds a <c>Constant</c> rid
		/// </summary>
		/// <param name="table">A <c>HasConstant</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>The <c>Constant</c> rid or 0 if <paramref name="rid"/> is invalid
		/// or if it has no row in the <c>Constant</c> table.</returns>
		public abstract uint GetConstantRid(Table table, uint rid);

		/// <summary>
		/// Returns the owner <c>TypeDef</c> rid
		/// </summary>
		/// <param name="fieldRid">A <c>Field</c> rid</param>
		/// <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="fieldRid"/> is invalid
		/// or if it has no owner.</returns>
		public abstract uint GetOwnerTypeOfField(uint fieldRid);

		/// <summary>
		/// Returns the owner <c>TypeDef</c> rid
		/// </summary>
		/// <param name="methodRid">A <c>Method</c> rid</param>
		/// <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="methodRid"/> is invalid
		/// or if it has no owner.</returns>
		public abstract uint GetOwnerTypeOfMethod(uint methodRid);

		/// <summary>
		/// Returns the owner <c>TypeDef</c> rid
		/// </summary>
		/// <param name="eventRid">A <c>Event</c> rid</param>
		/// <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="eventRid"/> is invalid
		/// or if it has no owner.</returns>
		public abstract uint GetOwnerTypeOfEvent(uint eventRid);

		/// <summary>
		/// Returns the owner <c>TypeDef</c> rid
		/// </summary>
		/// <param name="propertyRid">A <c>Property</c> rid</param>
		/// <returns>The owner <c>TypeDef</c> rid or 0 if <paramref name="propertyRid"/> is invalid
		/// or if it has no owner.</returns>
		public abstract uint GetOwnerTypeOfProperty(uint propertyRid);

		/// <summary>
		/// Returns the owner <c>TypeOrMethodDef</c> rid
		/// </summary>
		/// <param name="gpRid">A <c>GenericParam</c> rid</param>
		/// <returns>The owner <c>TypeOrMethodDef</c> rid or 0 if <paramref name="gpRid"/> is
		/// invalid or if it has no owner.</returns>
		public abstract uint GetOwnerOfGenericParam(uint gpRid);

		/// <summary>
		/// Returns the owner <c>GenericParam</c> rid
		/// </summary>
		/// <param name="gpcRid">A <c>GenericParamConstraint</c> rid</param>
		/// <returns>The owner <c>GenericParam</c> rid or 0 if <paramref name="gpcRid"/> is
		/// invalid or if it has no owner.</returns>
		public abstract uint GetOwnerOfGenericParamConstraint(uint gpcRid);

		/// <summary>
		/// Returns the owner <c>Method</c> rid
		/// </summary>
		/// <param name="paramRid">A <c>Param</c> rid</param>
		/// <returns>The owner <c>Method</c> rid or 0 if <paramref name="paramRid"/> is invalid
		/// or if it has no owner.</returns>
		public abstract uint GetOwnerOfParam(uint paramRid);

		/// <summary>
		/// Gets a list of all nested classes owned by <paramref name="typeDefRid"/>
		/// </summary>
		/// <param name="typeDefRid">A <c>TypeDef</c> rid</param>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		public abstract RidList GetNestedClassRidList(uint typeDefRid);

		/// <summary>
		/// Gets a list of all non-nested classes. A type is a non-nested type if
		/// <see cref="GetNestedClassRidList(uint)"/> returns an empty list.
		/// </summary>
		/// <returns>A new <see cref="RidList"/> instance</returns>
		public abstract RidList GetNonNestedClassRidList();

		/// <summary>
		/// Finds all <c>LocalScope</c> rids owned by <paramref name="methodRid"/>
		/// </summary>
		/// <param name="methodRid">Owner <c>Method</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>LocalScope</c> rids</returns>
		public abstract RidList GetLocalScopeRidList(uint methodRid);

		/// <summary>
		/// Finds all <c>LocalVariable</c> rids owned by <paramref name="localScopeRid"/>
		/// </summary>
		/// <param name="localScopeRid">Owner <c>LocalScope</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>LocalVariable</c> rids</returns>
		public abstract RidList GetLocalVariableRidList(uint localScopeRid);

		/// <summary>
		/// Finds all <c>LocalConstant</c> rids owned by <paramref name="localScopeRid"/>
		/// </summary>
		/// <param name="localScopeRid">Owner <c>LocalScope</c> rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>LocalConstant</c> rids</returns>
		public abstract RidList GetLocalConstantRidList(uint localScopeRid);

		/// <summary>
		/// Gets the <c>StateMachineMethod</c> rid or 0 if it's not a state machine method
		/// </summary>
		/// <param name="methodRid">Owner <c>Method</c> rid</param>
		/// <returns></returns>
		public abstract uint GetStateMachineMethodRid(uint methodRid);

		/// <summary>
		/// Finds all <c>CustomDebugInformation</c> rids owned by <paramref name="rid"/> in table <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <c>HasCustomDebugInformation</c> table</param>
		/// <param name="rid">Owner rid</param>
		/// <returns>A <see cref="RidList"/> instance containing the valid <c>CustomDebugInformation</c> rids</returns>
		public abstract RidList GetCustomDebugInformationRidList(Table table, uint rid);

		/// <summary>
		/// Disposes of this instance
		/// </summary>
		public abstract void Dispose();
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Common base class for #~ and #- metadata classes
	/// </summary>
	abstract class MetadataBase : Metadata {
		/// <summary>
		/// The PE image
		/// </summary>
		protected IPEImage peImage;

		/// <summary>
		/// The .NET header
		/// </summary>
		protected ImageCor20Header cor20Header;

		/// <summary>
		/// The MD header
		/// </summary>
		protected MetadataHeader mdHeader;

		/// <summary>
		/// The #Strings stream
		/// </summary>
		protected StringsStream stringsStream;

		/// <summary>
		/// The #US stream
		/// </summary>
		protected USStream usStream;

		/// <summary>
		/// The #Blob stream
		/// </summary>
		protected BlobStream blobStream;

		/// <summary>
		/// The #GUID stream
		/// </summary>
		protected GuidStream guidStream;

		/// <summary>
		/// The #~ or #- stream
		/// </summary>
		protected TablesStream tablesStream;

		/// <summary>
		/// The #Pdb stream
		/// </summary>
		protected PdbStream pdbStream;

		/// <summary>
		/// All the streams that are present in the PE image
		/// </summary>
		protected IList<DotNetStream> allStreams;

		public override bool IsStandalonePortablePdb => isStandalonePortablePdb;
		/// <summary><c>true</c> if this is standalone Portable PDB metadata</summary>
		protected readonly bool isStandalonePortablePdb;

		uint[] fieldRidToTypeDefRid;
		uint[] methodRidToTypeDefRid;
		uint[] eventRidToTypeDefRid;
		uint[] propertyRidToTypeDefRid;
		uint[] gpRidToOwnerRid;
		uint[] gpcRidToOwnerRid;
		uint[] paramRidToOwnerRid;
		Dictionary<uint, List<uint>> typeDefRidToNestedClasses;
		StrongBox<RidList> nonNestedTypes;

		DataReaderFactory mdReaderFactoryToDisposeLater;

		/// <summary>
		/// Sorts a table by key column
		/// </summary>
		protected sealed class SortedTable {
			RowInfo[] rows;

			/// <summary>
			/// Remembers <c>rid</c> and key
			/// </summary>
			[DebuggerDisplay("{rid} {key}")]
			readonly struct RowInfo : IComparable<RowInfo> {
				public readonly uint rid;
				public readonly uint key;

				/// <summary>
				/// Constructor
				/// </summary>
				/// <param name="rid">Row ID</param>
				/// <param name="key">Key</param>
				public RowInfo(uint rid, uint key) {
					this.rid = rid;
					this.key = key;
				}

				public int CompareTo(RowInfo other) {
					if (key < other.key)
						return -1;
					if (key > other.key)
						return 1;
					return rid.CompareTo(other.rid);
				}
			}

			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="mdTable">The MD table</param>
			/// <param name="keyColIndex">Index of key column</param>
			public SortedTable(MDTable mdTable, int keyColIndex) {
				InitializeKeys(mdTable, keyColIndex);
				Array.Sort(rows);
			}

			void InitializeKeys(MDTable mdTable, int keyColIndex) {
				var keyColumn = mdTable.TableInfo.Columns[keyColIndex];
				Debug.Assert(keyColumn.Size == 2 || keyColumn.Size == 4);
				rows = new RowInfo[mdTable.Rows + 1];
				if (mdTable.Rows == 0)
					return;
				var reader = mdTable.DataReader;
				reader.Position = (uint)keyColumn.Offset;
				uint increment = (uint)(mdTable.TableInfo.RowSize - keyColumn.Size);
				for (uint i = 1; i <= mdTable.Rows; i++) {
					rows[i] = new RowInfo(i, keyColumn.Unsafe_Read24(ref reader));
					if (i < mdTable.Rows)
						reader.Position += increment;
				}
			}

			/// <summary>
			/// Binary searches for a row with a certain key
			/// </summary>
			/// <param name="key">The key</param>
			/// <returns>The row or 0 if not found</returns>
			int BinarySearch(uint key) {
				int lo = 1, hi = rows.Length - 1;
				while (lo <= hi && hi != -1) {
					int curr = (lo + hi) / 2;
					uint key2 = rows[curr].key;
					if (key == key2)
						return curr;
					if (key2 > key)
						hi = curr - 1;
					else
						lo = curr + 1;
				}

				return 0;
			}

			/// <summary>
			/// Find all rids that contain <paramref name="key"/>
			/// </summary>
			/// <param name="key">The key</param>
			/// <returns>A new <see cref="RidList"/> instance</returns>
			public RidList FindAllRows(uint key) {
				int startIndex = BinarySearch(key);
				if (startIndex == 0)
					return RidList.Empty;
				int endIndex = startIndex + 1;
				for (; startIndex > 1; startIndex--) {
					if (key != rows[startIndex - 1].key)
						break;
				}
				for (; endIndex < rows.Length; endIndex++) {
					if (key != rows[endIndex].key)
						break;
				}
				var list = new List<uint>(endIndex - startIndex);
				for (int i = startIndex; i < endIndex; i++)
					list.Add(rows[i].rid);
				return RidList.Create(list);
			}
		}
		SortedTable eventMapSortedTable;
		SortedTable propertyMapSortedTable;

		public override ImageCor20Header ImageCor20Header => cor20Header;
		public override uint Version => ((uint)mdHeader.MajorVersion << 16) | mdHeader.MinorVersion;
		public override string VersionString => mdHeader.VersionString;
		public override IPEImage PEImage => peImage;
		public override MetadataHeader MetadataHeader => mdHeader;
		public override StringsStream StringsStream => stringsStream;
		public override USStream USStream => usStream;
		public override BlobStream BlobStream => blobStream;
		public override GuidStream GuidStream => guidStream;
		public override TablesStream TablesStream => tablesStream;
		public override PdbStream PdbStream => pdbStream;
		public override IList<DotNetStream> AllStreams => allStreams;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <param name="cor20Header">The .NET header</param>
		/// <param name="mdHeader">The MD header</param>
		protected MetadataBase(IPEImage peImage, ImageCor20Header cor20Header, MetadataHeader mdHeader) {
			try {
				allStreams = new List<DotNetStream>();
				this.peImage = peImage;
				this.cor20Header = cor20Header;
				this.mdHeader = mdHeader;
				isStandalonePortablePdb = false;
			}
			catch {
				if (peImage is not null)
					peImage.Dispose();
				throw;
			}
		}

		internal MetadataBase(MetadataHeader mdHeader, bool isStandalonePortablePdb) {
			allStreams = new List<DotNetStream>();
			peImage = null;
			cor20Header = null;
			this.mdHeader = mdHeader;
			this.isStandalonePortablePdb = isStandalonePortablePdb;
		}

		/// <summary>
		/// Initializes the metadata, tables, streams
		/// </summary>
		public void Initialize(DataReaderFactory mdReaderFactory) {
			mdReaderFactoryToDisposeLater = mdReaderFactory;
			uint metadataBaseOffset;
			if (peImage is not null) {
				Debug.Assert(mdReaderFactory is null);
				Debug.Assert(cor20Header is not null);
				metadataBaseOffset = (uint)peImage.ToFileOffset(cor20Header.Metadata.VirtualAddress);
				mdReaderFactory = peImage.DataReaderFactory;
			}
			else {
				Debug.Assert(mdReaderFactory is not null);
				metadataBaseOffset = 0;
			}
			InitializeInternal(mdReaderFactory, metadataBaseOffset);

			if (tablesStream is null)
				throw new BadImageFormatException("Missing MD stream");
			if (isStandalonePortablePdb && pdbStream is null)
				throw new BadImageFormatException("Missing #Pdb stream");
			InitializeNonExistentHeaps();
		}

		/// <summary>
		/// Creates empty heap objects if they're not present in the metadata
		/// </summary>
		protected void InitializeNonExistentHeaps() {
			if (stringsStream is null)
				stringsStream = new StringsStream();
			if (usStream is null)
				usStream = new USStream();
			if (blobStream is null)
				blobStream = new BlobStream();
			if (guidStream is null)
				guidStream = new GuidStream();
		}

		/// <summary>
		/// Called by <see cref="Initialize(DataReaderFactory)"/>
		/// </summary>
		protected abstract void InitializeInternal(DataReaderFactory mdReaderFactory, uint metadataBaseOffset);

		public override RidList GetTypeDefRidList() => RidList.Create(1, tablesStream.TypeDefTable.Rows);
		public override RidList GetExportedTypeRidList() => RidList.Create(1, tablesStream.ExportedTypeTable.Rows);

		/// <summary>
		/// Binary searches the table for a <c>rid</c> whose key column at index
		/// <paramref name="keyColIndex"/> is equal to <paramref name="key"/>.
		/// </summary>
		/// <param name="tableSource">Table to search</param>
		/// <param name="keyColIndex">Key column index</param>
		/// <param name="key">Key</param>
		/// <returns>The <c>rid</c> of the found row, or 0 if none found</returns>
		protected abstract uint BinarySearch(MDTable tableSource, int keyColIndex, uint key);

		/// <summary>
		/// Finds all rows owned by <paramref name="key"/> in table <paramref name="tableSource"/>
		/// whose index is <paramref name="keyColIndex"/>
		/// </summary>
		/// <param name="tableSource">Table to search</param>
		/// <param name="keyColIndex">Key column index</param>
		/// <param name="key">Key</param>
		/// <returns>A <see cref="RidList"/> instance</returns>
		protected RidList FindAllRows(MDTable tableSource, int keyColIndex, uint key) {
			uint startRid = BinarySearch(tableSource, keyColIndex, key);
			if (tableSource.IsInvalidRID(startRid))
				return RidList.Empty;
			uint endRid = startRid + 1;
			var column = tableSource.TableInfo.Columns[keyColIndex];
			for (; startRid > 1; startRid--) {
				if (!tablesStream.TryReadColumn24(tableSource, startRid - 1, column, out uint key2))
					break;	// Should never happen since startRid is valid
				if (key != key2)
					break;
			}
			for (; endRid <= tableSource.Rows; endRid++) {
				if (!tablesStream.TryReadColumn24(tableSource, endRid, column, out uint key2))
					break;	// Should never happen since endRid is valid
				if (key != key2)
					break;
			}
			return RidList.Create(startRid, endRid - startRid);
		}

		/// <summary>
		/// Finds all rows owned by <paramref name="key"/> in table <paramref name="tableSource"/>
		/// whose index is <paramref name="keyColIndex"/>. Should be called if <paramref name="tableSource"/>
		/// could be unsorted.
		/// </summary>
		/// <param name="tableSource">Table to search</param>
		/// <param name="keyColIndex">Key column index</param>
		/// <param name="key">Key</param>
		/// <returns>A <see cref="RidList"/> instance</returns>
		protected virtual RidList FindAllRowsUnsorted(MDTable tableSource, int keyColIndex, uint key) => FindAllRows(tableSource, keyColIndex, key);

		public override RidList GetInterfaceImplRidList(uint typeDefRid) => FindAllRowsUnsorted(tablesStream.InterfaceImplTable, 0, typeDefRid);

		public override RidList GetGenericParamRidList(Table table, uint rid) {
			if (!CodedToken.TypeOrMethodDef.Encode(new MDToken(table, rid), out uint codedToken))
				return RidList.Empty;
			return FindAllRowsUnsorted(tablesStream.GenericParamTable, 2, codedToken);
		}

		public override RidList GetGenericParamConstraintRidList(uint genericParamRid) =>
			FindAllRowsUnsorted(tablesStream.GenericParamConstraintTable, 0, genericParamRid);

		public override RidList GetCustomAttributeRidList(Table table, uint rid) {
			if (!CodedToken.HasCustomAttribute.Encode(new MDToken(table, rid), out uint codedToken))
				return RidList.Empty;
			return FindAllRowsUnsorted(tablesStream.CustomAttributeTable, 0, codedToken);
		}

		public override RidList GetDeclSecurityRidList(Table table, uint rid) {
			if (!CodedToken.HasDeclSecurity.Encode(new MDToken(table, rid), out uint codedToken))
				return RidList.Empty;
			return FindAllRowsUnsorted(tablesStream.DeclSecurityTable, 1, codedToken);
		}

		public override RidList GetMethodSemanticsRidList(Table table, uint rid) {
			if (!CodedToken.HasSemantic.Encode(new MDToken(table, rid), out uint codedToken))
				return RidList.Empty;
			return FindAllRowsUnsorted(tablesStream.MethodSemanticsTable, 2, codedToken);
		}

		public override RidList GetMethodImplRidList(uint typeDefRid) => FindAllRowsUnsorted(tablesStream.MethodImplTable, 0, typeDefRid);

		public override uint GetClassLayoutRid(uint typeDefRid) {
			var list = FindAllRowsUnsorted(tablesStream.ClassLayoutTable, 2, typeDefRid);
			return list.Count == 0 ? 0 : list[0];
		}

		public override uint GetFieldLayoutRid(uint fieldRid) {
			var list = FindAllRowsUnsorted(tablesStream.FieldLayoutTable, 1, fieldRid);
			return list.Count == 0 ? 0 : list[0];
		}

		public override uint GetFieldMarshalRid(Table table, uint rid) {
			if (!CodedToken.HasFieldMarshal.Encode(new MDToken(table, rid), out uint codedToken))
				return 0;
			var list = FindAllRowsUnsorted(tablesStream.FieldMarshalTable, 0, codedToken);
			return list.Count == 0 ? 0 : list[0];
		}

		public override uint GetFieldRVARid(uint fieldRid) {
			var list = FindAllRowsUnsorted(tablesStream.FieldRVATable, 1, fieldRid);
			return list.Count == 0 ? 0 : list[0];
		}

		public override uint GetImplMapRid(Table table, uint rid) {
			if (!CodedToken.MemberForwarded.Encode(new MDToken(table, rid), out uint codedToken))
				return 0;
			var list = FindAllRowsUnsorted(tablesStream.ImplMapTable, 1, codedToken);
			return list.Count == 0 ? 0 : list[0];
		}

		public override uint GetNestedClassRid(uint typeDefRid) {
			var list = FindAllRowsUnsorted(tablesStream.NestedClassTable, 0, typeDefRid);
			return list.Count == 0 ? 0 : list[0];
		}

		public override uint GetEventMapRid(uint typeDefRid) {
			// The EventMap and PropertyMap tables can only be trusted to be sorted if it's
			// an NGen image and it's the normal #- stream. The IsSorted bit must not be used
			// to check whether the tables are sorted. See coreclr: md/inc/metamodel.h / IsVerified()
			if (eventMapSortedTable is null)
				Interlocked.CompareExchange(ref eventMapSortedTable, new SortedTable(tablesStream.EventMapTable, 0), null);
			var list = eventMapSortedTable.FindAllRows(typeDefRid);
			return list.Count == 0 ? 0 : list[0];
		}

		public override uint GetPropertyMapRid(uint typeDefRid) {
			// Always unsorted, see comment in GetEventMapRid() above
			if (propertyMapSortedTable is null)
				Interlocked.CompareExchange(ref propertyMapSortedTable, new SortedTable(tablesStream.PropertyMapTable, 0), null);
			var list = propertyMapSortedTable.FindAllRows(typeDefRid);
			return list.Count == 0 ? 0 : list[0];
		}

		public override uint GetConstantRid(Table table, uint rid) {
			if (!CodedToken.HasConstant.Encode(new MDToken(table, rid), out uint codedToken))
				return 0;
			var list = FindAllRowsUnsorted(tablesStream.ConstantTable, 2, codedToken);
			return list.Count == 0 ? 0 : list[0];
		}

		public override uint GetOwnerTypeOfField(uint fieldRid) {
			if (fieldRidToTypeDefRid is null)
				InitializeInverseFieldOwnerRidList();
			uint index = fieldRid - 1;
			if (index >= fieldRidToTypeDefRid.LongLength)
				return 0;
			return fieldRidToTypeDefRid[index];
		}

		void InitializeInverseFieldOwnerRidList() {
			if (fieldRidToTypeDefRid is not null)
				return;
			var newFieldRidToTypeDefRid = new uint[tablesStream.FieldTable.Rows];
			var ownerList = GetTypeDefRidList();
			for (int i = 0; i < ownerList.Count; i++) {
				var ownerRid = ownerList[i];
				var fieldList = GetFieldRidList(ownerRid);
				for (int j = 0; j < fieldList.Count; j++) {
					uint ridIndex = fieldList[j] - 1;
					if (newFieldRidToTypeDefRid[ridIndex] != 0)
						continue;
					newFieldRidToTypeDefRid[ridIndex] = ownerRid;
				}
			}
			Interlocked.CompareExchange(ref fieldRidToTypeDefRid, newFieldRidToTypeDefRid, null);
		}

		public override uint GetOwnerTypeOfMethod(uint methodRid) {
			if (methodRidToTypeDefRid is null)
				InitializeInverseMethodOwnerRidList();
			uint index = methodRid - 1;
			if (index >= methodRidToTypeDefRid.LongLength)
				return 0;
			return methodRidToTypeDefRid[index];
		}

		void InitializeInverseMethodOwnerRidList() {
			if (methodRidToTypeDefRid is not null)
				return;
			var newMethodRidToTypeDefRid = new uint[tablesStream.MethodTable.Rows];
			var ownerList = GetTypeDefRidList();
			for (int i = 0; i < ownerList.Count; i++) {
				var ownerRid = ownerList[i];
				var methodList = GetMethodRidList(ownerRid);
				for (int j = 0; j < methodList.Count; j++) {
					uint ridIndex = methodList[j] - 1;
					if (newMethodRidToTypeDefRid[ridIndex] != 0)
						continue;
					newMethodRidToTypeDefRid[ridIndex] = ownerRid;
				}
			}
			Interlocked.CompareExchange(ref methodRidToTypeDefRid, newMethodRidToTypeDefRid, null);
		}

		public override uint GetOwnerTypeOfEvent(uint eventRid) {
			if (eventRidToTypeDefRid is null)
				InitializeInverseEventOwnerRidList();
			uint index = eventRid - 1;
			if (index >= eventRidToTypeDefRid.LongLength)
				return 0;
			return eventRidToTypeDefRid[index];
		}

		void InitializeInverseEventOwnerRidList() {
			if (eventRidToTypeDefRid is not null)
				return;
			var newEventRidToTypeDefRid = new uint[tablesStream.EventTable.Rows];
			var ownerList = GetTypeDefRidList();
			for (int i = 0; i < ownerList.Count; i++) {
				var ownerRid = ownerList[i];
				var eventList = GetEventRidList(GetEventMapRid(ownerRid));
				for (int j = 0; j < eventList.Count; j++) {
					uint ridIndex = eventList[j] - 1;
					if (newEventRidToTypeDefRid[ridIndex] != 0)
						continue;
					newEventRidToTypeDefRid[ridIndex] = ownerRid;
				}
			}
			Interlocked.CompareExchange(ref eventRidToTypeDefRid, newEventRidToTypeDefRid, null);
		}

		public override uint GetOwnerTypeOfProperty(uint propertyRid) {
			if (propertyRidToTypeDefRid is null)
				InitializeInversePropertyOwnerRidList();
			uint index = propertyRid - 1;
			if (index >= propertyRidToTypeDefRid.LongLength)
				return 0;
			return propertyRidToTypeDefRid[index];
		}

		void InitializeInversePropertyOwnerRidList() {
			if (propertyRidToTypeDefRid is not null)
				return;
			var newPropertyRidToTypeDefRid = new uint[tablesStream.PropertyTable.Rows];
			var ownerList = GetTypeDefRidList();
			for (int i = 0; i < ownerList.Count; i++) {
				var ownerRid = ownerList[i];
				var propertyList = GetPropertyRidList(GetPropertyMapRid(ownerRid));
				for (int j = 0; j < propertyList.Count; j++) {
					uint ridIndex = propertyList[j] - 1;
					if (newPropertyRidToTypeDefRid[ridIndex] != 0)
						continue;
					newPropertyRidToTypeDefRid[ridIndex] = ownerRid;
				}
			}
			Interlocked.CompareExchange(ref propertyRidToTypeDefRid, newPropertyRidToTypeDefRid, null);
		}

		public override uint GetOwnerOfGenericParam(uint gpRid) {
			// Don't use GenericParam.Owner column. If the GP table is sorted, it's
			// possible to have two blocks of GPs with the same owner. Only one of the
			// blocks is the "real" generic params for the owner. Of course, rarely
			// if ever will this occur, but could happen if some obfuscator has
			// added it.

			if (gpRidToOwnerRid is null)
				InitializeInverseGenericParamOwnerRidList();
			uint index = gpRid - 1;
			if (index >= gpRidToOwnerRid.LongLength)
				return 0;
			return gpRidToOwnerRid[index];
		}

		void InitializeInverseGenericParamOwnerRidList() {
			if (gpRidToOwnerRid is not null)
				return;
			var gpTable = tablesStream.GenericParamTable;
			var newGpRidToOwnerRid = new uint[gpTable.Rows];

			// Find all owners by reading the GenericParam.Owner column
			var ownerCol = gpTable.TableInfo.Columns[2];
			var ownersDict = new Dictionary<uint, bool>();
			for (uint rid = 1; rid <= gpTable.Rows; rid++) {
				if (!tablesStream.TryReadColumn24(gpTable, rid, ownerCol, out uint owner))
					continue;
				ownersDict[owner] = true;
			}

			// Now that we have the owners, find all the generic params they own. An obfuscated
			// module could have 2+ owners pointing to the same generic param row.
			var owners = new List<uint>(ownersDict.Keys);
			owners.Sort();
			for (int i = 0; i < owners.Count; i++) {
				if (!CodedToken.TypeOrMethodDef.Decode(owners[i], out uint ownerToken))
					continue;
				var ridList = GetGenericParamRidList(MDToken.ToTable(ownerToken), MDToken.ToRID(ownerToken));
				for (int j = 0; j < ridList.Count; j++) {
					uint ridIndex = ridList[j] - 1;
					if (newGpRidToOwnerRid[ridIndex] != 0)
						continue;
					newGpRidToOwnerRid[ridIndex] = owners[i];
				}
			}
			Interlocked.CompareExchange(ref gpRidToOwnerRid, newGpRidToOwnerRid, null);
		}

		public override uint GetOwnerOfGenericParamConstraint(uint gpcRid) {
			// Don't use GenericParamConstraint.Owner column for the same reason
			// as described in GetOwnerOfGenericParam().

			if (gpcRidToOwnerRid is null)
				InitializeInverseGenericParamConstraintOwnerRidList();
			uint index = gpcRid - 1;
			if (index >= gpcRidToOwnerRid.LongLength)
				return 0;
			return gpcRidToOwnerRid[index];
		}

		void InitializeInverseGenericParamConstraintOwnerRidList() {
			if (gpcRidToOwnerRid is not null)
				return;
			var gpcTable = tablesStream.GenericParamConstraintTable;
			var newGpcRidToOwnerRid = new uint[gpcTable.Rows];

			var ownerCol = gpcTable.TableInfo.Columns[0];
			var ownersDict = new Dictionary<uint, bool>();
			for (uint rid = 1; rid <= gpcTable.Rows; rid++) {
				if (!tablesStream.TryReadColumn24(gpcTable, rid, ownerCol, out uint owner))
					continue;
				ownersDict[owner] = true;
			}

			var owners = new List<uint>(ownersDict.Keys);
			owners.Sort();
			for (int i = 0; i < owners.Count; i++) {
				uint ownerToken = owners[i];
				var ridList = GetGenericParamConstraintRidList(ownerToken);
				for (int j = 0; j < ridList.Count; j++) {
					uint ridIndex = ridList[j] - 1;
					if (newGpcRidToOwnerRid[ridIndex] != 0)
						continue;
					newGpcRidToOwnerRid[ridIndex] = ownerToken;
				}
			}
			Interlocked.CompareExchange(ref gpcRidToOwnerRid, newGpcRidToOwnerRid, null);
		}

		public override uint GetOwnerOfParam(uint paramRid) {
			if (paramRidToOwnerRid is null)
				InitializeInverseParamOwnerRidList();
			uint index = paramRid - 1;
			if (index >= paramRidToOwnerRid.LongLength)
				return 0;
			return paramRidToOwnerRid[index];
		}

		void InitializeInverseParamOwnerRidList() {
			if (paramRidToOwnerRid is not null)
				return;

			var newParamRidToOwnerRid = new uint[tablesStream.ParamTable.Rows];
			var table = tablesStream.MethodTable;
			for (uint rid = 1; rid <= table.Rows; rid++) {
				var ridList = GetParamRidList(rid);
				for (int j = 0; j < ridList.Count; j++) {
					uint ridIndex = ridList[j] - 1;
					if (newParamRidToOwnerRid[ridIndex] != 0)
						continue;
					newParamRidToOwnerRid[ridIndex] = rid;
				}
			}
			Interlocked.CompareExchange(ref paramRidToOwnerRid, newParamRidToOwnerRid, null);
		}

		public override RidList GetNestedClassRidList(uint typeDefRid) {
			if (typeDefRidToNestedClasses is null)
				InitializeNestedClassesDictionary();
			if (typeDefRidToNestedClasses.TryGetValue(typeDefRid, out var ridList))
				return RidList.Create(ridList);
			return RidList.Empty;
		}

		void InitializeNestedClassesDictionary() {
			var table = tablesStream.NestedClassTable;
			var destTable = tablesStream.TypeDefTable;

			Dictionary<uint, bool> validTypeDefRids = null;
			var typeDefRidList = GetTypeDefRidList();
			if ((uint)typeDefRidList.Count != destTable.Rows) {
				validTypeDefRids = new Dictionary<uint, bool>(typeDefRidList.Count);
				for (int i = 0; i < typeDefRidList.Count; i++)
					validTypeDefRids[typeDefRidList[i]] = true;
			}

			var nestedRidsDict = new Dictionary<uint, bool>((int)table.Rows);
			var nestedRids = new List<uint>((int)table.Rows);	// Need it so we add the rids in correct order
			for (uint rid = 1; rid <= table.Rows; rid++) {
				if (validTypeDefRids is not null && !validTypeDefRids.ContainsKey(rid))
					continue;
				if (!tablesStream.TryReadNestedClassRow(rid, out var row))
					continue;	// Should never happen since rid is valid
				if (!destTable.IsValidRID(row.NestedClass) || !destTable.IsValidRID(row.EnclosingClass))
					continue;
				if (nestedRidsDict.ContainsKey(row.NestedClass))
					continue;
				nestedRidsDict[row.NestedClass] = true;
				nestedRids.Add(row.NestedClass);
			}

			var newTypeDefRidToNestedClasses = new Dictionary<uint, List<uint>>();
			int count = nestedRids.Count;
			for (int i = 0; i < count; i++) {
				var nestedRid = nestedRids[i];
				if (!tablesStream.TryReadNestedClassRow(GetNestedClassRid(nestedRid), out var row))
					continue;
				if (!newTypeDefRidToNestedClasses.TryGetValue(row.EnclosingClass, out var ridList))
					newTypeDefRidToNestedClasses[row.EnclosingClass] = ridList = new List<uint>();
				ridList.Add(nestedRid);
			}

			var newNonNestedTypes = new List<uint>((int)(destTable.Rows - nestedRidsDict.Count));
			for (uint rid = 1; rid <= destTable.Rows; rid++) {
				if (validTypeDefRids is not null && !validTypeDefRids.ContainsKey(rid))
					continue;
				if (nestedRidsDict.ContainsKey(rid))
					continue;
				newNonNestedTypes.Add(rid);
			}

			Interlocked.CompareExchange(ref nonNestedTypes, new StrongBox<RidList>(RidList.Create(newNonNestedTypes)), null);

			// Initialize this one last since it's tested by the callers of this method
			Interlocked.CompareExchange(ref typeDefRidToNestedClasses, newTypeDefRidToNestedClasses, null);
		}

		public override RidList GetNonNestedClassRidList() {
			// Check typeDefRidToNestedClasses and not nonNestedTypes since
			// InitializeNestedClassesDictionary() writes to typeDefRidToNestedClasses last.
			if (typeDefRidToNestedClasses is null)
				InitializeNestedClassesDictionary();
			return nonNestedTypes.Value;
		}

		public override RidList GetLocalScopeRidList(uint methodRid) => FindAllRows(tablesStream.LocalScopeTable, 0, methodRid);

		public override uint GetStateMachineMethodRid(uint methodRid) {
			var list = FindAllRows(tablesStream.StateMachineMethodTable, 0, methodRid);
			return list.Count == 0 ? 0 : list[0];
		}

		public override RidList GetCustomDebugInformationRidList(Table table, uint rid) {
			if (!CodedToken.HasCustomDebugInformation.Encode(new MDToken(table, rid), out uint codedToken))
				return RidList.Empty;
			return FindAllRows(tablesStream.CustomDebugInformationTable, 0, codedToken);
		}

		public override void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (!disposing)
				return;
			peImage?.Dispose();
			stringsStream?.Dispose();
			usStream?.Dispose();
			blobStream?.Dispose();
			guidStream?.Dispose();
			tablesStream?.Dispose();
			var as2 = allStreams;
			if (as2 is not null) {
				foreach (var stream in as2)
					stream?.Dispose();
			}
			mdReaderFactoryToDisposeLater?.Dispose();
			peImage = null;
			cor20Header = null;
			mdHeader = null;
			stringsStream = null;
			usStream = null;
			blobStream = null;
			guidStream = null;
			tablesStream = null;
			allStreams = null;
			fieldRidToTypeDefRid = null;
			methodRidToTypeDefRid = null;
			typeDefRidToNestedClasses = null;
			mdReaderFactoryToDisposeLater = null;
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Low level access to a .NET file's metadata
	/// </summary>
	public static class MetadataFactory {
		enum MetadataType {
			Unknown,
			Compressed,	// #~ (normal)
			ENC,		// #- (edit and continue)
		}

		internal static MetadataBase Load(string fileName, CLRRuntimeReaderKind runtime) {
			IPEImage peImage = null;
			try {
				return Load(peImage = new PEImage(fileName), runtime);
			}
			catch {
				if (peImage is not null)
					peImage.Dispose();
				throw;
			}
		}

		internal static MetadataBase Load(byte[] data, CLRRuntimeReaderKind runtime) {
			IPEImage peImage = null;
			try {
				return Load(peImage = new PEImage(data), runtime);
			}
			catch {
				if (peImage is not null)
					peImage.Dispose();
				throw;
			}
		}

		internal static MetadataBase Load(IntPtr addr, CLRRuntimeReaderKind runtime) {
			IPEImage peImage = null;

			// We don't know what layout it is. Memory is more common so try that first.
			try {
				return Load(peImage = new PEImage(addr, ImageLayout.Memory, true), runtime);
			}
			catch {
				if (peImage is not null)
					peImage.Dispose();
				peImage = null;
			}

			try {
				return Load(peImage = new PEImage(addr, ImageLayout.File, true), runtime);
			}
			catch {
				if (peImage is not null)
					peImage.Dispose();
				throw;
			}
		}

		internal static MetadataBase Load(IntPtr addr, ImageLayout imageLayout, CLRRuntimeReaderKind runtime) {
			IPEImage peImage = null;
			try {
				return Load(peImage = new PEImage(addr, imageLayout, true), runtime);
			}
			catch {
				if (peImage is not null)
					peImage.Dispose();
				throw;
			}
		}

		internal static MetadataBase Load(IPEImage peImage, CLRRuntimeReaderKind runtime) => Create(peImage, runtime, true);

		/// <summary>
		/// Create a <see cref="Metadata"/> instance
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <returns>A new <see cref="Metadata"/> instance</returns>
		public static Metadata CreateMetadata(IPEImage peImage) => CreateMetadata(peImage, CLRRuntimeReaderKind.CLR);

		/// <summary>
		/// Create a <see cref="Metadata"/> instance
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <param name="runtime">Runtime reader kind</param>
		/// <returns>A new <see cref="Metadata"/> instance</returns>
		public static Metadata CreateMetadata(IPEImage peImage, CLRRuntimeReaderKind runtime) => Create(peImage, runtime, true);

		/// <summary>
		/// Create a <see cref="Metadata"/> instance
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
		/// <returns>A new <see cref="Metadata"/> instance</returns>
		public static Metadata CreateMetadata(IPEImage peImage, bool verify) => CreateMetadata(peImage, CLRRuntimeReaderKind.CLR, verify);

		/// <summary>
		/// Create a <see cref="Metadata"/> instance
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <param name="runtime">Runtime reader kind</param>
		/// <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
		/// <returns>A new <see cref="Metadata"/> instance</returns>
		public static Metadata CreateMetadata(IPEImage peImage, CLRRuntimeReaderKind runtime, bool verify) => Create(peImage, runtime, verify);

		/// <summary>
		/// Create a <see cref="MetadataBase"/> instance
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <param name="runtime">Runtime reader kind</param>
		/// <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
		/// <returns>A new <see cref="MetadataBase"/> instance</returns>
		static MetadataBase Create(IPEImage peImage, CLRRuntimeReaderKind runtime, bool verify) {
			MetadataBase md = null;
			try {
				var dotNetDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[14];
				// Mono doesn't check that the Size field is >= 0x48
				if (dotNetDir.VirtualAddress == 0)
					throw new BadImageFormatException(".NET data directory RVA is 0");
				var cor20HeaderReader = peImage.CreateReader(dotNetDir.VirtualAddress, 0x48);
				var cor20Header = new ImageCor20Header(ref cor20HeaderReader, verify && runtime == CLRRuntimeReaderKind.CLR);
				if (cor20Header.Metadata.VirtualAddress == 0)
					throw new BadImageFormatException(".NET metadata RVA is 0");
				var mdRva = cor20Header.Metadata.VirtualAddress;
				// Don't use the size field, Mono ignores it. Create a reader that can read to EOF.
				var mdHeaderReader = peImage.CreateReader(mdRva);
				var mdHeader = new MetadataHeader(ref mdHeaderReader, runtime, verify);
				if (verify) {
					foreach (var sh in mdHeader.StreamHeaders) {
						if ((ulong)sh.Offset + sh.StreamSize > mdHeaderReader.EndOffset)
							throw new BadImageFormatException("Invalid stream header");
					}
				}

				md = GetMetadataType(mdHeader.StreamHeaders, runtime) switch {
					MetadataType.Compressed => new CompressedMetadata(peImage, cor20Header, mdHeader, runtime),
					MetadataType.ENC => new ENCMetadata(peImage, cor20Header, mdHeader, runtime),
					_ => throw new BadImageFormatException("No #~ or #- stream found"),
				};
				md.Initialize(null);

				return md;
			}
			catch {
				if (md is not null)
					md.Dispose();
				throw;
			}
		}

		/// <summary>
		/// Create a standalone portable PDB <see cref="MetadataBase"/> instance
		/// </summary>
		/// <param name="mdReaderFactory">Metadata stream</param>
		/// <param name="verify"><c>true</c> if we should verify that it's a .NET PE file</param>
		/// <returns>A new <see cref="MetadataBase"/> instance</returns>
		internal static MetadataBase CreateStandalonePortablePDB(DataReaderFactory mdReaderFactory, bool verify) {
			const CLRRuntimeReaderKind runtime = CLRRuntimeReaderKind.CLR;
			MetadataBase md = null;
			try {
				var reader = mdReaderFactory.CreateReader();
				var mdHeader = new MetadataHeader(ref reader, runtime, verify);
				if (verify) {
					foreach (var sh in mdHeader.StreamHeaders) {
						if (sh.Offset + sh.StreamSize < sh.Offset || sh.Offset + sh.StreamSize > reader.Length)
							throw new BadImageFormatException("Invalid stream header");
					}
				}

				md = GetMetadataType(mdHeader.StreamHeaders, runtime) switch {
					MetadataType.Compressed => new CompressedMetadata(mdHeader, true, runtime),
					MetadataType.ENC => new ENCMetadata(mdHeader, true, runtime),
					_ => throw new BadImageFormatException("No #~ or #- stream found"),
				};
				md.Initialize(mdReaderFactory);

				return md;
			}
			catch {
				md?.Dispose();
				throw;
			}
		}

		static MetadataType GetMetadataType(IList<StreamHeader> streamHeaders, CLRRuntimeReaderKind runtime) {
			MetadataType? mdType = null;
			if (runtime == CLRRuntimeReaderKind.CLR) {
				foreach (var sh in streamHeaders) {
					if (mdType is null) {
						if (sh.Name == "#~")
							mdType = MetadataType.Compressed;
						else if (sh.Name == "#-")
							mdType = MetadataType.ENC;
					}
					if (sh.Name == "#Schema")
						mdType = MetadataType.ENC;
				}
			}
			else if (runtime == CLRRuntimeReaderKind.Mono) {
				foreach (var sh in streamHeaders) {
					if (sh.Name == "#~")
						mdType = MetadataType.Compressed;
					else if (sh.Name == "#-") {
						mdType = MetadataType.ENC;
						break;
					}
				}
			}
			else
				throw new ArgumentOutOfRangeException(nameof(runtime));
			if (mdType is null)
				return MetadataType.Unknown;
			return mdType.Value;
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the .NET metadata header
	/// </summary>
	/// <remarks><c>IMAGE_COR20_HEADER.Metadata</c> points to this header</remarks>
	public sealed class MetadataHeader : FileSection {
		readonly uint signature;
		readonly ushort majorVersion;
		readonly ushort minorVersion;
		readonly uint reserved1;
		readonly uint stringLength;
		readonly string versionString;
		readonly FileOffset offset2ndPart;
		readonly StorageFlags flags;
		readonly byte reserved2;
		readonly ushort streams;
		readonly IList<StreamHeader> streamHeaders;

		/// <summary>
		/// Returns the signature (should be 0x424A5342)
		/// </summary>
		public uint Signature => signature;

		/// <summary>
		/// Returns the major version
		/// </summary>
		public ushort MajorVersion => majorVersion;

		/// <summary>
		/// Returns the minor version
		/// </summary>
		public ushort MinorVersion => minorVersion;

		/// <summary>
		/// Returns the reserved dword (pointer to extra header data)
		/// </summary>
		public uint Reserved1 => reserved1;

		/// <summary>
		/// Returns the version string length value
		/// </summary>
		public uint StringLength => stringLength;

		/// <summary>
		/// Returns the version string
		/// </summary>
		public string VersionString => versionString;

		/// <summary>
		/// Returns the offset of <c>STORAGEHEADER</c>
		/// </summary>
		public FileOffset StorageHeaderOffset => offset2ndPart;

		/// <summary>
		/// Returns the flags (reserved)
		/// </summary>
		public StorageFlags Flags => flags;

		/// <summary>
		/// Returns the reserved byte (padding)
		/// </summary>
		public byte Reserved2 => reserved2;

		/// <summary>
		/// Returns the number of streams
		/// </summary>
		public ushort Streams => streams;

		/// <summary>
		/// Returns all stream headers
		/// </summary>
		public IList<StreamHeader> StreamHeaders => streamHeaders;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public MetadataHeader(ref DataReader reader, bool verify)
			: this(ref reader, CLRRuntimeReaderKind.CLR, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="runtime">Runtime reader kind</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public MetadataHeader(ref DataReader reader, CLRRuntimeReaderKind runtime, bool verify) {
			SetStartOffset(ref reader);
			signature = reader.ReadUInt32();
			if (verify && signature != 0x424A5342)
				throw new BadImageFormatException("Invalid metadata header signature");
			majorVersion = reader.ReadUInt16();
			minorVersion = reader.ReadUInt16();
			reserved1 = reader.ReadUInt32();
			stringLength = reader.ReadUInt32();
			versionString = ReadString(ref reader, stringLength, runtime);
			offset2ndPart = (FileOffset)reader.CurrentOffset;
			flags = (StorageFlags)reader.ReadByte();
			reserved2 = reader.ReadByte();
			streams = reader.ReadUInt16();
			streamHeaders = new StreamHeader[streams];
			for (int i = 0; i < streamHeaders.Count; i++) {
				// Mono doesn't verify all of these so we can't either
				var sh = new StreamHeader(ref reader, throwOnError: false, verify, runtime, out bool failedVerification);
				if (failedVerification || (ulong)sh.Offset + sh.StreamSize > reader.EndOffset)
					sh = new StreamHeader(0, 0, "<invalid>");
				streamHeaders[i] = sh;
			}
			SetEndoffset(ref reader);
		}

		static string ReadString(ref DataReader reader, uint maxLength, CLRRuntimeReaderKind runtime) {
			ulong endOffset = (ulong)reader.CurrentOffset + maxLength;
			if (runtime == CLRRuntimeReaderKind.Mono)
				endOffset = (endOffset + 3) / 4 * 4;
			if (endOffset > reader.EndOffset)
				throw new BadImageFormatException("Invalid MD version string");
			var utf8Bytes = new byte[maxLength];
			uint i;
			for (i = 0; i < maxLength; i++) {
				byte b = reader.ReadByte();
				if (b == 0)
					break;
				utf8Bytes[i] = b;
			}
			reader.CurrentOffset = (uint)endOffset;
			return Encoding.UTF8.GetString(utf8Bytes, 0, (int)i);
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// #Pdb stream
	/// </summary>
	public sealed class PdbStream : HeapStream {
		/// <summary>
		/// Gets the PDB id
		/// </summary>
		public byte[] Id { get; private set; }

		/// <summary>
		/// Gets the entry point token or 0
		/// </summary>
		public MDToken EntryPoint { get; private set; }

		/// <summary>
		/// Gets the referenced type system tables in the PE metadata file
		/// </summary>
		public ulong ReferencedTypeSystemTables { get; private set; }

		/// <summary>
		/// Gets all type system table rows. This array has exactly 64 elements.
		/// </summary>
		public uint[] TypeSystemTableRows { get; private set; }

		/// <inheritdoc/>
		public PdbStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader)
			: base(mdReaderFactory, metadataBaseOffset, streamHeader) {
			var reader = CreateReader();
			Id = reader.ReadBytes(20);
			EntryPoint = new MDToken(reader.ReadUInt32());
			var tables = reader.ReadUInt64();
			ReferencedTypeSystemTables = tables;
			var rows = new uint[64];
			for (int i = 0; i < rows.Length; i++, tables >>= 1) {
				if (((uint)tables & 1) != 0)
					rows[i] = reader.ReadUInt32();
			}
			TypeSystemTableRows = rows;
		}
	}
}





#pragma warning disable 1591	// XML doc comments

namespace dnlib.DotNet.MD {
	/// <summary>
	/// Equality comparer for all raw rows
	/// </summary>
	public sealed class RawRowEqualityComparer : IEqualityComparer<RawModuleRow>,
		IEqualityComparer<RawTypeRefRow>, IEqualityComparer<RawTypeDefRow>,
		IEqualityComparer<RawFieldPtrRow>, IEqualityComparer<RawFieldRow>,
		IEqualityComparer<RawMethodPtrRow>, IEqualityComparer<RawMethodRow>,
		IEqualityComparer<RawParamPtrRow>, IEqualityComparer<RawParamRow>,
		IEqualityComparer<RawInterfaceImplRow>, IEqualityComparer<RawMemberRefRow>,
		IEqualityComparer<RawConstantRow>, IEqualityComparer<RawCustomAttributeRow>,
		IEqualityComparer<RawFieldMarshalRow>, IEqualityComparer<RawDeclSecurityRow>,
		IEqualityComparer<RawClassLayoutRow>, IEqualityComparer<RawFieldLayoutRow>,
		IEqualityComparer<RawStandAloneSigRow>, IEqualityComparer<RawEventMapRow>,
		IEqualityComparer<RawEventPtrRow>, IEqualityComparer<RawEventRow>,
		IEqualityComparer<RawPropertyMapRow>, IEqualityComparer<RawPropertyPtrRow>,
		IEqualityComparer<RawPropertyRow>, IEqualityComparer<RawMethodSemanticsRow>,
		IEqualityComparer<RawMethodImplRow>, IEqualityComparer<RawModuleRefRow>,
		IEqualityComparer<RawTypeSpecRow>, IEqualityComparer<RawImplMapRow>,
		IEqualityComparer<RawFieldRVARow>, IEqualityComparer<RawENCLogRow>,
		IEqualityComparer<RawENCMapRow>, IEqualityComparer<RawAssemblyRow>,
		IEqualityComparer<RawAssemblyProcessorRow>, IEqualityComparer<RawAssemblyOSRow>,
		IEqualityComparer<RawAssemblyRefRow>, IEqualityComparer<RawAssemblyRefProcessorRow>,
		IEqualityComparer<RawAssemblyRefOSRow>, IEqualityComparer<RawFileRow>,
		IEqualityComparer<RawExportedTypeRow>, IEqualityComparer<RawManifestResourceRow>,
		IEqualityComparer<RawNestedClassRow>, IEqualityComparer<RawGenericParamRow>,
		IEqualityComparer<RawMethodSpecRow>, IEqualityComparer<RawGenericParamConstraintRow>,
		IEqualityComparer<RawDocumentRow>, IEqualityComparer<RawMethodDebugInformationRow>,
		IEqualityComparer<RawLocalScopeRow>, IEqualityComparer<RawLocalVariableRow>,
		IEqualityComparer<RawLocalConstantRow>, IEqualityComparer<RawImportScopeRow>,
		IEqualityComparer<RawStateMachineMethodRow>, IEqualityComparer<RawCustomDebugInformationRow> {

		/// <summary>
		/// Default instance
		/// </summary>
		public static readonly RawRowEqualityComparer Instance = new RawRowEqualityComparer();

		static int rol(uint val, int shift) => (int)((val << shift) | (val >> (32 - shift)));

		public bool Equals(RawModuleRow x, RawModuleRow y) =>
			x.Generation == y.Generation &&
			x.Name == y.Name &&
			x.Mvid == y.Mvid &&
			x.EncId == y.EncId &&
			x.EncBaseId == y.EncBaseId;

		public int GetHashCode(RawModuleRow obj) =>
			obj.Generation +
			rol(obj.Name, 3) +
			rol(obj.Mvid, 7) +
			rol(obj.EncId, 11) +
			rol(obj.EncBaseId, 15);

		public bool Equals(RawTypeRefRow x, RawTypeRefRow y) =>
			x.ResolutionScope == y.ResolutionScope &&
			x.Name == y.Name &&
			x.Namespace == y.Namespace;

		public int GetHashCode(RawTypeRefRow obj) =>
			(int)obj.ResolutionScope +
			rol(obj.Name, 3) +
			rol(obj.Namespace, 7);

		public bool Equals(RawTypeDefRow x, RawTypeDefRow y) =>
			x.Flags == y.Flags &&
			x.Name == y.Name &&
			x.Namespace == y.Namespace &&
			x.Extends == y.Extends &&
			x.FieldList == y.FieldList &&
			x.MethodList == y.MethodList;

		public int GetHashCode(RawTypeDefRow obj) =>
			(int)obj.Flags +
			rol(obj.Name, 3) +
			rol(obj.Namespace, 7) +
			rol(obj.Extends, 11) +
			rol(obj.FieldList, 15) +
			rol(obj.MethodList, 19);

		public bool Equals(RawFieldPtrRow x, RawFieldPtrRow y) => x.Field == y.Field;

		public int GetHashCode(RawFieldPtrRow obj) => (int)obj.Field;

		public bool Equals(RawFieldRow x, RawFieldRow y) =>
			x.Flags == y.Flags &&
			x.Name == y.Name &&
			x.Signature == y.Signature;

		public int GetHashCode(RawFieldRow obj) =>
			(int)obj.Flags +
			rol(obj.Name, 3) +
			rol(obj.Signature, 7);

		public bool Equals(RawMethodPtrRow x, RawMethodPtrRow y) => x.Method == y.Method;

		public int GetHashCode(RawMethodPtrRow obj) => (int)obj.Method;

		public bool Equals(RawMethodRow x, RawMethodRow y) =>
			x.RVA == y.RVA &&
			x.ImplFlags == y.ImplFlags &&
			x.Flags == y.Flags &&
			x.Name == y.Name &&
			x.Signature == y.Signature &&
			x.ParamList == y.ParamList;

		public int GetHashCode(RawMethodRow obj) =>
			(int)obj.RVA +
			rol(obj.ImplFlags, 3) +
			rol(obj.Flags, 7) +
			rol(obj.Name, 11) +
			rol(obj.Signature, 15) +
			rol(obj.ParamList, 19);

		public bool Equals(RawParamPtrRow x, RawParamPtrRow y) => x.Param == y.Param;

		public int GetHashCode(RawParamPtrRow obj) => (int)obj.Param;

		public bool Equals(RawParamRow x, RawParamRow y) =>
			x.Flags == y.Flags &&
			x.Sequence == y.Sequence &&
			x.Name == y.Name;

		public int GetHashCode(RawParamRow obj) =>
			(int)obj.Flags +
			rol(obj.Sequence, 3) +
			rol(obj.Name, 7);

		public bool Equals(RawInterfaceImplRow x, RawInterfaceImplRow y) =>
			x.Class == y.Class &&
			x.Interface == y.Interface;

		public int GetHashCode(RawInterfaceImplRow obj) =>
			(int)obj.Class +
			rol(obj.Interface, 3);

		public bool Equals(RawMemberRefRow x, RawMemberRefRow y) =>
			x.Class == y.Class &&
			x.Name == y.Name &&
			x.Signature == y.Signature;

		public int GetHashCode(RawMemberRefRow obj) =>
			(int)obj.Class +
			rol(obj.Name, 3) +
			rol(obj.Signature, 7);

		public bool Equals(RawConstantRow x, RawConstantRow y) =>
			x.Type == y.Type &&
			x.Padding == y.Padding &&
			x.Parent == y.Parent &&
			x.Value == y.Value;

		public int GetHashCode(RawConstantRow obj) =>
			(int)obj.Type +
			rol(obj.Padding, 3) +
			rol(obj.Parent, 7) +
			rol(obj.Value, 11);

		public bool Equals(RawCustomAttributeRow x, RawCustomAttributeRow y) =>
			x.Parent == y.Parent &&
			x.Type == y.Type &&
			x.Value == y.Value;

		public int GetHashCode(RawCustomAttributeRow obj) =>
			(int)obj.Parent +
			rol(obj.Type, 3) +
			rol(obj.Value, 7);

		public bool Equals(RawFieldMarshalRow x, RawFieldMarshalRow y) =>
			x.Parent == y.Parent &&
			x.NativeType == y.NativeType;

		public int GetHashCode(RawFieldMarshalRow obj) =>
			(int)obj.Parent +
			rol(obj.NativeType, 3);

		public bool Equals(RawDeclSecurityRow x, RawDeclSecurityRow y) =>
			x.Action == y.Action &&
			x.Parent == y.Parent &&
			x.PermissionSet == y.PermissionSet;

		public int GetHashCode(RawDeclSecurityRow obj) =>
			(int)obj.Action +
			rol(obj.Parent, 3) +
			rol(obj.PermissionSet, 7);

		public bool Equals(RawClassLayoutRow x, RawClassLayoutRow y) =>
			x.PackingSize == y.PackingSize &&
			x.ClassSize == y.ClassSize &&
			x.Parent == y.Parent;

		public int GetHashCode(RawClassLayoutRow obj) =>
			(int)obj.PackingSize +
			rol(obj.ClassSize, 3) +
			rol(obj.Parent, 7);

		public bool Equals(RawFieldLayoutRow x, RawFieldLayoutRow y) =>
			x.OffSet == y.OffSet &&
			x.Field == y.Field;

		public int GetHashCode(RawFieldLayoutRow obj) =>
			(int)obj.OffSet +
			rol(obj.Field, 3);

		public bool Equals(RawStandAloneSigRow x, RawStandAloneSigRow y) => x.Signature == y.Signature;

		public int GetHashCode(RawStandAloneSigRow obj) => (int)obj.Signature;

		public bool Equals(RawEventMapRow x, RawEventMapRow y) =>
			x.Parent == y.Parent &&
			x.EventList == y.EventList;

		public int GetHashCode(RawEventMapRow obj) =>
			(int)obj.Parent +
			rol(obj.EventList, 3);

		public bool Equals(RawEventPtrRow x, RawEventPtrRow y) => x.Event == y.Event;

		public int GetHashCode(RawEventPtrRow obj) => (int)obj.Event;

		public bool Equals(RawEventRow x, RawEventRow y) =>
			x.EventFlags == y.EventFlags &&
			x.Name == y.Name &&
			x.EventType == y.EventType;

		public int GetHashCode(RawEventRow obj) =>
			(int)obj.EventFlags +
			rol(obj.Name, 3) +
			rol(obj.EventType, 7);

		public bool Equals(RawPropertyMapRow x, RawPropertyMapRow y) =>
			x.Parent == y.Parent &&
			x.PropertyList == y.PropertyList;

		public int GetHashCode(RawPropertyMapRow obj) =>
			(int)obj.Parent +
			rol(obj.PropertyList, 3);

		public bool Equals(RawPropertyPtrRow x, RawPropertyPtrRow y) => x.Property == y.Property;

		public int GetHashCode(RawPropertyPtrRow obj) => (int)obj.Property;

		public bool Equals(RawPropertyRow x, RawPropertyRow y) =>
			x.PropFlags == y.PropFlags &&
			x.Name == y.Name &&
			x.Type == y.Type;

		public int GetHashCode(RawPropertyRow obj) =>
			(int)obj.PropFlags +
			rol(obj.Name, 3) +
			rol(obj.Type, 7);

		public bool Equals(RawMethodSemanticsRow x, RawMethodSemanticsRow y) =>
			x.Semantic == y.Semantic &&
			x.Method == y.Method &&
			x.Association == y.Association;

		public int GetHashCode(RawMethodSemanticsRow obj) =>
			(int)obj.Semantic +
			rol(obj.Method, 3) +
			rol(obj.Association, 7);

		public bool Equals(RawMethodImplRow x, RawMethodImplRow y) =>
			x.Class == y.Class &&
			x.MethodBody == y.MethodBody &&
			x.MethodDeclaration == y.MethodDeclaration;

		public int GetHashCode(RawMethodImplRow obj) =>
			(int)obj.Class +
			rol(obj.MethodBody, 3) +
			rol(obj.MethodDeclaration, 7);

		public bool Equals(RawModuleRefRow x, RawModuleRefRow y) => x.Name == y.Name;

		public int GetHashCode(RawModuleRefRow obj) => (int)obj.Name;

		public bool Equals(RawTypeSpecRow x, RawTypeSpecRow y) => x.Signature == y.Signature;

		public int GetHashCode(RawTypeSpecRow obj) => (int)obj.Signature;

		public bool Equals(RawImplMapRow x, RawImplMapRow y) =>
			x.MappingFlags == y.MappingFlags &&
			x.MemberForwarded == y.MemberForwarded &&
			x.ImportName == y.ImportName &&
			x.ImportScope == y.ImportScope;

		public int GetHashCode(RawImplMapRow obj) =>
			(int)obj.MappingFlags +
			rol(obj.MemberForwarded, 3) +
			rol(obj.ImportName, 7) +
			rol(obj.ImportScope, 11);

		public bool Equals(RawFieldRVARow x, RawFieldRVARow y) =>
			x.RVA == y.RVA &&
			x.Field == y.Field;

		public int GetHashCode(RawFieldRVARow obj) =>
			(int)obj.RVA +
			rol(obj.Field, 3);

		public bool Equals(RawENCLogRow x, RawENCLogRow y) =>
			x.Token == y.Token &&
			x.FuncCode == y.FuncCode;

		public int GetHashCode(RawENCLogRow obj) =>
			(int)obj.Token +
			rol(obj.FuncCode, 3);

		public bool Equals(RawENCMapRow x, RawENCMapRow y) => x.Token == y.Token;

		public int GetHashCode(RawENCMapRow obj) => (int)obj.Token;

		public bool Equals(RawAssemblyRow x, RawAssemblyRow y) =>
			x.HashAlgId == y.HashAlgId &&
			x.MajorVersion == y.MajorVersion &&
			x.MinorVersion == y.MinorVersion &&
			x.BuildNumber == y.BuildNumber &&
			x.RevisionNumber == y.RevisionNumber &&
			x.Flags == y.Flags &&
			x.PublicKey == y.PublicKey &&
			x.Name == y.Name &&
			x.Locale == y.Locale;

		public int GetHashCode(RawAssemblyRow obj) =>
			(int)obj.HashAlgId +
			rol(obj.MajorVersion, 3) +
			rol(obj.MinorVersion, 7) +
			rol(obj.BuildNumber, 11) +
			rol(obj.RevisionNumber, 15) +
			rol(obj.Flags, 19) +
			rol(obj.PublicKey, 23) +
			rol(obj.Name, 27) +
			rol(obj.Locale, 31);

		public bool Equals(RawAssemblyProcessorRow x, RawAssemblyProcessorRow y) => x.Processor == y.Processor;

		public int GetHashCode(RawAssemblyProcessorRow obj) => (int)obj.Processor;

		public bool Equals(RawAssemblyOSRow x, RawAssemblyOSRow y) =>
			x.OSPlatformId == y.OSPlatformId &&
			x.OSMajorVersion == y.OSMajorVersion &&
			x.OSMinorVersion == y.OSMinorVersion;

		public int GetHashCode(RawAssemblyOSRow obj) =>
			(int)obj.OSPlatformId +
			rol(obj.OSMajorVersion, 3) +
			rol(obj.OSMinorVersion, 7);

		public bool Equals(RawAssemblyRefRow x, RawAssemblyRefRow y) =>
			x.MajorVersion == y.MajorVersion &&
			x.MinorVersion == y.MinorVersion &&
			x.BuildNumber == y.BuildNumber &&
			x.RevisionNumber == y.RevisionNumber &&
			x.Flags == y.Flags &&
			x.PublicKeyOrToken == y.PublicKeyOrToken &&
			x.Name == y.Name &&
			x.Locale == y.Locale &&
			x.HashValue == y.HashValue;

		public int GetHashCode(RawAssemblyRefRow obj) =>
			(int)obj.MajorVersion +
			rol(obj.MinorVersion, 3) +
			rol(obj.BuildNumber, 7) +
			rol(obj.RevisionNumber, 11) +
			rol(obj.Flags, 15) +
			rol(obj.PublicKeyOrToken, 19) +
			rol(obj.Name, 23) +
			rol(obj.Locale, 27) +
			rol(obj.HashValue, 31);

		public bool Equals(RawAssemblyRefProcessorRow x, RawAssemblyRefProcessorRow y) =>
			x.Processor == y.Processor &&
			x.AssemblyRef == y.AssemblyRef;

		public int GetHashCode(RawAssemblyRefProcessorRow obj) =>
			(int)obj.Processor +
			rol(obj.AssemblyRef, 3);

		public bool Equals(RawAssemblyRefOSRow x, RawAssemblyRefOSRow y) =>
			x.OSPlatformId == y.OSPlatformId &&
			x.OSMajorVersion == y.OSMajorVersion &&
			x.OSMinorVersion == y.OSMinorVersion &&
			x.AssemblyRef == y.AssemblyRef;

		public int GetHashCode(RawAssemblyRefOSRow obj) =>
			(int)obj.OSPlatformId +
			rol(obj.OSMajorVersion, 3) +
			rol(obj.OSMinorVersion, 7) +
			rol(obj.AssemblyRef, 11);

		public bool Equals(RawFileRow x, RawFileRow y) =>
			x.Flags == y.Flags &&
			x.Name == y.Name &&
			x.HashValue == y.HashValue;

		public int GetHashCode(RawFileRow obj) =>
			(int)obj.Flags +
			rol(obj.Name, 3) +
			rol(obj.HashValue, 7);

		public bool Equals(RawExportedTypeRow x, RawExportedTypeRow y) =>
			x.Flags == y.Flags &&
			x.TypeDefId == y.TypeDefId &&
			x.TypeName == y.TypeName &&
			x.TypeNamespace == y.TypeNamespace &&
			x.Implementation == y.Implementation;

		public int GetHashCode(RawExportedTypeRow obj) =>
			(int)obj.Flags +
			rol(obj.TypeDefId, 3) +
			rol(obj.TypeName, 7) +
			rol(obj.TypeNamespace, 11) +
			rol(obj.Implementation, 15);

		public bool Equals(RawManifestResourceRow x, RawManifestResourceRow y) =>
			x.Offset == y.Offset &&
			x.Flags == y.Flags &&
			x.Name == y.Name &&
			x.Implementation == y.Implementation;

		public int GetHashCode(RawManifestResourceRow obj) =>
			(int)obj.Offset +
			rol(obj.Flags, 3) +
			rol(obj.Name, 7) +
			rol(obj.Implementation, 11);

		public bool Equals(RawNestedClassRow x, RawNestedClassRow y) =>
			x.NestedClass == y.NestedClass &&
			x.EnclosingClass == y.EnclosingClass;

		public int GetHashCode(RawNestedClassRow obj) =>
			(int)obj.NestedClass +
			rol(obj.EnclosingClass, 3);

		public bool Equals(RawGenericParamRow x, RawGenericParamRow y) =>
			x.Number == y.Number &&
			x.Flags == y.Flags &&
			x.Owner == y.Owner &&
			x.Name == y.Name &&
			x.Kind == y.Kind;

		public int GetHashCode(RawGenericParamRow obj) =>
			(int)obj.Number +
			rol(obj.Flags, 3) +
			rol(obj.Owner, 7) +
			rol(obj.Name, 11) +
			rol(obj.Kind, 15);

		public bool Equals(RawMethodSpecRow x, RawMethodSpecRow y) =>
			x.Method == y.Method &&
			x.Instantiation == y.Instantiation;

		public int GetHashCode(RawMethodSpecRow obj) =>
			(int)obj.Method +
			rol(obj.Instantiation, 3);

		public bool Equals(RawGenericParamConstraintRow x, RawGenericParamConstraintRow y) =>
			x.Owner == y.Owner &&
			x.Constraint == y.Constraint;

		public int GetHashCode(RawGenericParamConstraintRow obj) =>
			(int)obj.Owner +
			rol(obj.Constraint, 3);

		public bool Equals(RawDocumentRow x, RawDocumentRow y) =>
			x.Name == y.Name &&
			x.HashAlgorithm == y.HashAlgorithm &&
			x.Hash == y.Hash &&
			x.Language == y.Language;

		public int GetHashCode(RawDocumentRow obj) =>
			(int)obj.Name +
			rol(obj.HashAlgorithm, 3) +
			rol(obj.Hash, 7) +
			rol(obj.Language, 11);

		public bool Equals(RawMethodDebugInformationRow x, RawMethodDebugInformationRow y) =>
			x.Document == y.Document &&
			x.SequencePoints == y.SequencePoints;

		public int GetHashCode(RawMethodDebugInformationRow obj) =>
			(int)obj.Document +
			rol(obj.SequencePoints, 3);

		public bool Equals(RawLocalScopeRow x, RawLocalScopeRow y) =>
			x.Method == y.Method &&
			x.ImportScope == y.ImportScope &&
			x.VariableList == y.VariableList &&
			x.ConstantList == y.ConstantList &&
			x.StartOffset == y.StartOffset &&
			x.Length == y.Length;

		public int GetHashCode(RawLocalScopeRow obj) =>
			(int)obj.Method +
			rol(obj.ImportScope, 3) +
			rol(obj.VariableList, 7) +
			rol(obj.ConstantList, 11) +
			rol(obj.StartOffset, 15) +
			rol(obj.Length, 19);

		public bool Equals(RawLocalVariableRow x, RawLocalVariableRow y) =>
			x.Attributes == y.Attributes &&
			x.Index == y.Index &&
			x.Name == y.Name;

		public int GetHashCode(RawLocalVariableRow obj) =>
			obj.Attributes +
			rol(obj.Index, 3) +
			rol(obj.Name, 7);

		public bool Equals(RawLocalConstantRow x, RawLocalConstantRow y) =>
			x.Name == y.Name &&
			x.Signature == y.Signature;

		public int GetHashCode(RawLocalConstantRow obj) =>
			(int)obj.Name +
			rol(obj.Signature, 3);

		public bool Equals(RawImportScopeRow x, RawImportScopeRow y) =>
			x.Parent == y.Parent &&
			x.Imports == y.Imports;

		public int GetHashCode(RawImportScopeRow obj) =>
			(int)obj.Parent +
			rol(obj.Imports, 3);

		public bool Equals(RawStateMachineMethodRow x, RawStateMachineMethodRow y) =>
			x.MoveNextMethod == y.MoveNextMethod &&
			x.KickoffMethod == y.KickoffMethod;

		public int GetHashCode(RawStateMachineMethodRow obj) =>
			(int)obj.MoveNextMethod +
			rol(obj.KickoffMethod, 3);

		public bool Equals(RawCustomDebugInformationRow x, RawCustomDebugInformationRow y) =>
			x.Parent == y.Parent &&
			x.Kind == y.Kind &&
			x.Value == y.Value;

		public int GetHashCode(RawCustomDebugInformationRow obj) =>
			(int)obj.Parent +
			rol(obj.Kind, 3) +
			rol(obj.Value, 7);
	}
}




namespace dnlib.DotNet.MD {
#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
	/// <summary>
	/// Raw contents of an uncompressed Module table row
	/// </summary>
	public readonly struct RawModuleRow {
		public readonly ushort Generation;
		public readonly uint Name;
		public readonly uint Mvid;
		public readonly uint EncId;
		public readonly uint EncBaseId;

		public RawModuleRow(ushort Generation, uint Name, uint Mvid, uint EncId, uint EncBaseId) {
			this.Generation = Generation;
			this.Name = Name;
			this.Mvid = Mvid;
			this.EncId = EncId;
			this.EncBaseId = EncBaseId;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Generation,
				1 => Name,
				2 => Mvid,
				3 => EncId,
				4 => EncBaseId,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed TypeRef table row
	/// </summary>
	public readonly struct RawTypeRefRow {
		public readonly uint ResolutionScope;
		public readonly uint Name;
		public readonly uint Namespace;

		public RawTypeRefRow(uint ResolutionScope, uint Name, uint Namespace) {
			this.ResolutionScope = ResolutionScope;
			this.Name = Name;
			this.Namespace = Namespace;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => ResolutionScope,
				1 => Name,
				2 => Namespace,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed TypeDef table row
	/// </summary>
	public readonly struct RawTypeDefRow {
		public readonly uint Flags;
		public readonly uint Name;
		public readonly uint Namespace;
		public readonly uint Extends;
		public readonly uint FieldList;
		public readonly uint MethodList;

		public RawTypeDefRow(uint Flags, uint Name, uint Namespace, uint Extends, uint FieldList, uint MethodList) {
			this.Flags = Flags;
			this.Name = Name;
			this.Namespace = Namespace;
			this.Extends = Extends;
			this.FieldList = FieldList;
			this.MethodList = MethodList;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Flags,
				1 => Name,
				2 => Namespace,
				3 => Extends,
				4 => FieldList,
				5 => MethodList,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed FieldPtr table row
	/// </summary>
	public readonly struct RawFieldPtrRow {
		public readonly uint Field;

		public RawFieldPtrRow(uint Field) => this.Field = Field;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Field,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed Field table row
	/// </summary>
	public readonly struct RawFieldRow {
		public readonly ushort Flags;
		public readonly uint Name;
		public readonly uint Signature;

		public RawFieldRow(ushort Flags, uint Name, uint Signature) {
			this.Flags = Flags;
			this.Name = Name;
			this.Signature = Signature;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Flags,
				1 => Name,
				2 => Signature,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodPtr table row
	/// </summary>
	public readonly struct RawMethodPtrRow {
		public readonly uint Method;

		public RawMethodPtrRow(uint Method) => this.Method = Method;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Method,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed Method table row
	/// </summary>
	public readonly struct RawMethodRow {
		public readonly uint RVA;
		public readonly ushort ImplFlags;
		public readonly ushort Flags;
		public readonly uint Name;
		public readonly uint Signature;
		public readonly uint ParamList;

		public RawMethodRow(uint RVA, ushort ImplFlags, ushort Flags, uint Name, uint Signature, uint ParamList) {
			this.RVA = RVA;
			this.ImplFlags = ImplFlags;
			this.Flags = Flags;
			this.Name = Name;
			this.Signature = Signature;
			this.ParamList = ParamList;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => RVA,
				1 => ImplFlags,
				2 => Flags,
				3 => Name,
				4 => Signature,
				5 => ParamList,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed ParamPtr table row
	/// </summary>
	public readonly struct RawParamPtrRow {
		public readonly uint Param;

		public RawParamPtrRow(uint Param) => this.Param = Param;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Param,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed Param table row
	/// </summary>
	public readonly struct RawParamRow {
		public readonly ushort Flags;
		public readonly ushort Sequence;
		public readonly uint Name;

		public RawParamRow(ushort Flags, ushort Sequence, uint Name) {
			this.Flags = Flags;
			this.Sequence = Sequence;
			this.Name = Name;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Flags,
				1 => Sequence,
				2 => Name,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed InterfaceImpl table row
	/// </summary>
	public readonly struct RawInterfaceImplRow {
		public readonly uint Class;
		public readonly uint Interface;

		public RawInterfaceImplRow(uint Class, uint Interface) {
			this.Class = Class;
			this.Interface = Interface;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Class,
				1 => Interface,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed MemberRef table row
	/// </summary>
	public readonly struct RawMemberRefRow {
		public readonly uint Class;
		public readonly uint Name;
		public readonly uint Signature;

		public RawMemberRefRow(uint Class, uint Name, uint Signature) {
			this.Class = Class;
			this.Name = Name;
			this.Signature = Signature;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Class,
				1 => Name,
				2 => Signature,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed Constant table row
	/// </summary>
	public readonly struct RawConstantRow {
		public readonly byte Type;
		public readonly byte Padding;
		public readonly uint Parent;
		public readonly uint Value;

		public RawConstantRow(byte Type, byte Padding, uint Parent, uint Value) {
			this.Type = Type;
			this.Padding = Padding;
			this.Parent = Parent;
			this.Value = Value;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Type,
				1 => Padding,
				2 => Parent,
				3 => Value,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed CustomAttribute table row
	/// </summary>
	public readonly struct RawCustomAttributeRow {
		public readonly uint Parent;
		public readonly uint Type;
		public readonly uint Value;

		public RawCustomAttributeRow(uint Parent, uint Type, uint Value) {
			this.Parent = Parent;
			this.Type = Type;
			this.Value = Value;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Parent,
				1 => Type,
				2 => Value,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed FieldMarshal table row
	/// </summary>
	public readonly struct RawFieldMarshalRow {
		public readonly uint Parent;
		public readonly uint NativeType;

		public RawFieldMarshalRow(uint Parent, uint NativeType) {
			this.Parent = Parent;
			this.NativeType = NativeType;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Parent,
				1 => NativeType,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed DeclSecurity table row
	/// </summary>
	public readonly struct RawDeclSecurityRow {
		public readonly short Action;
		public readonly uint Parent;
		public readonly uint PermissionSet;

		public RawDeclSecurityRow(short Action, uint Parent, uint PermissionSet) {
			this.Action = Action;
			this.Parent = Parent;
			this.PermissionSet = PermissionSet;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => (uint)(int)Action,
				1 => Parent,
				2 => PermissionSet,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed ClassLayout table row
	/// </summary>
	public readonly struct RawClassLayoutRow {
		public readonly ushort PackingSize;
		public readonly uint ClassSize;
		public readonly uint Parent;

		public RawClassLayoutRow(ushort PackingSize, uint ClassSize, uint Parent) {
			this.PackingSize = PackingSize;
			this.ClassSize = ClassSize;
			this.Parent = Parent;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => PackingSize,
				1 => ClassSize,
				2 => Parent,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed FieldLayout table row
	/// </summary>
	public readonly struct RawFieldLayoutRow {
		public readonly uint OffSet;
		public readonly uint Field;

		public RawFieldLayoutRow(uint OffSet, uint Field) {
			this.OffSet = OffSet;
			this.Field = Field;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => OffSet,
				1 => Field,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed StandAloneSig table row
	/// </summary>
	public readonly struct RawStandAloneSigRow {
		public readonly uint Signature;

		public RawStandAloneSigRow(uint Signature) => this.Signature = Signature;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Signature,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed EventMap table row
	/// </summary>
	public readonly struct RawEventMapRow {
		public readonly uint Parent;
		public readonly uint EventList;

		public RawEventMapRow(uint Parent, uint EventList) {
			this.Parent = Parent;
			this.EventList = EventList;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Parent,
				1 => EventList,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed EventPtr table row
	/// </summary>
	public readonly struct RawEventPtrRow {
		public readonly uint Event;

		public RawEventPtrRow(uint Event) => this.Event = Event;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Event,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed Event table row
	/// </summary>
	public readonly struct RawEventRow {
		public readonly ushort EventFlags;
		public readonly uint Name;
		public readonly uint EventType;

		public RawEventRow(ushort EventFlags, uint Name, uint EventType) {
			this.EventFlags = EventFlags;
			this.Name = Name;
			this.EventType = EventType;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => EventFlags,
				1 => Name,
				2 => EventType,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed PropertyMap table row
	/// </summary>
	public readonly struct RawPropertyMapRow {
		public readonly uint Parent;
		public readonly uint PropertyList;

		public RawPropertyMapRow(uint Parent, uint PropertyList) {
			this.Parent = Parent;
			this.PropertyList = PropertyList;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Parent,
				1 => PropertyList,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed PropertyPtr table row
	/// </summary>
	public readonly struct RawPropertyPtrRow {
		public readonly uint Property;

		public RawPropertyPtrRow(uint Property) => this.Property = Property;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Property,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed Property table row
	/// </summary>
	public readonly struct RawPropertyRow {
		public readonly ushort PropFlags;
		public readonly uint Name;
		public readonly uint Type;

		public RawPropertyRow(ushort PropFlags, uint Name, uint Type) {
			this.PropFlags = PropFlags;
			this.Name = Name;
			this.Type = Type;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => PropFlags,
				1 => Name,
				2 => Type,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodSemantics table row
	/// </summary>
	public readonly struct RawMethodSemanticsRow {
		public readonly ushort Semantic;
		public readonly uint Method;
		public readonly uint Association;

		public RawMethodSemanticsRow(ushort Semantic, uint Method, uint Association) {
			this.Semantic = Semantic;
			this.Method = Method;
			this.Association = Association;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Semantic,
				1 => Method,
				2 => Association,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodImpl table row
	/// </summary>
	public readonly struct RawMethodImplRow {
		public readonly uint Class;
		public readonly uint MethodBody;
		public readonly uint MethodDeclaration;

		public RawMethodImplRow(uint Class, uint MethodBody, uint MethodDeclaration) {
			this.Class = Class;
			this.MethodBody = MethodBody;
			this.MethodDeclaration = MethodDeclaration;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Class,
				1 => MethodBody,
				2 => MethodDeclaration,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed ModuleRef table row
	/// </summary>
	public readonly struct RawModuleRefRow {
		public readonly uint Name;

		public RawModuleRefRow(uint Name) => this.Name = Name;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Name,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed TypeSpec table row
	/// </summary>
	public readonly struct RawTypeSpecRow {
		public readonly uint Signature;

		public RawTypeSpecRow(uint Signature) => this.Signature = Signature;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Signature,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed ImplMap table row
	/// </summary>
	public readonly struct RawImplMapRow {
		public readonly ushort MappingFlags;
		public readonly uint MemberForwarded;
		public readonly uint ImportName;
		public readonly uint ImportScope;

		public RawImplMapRow(ushort MappingFlags, uint MemberForwarded, uint ImportName, uint ImportScope) {
			this.MappingFlags = MappingFlags;
			this.MemberForwarded = MemberForwarded;
			this.ImportName = ImportName;
			this.ImportScope = ImportScope;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => MappingFlags,
				1 => MemberForwarded,
				2 => ImportName,
				3 => ImportScope,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed FieldRVA table row
	/// </summary>
	public readonly struct RawFieldRVARow {
		public readonly uint RVA;
		public readonly uint Field;

		public RawFieldRVARow(uint RVA, uint Field) {
			this.RVA = RVA;
			this.Field = Field;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => RVA,
				1 => Field,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed ENCLog table row
	/// </summary>
	public readonly struct RawENCLogRow {
		public readonly uint Token;
		public readonly uint FuncCode;

		public RawENCLogRow(uint Token, uint FuncCode) {
			this.Token = Token;
			this.FuncCode = FuncCode;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Token,
				1 => FuncCode,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed ENCMap table row
	/// </summary>
	public readonly struct RawENCMapRow {
		public readonly uint Token;

		public RawENCMapRow(uint Token) => this.Token = Token;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Token,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed Assembly table row
	/// </summary>
	public readonly struct RawAssemblyRow {
		public readonly uint HashAlgId;
		public readonly ushort MajorVersion;
		public readonly ushort MinorVersion;
		public readonly ushort BuildNumber;
		public readonly ushort RevisionNumber;
		public readonly uint Flags;
		public readonly uint PublicKey;
		public readonly uint Name;
		public readonly uint Locale;

		public RawAssemblyRow(uint HashAlgId, ushort MajorVersion, ushort MinorVersion, ushort BuildNumber, ushort RevisionNumber, uint Flags, uint PublicKey, uint Name, uint Locale) {
			this.HashAlgId = HashAlgId;
			this.MajorVersion = MajorVersion;
			this.MinorVersion = MinorVersion;
			this.BuildNumber = BuildNumber;
			this.RevisionNumber = RevisionNumber;
			this.Flags = Flags;
			this.PublicKey = PublicKey;
			this.Name = Name;
			this.Locale = Locale;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => HashAlgId,
				1 => MajorVersion,
				2 => MinorVersion,
				3 => BuildNumber,
				4 => RevisionNumber,
				5 => Flags,
				6 => PublicKey,
				7 => Name,
				8 => Locale,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyProcessor table row
	/// </summary>
	public readonly struct RawAssemblyProcessorRow {
		public readonly uint Processor;

		public RawAssemblyProcessorRow(uint Processor) => this.Processor = Processor;

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Processor,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyOS table row
	/// </summary>
	public readonly struct RawAssemblyOSRow {
		public readonly uint OSPlatformId;
		public readonly uint OSMajorVersion;
		public readonly uint OSMinorVersion;

		public RawAssemblyOSRow(uint OSPlatformId, uint OSMajorVersion, uint OSMinorVersion) {
			this.OSPlatformId = OSPlatformId;
			this.OSMajorVersion = OSMajorVersion;
			this.OSMinorVersion = OSMinorVersion;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => OSPlatformId,
				1 => OSMajorVersion,
				2 => OSMinorVersion,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyRef table row
	/// </summary>
	public readonly struct RawAssemblyRefRow {
		public readonly ushort MajorVersion;
		public readonly ushort MinorVersion;
		public readonly ushort BuildNumber;
		public readonly ushort RevisionNumber;
		public readonly uint Flags;
		public readonly uint PublicKeyOrToken;
		public readonly uint Name;
		public readonly uint Locale;
		public readonly uint HashValue;

		public RawAssemblyRefRow(ushort MajorVersion, ushort MinorVersion, ushort BuildNumber, ushort RevisionNumber, uint Flags, uint PublicKeyOrToken, uint Name, uint Locale, uint HashValue) {
			this.MajorVersion = MajorVersion;
			this.MinorVersion = MinorVersion;
			this.BuildNumber = BuildNumber;
			this.RevisionNumber = RevisionNumber;
			this.Flags = Flags;
			this.PublicKeyOrToken = PublicKeyOrToken;
			this.Name = Name;
			this.Locale = Locale;
			this.HashValue = HashValue;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => MajorVersion,
				1 => MinorVersion,
				2 => BuildNumber,
				3 => RevisionNumber,
				4 => Flags,
				5 => PublicKeyOrToken,
				6 => Name,
				7 => Locale,
				8 => HashValue,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyRefProcessor table row
	/// </summary>
	public readonly struct RawAssemblyRefProcessorRow {
		public readonly uint Processor;
		public readonly uint AssemblyRef;

		public RawAssemblyRefProcessorRow(uint Processor, uint AssemblyRef) {
			this.Processor = Processor;
			this.AssemblyRef = AssemblyRef;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Processor,
				1 => AssemblyRef,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed AssemblyRefOS table row
	/// </summary>
	public readonly struct RawAssemblyRefOSRow {
		public readonly uint OSPlatformId;
		public readonly uint OSMajorVersion;
		public readonly uint OSMinorVersion;
		public readonly uint AssemblyRef;

		public RawAssemblyRefOSRow(uint OSPlatformId, uint OSMajorVersion, uint OSMinorVersion, uint AssemblyRef) {
			this.OSPlatformId = OSPlatformId;
			this.OSMajorVersion = OSMajorVersion;
			this.OSMinorVersion = OSMinorVersion;
			this.AssemblyRef = AssemblyRef;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => OSPlatformId,
				1 => OSMajorVersion,
				2 => OSMinorVersion,
				3 => AssemblyRef,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed File table row
	/// </summary>
	public readonly struct RawFileRow {
		public readonly uint Flags;
		public readonly uint Name;
		public readonly uint HashValue;

		public RawFileRow(uint Flags, uint Name, uint HashValue) {
			this.Flags = Flags;
			this.Name = Name;
			this.HashValue = HashValue;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Flags,
				1 => Name,
				2 => HashValue,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed ExportedType table row
	/// </summary>
	public readonly struct RawExportedTypeRow {
		public readonly uint Flags;
		public readonly uint TypeDefId;
		public readonly uint TypeName;
		public readonly uint TypeNamespace;
		public readonly uint Implementation;

		public RawExportedTypeRow(uint Flags, uint TypeDefId, uint TypeName, uint TypeNamespace, uint Implementation) {
			this.Flags = Flags;
			this.TypeDefId = TypeDefId;
			this.TypeName = TypeName;
			this.TypeNamespace = TypeNamespace;
			this.Implementation = Implementation;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Flags,
				1 => TypeDefId,
				2 => TypeName,
				3 => TypeNamespace,
				4 => Implementation,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed ManifestResource table row
	/// </summary>
	public readonly struct RawManifestResourceRow {
		public readonly uint Offset;
		public readonly uint Flags;
		public readonly uint Name;
		public readonly uint Implementation;

		public RawManifestResourceRow(uint Offset, uint Flags, uint Name, uint Implementation) {
			this.Offset = Offset;
			this.Flags = Flags;
			this.Name = Name;
			this.Implementation = Implementation;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Offset,
				1 => Flags,
				2 => Name,
				3 => Implementation,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed NestedClass table row
	/// </summary>
	public readonly struct RawNestedClassRow {
		public readonly uint NestedClass;
		public readonly uint EnclosingClass;

		public RawNestedClassRow(uint NestedClass, uint EnclosingClass) {
			this.NestedClass = NestedClass;
			this.EnclosingClass = EnclosingClass;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => NestedClass,
				1 => EnclosingClass,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed GenericParam table row
	/// </summary>
	public readonly struct RawGenericParamRow {
		public readonly ushort Number;
		public readonly ushort Flags;
		public readonly uint Owner;
		public readonly uint Name;
		public readonly uint Kind;

		public RawGenericParamRow(ushort Number, ushort Flags, uint Owner, uint Name, uint Kind) {
			this.Number = Number;
			this.Flags = Flags;
			this.Owner = Owner;
			this.Name = Name;
			this.Kind = Kind;
		}

		public RawGenericParamRow(ushort Number, ushort Flags, uint Owner, uint Name) {
			this.Number = Number;
			this.Flags = Flags;
			this.Owner = Owner;
			this.Name = Name;
			Kind = 0;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Number,
				1 => Flags,
				2 => Owner,
				3 => Name,
				4 => Kind,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodSpec table row
	/// </summary>
	public readonly struct RawMethodSpecRow {
		public readonly uint Method;
		public readonly uint Instantiation;

		public RawMethodSpecRow(uint Method, uint Instantiation) {
			this.Method = Method;
			this.Instantiation = Instantiation;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Method,
				1 => Instantiation,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed GenericParamConstraint table row
	/// </summary>
	public readonly struct RawGenericParamConstraintRow {
		public readonly uint Owner;
		public readonly uint Constraint;

		public RawGenericParamConstraintRow(uint Owner, uint Constraint) {
			this.Owner = Owner;
			this.Constraint = Constraint;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Owner,
				1 => Constraint,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed Document table row
	/// </summary>
	public readonly struct RawDocumentRow {
		public readonly uint Name;
		public readonly uint HashAlgorithm;
		public readonly uint Hash;
		public readonly uint Language;

		public RawDocumentRow(uint Name, uint HashAlgorithm, uint Hash, uint Language) {
			this.Name = Name;
			this.HashAlgorithm = HashAlgorithm;
			this.Hash = Hash;
			this.Language = Language;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Name,
				1 => HashAlgorithm,
				2 => Hash,
				3 => Language,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed MethodDebugInformation table row
	/// </summary>
	public readonly struct RawMethodDebugInformationRow {
		public readonly uint Document;
		public readonly uint SequencePoints;

		public RawMethodDebugInformationRow(uint Document, uint SequencePoints) {
			this.Document = Document;
			this.SequencePoints = SequencePoints;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Document,
				1 => SequencePoints,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed LocalScope table row
	/// </summary>
	public readonly struct RawLocalScopeRow {
		public readonly uint Method;
		public readonly uint ImportScope;
		public readonly uint VariableList;
		public readonly uint ConstantList;
		public readonly uint StartOffset;
		public readonly uint Length;

		public RawLocalScopeRow(uint Method, uint ImportScope, uint VariableList, uint ConstantList, uint StartOffset, uint Length) {
			this.Method = Method;
			this.ImportScope = ImportScope;
			this.VariableList = VariableList;
			this.ConstantList = ConstantList;
			this.StartOffset = StartOffset;
			this.Length = Length;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Method,
				1 => ImportScope,
				2 => VariableList,
				3 => ConstantList,
				4 => StartOffset,
				5 => Length,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed LocalVariable table row
	/// </summary>
	public readonly struct RawLocalVariableRow {
		public readonly ushort Attributes;
		public readonly ushort Index;
		public readonly uint Name;

		public RawLocalVariableRow(ushort Attributes, ushort Index, uint Name) {
			this.Attributes = Attributes;
			this.Index = Index;
			this.Name = Name;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Attributes,
				1 => Index,
				2 => Name,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed LocalConstant table row
	/// </summary>
	public readonly struct RawLocalConstantRow {
		public readonly uint Name;
		public readonly uint Signature;

		public RawLocalConstantRow(uint Name, uint Signature) {
			this.Name = Name;
			this.Signature = Signature;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Name,
				1 => Signature,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed ImportScope table row
	/// </summary>
	public readonly struct RawImportScopeRow {
		public readonly uint Parent;
		public readonly uint Imports;

		public RawImportScopeRow(uint Parent, uint Imports) {
			this.Parent = Parent;
			this.Imports = Imports;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Parent,
				1 => Imports,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed StateMachineMethod table row
	/// </summary>
	public readonly struct RawStateMachineMethodRow {
		public readonly uint MoveNextMethod;
		public readonly uint KickoffMethod;

		public RawStateMachineMethodRow(uint MoveNextMethod, uint KickoffMethod) {
			this.MoveNextMethod = MoveNextMethod;
			this.KickoffMethod = KickoffMethod;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => MoveNextMethod,
				1 => KickoffMethod,
				_ => 0,
			};
	}

	/// <summary>
	/// Raw contents of an uncompressed CustomDebugInformation table row
	/// </summary>
	public readonly struct RawCustomDebugInformationRow {
		public readonly uint Parent;
		public readonly uint Kind;
		public readonly uint Value;

		public RawCustomDebugInformationRow(uint Parent, uint Kind, uint Value) {
			this.Parent = Parent;
			this.Kind = Kind;
			this.Value = Value;
		}

		/// <summary>
		/// Gets a column
		/// </summary>
		/// <param name="index">Index of column</param>
		/// <returns></returns>
		public uint this[int index] =>
			index switch {
				0 => Parent,
				1 => Kind,
				2 => Value,
				_ => 0,
			};
	}
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Stores a list of rids
	/// </summary>
	[DebuggerDisplay("Count = {Count}")]
	public readonly struct RidList : IEnumerable<uint> {
		readonly uint startRid;
		readonly uint length;
		readonly IList<uint> rids;

		/// <summary>
		/// Gets the empty instance
		/// </summary>
		public static readonly RidList Empty = Create(0, 0);

		/// <summary>
		/// Creates a new instance
		/// </summary>
		/// <param name="startRid"></param>
		/// <param name="length"></param>
		/// <returns></returns>
		public static RidList Create(uint startRid, uint length) => new RidList(startRid, length);

		/// <summary>
		/// Creates a new instance
		/// </summary>
		/// <param name="rids">List of valid rids</param>
		/// <returns></returns>
		public static RidList Create(IList<uint> rids) => new RidList(rids);

		RidList(uint startRid, uint length) {
			this.startRid = startRid;
			this.length = length;
			rids = null;
		}

		RidList(IList<uint> rids) {
			this.rids = rids ?? throw new ArgumentNullException(nameof(rids));
			startRid = 0;
			length = (uint)rids.Count;
		}

		/// <summary>
		/// Gets the <paramref name="index"/>'th rid
		/// </summary>
		/// <param name="index">Index. Must be &lt; <see cref="Count"/></param>
		/// <returns>A rid or 0 if <paramref name="index"/> is invalid</returns>
		public uint this[int index] {
			get {
				if (rids is not null) {
					if ((uint)index >= (uint)rids.Count)
						return 0;
					return rids[index];
				}
				else {
					if ((uint)index >= length)
						return 0;
					return startRid + (uint)index;
				}
			}
		}

		/// <summary>
		/// Gets the number of rids it will iterate over
		/// </summary>
		public int Count => (int)length;

		/// <summary>
		/// Enumerator
		/// </summary>
		public struct Enumerator : IEnumerator<uint> {
			readonly uint startRid;
			readonly uint length;
			readonly IList<uint> rids;
			uint index;
			uint current;

			internal Enumerator(in RidList list) {
				startRid = list.startRid;
				length = list.length;
				rids = list.rids;
				index = 0;
				current = 0;
			}

			/// <summary>
			/// Gets the current rid
			/// </summary>
			public uint Current => current;
			object IEnumerator.Current => current;

			/// <summary>
			/// Disposes this instance
			/// </summary>
			public void Dispose() { }

			/// <summary>
			/// Moves to the next rid
			/// </summary>
			/// <returns></returns>
			public bool MoveNext() {
				if (rids is null && index < length) {
					current = startRid + index;
					index++;
					return true;
				}
				return MoveNextOther();
			}

			bool MoveNextOther() {
				if (index >= length) {
					current = 0;
					return false;
				}
				if (rids is not null)
					current = rids[(int)index];
				else
					current = startRid + index;
				index++;
				return true;
			}

			void IEnumerator.Reset() => throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the enumerator
		/// </summary>
		/// <returns></returns>
		public Enumerator GetEnumerator() => new Enumerator(this);
		IEnumerator<uint> IEnumerable<uint>.GetEnumerator() => GetEnumerator();
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Storage flags found in the MD header
	/// </summary>
	[Flags]
	public enum StorageFlags : byte {
		/// <summary>
		/// Normal flags
		/// </summary>
		Normal = 0,

		/// <summary>
		/// More data after the header but before the streams.
		/// </summary>
		/// <remarks>The CLR will fail to load the file if this flag (or any other bits) is set.</remarks>
		ExtraData = 1,
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// A metadata stream header
	/// </summary>
	[DebuggerDisplay("O:{offset} L:{streamSize} {name}")]
	public sealed class StreamHeader : FileSection {
		readonly uint offset;
		readonly uint streamSize;
		readonly string name;

		/// <summary>
		/// The offset of the stream relative to the start of the metadata header
		/// </summary>
		public uint Offset => offset;

		/// <summary>
		/// The size of the stream
		/// </summary>
		public uint StreamSize => streamSize;

		/// <summary>
		/// The name of the stream
		/// </summary>
		public string Name => name;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public StreamHeader(ref DataReader reader, bool verify)
			: this(ref reader, verify, verify, CLRRuntimeReaderKind.CLR, out _) {
		}

		internal StreamHeader(ref DataReader reader, bool throwOnError, bool verify, CLRRuntimeReaderKind runtime, out bool failedVerification) {
			failedVerification = false;
			SetStartOffset(ref reader);
			offset = reader.ReadUInt32();
			streamSize = reader.ReadUInt32();
			name = ReadString(ref reader, 32, verify, ref failedVerification);
			SetEndoffset(ref reader);
			if (runtime == CLRRuntimeReaderKind.Mono) {
				if (offset > reader.Length)
					offset = reader.Length;
				// Mono ignores the size (eg. it can be 0 or max value) so set it to the max possible value
				streamSize = reader.Length - offset;
			}
			if (verify && offset + size < offset)
				failedVerification = true;
			if (throwOnError && failedVerification)
				throw new BadImageFormatException("Invalid stream header");
		}

		internal StreamHeader(uint offset, uint streamSize, string name) {
			this.offset = offset;
			this.streamSize = streamSize;
			this.name = name ?? throw new ArgumentNullException(nameof(name));
		}

		static string ReadString(ref DataReader reader, int maxLen, bool verify, ref bool failedVerification) {
			var origPos = reader.Position;
			var sb = new StringBuilder(maxLen);
			int i;
			for (i = 0; i < maxLen; i++) {
				byte b = reader.ReadByte();
				if (b == 0)
					break;
				sb.Append((char)b);
			}
			if (verify && i == maxLen)
				failedVerification = true;
			if (i != maxLen)
				reader.Position = origPos + (((uint)i + 1 + 3) & ~3U);
			return sb.ToString();
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the #Strings stream
	/// </summary>
	public sealed class StringsStream : HeapStream {
		/// <inheritdoc/>
		public StringsStream() {
		}

		/// <inheritdoc/>
		public StringsStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader)
			: base(mdReaderFactory, metadataBaseOffset, streamHeader) {
		}

		/// <summary>
		/// Reads a <see cref="UTF8String"/>
		/// </summary>
		/// <param name="offset">Offset of string</param>
		/// <returns>A <see cref="UTF8String"/> instance or <c>null</c> if invalid offset</returns>
		public UTF8String Read(uint offset) {
			if (offset >= StreamLength)
				return null;
			byte[] data;
			var reader = dataReader;
			reader.Position = offset;
			data = reader.TryReadBytesUntil(0);
			if (data is null)
				return null;
			return new UTF8String(data);
		}

		/// <summary>
		/// Reads a <see cref="UTF8String"/>. The empty string is returned if <paramref name="offset"/>
		/// is invalid.
		/// </summary>
		/// <param name="offset">Offset of string</param>
		/// <returns>A <see cref="UTF8String"/> instance</returns>
		public UTF8String ReadNoNull(uint offset) => Read(offset) ?? UTF8String.Empty;
	}
}




namespace dnlib.DotNet.MD {
	/// <summary>
	/// The metadata tables
	/// </summary>
	public enum Table : byte {
		/// <summary>Module table (00h)</summary>
		Module,
		/// <summary>TypeRef table (01h)</summary>
		TypeRef,
		/// <summary>TypeDef table (02h)</summary>
		TypeDef,
		/// <summary>FieldPtr table (03h)</summary>
		FieldPtr,
		/// <summary>Field table (04h)</summary>
		Field,
		/// <summary>MethodPtr table (05h)</summary>
		MethodPtr,
		/// <summary>Method table (06h)</summary>
		Method,
		/// <summary>ParamPtr table (07h)</summary>
		ParamPtr,
		/// <summary>Param table (08h)</summary>
		Param,
		/// <summary>InterfaceImpl table (09h)</summary>
		InterfaceImpl,
		/// <summary>MemberRef table (0Ah)</summary>
		MemberRef,
		/// <summary>Constant table (0Bh)</summary>
		Constant,
		/// <summary>CustomAttribute table (0Ch)</summary>
		CustomAttribute,
		/// <summary>FieldMarshal table (0Dh)</summary>
		FieldMarshal,
		/// <summary>DeclSecurity table (0Eh)</summary>
		DeclSecurity,
		/// <summary>ClassLayout table (0Fh)</summary>
		ClassLayout,
		/// <summary>FieldLayout table (10h)</summary>
		FieldLayout,
		/// <summary>StandAloneSig table (11h)</summary>
		StandAloneSig,
		/// <summary>EventMap table (12h)</summary>
		EventMap,
		/// <summary>EventPtr table (13h)</summary>
		EventPtr,
		/// <summary>Event table (14h)</summary>
		Event,
		/// <summary>PropertyMap table (15h)</summary>
		PropertyMap,
		/// <summary>PropertyPtr table (16h)</summary>
		PropertyPtr,
		/// <summary>Property table (17h)</summary>
		Property,
		/// <summary>MethodSemantics table (18h)</summary>
		MethodSemantics,
		/// <summary>MethodImpl table (19h)</summary>
		MethodImpl,
		/// <summary>ModuleRef table (1Ah)</summary>
		ModuleRef,
		/// <summary>TypeSpec table (1Bh)</summary>
		TypeSpec,
		/// <summary>ImplMap table (1Ch)</summary>
		ImplMap,
		/// <summary>FieldRVA table (1Dh)</summary>
		FieldRVA,
		/// <summary>ENCLog table (1Eh)</summary>
		ENCLog,
		/// <summary>ENCMap table (1Fh)</summary>
		ENCMap,
		/// <summary>Assembly table (20h)</summary>
		Assembly,
		/// <summary>AssemblyProcessor table (21h)</summary>
		AssemblyProcessor,
		/// <summary>AssemblyOS table (22h)</summary>
		AssemblyOS,
		/// <summary>AssemblyRef table (23h)</summary>
		AssemblyRef,
		/// <summary>AssemblyRefProcessor table (24h)</summary>
		AssemblyRefProcessor,
		/// <summary>AssemblyRefOS table (25h)</summary>
		AssemblyRefOS,
		/// <summary>File table (26h)</summary>
		File,
		/// <summary>ExportedType table (27h)</summary>
		ExportedType,
		/// <summary>ManifestResource table (28h)</summary>
		ManifestResource,
		/// <summary>NestedClass table (29h)</summary>
		NestedClass,
		/// <summary>GenericParam table (2Ah)</summary>
		GenericParam,
		/// <summary>MethodSpec table (2Bh)</summary>
		MethodSpec,
		/// <summary>GenericParamConstraint table (2Ch)</summary>
		GenericParamConstraint,

		/// <summary>(Portable PDB) Document table (30h)</summary>
		Document = 0x30,
		/// <summary>(Portable PDB) MethodDebugInformation table (31h)</summary>
		MethodDebugInformation,
		/// <summary>(Portable PDB) LocalScope table (32h)</summary>
		LocalScope,
		/// <summary>(Portable PDB) LocalVariable table (33h)</summary>
		LocalVariable,
		/// <summary>(Portable PDB) LocalConstant table (34h)</summary>
		LocalConstant,
		/// <summary>(Portable PDB) ImportScope table (35h)</summary>
		ImportScope,
		/// <summary>(Portable PDB) StateMachineMethod table (36h)</summary>
		StateMachineMethod,
		/// <summary>(Portable PDB) CustomDebugInformation table (37h)</summary>
		CustomDebugInformation,
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Info about one MD table
	/// </summary>
	[DebuggerDisplay("{rowSize} {name}")]
	public sealed class TableInfo {
		readonly Table table;
		int rowSize;
		readonly ColumnInfo[] columns;
		readonly string name;

		/// <summary>
		/// Returns the table type
		/// </summary>
		public Table Table => table;

		/// <summary>
		/// Returns the total size of a row in bytes
		/// </summary>
		public int RowSize {
			get => rowSize;
			internal set => rowSize = value;
		}

		/// <summary>
		/// Returns all the columns
		/// </summary>
		public ColumnInfo[] Columns => columns;

		/// <summary>
		/// Returns the name of the table
		/// </summary>
		public string Name => name;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">Table type</param>
		/// <param name="name">Table name</param>
		/// <param name="columns">All columns</param>
		public TableInfo(Table table, string name, ColumnInfo[] columns) {
			this.table = table;
			this.name = name;
			this.columns = columns;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">Table type</param>
		/// <param name="name">Table name</param>
		/// <param name="columns">All columns</param>
		/// <param name="rowSize">Row size</param>
		public TableInfo(Table table, string name, ColumnInfo[] columns, int rowSize) {
			this.table = table;
			this.name = name;
			this.columns = columns;
			this.rowSize = rowSize;
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// .NET metadata tables stream
	/// </summary>
	public sealed partial class TablesStream : DotNetStream {
		bool initialized;
		uint reserved1;
		byte majorVersion;
		byte minorVersion;
		MDStreamFlags flags;
		byte log2Rid;
		ulong validMask;
		ulong sortedMask;
		uint extraData;
		MDTable[] mdTables;
		uint mdTablesPos;

		IColumnReader columnReader;
		IRowReader<RawMethodRow> methodRowReader;
		readonly CLRRuntimeReaderKind runtime;

#pragma warning disable 1591	// XML doc comment
		public MDTable ModuleTable { get; private set; }
		public MDTable TypeRefTable { get; private set; }
		public MDTable TypeDefTable { get; private set; }
		public MDTable FieldPtrTable { get; private set; }
		public MDTable FieldTable { get; private set; }
		public MDTable MethodPtrTable { get; private set; }
		public MDTable MethodTable { get; private set; }
		public MDTable ParamPtrTable { get; private set; }
		public MDTable ParamTable { get; private set; }
		public MDTable InterfaceImplTable { get; private set; }
		public MDTable MemberRefTable { get; private set; }
		public MDTable ConstantTable { get; private set; }
		public MDTable CustomAttributeTable { get; private set; }
		public MDTable FieldMarshalTable { get; private set; }
		public MDTable DeclSecurityTable { get; private set; }
		public MDTable ClassLayoutTable { get; private set; }
		public MDTable FieldLayoutTable { get; private set; }
		public MDTable StandAloneSigTable { get; private set; }
		public MDTable EventMapTable { get; private set; }
		public MDTable EventPtrTable { get; private set; }
		public MDTable EventTable { get; private set; }
		public MDTable PropertyMapTable { get; private set; }
		public MDTable PropertyPtrTable { get; private set; }
		public MDTable PropertyTable { get; private set; }
		public MDTable MethodSemanticsTable { get; private set; }
		public MDTable MethodImplTable { get; private set; }
		public MDTable ModuleRefTable { get; private set; }
		public MDTable TypeSpecTable { get; private set; }
		public MDTable ImplMapTable { get; private set; }
		public MDTable FieldRVATable { get; private set; }
		public MDTable ENCLogTable { get; private set; }
		public MDTable ENCMapTable { get; private set; }
		public MDTable AssemblyTable { get; private set; }
		public MDTable AssemblyProcessorTable { get; private set; }
		public MDTable AssemblyOSTable { get; private set; }
		public MDTable AssemblyRefTable { get; private set; }
		public MDTable AssemblyRefProcessorTable { get; private set; }
		public MDTable AssemblyRefOSTable { get; private set; }
		public MDTable FileTable { get; private set; }
		public MDTable ExportedTypeTable { get; private set; }
		public MDTable ManifestResourceTable { get; private set; }
		public MDTable NestedClassTable { get; private set; }
		public MDTable GenericParamTable { get; private set; }
		public MDTable MethodSpecTable { get; private set; }
		public MDTable GenericParamConstraintTable { get; private set; }
		public MDTable DocumentTable { get; private set; }
		public MDTable MethodDebugInformationTable { get; private set; }
		public MDTable LocalScopeTable { get; private set; }
		public MDTable LocalVariableTable { get; private set; }
		public MDTable LocalConstantTable { get; private set; }
		public MDTable ImportScopeTable { get; private set; }
		public MDTable StateMachineMethodTable { get; private set; }
		public MDTable CustomDebugInformationTable { get; private set; }
#pragma warning restore

		/// <summary>
		/// Gets/sets the column reader
		/// </summary>
		public IColumnReader ColumnReader {
			get => columnReader;
			set => columnReader = value;
		}

		/// <summary>
		/// Gets/sets the <c>Method</c> table reader
		/// </summary>
		public IRowReader<RawMethodRow> MethodRowReader {
			get => methodRowReader;
			set => methodRowReader = value;
		}

		/// <summary>
		/// Gets the reserved field
		/// </summary>
		public uint Reserved1 => reserved1;

		/// <summary>
		/// Gets the version. The major version is in the upper 8 bits, and the minor version
		/// is in the lower 8 bits.
		/// </summary>
		public ushort Version => (ushort)((majorVersion << 8) | minorVersion);

		/// <summary>
		/// Gets <see cref="MDStreamFlags"/>
		/// </summary>
		public MDStreamFlags Flags => flags;

		/// <summary>
		/// Gets the reserved log2 rid field
		/// </summary>
		public byte Log2Rid => log2Rid;

		/// <summary>
		/// Gets the valid mask
		/// </summary>
		public ulong ValidMask => validMask;

		/// <summary>
		/// Gets the sorted mask
		/// </summary>
		public ulong SortedMask => sortedMask;

		/// <summary>
		/// Gets the extra data
		/// </summary>
		public uint ExtraData => extraData;

		/// <summary>
		/// Gets the MD tables
		/// </summary>
		public MDTable[] MDTables => mdTables;

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.BigStrings"/> bit
		/// </summary>
		public bool HasBigStrings => (flags & MDStreamFlags.BigStrings) != 0;

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.BigGUID"/> bit
		/// </summary>
		public bool HasBigGUID => (flags & MDStreamFlags.BigGUID) != 0;

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.BigBlob"/> bit
		/// </summary>
		public bool HasBigBlob => (flags & MDStreamFlags.BigBlob) != 0;

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.Padding"/> bit
		/// </summary>
		public bool HasPadding => runtime == CLRRuntimeReaderKind.CLR && (flags & MDStreamFlags.Padding) != 0;

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.DeltaOnly"/> bit
		/// </summary>
		public bool HasDeltaOnly => runtime == CLRRuntimeReaderKind.CLR && (flags & MDStreamFlags.DeltaOnly) != 0;

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.ExtraData"/> bit
		/// </summary>
		public bool HasExtraData => runtime == CLRRuntimeReaderKind.CLR && (flags & MDStreamFlags.ExtraData) != 0;

		/// <summary>
		/// Gets the <see cref="MDStreamFlags.HasDelete"/> bit
		/// </summary>
		public bool HasDelete => runtime == CLRRuntimeReaderKind.CLR && (flags & MDStreamFlags.HasDelete) != 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="mdReaderFactory"><see cref="DataReader"/> factory</param>
		/// <param name="metadataBaseOffset">Offset of metadata</param>
		/// <param name="streamHeader">Stream header</param>
		public TablesStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader)
			: this(mdReaderFactory, metadataBaseOffset, streamHeader, CLRRuntimeReaderKind.CLR) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="mdReaderFactory"><see cref="DataReader"/> factory</param>
		/// <param name="metadataBaseOffset">Offset of metadata</param>
		/// <param name="streamHeader">Stream header</param>
		/// <param name="runtime">Runtime kind</param>
		public TablesStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader, CLRRuntimeReaderKind runtime)
			: base(mdReaderFactory, metadataBaseOffset, streamHeader) {
			this.runtime = runtime;
		}

		/// <summary>
		/// Initializes MD tables
		/// </summary>
		/// <param name="typeSystemTableRows">Type system table rows (from #Pdb stream)</param>
		public void Initialize(uint[] typeSystemTableRows) =>
			Initialize(typeSystemTableRows, false);

		/// <summary>
		/// Initializes MD tables
		/// </summary>
		/// <param name="typeSystemTableRows">Type system table rows (from #Pdb stream)</param>
		/// <param name="forceAllBig">Force all columns to 4 bytes instead of 2 or 4 bytes</param>
		internal void Initialize(uint[] typeSystemTableRows, bool forceAllBig) {
			if (initialized)
				throw new Exception("Initialize() has already been called");
			initialized = true;

			var reader = dataReader;
			reserved1 = reader.ReadUInt32();
			majorVersion = reader.ReadByte();
			minorVersion = reader.ReadByte();
			flags = (MDStreamFlags)reader.ReadByte();
			log2Rid = reader.ReadByte();
			validMask = reader.ReadUInt64();
			sortedMask = reader.ReadUInt64();
			// Mono assumes everything is sorted
			if (runtime == CLRRuntimeReaderKind.Mono)
				sortedMask = ulong.MaxValue;

			var dnTableSizes = new DotNetTableSizes();
			byte tmpMajor = majorVersion, tmpMinor = minorVersion;
			// It ignores the version so use 2.0
			if (runtime == CLRRuntimeReaderKind.Mono) {
				tmpMajor = 2;
				tmpMinor = 0;
			}
			var tableInfos = dnTableSizes.CreateTables(tmpMajor, tmpMinor, out int maxPresentTables);
			if (typeSystemTableRows is not null)
				maxPresentTables = DotNetTableSizes.normalMaxTables;
			mdTables = new MDTable[tableInfos.Length];

			ulong valid = validMask;
			var sizes = new uint[64];
			for (int i = 0; i < 64; valid >>= 1, i++) {
				uint rows = (valid & 1) == 0 ? 0 : reader.ReadUInt32();
				// Mono ignores the high byte
				rows &= 0x00FFFFFF;
				if (i >= maxPresentTables)
					rows = 0;
				sizes[i] = rows;
				if (i < mdTables.Length)
					mdTables[i] = new MDTable((Table)i, rows, tableInfos[i]);
			}

			if (HasExtraData)
				extraData = reader.ReadUInt32();

			var debugSizes = sizes;
			if (typeSystemTableRows is not null) {
				debugSizes = new uint[sizes.Length];
				for (int i = 0; i < 64; i++) {
					if (DotNetTableSizes.IsSystemTable((Table)i))
						debugSizes[i] = typeSystemTableRows[i];
					else
						debugSizes[i] = sizes[i];
				}
			}

			dnTableSizes.InitializeSizes(HasBigStrings, HasBigGUID, HasBigBlob, sizes, debugSizes, forceAllBig);

			mdTablesPos = reader.Position;
			InitializeMdTableReaders();
			InitializeTables();
		}

		/// <inheritdoc/>
		protected override void OnReaderRecreated() => InitializeMdTableReaders();

		void InitializeMdTableReaders() {
			var reader = dataReader;
			reader.Position = mdTablesPos;
			var currentPos = reader.Position;
			foreach (var mdTable in mdTables) {
				var dataLen = (uint)mdTable.TableInfo.RowSize * mdTable.Rows;
				if (currentPos > reader.Length)
					currentPos = reader.Length;
				if ((ulong)currentPos + dataLen > reader.Length)
					dataLen = reader.Length - currentPos;
				mdTable.DataReader = reader.Slice(currentPos, dataLen);
				var newPos = currentPos + dataLen;
				if (newPos < currentPos)
					throw new BadImageFormatException("Too big MD table");
				currentPos = newPos;
			}
		}

		void InitializeTables() {
			ModuleTable = mdTables[(int)Table.Module];
			TypeRefTable = mdTables[(int)Table.TypeRef];
			TypeDefTable = mdTables[(int)Table.TypeDef];
			FieldPtrTable = mdTables[(int)Table.FieldPtr];
			FieldTable = mdTables[(int)Table.Field];
			MethodPtrTable = mdTables[(int)Table.MethodPtr];
			MethodTable = mdTables[(int)Table.Method];
			ParamPtrTable = mdTables[(int)Table.ParamPtr];
			ParamTable = mdTables[(int)Table.Param];
			InterfaceImplTable = mdTables[(int)Table.InterfaceImpl];
			MemberRefTable = mdTables[(int)Table.MemberRef];
			ConstantTable = mdTables[(int)Table.Constant];
			CustomAttributeTable = mdTables[(int)Table.CustomAttribute];
			FieldMarshalTable = mdTables[(int)Table.FieldMarshal];
			DeclSecurityTable = mdTables[(int)Table.DeclSecurity];
			ClassLayoutTable = mdTables[(int)Table.ClassLayout];
			FieldLayoutTable = mdTables[(int)Table.FieldLayout];
			StandAloneSigTable = mdTables[(int)Table.StandAloneSig];
			EventMapTable = mdTables[(int)Table.EventMap];
			EventPtrTable = mdTables[(int)Table.EventPtr];
			EventTable = mdTables[(int)Table.Event];
			PropertyMapTable = mdTables[(int)Table.PropertyMap];
			PropertyPtrTable = mdTables[(int)Table.PropertyPtr];
			PropertyTable = mdTables[(int)Table.Property];
			MethodSemanticsTable = mdTables[(int)Table.MethodSemantics];
			MethodImplTable = mdTables[(int)Table.MethodImpl];
			ModuleRefTable = mdTables[(int)Table.ModuleRef];
			TypeSpecTable = mdTables[(int)Table.TypeSpec];
			ImplMapTable = mdTables[(int)Table.ImplMap];
			FieldRVATable = mdTables[(int)Table.FieldRVA];
			ENCLogTable = mdTables[(int)Table.ENCLog];
			ENCMapTable = mdTables[(int)Table.ENCMap];
			AssemblyTable = mdTables[(int)Table.Assembly];
			AssemblyProcessorTable = mdTables[(int)Table.AssemblyProcessor];
			AssemblyOSTable = mdTables[(int)Table.AssemblyOS];
			AssemblyRefTable = mdTables[(int)Table.AssemblyRef];
			AssemblyRefProcessorTable = mdTables[(int)Table.AssemblyRefProcessor];
			AssemblyRefOSTable = mdTables[(int)Table.AssemblyRefOS];
			FileTable = mdTables[(int)Table.File];
			ExportedTypeTable = mdTables[(int)Table.ExportedType];
			ManifestResourceTable = mdTables[(int)Table.ManifestResource];
			NestedClassTable = mdTables[(int)Table.NestedClass];
			GenericParamTable = mdTables[(int)Table.GenericParam];
			MethodSpecTable = mdTables[(int)Table.MethodSpec];
			GenericParamConstraintTable = mdTables[(int)Table.GenericParamConstraint];
			DocumentTable = mdTables[(int)Table.Document];
			MethodDebugInformationTable = mdTables[(int)Table.MethodDebugInformation];
			LocalScopeTable = mdTables[(int)Table.LocalScope];
			LocalVariableTable = mdTables[(int)Table.LocalVariable];
			LocalConstantTable = mdTables[(int)Table.LocalConstant];
			ImportScopeTable = mdTables[(int)Table.ImportScope];
			StateMachineMethodTable = mdTables[(int)Table.StateMachineMethod];
			CustomDebugInformationTable = mdTables[(int)Table.CustomDebugInformation];
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			if (disposing) {
				var mt = mdTables;
				if (mt is not null) {
					foreach (var mdTable in mt) {
						if (mdTable is not null)
							mdTable.Dispose();
					}
					mdTables = null;
				}
			}
			base.Dispose(disposing);
		}

		/// <summary>
		/// Returns a MD table
		/// </summary>
		/// <param name="table">The table type</param>
		/// <returns>A <see cref="MDTable"/> or <c>null</c> if table doesn't exist</returns>
		public MDTable Get(Table table) {
			int index = (int)table;
			if ((uint)index >= (uint)mdTables.Length)
				return null;
			return mdTables[index];
		}

		/// <summary>
		/// Checks whether a table exists
		/// </summary>
		/// <param name="table">The table type</param>
		/// <returns><c>true</c> if the table exists</returns>
		public bool HasTable(Table table) => (uint)table < (uint)mdTables.Length;

		/// <summary>
		/// Checks whether table <paramref name="table"/> is sorted
		/// </summary>
		/// <param name="table">The table</param>
		public bool IsSorted(MDTable table) {
			int index = (int)table.Table;
			if ((uint)index >= 64)
				return false;
			return (sortedMask & (1UL << index)) != 0;
		}
	}
}





namespace dnlib.DotNet.MD {
	public partial class TablesStream {
		/// <summary>
		/// Reads a raw <c>Module</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadModuleRow(uint rid, out RawModuleRow row) {
			var table = ModuleTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawModuleRow(
				reader.Unsafe_ReadUInt16(),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader),
				table.Column3.Unsafe_Read24(ref reader),
				table.Column4.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>TypeRef</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadTypeRefRow(uint rid, out RawTypeRefRow row) {
			var table = TypeRefTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawTypeRefRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>TypeDef</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadTypeDefRow(uint rid, out RawTypeDefRow row) {
			var table = TypeDefTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawTypeDefRow(
				reader.Unsafe_ReadUInt32(),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader),
				table.Column3.Unsafe_Read24(ref reader),
				table.Column4.Unsafe_Read24(ref reader),
				table.Column5.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>FieldPtr</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadFieldPtrRow(uint rid, out RawFieldPtrRow row) {
			var table = FieldPtrTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawFieldPtrRow(table.Column0.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>Field</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadFieldRow(uint rid, out RawFieldRow row) {
			var table = FieldTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawFieldRow(
				reader.Unsafe_ReadUInt16(),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>MethodPtr</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadMethodPtrRow(uint rid, out RawMethodPtrRow row) {
			var table = MethodPtrTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawMethodPtrRow(table.Column0.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>Method</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadMethodRow(uint rid, out RawMethodRow row) {
			var table = MethodTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var mrr = methodRowReader;
			if (mrr is not null && mrr.TryReadRow(rid, out row))
				return true;
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawMethodRow(
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt16(),
				table.Column3.Unsafe_Read24(ref reader),
				table.Column4.Unsafe_Read24(ref reader),
				table.Column5.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>ParamPtr</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadParamPtrRow(uint rid, out RawParamPtrRow row) {
			var table = ParamPtrTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawParamPtrRow(table.Column0.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>Param</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadParamRow(uint rid, out RawParamRow row) {
			var table = ParamTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawParamRow(
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt16(),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>InterfaceImpl</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadInterfaceImplRow(uint rid, out RawInterfaceImplRow row) {
			var table = InterfaceImplTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawInterfaceImplRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>MemberRef</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadMemberRefRow(uint rid, out RawMemberRefRow row) {
			var table = MemberRefTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawMemberRefRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>Constant</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadConstantRow(uint rid, out RawConstantRow row) {
			var table = ConstantTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawConstantRow(
				reader.Unsafe_ReadByte(),
				reader.Unsafe_ReadByte(),
				table.Column2.Unsafe_Read24(ref reader),
				table.Column3.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>CustomAttribute</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadCustomAttributeRow(uint rid, out RawCustomAttributeRow row) {
			var table = CustomAttributeTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawCustomAttributeRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>FieldMarshal</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadFieldMarshalRow(uint rid, out RawFieldMarshalRow row) {
			var table = FieldMarshalTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawFieldMarshalRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>DeclSecurity</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadDeclSecurityRow(uint rid, out RawDeclSecurityRow row) {
			var table = DeclSecurityTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawDeclSecurityRow(
				(short)reader.Unsafe_ReadUInt16(),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>ClassLayout</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadClassLayoutRow(uint rid, out RawClassLayoutRow row) {
			var table = ClassLayoutTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawClassLayoutRow(
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt32(),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>FieldLayout</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadFieldLayoutRow(uint rid, out RawFieldLayoutRow row) {
			var table = FieldLayoutTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawFieldLayoutRow(
				reader.Unsafe_ReadUInt32(),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>StandAloneSig</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadStandAloneSigRow(uint rid, out RawStandAloneSigRow row) {
			var table = StandAloneSigTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawStandAloneSigRow(table.Column0.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>EventMap</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadEventMapRow(uint rid, out RawEventMapRow row) {
			var table = EventMapTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawEventMapRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>EventPtr</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadEventPtrRow(uint rid, out RawEventPtrRow row) {
			var table = EventPtrTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawEventPtrRow(table.Column0.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>Event</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadEventRow(uint rid, out RawEventRow row) {
			var table = EventTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawEventRow(
				reader.Unsafe_ReadUInt16(),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>PropertyMap</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadPropertyMapRow(uint rid, out RawPropertyMapRow row) {
			var table = PropertyMapTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawPropertyMapRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>PropertyPtr</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadPropertyPtrRow(uint rid, out RawPropertyPtrRow row) {
			var table = PropertyPtrTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawPropertyPtrRow(table.Column0.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>Property</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadPropertyRow(uint rid, out RawPropertyRow row) {
			var table = PropertyTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawPropertyRow(
				reader.Unsafe_ReadUInt16(),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>MethodSemantics</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadMethodSemanticsRow(uint rid, out RawMethodSemanticsRow row) {
			var table = MethodSemanticsTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawMethodSemanticsRow(
				reader.Unsafe_ReadUInt16(),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>MethodImpl</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadMethodImplRow(uint rid, out RawMethodImplRow row) {
			var table = MethodImplTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawMethodImplRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>ModuleRef</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadModuleRefRow(uint rid, out RawModuleRefRow row) {
			var table = ModuleRefTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawModuleRefRow(table.Column0.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>TypeSpec</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadTypeSpecRow(uint rid, out RawTypeSpecRow row) {
			var table = TypeSpecTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawTypeSpecRow(table.Column0.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>ImplMap</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadImplMapRow(uint rid, out RawImplMapRow row) {
			var table = ImplMapTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawImplMapRow(
				reader.Unsafe_ReadUInt16(),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader),
				table.Column3.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>FieldRVA</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadFieldRVARow(uint rid, out RawFieldRVARow row) {
			var table = FieldRVATable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawFieldRVARow(
				reader.Unsafe_ReadUInt32(),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>ENCLog</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadENCLogRow(uint rid, out RawENCLogRow row) {
			var table = ENCLogTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawENCLogRow(
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt32());
			return true;
		}

		/// <summary>
		/// Reads a raw <c>ENCMap</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadENCMapRow(uint rid, out RawENCMapRow row) {
			var table = ENCMapTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawENCMapRow(reader.Unsafe_ReadUInt32());
			return true;
		}

		/// <summary>
		/// Reads a raw <c>Assembly</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadAssemblyRow(uint rid, out RawAssemblyRow row) {
			var table = AssemblyTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawAssemblyRow(
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt32(),
				table.Column6.Unsafe_Read24(ref reader),
				table.Column7.Unsafe_Read24(ref reader),
				table.Column8.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>AssemblyProcessor</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadAssemblyProcessorRow(uint rid, out RawAssemblyProcessorRow row) {
			var table = AssemblyProcessorTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawAssemblyProcessorRow(reader.Unsafe_ReadUInt32());
			return true;
		}

		/// <summary>
		/// Reads a raw <c>AssemblyOS</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadAssemblyOSRow(uint rid, out RawAssemblyOSRow row) {
			var table = AssemblyOSTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawAssemblyOSRow(
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt32());
			return true;
		}

		/// <summary>
		/// Reads a raw <c>AssemblyRef</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadAssemblyRefRow(uint rid, out RawAssemblyRefRow row) {
			var table = AssemblyRefTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawAssemblyRefRow(
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt32(),
				table.Column5.Unsafe_Read24(ref reader),
				table.Column6.Unsafe_Read24(ref reader),
				table.Column7.Unsafe_Read24(ref reader),
				table.Column8.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>AssemblyRefProcessor</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadAssemblyRefProcessorRow(uint rid, out RawAssemblyRefProcessorRow row) {
			var table = AssemblyRefProcessorTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawAssemblyRefProcessorRow(
				reader.Unsafe_ReadUInt32(),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>AssemblyRefOS</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadAssemblyRefOSRow(uint rid, out RawAssemblyRefOSRow row) {
			var table = AssemblyRefOSTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawAssemblyRefOSRow(
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt32(),
				table.Column3.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>File</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadFileRow(uint rid, out RawFileRow row) {
			var table = FileTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawFileRow(
				reader.Unsafe_ReadUInt32(),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>ExportedType</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadExportedTypeRow(uint rid, out RawExportedTypeRow row) {
			var table = ExportedTypeTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawExportedTypeRow(
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt32(),
				table.Column2.Unsafe_Read24(ref reader),
				table.Column3.Unsafe_Read24(ref reader),
				table.Column4.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>ManifestResource</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadManifestResourceRow(uint rid, out RawManifestResourceRow row) {
			var table = ManifestResourceTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawManifestResourceRow(
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt32(),
				table.Column2.Unsafe_Read24(ref reader),
				table.Column3.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>NestedClass</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadNestedClassRow(uint rid, out RawNestedClassRow row) {
			var table = NestedClassTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawNestedClassRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>GenericParam</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadGenericParamRow(uint rid, out RawGenericParamRow row) {
			var table = GenericParamTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			if (table.Column4 is null) {
				row = new RawGenericParamRow(
					reader.Unsafe_ReadUInt16(),
					reader.Unsafe_ReadUInt16(),
					table.Column2.Unsafe_Read24(ref reader),
					table.Column3.Unsafe_Read24(ref reader));
				return true;
			}
			else {
				row = new RawGenericParamRow(
					reader.Unsafe_ReadUInt16(),
					reader.Unsafe_ReadUInt16(),
					table.Column2.Unsafe_Read24(ref reader),
					table.Column3.Unsafe_Read24(ref reader),
					table.Column4.Unsafe_Read24(ref reader));
				return true;
			}
		}

		/// <summary>
		/// Reads a raw <c>MethodSpec</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadMethodSpecRow(uint rid, out RawMethodSpecRow row) {
			var table = MethodSpecTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawMethodSpecRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>GenericParamConstraint</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadGenericParamConstraintRow(uint rid, out RawGenericParamConstraintRow row) {
			var table = GenericParamConstraintTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawGenericParamConstraintRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>Document</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadDocumentRow(uint rid, out RawDocumentRow row) {
			var table = DocumentTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawDocumentRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader),
				table.Column3.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>MethodDebugInformation</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadMethodDebugInformationRow(uint rid, out RawMethodDebugInformationRow row) {
			var table = MethodDebugInformationTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawMethodDebugInformationRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>LocalScope</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadLocalScopeRow(uint rid, out RawLocalScopeRow row) {
			var table = LocalScopeTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawLocalScopeRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader),
				table.Column3.Unsafe_Read24(ref reader),
				reader.Unsafe_ReadUInt32(),
				reader.Unsafe_ReadUInt32());
			return true;
		}

		/// <summary>
		/// Reads a raw <c>LocalVariable</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadLocalVariableRow(uint rid, out RawLocalVariableRow row) {
			var table = LocalVariableTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawLocalVariableRow(
				reader.Unsafe_ReadUInt16(),
				reader.Unsafe_ReadUInt16(),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>LocalConstant</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadLocalConstantRow(uint rid, out RawLocalConstantRow row) {
			var table = LocalConstantTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawLocalConstantRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>ImportScope</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadImportScopeRow(uint rid, out RawImportScopeRow row) {
			var table = ImportScopeTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawImportScopeRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>StateMachineMethod</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadStateMachineMethodRow(uint rid, out RawStateMachineMethodRow row) {
			var table = StateMachineMethodTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawStateMachineMethodRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a raw <c>CustomDebugInformation</c> row or returns false if the row doesn't exist
		/// </summary>
		/// <param name="rid">Row ID</param>
		/// <param name="row">Row data</param>
		/// <returns></returns>
		public bool TryReadCustomDebugInformationRow(uint rid, out RawCustomDebugInformationRow row) {
			var table = CustomDebugInformationTable;
			if (table.IsInvalidRID(rid)) {
				row = default;
				return false;
			}
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize;
			row = new RawCustomDebugInformationRow(
				table.Column0.Unsafe_Read24(ref reader),
				table.Column1.Unsafe_Read24(ref reader),
				table.Column2.Unsafe_Read24(ref reader));
			return true;
		}

		/// <summary>
		/// Reads a column
		/// </summary>
		/// <param name="table">The table</param>
		/// <param name="rid">Row ID</param>
		/// <param name="colIndex">Column index in <paramref name="table"/></param>
		/// <param name="value">Result is put here or 0 if we return <c>false</c></param>
		/// <returns><c>true</c> if we could read the column, <c>false</c> otherwise</returns>
		public bool TryReadColumn(MDTable table, uint rid, int colIndex, out uint value) =>
			TryReadColumn(table, rid, table.TableInfo.Columns[colIndex], out value);

		/// <summary>
		/// Reads a column
		/// </summary>
		/// <param name="table">The table</param>
		/// <param name="rid">Row ID</param>
		/// <param name="column">Column</param>
		/// <param name="value">Result is put here or 0 if we return <c>false</c></param>
		/// <returns><c>true</c> if we could read the column, <c>false</c> otherwise</returns>
		public bool TryReadColumn(MDTable table, uint rid, ColumnInfo column, out uint value) {
			if (table.IsInvalidRID(rid)) {
				value = 0;
				return false;
			}
			var cr = columnReader;
			if (cr is not null && cr.ReadColumn(table, rid, column, out value))
				return true;
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize + (uint)column.Offset;
			value = column.Read(ref reader);
			return true;
		}

		internal bool TryReadColumn24(MDTable table, uint rid, int colIndex, out uint value) =>
			TryReadColumn24(table, rid, table.TableInfo.Columns[colIndex], out value);

		internal bool TryReadColumn24(MDTable table, uint rid, ColumnInfo column, out uint value) {
			Debug.Assert(column.Size == 2 || column.Size == 4);
			if (table.IsInvalidRID(rid)) {
				value = 0;
				return false;
			}
			var cr = columnReader;
			if (cr is not null && cr.ReadColumn(table, rid, column, out value))
				return true;
			var reader = table.DataReader;
			reader.Position = (rid - 1) * (uint)table.TableInfo.RowSize + (uint)column.Offset;
			value = column.Size == 2 ? reader.Unsafe_ReadUInt16() : reader.Unsafe_ReadUInt32();
			return true;
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the #US stream
	/// </summary>
	public sealed class USStream : HeapStream {
		/// <inheritdoc/>
		public USStream() {
		}

		/// <inheritdoc/>
		public USStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader)
			: base(mdReaderFactory, metadataBaseOffset, streamHeader) {
		}

		/// <summary>
		/// Reads a unicode string
		/// </summary>
		/// <param name="offset">Offset of unicode string</param>
		/// <returns>A string or <c>null</c> if <paramref name="offset"/> is invalid</returns>
		public string Read(uint offset) {
			if (offset == 0)
				return string.Empty;
			if (!IsValidOffset(offset))
				return null;
			var reader = dataReader;
			reader.Position = offset;
			if (!reader.TryReadCompressedUInt32(out uint length))
				return null;
			if (!reader.CanRead(length))
				return null;
			try {
				return reader.ReadUtf16String((int)(length / 2));
			}
			catch (OutOfMemoryException) {
				throw;
			}
			catch {
				// It's possible that an exception is thrown when converting a char* to
				// a string. If so, return an empty string.
				return string.Empty;
			}
		}

		/// <summary>
		/// Reads data just like <see cref="Read"/>, but returns an empty string if
		/// offset is invalid
		/// </summary>
		/// <param name="offset">Offset of unicode string</param>
		/// <returns>The string</returns>
		public string ReadNoNull(uint offset) => Read(offset) ?? string.Empty;
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Represents the #Blob stream
	/// </summary>
	public sealed class BlobStream : HeapStream {
		/// <inheritdoc/>
		public BlobStream() {
		}

		/// <inheritdoc/>
		public BlobStream(DataReaderFactory mdReaderFactory, uint metadataBaseOffset, StreamHeader streamHeader)
			: base(mdReaderFactory, metadataBaseOffset, streamHeader) {
		}

		/// <summary>
		/// Reads data
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns>The data or <c>null</c> if invalid offset</returns>
		public byte[] Read(uint offset) {
			// The CLR has a special check for offset 0. It always interprets it as
			// 0-length data, even if that first byte isn't 0 at all.
			if (offset == 0)
				return Array2.Empty<byte>();
			if (!TryCreateReader(offset, out var reader))
				return null;
			return reader.ToArray();
		}

		/// <summary>
		/// Reads data just like <see cref="Read"/>, but returns an empty array if
		/// offset is invalid
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns>The data</returns>
		public byte[] ReadNoNull(uint offset) => Read(offset) ?? Array2.Empty<byte>();

		/// <summary>
		/// Creates a reader that can access a blob
		/// </summary>
		/// <param name="offset">Offset of blob</param>
		/// <returns>A new stream</returns>
		public DataReader CreateReader(uint offset) {
			TryCreateReader(offset, out var reader);
			return reader;
		}

		/// <summary>
		/// Creates a reader that can access a blob or returns false on failure
		/// </summary>
		/// <param name="offset">Offset of blob</param>
		/// <param name="reader">Updated with the reader</param>
		/// <returns></returns>
		public bool TryCreateReader(uint offset, out DataReader reader) {
			reader = dataReader;
			if (!IsValidOffset(offset))
				return false;
			reader.Position = offset;
			if (!reader.TryReadCompressedUInt32(out uint length))
				return false;
			if (!reader.CanRead(length))
				return false;
			reader = reader.Slice(reader.Position, length);
			return true;
		}
	}
}





namespace dnlib.DotNet.MD {
	/// <summary>
	/// Contains all possible coded token classes
	/// </summary>
	public sealed class CodedToken {
		/// <summary>TypeDefOrRef coded token</summary>
		public static readonly CodedToken TypeDefOrRef = new CodedToken(2, new Table[3] {
			Table.TypeDef, Table.TypeRef, Table.TypeSpec,
		});

		/// <summary>HasConstant coded token</summary>
		public static readonly CodedToken HasConstant = new CodedToken(2, new Table[3] {
			Table.Field, Table.Param, Table.Property,
		});

		/// <summary>HasCustomAttribute coded token</summary>
		public static readonly CodedToken HasCustomAttribute = new CodedToken(5, new Table[24] {
			Table.Method, Table.Field, Table.TypeRef, Table.TypeDef,
			Table.Param, Table.InterfaceImpl, Table.MemberRef, Table.Module,
			Table.DeclSecurity, Table.Property, Table.Event, Table.StandAloneSig,
			Table.ModuleRef, Table.TypeSpec, Table.Assembly, Table.AssemblyRef,
			Table.File, Table.ExportedType, Table.ManifestResource, Table.GenericParam,
			Table.GenericParamConstraint, Table.MethodSpec, 0, 0,
		});

		/// <summary>HasFieldMarshal coded token</summary>
		public static readonly CodedToken HasFieldMarshal = new CodedToken(1, new Table[2] {
			Table.Field, Table.Param,
		});

		/// <summary>HasDeclSecurity coded token</summary>
		public static readonly CodedToken HasDeclSecurity = new CodedToken(2, new Table[3] {
			Table.TypeDef, Table.Method, Table.Assembly,
		});

		/// <summary>MemberRefParent coded token</summary>
		public static readonly CodedToken MemberRefParent = new CodedToken(3, new Table[5] {
			Table.TypeDef, Table.TypeRef, Table.ModuleRef, Table.Method,
			Table.TypeSpec,
		});

		/// <summary>HasSemantic coded token</summary>
		public static readonly CodedToken HasSemantic = new CodedToken(1, new Table[2] {
			Table.Event, Table.Property,
		});

		/// <summary>MethodDefOrRef coded token</summary>
		public static readonly CodedToken MethodDefOrRef = new CodedToken(1, new Table[2] {
			Table.Method, Table.MemberRef,
		});

		/// <summary>MemberForwarded coded token</summary>
		public static readonly CodedToken MemberForwarded = new CodedToken(1, new Table[2] {
			Table.Field, Table.Method,
		});

		/// <summary>Implementation coded token</summary>
		public static readonly CodedToken Implementation = new CodedToken(2, new Table[3] {
			Table.File, Table.AssemblyRef, Table.ExportedType,
		});

		/// <summary>CustomAttributeType coded token</summary>
		public static readonly CodedToken CustomAttributeType = new CodedToken(3, new Table[5] {
			0, 0, Table.Method, Table.MemberRef, 0,
		});

		/// <summary>ResolutionScope coded token</summary>
		public static readonly CodedToken ResolutionScope = new CodedToken(2, new Table[4] {
			Table.Module, Table.ModuleRef, Table.AssemblyRef, Table.TypeRef,
		});

		/// <summary>TypeOrMethodDef coded token</summary>
		public static readonly CodedToken TypeOrMethodDef = new CodedToken(1, new Table[2] {
			Table.TypeDef, Table.Method,
		});

		/// <summary>HasCustomDebugInformation coded token</summary>
		public static readonly CodedToken HasCustomDebugInformation = new CodedToken(5, new Table[27] {
			Table.Method, Table.Field, Table.TypeRef, Table.TypeDef,
			Table.Param, Table.InterfaceImpl, Table.MemberRef, Table.Module,
			Table.DeclSecurity, Table.Property, Table.Event, Table.StandAloneSig,
			Table.ModuleRef, Table.TypeSpec, Table.Assembly, Table.AssemblyRef,
			Table.File, Table.ExportedType, Table.ManifestResource, Table.GenericParam,
			Table.GenericParamConstraint, Table.MethodSpec, Table.Document, Table.LocalScope,
			Table.LocalVariable, Table.LocalConstant, Table.ImportScope,
		});

		readonly Table[] tableTypes;
		readonly int bits;
		readonly int mask;

		/// <summary>
		/// Returns all types of tables
		/// </summary>
		public Table[] TableTypes => tableTypes;

		/// <summary>
		/// Returns the number of bits that is used to encode table type
		/// </summary>
		public int Bits => bits;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="bits">Number of bits used to encode token type</param>
		/// <param name="tableTypes">All table types</param>
		internal CodedToken(int bits, Table[] tableTypes) {
			this.bits = bits;
			mask = (1 << bits) - 1;
			this.tableTypes = tableTypes;
		}

		/// <summary>
		/// Encodes a token
		/// </summary>
		/// <param name="token">The token</param>
		/// <returns>Coded token</returns>
		/// <seealso cref="Encode(MDToken,out uint)"/>
		public uint Encode(MDToken token) => Encode(token.Raw);

		/// <summary>
		/// Encodes a token
		/// </summary>
		/// <param name="token">The token</param>
		/// <returns>Coded token</returns>
		/// <seealso cref="Encode(uint,out uint)"/>
		public uint Encode(uint token) {
			Encode(token, out uint codedToken);
			return codedToken;
		}

		/// <summary>
		/// Encodes a token
		/// </summary>
		/// <param name="token">The token</param>
		/// <param name="codedToken">Coded token</param>
		/// <returns><c>true</c> if successful</returns>
		public bool Encode(MDToken token, out uint codedToken) => Encode(token.Raw, out codedToken);

		/// <summary>
		/// Encodes a token
		/// </summary>
		/// <param name="token">The token</param>
		/// <param name="codedToken">Coded token</param>
		/// <returns><c>true</c> if successful</returns>
		public bool Encode(uint token, out uint codedToken) {
			int index = Array.IndexOf(tableTypes, MDToken.ToTable(token));
			if (index < 0) {
				codedToken = uint.MaxValue;
				return false;
			}
			// This shift can never overflow a uint since bits < 8 (it's at most 5), and
			// ToRid() returns an integer <= 0x00FFFFFF.
			codedToken = (MDToken.ToRID(token) << bits) | (uint)index;
			return true;
		}

		/// <summary>
		/// Decodes a coded token
		/// </summary>
		/// <param name="codedToken">The coded token</param>
		/// <returns>Decoded token or 0 on failure</returns>
		/// <seealso cref="Decode(uint,out MDToken)"/>
		public MDToken Decode2(uint codedToken) {
			Decode(codedToken, out uint token);
			return new MDToken(token);
		}

		/// <summary>
		/// Decodes a coded token
		/// </summary>
		/// <param name="codedToken">The coded token</param>
		/// <returns>Decoded token or 0 on failure</returns>
		/// <seealso cref="Decode(uint,out uint)"/>
		public uint Decode(uint codedToken) {
			Decode(codedToken, out uint token);
			return token;
		}

		/// <summary>
		/// Decodes a coded token
		/// </summary>
		/// <param name="codedToken">The coded token</param>
		/// <param name="token">Decoded token</param>
		/// <returns><c>true</c> if successful</returns>
		public bool Decode(uint codedToken, out MDToken token) {
			bool result = Decode(codedToken, out uint decodedToken);
			token = new MDToken(decodedToken);
			return result;
		}

		/// <summary>
		/// Decodes a coded token
		/// </summary>
		/// <param name="codedToken">The coded token</param>
		/// <param name="token">Decoded token</param>
		/// <returns><c>true</c> if successful</returns>
		public bool Decode(uint codedToken, out uint token) {
			uint rid = codedToken >> bits;
			int index = (int)(codedToken & mask);
			if (rid > MDToken.RID_MAX || index >= tableTypes.Length) {
				token = 0;
				return false;
			}

			token = ((uint)tableTypes[index] << MDToken.TABLE_SHIFT) | rid;
			return true;
		}
	}
}





namespace dnlib.DotNet.Pdb {
	static class DataReaderFactoryUtils {
		public static DataReaderFactory TryCreateDataReaderFactory(string filename) {
			try {
				if (!File.Exists(filename))
					return null;
				// Don't use memory mapped I/O
				return ByteArrayDataReaderFactory.Create(File.ReadAllBytes(filename), filename);
			}
			catch (IOException) {
			}
			catch (UnauthorizedAccessException) {
			}
			catch (SecurityException) {
			}
			return null;
		}
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// IMAGE_DEBUG_DIRECTORY
	/// </summary>
	public struct IMAGE_DEBUG_DIRECTORY {
#pragma warning disable 1591
		public uint Characteristics;
		public uint TimeDateStamp;
		public ushort MajorVersion;
		public ushort MinorVersion;
		public ImageDebugType Type;
		public uint SizeOfData;
		public uint AddressOfRawData;
		public uint PointerToRawData;
#pragma warning restore 1591
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A constant in a method scope, eg. "const int SomeConstant = 123;"
	/// </summary>
	public sealed class PdbConstant : IHasCustomDebugInformation {
		string name;
		TypeSig type;
		object value;

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public string Name {
			get => name;
			set => name = value;
		}

		/// <summary>
		/// Gets/sets the type of the constant
		/// </summary>
		public TypeSig Type {
			get => type;
			set => type = value;
		}

		/// <summary>
		/// Gets/sets the value of the constant
		/// </summary>
		public object Value {
			get => value;
			set => this.value = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbConstant() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of constant</param>
		/// <param name="type">Type of constant</param>
		/// <param name="value">Constant value</param>
		public PdbConstant(string name, TypeSig type, object value) {
			this.name = name;
			this.type = type;
			this.value = value;
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 25;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos => customDebugInfos;
		readonly IList<PdbCustomDebugInfo> customDebugInfos = new List<PdbCustomDebugInfo>();

		/// <summary>
		/// ToString()
		/// </summary>
		/// <returns></returns>
		public override string ToString() {
			var type = Type;
			return (type is null ? "" : type.ToString()) + " " + Name + " = " + (Value is null ? "null" : Value.ToString() + " (" + Value.GetType().FullName + ")");
		}
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// Custom debug info kind
	/// </summary>
	/// <remarks>See <c>CustomDebugInfoKind</c> in Roslyn source code</remarks>
	public enum PdbCustomDebugInfoKind {
		/// <summary>
		/// <see cref="PdbUsingGroupsCustomDebugInfo"/>
		/// </summary>
		UsingGroups,

		/// <summary>
		/// <see cref="PdbForwardMethodInfoCustomDebugInfo"/>
		/// </summary>
		ForwardMethodInfo,

		/// <summary>
		/// <see cref="PdbForwardModuleInfoCustomDebugInfo"/>
		/// </summary>
		ForwardModuleInfo,

		/// <summary>
		/// <see cref="PdbStateMachineHoistedLocalScopesCustomDebugInfo"/>
		/// </summary>
		StateMachineHoistedLocalScopes,

		/// <summary>
		/// <see cref="PdbStateMachineTypeNameCustomDebugInfo"/>
		/// </summary>
		StateMachineTypeName,

		/// <summary>
		/// <see cref="PdbDynamicLocalsCustomDebugInfo"/>
		/// </summary>
		DynamicLocals,

		/// <summary>
		/// <see cref="PdbEditAndContinueLocalSlotMapCustomDebugInfo"/>
		/// </summary>
		EditAndContinueLocalSlotMap,

		/// <summary>
		/// <see cref="PdbEditAndContinueLambdaMapCustomDebugInfo"/>
		/// </summary>
		EditAndContinueLambdaMap,

		/// <summary>
		/// <see cref="PdbTupleElementNamesCustomDebugInfo"/>
		/// </summary>
		TupleElementNames,

		// Values 0x00-0xFF are reserved for Windows PDB CDIs.

		/// <summary>
		/// Unknown
		/// </summary>
		Unknown = int.MinValue,

		/// <summary>
		/// <see cref="PortablePdbTupleElementNamesCustomDebugInfo"/>
		/// </summary>
		TupleElementNames_PortablePdb,

		/// <summary>
		/// <see cref="PdbDefaultNamespaceCustomDebugInfo"/>
		/// </summary>
		DefaultNamespace,

		/// <summary>
		/// <see cref="PdbDynamicLocalVariablesCustomDebugInfo"/>
		/// </summary>
		DynamicLocalVariables,

		/// <summary>
		/// <see cref="PdbEmbeddedSourceCustomDebugInfo"/>
		/// </summary>
		EmbeddedSource,

		/// <summary>
		/// <see cref="PdbSourceLinkCustomDebugInfo"/>
		/// </summary>
		SourceLink,

		/// <summary>
		/// <see cref="PdbSourceServerCustomDebugInfo"/>
		/// </summary>
		SourceServer,

		/// <summary>
		/// <see cref="PdbAsyncMethodCustomDebugInfo"/>
		/// </summary>
		AsyncMethod,

		/// <summary>
		/// <see cref="PdbIteratorMethodCustomDebugInfo"/>
		/// </summary>
		IteratorMethod,

		/// <summary>
		/// <see cref="PdbCompilationMetadataReferencesCustomDebugInfo"/>
		/// </summary>
		CompilationMetadataReferences,

		/// <summary>
		/// <see cref="PdbCompilationOptionsCustomDebugInfo"/>
		/// </summary>
		CompilationOptions,
	}

	/// <summary>
	/// Base class of custom debug info added to the PDB file by the compiler
	/// </summary>
	public abstract class PdbCustomDebugInfo {
		/// <summary>
		/// Gets the custom debug info kind
		/// </summary>
		public abstract PdbCustomDebugInfoKind Kind { get; }

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public abstract Guid Guid { get; }
	}

	/// <summary>
	/// Unknown custom debug info. If you see an instance of this class, you're using an old dnlib version or
	/// dnlib hasn't been updated to support this new custom debug info kind.
	/// </summary>
	public sealed class PdbUnknownCustomDebugInfo : PdbCustomDebugInfo {
		readonly PdbCustomDebugInfoKind kind;
		readonly Guid guid;
		readonly byte[] data;

		/// <summary>
		/// Gets the custom debug info kind
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => kind;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => guid;

		/// <summary>
		/// Gets the data
		/// </summary>
		public byte[] Data => data;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="kind">Custom debug info kind</param>
		/// <param name="data">Raw custom debug info data</param>
		public PdbUnknownCustomDebugInfo(PdbCustomDebugInfoKind kind, byte[] data) {
			this.kind = kind;
			this.data = data ?? throw new ArgumentNullException(nameof(data));
			guid = Guid.Empty;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">Custom debug info guid</param>
		/// <param name="data">Raw custom debug info data</param>
		public PdbUnknownCustomDebugInfo(Guid guid, byte[] data) {
			kind = PdbCustomDebugInfoKind.Unknown;
			this.data = data ?? throw new ArgumentNullException(nameof(data));
			this.guid = guid;
		}
	}

	/// <summary>
	/// Contains sizes of using groups
	/// </summary>
	public sealed class PdbUsingGroupsCustomDebugInfo : PdbCustomDebugInfo {
		readonly IList<ushort> usingCounts;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.UsingGroups"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.UsingGroups;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => Guid.Empty;

		/// <summary>
		/// Gets the using counts
		/// </summary>
		public IList<ushort> UsingCounts => usingCounts;

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbUsingGroupsCustomDebugInfo() => usingCounts = new List<ushort>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="UsingCounts"/></param>
		public PdbUsingGroupsCustomDebugInfo(int capacity) => usingCounts = new List<ushort>(capacity);
	}

	/// <summary>
	/// Contains a reference to another method that contains the import strings
	/// </summary>
	public sealed class PdbForwardMethodInfoCustomDebugInfo : PdbCustomDebugInfo {
		IMethodDefOrRef method;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.ForwardMethodInfo"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.ForwardMethodInfo;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => Guid.Empty;

		/// <summary>
		/// Gets/sets the referenced method
		/// </summary>
		public IMethodDefOrRef Method {
			get => method;
			set => method = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbForwardMethodInfoCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The referenced method</param>
		public PdbForwardMethodInfoCustomDebugInfo(IMethodDefOrRef method) => this.method = method;
	}

	/// <summary>
	/// Contains a reference to another method that contains the per-module debug info (assembly reference aliases)
	/// </summary>
	public sealed class PdbForwardModuleInfoCustomDebugInfo : PdbCustomDebugInfo {
		IMethodDefOrRef method;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.ForwardModuleInfo"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.ForwardModuleInfo;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => Guid.Empty;

		/// <summary>
		/// Gets/sets the referenced method
		/// </summary>
		public IMethodDefOrRef Method {
			get => method;
			set => method = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbForwardModuleInfoCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="method">The referenced method</param>
		public PdbForwardModuleInfoCustomDebugInfo(IMethodDefOrRef method) => this.method = method;
	}

	/// <summary>
	/// State machine hosted local scope info
	/// </summary>
	public struct StateMachineHoistedLocalScope {
		/// <summary>
		/// true if it's a syntesized local (<see cref="Start"/> and <see cref="End"/> are both null)
		/// </summary>
		public readonly bool IsSynthesizedLocal => Start is null && End is null;

		/// <summary>
		/// The instruction of the first operation in the scope. Can be null if it's a synthesized local
		/// </summary>
		public Instruction Start;

		/// <summary>
		/// The instruction of the first operation outside of the scope or null if it ends at the last instruction in the body.
		/// Can also be null if it's a synthesized local (in which case <see cref="Start"/> is also null, see <see cref="IsSynthesizedLocal"/>)
		/// </summary>
		public Instruction End;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="start">Start of the scope</param>
		/// <param name="end">First instruction after the end of the scope</param>
		public StateMachineHoistedLocalScope(Instruction start, Instruction end) {
			Start = start;
			End = end;
		}
	}

	/// <summary>
	/// Contains local scopes for state machine hoisted local variables.
	/// </summary>
	public sealed class PdbStateMachineHoistedLocalScopesCustomDebugInfo : PdbCustomDebugInfo {
		readonly IList<StateMachineHoistedLocalScope> scopes;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.StateMachineHoistedLocalScopes;

		/// <summary>
		/// Gets the scopes
		/// </summary>
		public IList<StateMachineHoistedLocalScope> Scopes => scopes;

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbStateMachineHoistedLocalScopesCustomDebugInfo() => scopes = new List<StateMachineHoistedLocalScope>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Scopes"/></param>
		public PdbStateMachineHoistedLocalScopesCustomDebugInfo(int capacity) => scopes = new List<StateMachineHoistedLocalScope>(capacity);
	}

	/// <summary>
	/// Contains the state machine type
	/// </summary>
	public sealed class PdbStateMachineTypeNameCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.StateMachineTypeName"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.StateMachineTypeName;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => Guid.Empty;

		/// <summary>
		/// Gets/sets the state machine type
		/// </summary>
		public TypeDef Type { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbStateMachineTypeNameCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">State machine type</param>
		public PdbStateMachineTypeNameCustomDebugInfo(TypeDef type) => Type = type;
	}

	/// <summary>
	/// Contains dynamic flags for local variables and constants
	/// </summary>
	public sealed class PdbDynamicLocalsCustomDebugInfo : PdbCustomDebugInfo {
		readonly IList<PdbDynamicLocal> locals;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.DynamicLocals"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.DynamicLocals;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => Guid.Empty;

		/// <summary>
		/// Gets the dynamic locals
		/// </summary>
		public IList<PdbDynamicLocal> Locals => locals;

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbDynamicLocalsCustomDebugInfo() => locals = new List<PdbDynamicLocal>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Locals"/></param>
		public PdbDynamicLocalsCustomDebugInfo(int capacity) => locals = new List<PdbDynamicLocal>(capacity);
	}

	/// <summary>
	/// Dynamic local info
	/// </summary>
	public sealed class PdbDynamicLocal {
		readonly IList<byte> flags;
		string name;
		Local local;

		/// <summary>
		/// Gets the dynamic flags
		/// </summary>
		public IList<byte> Flags => flags;

		/// <summary>
		/// Gets/sets the name of the local. The name must have at most 64 characters and no char can be NUL (0x0000).
		/// If null is written, <see cref="dnlib.DotNet.Emit.Local.Name"/> is returned instead.
		/// </summary>
		public string Name {
			get {
				var n = name;
				if (n is not null)
					return n;
				return local?.Name;
			}
			set => name = value;
		}

		/// <summary>
		/// true if it's a constant and not a variable (<see cref="Local"/> is null)
		/// </summary>
		public bool IsConstant => Local is null;

		/// <summary>
		/// true if it's a variable (<see cref="Local"/> is not null)
		/// </summary>
		public bool IsVariable => Local is not null;

		/// <summary>
		/// Gets/sets the local. Could be null if there's no local (it's a 'const' local).
		/// </summary>
		public Local Local {
			get => local;
			set => local = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbDynamicLocal() => flags = new List<byte>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Flags"/></param>
		public PdbDynamicLocal(int capacity) => flags = new List<byte>(capacity);
	}

	/// <summary>
	/// Contains the EnC local variable slot map
	/// </summary>
	public sealed class PdbEditAndContinueLocalSlotMapCustomDebugInfo : PdbCustomDebugInfo {
		readonly byte[] data;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.EncLocalSlotMap;

		/// <summary>
		/// Gets the data. Spec: https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLocalSlotMap
		/// </summary>
		public byte[] Data => data;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Raw custom debug info data</param>
		public PdbEditAndContinueLocalSlotMapCustomDebugInfo(byte[] data) => this.data = data ?? throw new ArgumentNullException(nameof(data));
	}

	/// <summary>
	/// Contains the EnC lambda map
	/// </summary>
	public sealed class PdbEditAndContinueLambdaMapCustomDebugInfo : PdbCustomDebugInfo {
		readonly byte[] data;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.EditAndContinueLambdaMap"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.EditAndContinueLambdaMap;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.EncLambdaAndClosureMap;

		/// <summary>
		/// Gets the data. Spec: https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#EditAndContinueLambdaAndClosureMap
		/// </summary>
		public byte[] Data => data;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Raw custom debug info data</param>
		public PdbEditAndContinueLambdaMapCustomDebugInfo(byte[] data) => this.data = data ?? throw new ArgumentNullException(nameof(data));
	}

	/// <summary>
	/// Contains tuple element names for local variables and constants
	/// </summary>
	public sealed class PdbTupleElementNamesCustomDebugInfo : PdbCustomDebugInfo {
		readonly IList<PdbTupleElementNames> names;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.TupleElementNames"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.TupleElementNames;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => Guid.Empty;

		/// <summary>
		/// Gets the tuple element names
		/// </summary>
		public IList<PdbTupleElementNames> Names => names;

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbTupleElementNamesCustomDebugInfo() => names = new List<PdbTupleElementNames>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Names"/></param>
		public PdbTupleElementNamesCustomDebugInfo(int capacity) => names = new List<PdbTupleElementNames>(capacity);
	}

	/// <summary>
	/// Tuple element name info
	/// </summary>
	public sealed class PdbTupleElementNames {
		readonly IList<string> tupleElementNames;
		string name;
		Local local;
		Instruction scopeStart, scopeEnd;

		/// <summary>
		/// Gets/sets the name of the local. If null is written, <see cref="dnlib.DotNet.Emit.Local.Name"/> is returned instead.
		/// </summary>
		public string Name {
			get {
				var n = name;
				if (n is not null)
					return n;
				return local?.Name;
			}
			set => name = value;
		}

		/// <summary>
		/// Gets/sets the local. It's null if it's a constant, and non-null if it's a variable
		/// </summary>
		public Local Local {
			get => local;
			set => local = value;
		}

		/// <summary>
		/// true if it's a constant. Constants have a scope (<see cref="ScopeStart"/> and <see cref="ScopeEnd"/>)
		/// </summary>
		public bool IsConstant => local is null;

		/// <summary>
		/// true if it's a variable. Variables don't have a scope (<see cref="ScopeStart"/> and <see cref="ScopeEnd"/>)
		/// </summary>
		public bool IsVariable => local is not null;

		/// <summary>
		/// Gets/sets the start of the scope or null. Only constants have a scope.
		/// </summary>
		public Instruction ScopeStart {
			get => scopeStart;
			set => scopeStart = value;
		}

		/// <summary>
		/// Gets/sets the end of the scope or null if it has no scope or if the scope ends at the end of the body. Only constants have a scope.
		/// </summary>
		public Instruction ScopeEnd {
			get => scopeEnd;
			set => scopeEnd = value;
		}

		/// <summary>
		/// Gets the tuple element names
		/// </summary>
		public IList<string> TupleElementNames => tupleElementNames;

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbTupleElementNames() => tupleElementNames = new List<string>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="TupleElementNames"/></param>
		public PdbTupleElementNames(int capacity) => tupleElementNames = new List<string>(capacity);
	}

	/// <summary>
	/// Contains tuple element names for local variables and constants
	/// </summary>
	public sealed class PortablePdbTupleElementNamesCustomDebugInfo : PdbCustomDebugInfo {
		readonly IList<string> names;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.TupleElementNames_PortablePdb"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.TupleElementNames_PortablePdb;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.TupleElementNames;

		/// <summary>
		/// Gets the tuple element names
		/// </summary>
		public IList<string> Names => names;

		/// <summary>
		/// Constructor
		/// </summary>
		public PortablePdbTupleElementNamesCustomDebugInfo() => names = new List<string>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="capacity">Initial capacity of <see cref="Names"/></param>
		public PortablePdbTupleElementNamesCustomDebugInfo(int capacity) => names = new List<string>(capacity);
	}

	/// <summary>
	/// Async method stepping info
	/// 
	/// It's internal and translated to a <see cref="PdbAsyncMethodCustomDebugInfo"/>
	/// </summary>
	sealed class PdbAsyncMethodSteppingInformationCustomDebugInfo : PdbCustomDebugInfo {
		readonly IList<PdbAsyncStepInfo> asyncStepInfos;

		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.Unknown"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.Unknown;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.AsyncMethodSteppingInformationBlob;

		/// <summary>
		/// Gets the catch handler instruction or null
		/// </summary>
		public Instruction CatchHandler { get; set; }

		/// <summary>
		/// Gets all async step infos
		/// </summary>
		public IList<PdbAsyncStepInfo> AsyncStepInfos => asyncStepInfos;

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAsyncMethodSteppingInformationCustomDebugInfo() => asyncStepInfos = new List<PdbAsyncStepInfo>();
	}

	/// <summary>
	/// Default namespace
	/// </summary>
	public sealed class PdbDefaultNamespaceCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.DefaultNamespace"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.DefaultNamespace;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.DefaultNamespace;

		/// <summary>
		/// Gets the default namespace
		/// </summary>
		public string Namespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbDefaultNamespaceCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="defaultNamespace">Default namespace</param>
		public PdbDefaultNamespaceCustomDebugInfo(string defaultNamespace) => Namespace = defaultNamespace;
	}

	/// <summary>
	/// Dynamic flags
	/// </summary>
	public sealed class PdbDynamicLocalVariablesCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.DynamicLocalVariables"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.DynamicLocalVariables;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.DynamicLocalVariables;

		/// <summary>
		/// Gets/sets the dynamic flags
		/// </summary>
		public bool[] Flags { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbDynamicLocalVariablesCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Dynamic flags</param>
		public PdbDynamicLocalVariablesCustomDebugInfo(bool[] flags) => Flags = flags;
	}

	/// <summary>
	/// Contains the source code
	/// </summary>
	public sealed class PdbEmbeddedSourceCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.EmbeddedSource"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.EmbeddedSource;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.EmbeddedSource;

		/// <summary>
		/// Gets the source code blob.
		/// 
		/// It's not decompressed and converted to a string because the encoding isn't specified.
		/// 
		/// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#embedded-source-c-and-vb-compilers
		/// </summary>
		public byte[] SourceCodeBlob { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbEmbeddedSourceCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="sourceCodeBlob">Source code blob</param>
		public PdbEmbeddedSourceCustomDebugInfo(byte[] sourceCodeBlob) => SourceCodeBlob = sourceCodeBlob;
	}

	/// <summary>
	/// Contains the source link file
	/// </summary>
	public sealed class PdbSourceLinkCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.SourceLink"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.SourceLink;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.SourceLink;

		/// <summary>
		/// Gets the source link file contents
		/// </summary>
		public byte[] FileBlob { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbSourceLinkCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="fileBlob">Source link file contents</param>
		public PdbSourceLinkCustomDebugInfo(byte[] fileBlob) => FileBlob = fileBlob;
	}

	/// <summary>
	/// Contains the source server file
	/// </summary>
	public sealed class PdbSourceServerCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.SourceServer"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.SourceServer;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => Guid.Empty;

		/// <summary>
		/// Gets the source server file contents
		/// </summary>
		public byte[] FileBlob { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbSourceServerCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="fileBlob">Source server file contents</param>
		public PdbSourceServerCustomDebugInfo(byte[] fileBlob) => FileBlob = fileBlob;
	}

	/// <summary>
	/// Async method info
	/// </summary>
	public sealed class PdbAsyncMethodCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.AsyncMethod"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.AsyncMethod;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => Guid.Empty;

		readonly IList<PdbAsyncStepInfo> asyncStepInfos;

		/// <summary>
		/// Gets/sets the starting method that initiates the async operation
		/// </summary>
		public MethodDef KickoffMethod { get; set; }

		/// <summary>
		/// Gets/sets the instruction for the compiler generated catch handler that wraps an async method.
		/// This can be null.
		/// </summary>
		public Instruction CatchHandlerInstruction { get; set; }

		/// <summary>
		/// Gets all step infos used by the debugger
		/// </summary>
		public IList<PdbAsyncStepInfo> StepInfos => asyncStepInfos;

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAsyncMethodCustomDebugInfo() => asyncStepInfos = new List<PdbAsyncStepInfo>();

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stepInfosCapacity">Default capacity for <see cref="StepInfos"/></param>
		public PdbAsyncMethodCustomDebugInfo(int stepInfosCapacity) => asyncStepInfos = new List<PdbAsyncStepInfo>(stepInfosCapacity);
	}

	/// <summary>
	/// Async step info used by debuggers
	/// </summary>
	public struct PdbAsyncStepInfo {
		/// <summary>
		/// The yield instruction
		/// </summary>
		public Instruction YieldInstruction;

		/// <summary>
		/// Resume method
		/// </summary>
		public MethodDef BreakpointMethod;

		/// <summary>
		/// Resume instruction (where the debugger puts a breakpoint)
		/// </summary>
		public Instruction BreakpointInstruction;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="yieldInstruction">The yield instruction</param>
		/// <param name="breakpointMethod">Resume method</param>
		/// <param name="breakpointInstruction">Resume instruction (where the debugger puts a breakpoint)</param>
		public PdbAsyncStepInfo(Instruction yieldInstruction, MethodDef breakpointMethod, Instruction breakpointInstruction) {
			YieldInstruction = yieldInstruction;
			BreakpointMethod = breakpointMethod;
			BreakpointInstruction = breakpointInstruction;
		}
	}

	/// <summary>
	/// Iterator method
	/// </summary>
	public sealed class PdbIteratorMethodCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.IteratorMethod"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.IteratorMethod;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => Guid.Empty;

		/// <summary>
		/// Gets the kickoff method
		/// </summary>
		public MethodDef KickoffMethod { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbIteratorMethodCustomDebugInfo() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="kickoffMethod">Kickoff method</param>
		public PdbIteratorMethodCustomDebugInfo(MethodDef kickoffMethod) => KickoffMethod = kickoffMethod;
	}

	/// <summary>
	/// Compilation metadata references
	/// </summary>
	public sealed class PdbCompilationMetadataReferencesCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.CompilationMetadataReferences"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.CompilationMetadataReferences;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.CompilationMetadataReferences;

		/// <summary>
		/// Gets all references
		/// </summary>
		public List<PdbCompilationMetadataReference> References { get; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbCompilationMetadataReferencesCustomDebugInfo() => References = new List<PdbCompilationMetadataReference>();
	}

	/// <summary>
	/// Compilation metadata reference flags, see https://github.com/dotnet/roslyn/blob/master/docs/features/pdb-compilation-options.md
	/// </summary>
	[Flags]
	public enum PdbCompilationMetadataReferenceFlags : byte {
		/// <summary>
		/// No bit is set
		/// </summary>
		None					= 0,

		/// <summary>
		/// Set if it's an assembly reference, clear if it's a module reference
		/// </summary>
		Assembly				= 0x01,

		/// <summary>
		/// EmbedInteropTypes was enabled
		/// </summary>
		EmbedInteropTypes		= 0x02,
	}

	/// <summary>
	/// A compilation metadata reference
	/// </summary>
	public sealed class PdbCompilationMetadataReference {
		/// <summary>
		/// Name of the reference (eg. filename)
		/// </summary>
		public string Name { get; set; }

		/// <summary>
		/// Aliases (or an empty string), separated with commas
		/// </summary>
		public string Aliases { get; set; }

		/// <summary>
		/// Gets the flags
		/// </summary>
		public PdbCompilationMetadataReferenceFlags Flags { get; set; }

		/// <summary>
		/// Gets the timestamp stored in the PE header
		/// </summary>
		public uint Timestamp { get; set; }

		/// <summary>
		/// Gets SizeOfImage stored in the PE header
		/// </summary>
		public uint SizeOfImage { get; set; }

		/// <summary>
		/// Gets the MVID stored in the .NET metadata
		/// </summary>
		public Guid Mvid { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbCompilationMetadataReference() {
			Name = string.Empty;
			Aliases = string.Empty;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name of reference</param>
		/// <param name="aliases">Aliases (or an empty string), separated with commas</param>
		/// <param name="flags">Reference flags</param>
		/// <param name="timestamp">Timestamp in PE header</param>
		/// <param name="sizeOfImage">SizeOfImage in PE header</param>
		/// <param name="mvid">MVID stored in the .NET metadata</param>
		public PdbCompilationMetadataReference(string name, string aliases, PdbCompilationMetadataReferenceFlags flags, uint timestamp, uint sizeOfImage, Guid mvid) {
			Name = name;
			Aliases = aliases;
			Flags = flags;
			Timestamp = timestamp;
			SizeOfImage = sizeOfImage;
			Mvid = mvid;
		}
	}

	/// <summary>
	/// Compilation options
	/// </summary>
	public sealed class PdbCompilationOptionsCustomDebugInfo : PdbCustomDebugInfo {
		/// <summary>
		/// Returns <see cref="PdbCustomDebugInfoKind.CompilationOptions"/>
		/// </summary>
		public override PdbCustomDebugInfoKind Kind => PdbCustomDebugInfoKind.CompilationOptions;

		/// <summary>
		/// Gets the custom debug info guid, see <see cref="CustomDebugInfoGuids"/>
		/// </summary>
		public override Guid Guid => CustomDebugInfoGuids.CompilationOptions;

		/// <summary>
		/// Gets all compilation options, see https://github.com/dotnet/roslyn/blob/master/docs/features/pdb-compilation-options.md .
		/// Option names (key): see roslyn/src/Compilers/Core/Portable/PEWriter/CompilationOptionNames.cs
		/// </summary>
		public List<KeyValuePair<string, string>> Options { get; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbCompilationOptionsCustomDebugInfo() => Options = new List<KeyValuePair<string, string>>();
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A PDB document
	/// </summary>
	[DebuggerDisplay("{Url}")]
	public sealed class PdbDocument : IHasCustomDebugInformation {
		/// <summary>
		/// Gets/sets the document URL
		/// </summary>
		public string Url { get; set; }

		/// <summary>
		/// Gets/sets the language GUID. See <see cref="PdbDocumentConstants"/>
		/// </summary>
		public Guid Language { get; set; }

		/// <summary>
		/// Gets/sets the language vendor GUID. See <see cref="PdbDocumentConstants"/>
		/// </summary>
		public Guid LanguageVendor { get; set; }

		/// <summary>
		/// Gets/sets the document type GUID. See <see cref="PdbDocumentConstants"/>
		/// </summary>
		public Guid DocumentType { get; set; }

		/// <summary>
		/// Gets/sets the checksum algorithm ID. See <see cref="PdbDocumentConstants"/>
		/// </summary>
		public Guid CheckSumAlgorithmId { get; set; }

		/// <summary>
		/// Gets/sets the checksum
		/// </summary>
		public byte[] CheckSum { get; set; }

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 22;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos => customDebugInfos;
		IList<PdbCustomDebugInfo> customDebugInfos;

		/// <summary>
		/// Default constructor
		/// </summary>
		public PdbDocument() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="symDoc">A <see cref="SymbolDocument"/> instance</param>
		public PdbDocument(SymbolDocument symDoc) : this(symDoc, partial: false) {
		}

		PdbDocument(SymbolDocument symDoc, bool partial) {
			if (symDoc is null)
				throw new ArgumentNullException(nameof(symDoc));
			Url = symDoc.URL;
			if (!partial)
				Initialize(symDoc);
		}

		internal static PdbDocument CreatePartialForCompare(SymbolDocument symDoc) =>
			new PdbDocument(symDoc, partial: true);

		internal void Initialize(SymbolDocument symDoc) {
			Language = symDoc.Language;
			LanguageVendor = symDoc.LanguageVendor;
			DocumentType = symDoc.DocumentType;
			CheckSumAlgorithmId = symDoc.CheckSumAlgorithmId;
			CheckSum = symDoc.CheckSum;
			customDebugInfos = new List<PdbCustomDebugInfo>();
			foreach (var cdi in symDoc.CustomDebugInfos)
				customDebugInfos.Add(cdi);
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="url">Document URL</param>
		/// <param name="language">Language. See <see cref="PdbDocumentConstants"/></param>
		/// <param name="languageVendor">Language vendor. See <see cref="PdbDocumentConstants"/></param>
		/// <param name="documentType">Document type. See <see cref="PdbDocumentConstants"/></param>
		/// <param name="checkSumAlgorithmId">Checksum algorithm ID. See <see cref="PdbDocumentConstants"/></param>
		/// <param name="checkSum">Checksum</param>
		public PdbDocument(string url, Guid language, Guid languageVendor, Guid documentType, Guid checkSumAlgorithmId, byte[] checkSum) {
			Url = url;
			Language = language;
			LanguageVendor = languageVendor;
			DocumentType = documentType;
			CheckSumAlgorithmId = checkSumAlgorithmId;
			CheckSum = checkSum;
		}

		/// <inheritdoc/>
		public override int GetHashCode() => StringComparer.OrdinalIgnoreCase.GetHashCode(Url ?? string.Empty);

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			var other = obj as PdbDocument;
			if (other is null)
				return false;
			return StringComparer.OrdinalIgnoreCase.Equals(Url ?? string.Empty, other.Url ?? string.Empty);
		}
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB document constants
	/// </summary>
	public static class PdbDocumentConstants {
#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
		public static readonly Guid LanguageCSharp = new Guid("3F5162F8-07C6-11D3-9053-00C04FA302A1");
		public static readonly Guid LanguageVisualBasic = new Guid("3A12D0B8-C26C-11D0-B442-00A0244A1DD2");
		public static readonly Guid LanguageFSharp = new Guid("AB4F38C9-B6E6-43BA-BE3B-58080B2CCCE3");

		public static readonly Guid HashSHA1 = new Guid("FF1816EC-AA5E-4D10-87F7-6F4963833460");
		public static readonly Guid HashSHA256 = new Guid("8829D00F-11B8-4213-878B-770E8597AC16");

		public static readonly Guid LanguageVendorMicrosoft = new Guid("994B45C4-E6E9-11D2-903F-00C04FA302A1");

		public static readonly Guid DocumentTypeText = new Guid("5A869D0B-6611-11D3-BD2A-0000F80849BD");
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
	}
}




namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB file kind
	/// </summary>
	public enum PdbFileKind {
		/// <summary>
		/// Windows PDB
		/// </summary>
		WindowsPDB,

		/// <summary>
		/// Portable PDB
		/// </summary>
		PortablePDB,

		/// <summary>
		/// Embedded portable PDB
		/// </summary>
		EmbeddedPortablePDB,
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// Import scope
	/// </summary>
	public sealed class PdbImportScope : IHasCustomDebugInformation {
		readonly IList<PdbImport> imports = new List<PdbImport>();

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportScope() {
		}

		/// <summary>
		/// Gets/sets the parent import scope
		/// </summary>
		public PdbImportScope Parent { get; set; }

		/// <summary>
		/// Gets all imports
		/// </summary>
		public IList<PdbImport> Imports => imports;

		/// <summary>
		/// <c>true</c> if <see cref="Imports"/> is not empty
		/// </summary>
		public bool HasImports => imports.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 26;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos => customDebugInfos;
		readonly IList<PdbCustomDebugInfo> customDebugInfos = new List<PdbCustomDebugInfo>();
	}

	/// <summary>
	/// Import kind
	/// </summary>
	public enum PdbImportDefinitionKind {
#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
		ImportNamespace,
		ImportAssemblyNamespace,
		ImportType,
		ImportXmlNamespace,
		ImportAssemblyReferenceAlias,
		AliasAssemblyReference,
		AliasNamespace,
		AliasAssemblyNamespace,
		AliasType,
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
	}

	/// <summary>
	/// PDB import base class
	/// </summary>
	public abstract class PdbImport {
		/// <summary>
		/// Gets the import kind
		/// </summary>
		public abstract PdbImportDefinitionKind Kind { get; }

		internal abstract void PreventNewClasses();
	}

	/// <summary>
	/// Import namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind => PdbImportDefinitionKind.ImportNamespace;

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="targetNamespace"></param>
		public PdbImportNamespace(string targetNamespace) => TargetNamespace = targetNamespace;

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() => $"{Kind}: {TargetNamespace}";
	}

	/// <summary>
	/// Import assembly, namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportAssemblyNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportAssemblyNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind => PdbImportDefinitionKind.ImportAssemblyNamespace;

		/// <summary>
		/// Gets the target assembly
		/// </summary>
		public AssemblyRef TargetAssembly { get; set; }

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportAssemblyNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="targetAssembly"></param>
		/// <param name="targetNamespace"></param>
		public PdbImportAssemblyNamespace(AssemblyRef targetAssembly, string targetNamespace) {
			TargetAssembly = targetAssembly;
			TargetNamespace = targetNamespace;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() => $"{Kind}: {TargetAssembly} {TargetNamespace}";
	}

	/// <summary>
	/// Import type
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportType : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportType"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind => PdbImportDefinitionKind.ImportType;

		/// <summary>
		/// Gets the target type
		/// </summary>
		public ITypeDefOrRef TargetType { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportType() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="targetType"></param>
		public PdbImportType(ITypeDefOrRef targetType) => TargetType = targetType;

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() => $"{Kind}: {TargetType}";
	}

	/// <summary>
	/// Import xml namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportXmlNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportXmlNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind => PdbImportDefinitionKind.ImportXmlNamespace;

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportXmlNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetNamespace"></param>
		public PdbImportXmlNamespace(string alias, string targetNamespace) {
			Alias = alias;
			TargetNamespace = targetNamespace;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() => $"{Kind}: {Alias} = {TargetNamespace}";
	}

	/// <summary>
	/// Import assembly reference alias
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbImportAssemblyReferenceAlias : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.ImportAssemblyReferenceAlias"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind => PdbImportDefinitionKind.ImportAssemblyReferenceAlias;

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbImportAssemblyReferenceAlias() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		public PdbImportAssemblyReferenceAlias(string alias) => Alias = alias;

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() => $"{Kind}: {Alias}";
	}

	/// <summary>
	/// Alias assembly reference
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbAliasAssemblyReference : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.AliasAssemblyReference"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind => PdbImportDefinitionKind.AliasAssemblyReference;

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target assembly
		/// </summary>
		public AssemblyRef TargetAssembly { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAliasAssemblyReference() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetAssembly"></param>
		public PdbAliasAssemblyReference(string alias, AssemblyRef targetAssembly) {
			Alias = alias;
			TargetAssembly = targetAssembly;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() => $"{Kind}: {Alias} = {TargetAssembly}";
	}

	/// <summary>
	/// Alias namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbAliasNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.AliasNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind => PdbImportDefinitionKind.AliasNamespace;

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAliasNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetNamespace"></param>
		public PdbAliasNamespace(string alias, string targetNamespace) {
			Alias = alias;
			TargetNamespace = targetNamespace;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() => $"{Kind}: {Alias} = {TargetNamespace}";
	}

	/// <summary>
	/// Alias assembly namespace
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbAliasAssemblyNamespace : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.AliasAssemblyNamespace"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind => PdbImportDefinitionKind.AliasAssemblyNamespace;

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target assembly
		/// </summary>
		public AssemblyRef TargetAssembly { get; set; }

		/// <summary>
		/// Gets the target namespace
		/// </summary>
		public string TargetNamespace { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAliasAssemblyNamespace() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetAssembly"></param>
		/// <param name="targetNamespace"></param>
		public PdbAliasAssemblyNamespace(string alias, AssemblyRef targetAssembly, string targetNamespace) {
			Alias = alias;
			TargetAssembly = targetAssembly;
			TargetNamespace = targetNamespace;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() => $"{Kind}: {Alias} = {TargetAssembly} {TargetNamespace}";
	}

	/// <summary>
	/// Alias type
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public sealed class PdbAliasType : PdbImport {
		/// <summary>
		/// Returns <see cref="PdbImportDefinitionKind.AliasType"/>
		/// </summary>
		public sealed override PdbImportDefinitionKind Kind => PdbImportDefinitionKind.AliasType;

		/// <summary>
		/// Gets the alias
		/// </summary>
		public string Alias { get; set; }

		/// <summary>
		/// Gets the target type
		/// </summary>
		public ITypeDefOrRef TargetType { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbAliasType() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alias"></param>
		/// <param name="targetType"></param>
		public PdbAliasType(string alias, ITypeDefOrRef targetType) {
			Alias = alias;
			TargetType = targetType;
		}

		internal sealed override void PreventNewClasses() { }

		string GetDebuggerString() => $"{Kind}: {Alias} = {TargetType}";
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A local variable
	/// </summary>
	public sealed class PdbLocal : IHasCustomDebugInformation {
		/// <summary>
		/// Constructor
		/// </summary>
		public PdbLocal() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="local"></param>
		/// <param name="name"></param>
		/// <param name="attributes"></param>
		public PdbLocal(Local local, string name, PdbLocalAttributes attributes) {
			Local = local;
			Name = name;
			Attributes = attributes;
		}

		/// <summary>
		/// Gets/sets the local
		/// </summary>
		public Local Local { get; set; }

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public string Name { get; set; }

		/// <summary>
		/// Gets/sets the attributes
		/// </summary>
		public PdbLocalAttributes Attributes { get; set; }

		/// <summary>
		/// Gets the index of the local
		/// </summary>
		public int Index => Local.Index;

		/// <summary>
		/// true if it should be hidden in debugger variables windows. Not all compiler generated locals have this flag set.
		/// </summary>
		public bool IsDebuggerHidden {
			get => (Attributes & PdbLocalAttributes.DebuggerHidden) != 0;
			set {
				if (value)
					Attributes |= PdbLocalAttributes.DebuggerHidden;
				else
					Attributes &= ~PdbLocalAttributes.DebuggerHidden;
			}
		}

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 24;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos => customDebugInfos;
		readonly IList<PdbCustomDebugInfo> customDebugInfos = new List<PdbCustomDebugInfo>();
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// Local attributes
	/// </summary>
	[Flags]
	public enum PdbLocalAttributes {
		/// <summary>
		/// No bit is set
		/// </summary>
		None					= 0,

		/// <summary>
		/// Local should be hidden in debugger variables windows. Not all compiler generated locals have this flag set.
		/// </summary>
		DebuggerHidden			= 0x00000001,
	}
}




namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A PDB method
	/// </summary>
	public sealed class PdbMethod {
		/// <summary>
		/// Gets/sets the root scope. It contains all scopes of the method, using namespaces, variables and constants
		/// </summary>
		public PdbScope Scope { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbMethod() {
		}
	}
}





namespace dnlib.DotNet.Pdb {
	readonly struct PdbReaderContext {
		readonly IPEImage peImage;
		readonly ImageDebugDirectory codeViewDebugDir;

		public bool HasDebugInfo => codeViewDebugDir is not null;
		public ImageDebugDirectory CodeViewDebugDirectory => codeViewDebugDir;
		public PdbReaderOptions Options { get; }

		public PdbReaderContext(IPEImage peImage, PdbReaderOptions options) {
			this.peImage = peImage;
			Options = options;
			codeViewDebugDir = TryGetDebugDirectoryEntry(peImage, ImageDebugType.CodeView);
		}

		public ImageDebugDirectory TryGetDebugDirectoryEntry(ImageDebugType imageDebugType) =>
			TryGetDebugDirectoryEntry(peImage, imageDebugType);

		static ImageDebugDirectory TryGetDebugDirectoryEntry(IPEImage peImage, ImageDebugType imageDebugType) {
			var list = peImage.ImageDebugDirectories;
			int count = list.Count;
			for (int i = 0; i < count; i++) {
				var entry = list[i];
				if (entry.Type == imageDebugType)
					return entry;
			}
			return null;
		}

		public bool TryGetCodeViewData(out Guid guid, out uint age) => TryGetCodeViewData(out guid, out age, out _);

		public bool TryGetCodeViewData(out Guid guid, out uint age, out string pdbFilename) {
			guid = Guid.Empty;
			age = 0;
			pdbFilename = null;
			var reader = GetCodeViewDataReader();
			// magic, guid, age, zero-terminated string
			if (reader.Length < 4 + 16 + 4 + 1)
				return false;
			if (reader.ReadUInt32() != 0x53445352)
				return false;
			guid = reader.ReadGuid();
			age = reader.ReadUInt32();
			pdbFilename = reader.TryReadZeroTerminatedUtf8String();
			return pdbFilename is not null;
		}

		DataReader GetCodeViewDataReader() {
			if (codeViewDebugDir is null)
				return default;
			return CreateReader(codeViewDebugDir.AddressOfRawData, codeViewDebugDir.SizeOfData);
		}

		public DataReader CreateReader(RVA rva, uint size) {
			if (rva == 0 || size == 0)
				return default;
			var reader = peImage.CreateReader(rva, size);
			if (reader.Length != size)
				return default;
			return reader;
		}
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB reader options
	/// </summary>
	[Flags]
	public enum PdbReaderOptions {
		/// <summary>
		/// No bit is set
		/// </summary>
		None					= 0,

		/// <summary>
		/// Use the COM Windows PDB reader instead of the managed Windows PDB reader.
		/// 
		/// This is NOT recommended since the COM reader can only be called on the same
		/// thread it was created on. It also requires a Windows OS.
		/// 
		/// If this is not set, the managed PDB reader will be used.
		/// 
		/// This option is only used if it's a Windows PDB file, not if it's a Portable PDB file.
		/// </summary>
		MicrosoftComReader		= 0x00000001,

		/// <summary>
		/// Don't use Microsoft.DiaSymReader.Native. This is a NuGet package with an updated Windows PDB reader/writer implementation,
		/// and if it's available at runtime, dnlib will try to use it. If this option is set, dnlib won't use it.
		/// You have to add a reference to the NuGet package if you want to use it, dnlib has no reference to the NuGet package.
		/// 
		/// Only used if <see cref="MicrosoftComReader"/> is set and if it's a Windows PDB file
		/// </summary>
		NoDiaSymReader			= 0x00000002,

		/// <summary>
		/// Don't use diasymreader.dll's PDB reader that is shipped with .NET Framework.
		/// 
		/// Only used if <see cref="MicrosoftComReader"/> is set and if it's a Windows PDB file
		/// </summary>
		NoOldDiaSymReader		= 0x00000004,
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// A PDB scope
	/// </summary>
	[DebuggerDisplay("{Start} - {End}")]
	public sealed class PdbScope : IHasCustomDebugInformation {
		readonly IList<PdbScope> scopes = new List<PdbScope>();
		readonly IList<PdbLocal> locals = new List<PdbLocal>();
		readonly IList<string> namespaces = new List<string>();
		readonly IList<PdbConstant> constants = new List<PdbConstant>();

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbScope() {
		}

		/// <summary>
		/// Gets/sets the first instruction
		/// </summary>
		public Instruction Start { get; set; }

		/// <summary>
		/// Gets/sets the last instruction. It's <c>null</c> if it ends at the end of the method.
		/// </summary>
		public Instruction End { get; set; }

		/// <summary>
		/// Gets all child scopes
		/// </summary>
		public IList<PdbScope> Scopes => scopes;

		/// <summary>
		/// <c>true</c> if <see cref="Scopes"/> is not empty
		/// </summary>
		public bool HasScopes => scopes.Count > 0;

		/// <summary>
		/// Gets all locals in this scope
		/// </summary>
		public IList<PdbLocal> Variables => locals;

		/// <summary>
		/// <c>true</c> if <see cref="Variables"/> is not empty
		/// </summary>
		public bool HasVariables => locals.Count > 0;

		/// <summary>
		/// Gets all namespaces (Windows PDBs). Portable PDBs use <see cref="ImportScope"/>
		/// </summary>
		public IList<string> Namespaces => namespaces;

		/// <summary>
		/// <c>true</c> if <see cref="Namespaces"/> is not empty
		/// </summary>
		public bool HasNamespaces => namespaces.Count > 0;

		/// <summary>
		/// Gets/sets the import scope (Portable PDBs). Windows PDBs use <see cref="Namespaces"/>
		/// </summary>
		public PdbImportScope ImportScope { get; set; }

		/// <summary>
		/// Gets all constants
		/// </summary>
		public IList<PdbConstant> Constants => constants;

		/// <summary>
		/// <c>true</c> if <see cref="Constants"/> is not empty
		/// </summary>
		public bool HasConstants => constants.Count > 0;

		/// <inheritdoc/>
		public int HasCustomDebugInformationTag => 23;

		/// <inheritdoc/>
		public bool HasCustomDebugInfos => CustomDebugInfos.Count > 0;

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public IList<PdbCustomDebugInfo> CustomDebugInfos => customDebugInfos;
		readonly IList<PdbCustomDebugInfo> customDebugInfos = new List<PdbCustomDebugInfo>();
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB state for a <see cref="ModuleDef"/>
	/// </summary>
	public sealed class PdbState {
		readonly SymbolReader reader;
		readonly Dictionary<PdbDocument, PdbDocument> docDict = new Dictionary<PdbDocument, PdbDocument>();
		MethodDef userEntryPoint;
		readonly Compiler compiler;
		readonly PdbFileKind originalPdbFileKind;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Gets/sets the PDB file kind. You can change it from portable PDB to embedded portable PDB
		/// and vice versa. Converting a Windows PDB to a portable PDB isn't supported.
		/// </summary>
		public PdbFileKind PdbFileKind { get; set; }

		/// <summary>
		/// Gets/sets the user entry point method.
		/// </summary>
		public MethodDef UserEntryPoint {
			get => userEntryPoint;
			set => userEntryPoint = value;
		}

		/// <summary>
		/// Gets all PDB documents
		/// </summary>
		public IEnumerable<PdbDocument> Documents {
			get {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
					return new List<PdbDocument>(docDict.Values);
				} finally { theLock.ExitWriteLock(); }
#else
				return docDict.Values;
#endif
			}
		}

		/// <summary>
		/// <c>true</c> if <see cref="Documents"/> is not empty
		/// </summary>
		public bool HasDocuments {
			get {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				return docDict.Count > 0;
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
		
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="pdbFileKind">PDB file kind</param>
		public PdbState(ModuleDef module, PdbFileKind pdbFileKind) {
			if (module is null)
				throw new ArgumentNullException(nameof(module));
			compiler = CalculateCompiler(module);
			PdbFileKind = pdbFileKind;
			originalPdbFileKind = pdbFileKind;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">A <see cref="SymbolReader"/> instance</param>
		/// <param name="module">Owner module</param>
		public PdbState(SymbolReader reader, ModuleDefMD module) {
			if (module is null)
				throw new ArgumentNullException(nameof(module));
			this.reader = reader ?? throw new ArgumentNullException(nameof(reader));
			reader.Initialize(module);
			PdbFileKind = reader.PdbFileKind;
			originalPdbFileKind = reader.PdbFileKind;
			compiler = CalculateCompiler(module);

			userEntryPoint = module.ResolveToken(reader.UserEntryPoint) as MethodDef;

			var documents = reader.Documents;
			int count = documents.Count;
			for (int i = 0; i < count; i++)
				Add_NoLock(documents[i]);
		}

		/// <summary>
		/// Adds <paramref name="doc"/>
		/// </summary>
		/// <param name="doc">New document</param>
		/// <returns><paramref name="doc"/> if it wasn't inserted, or the already existing document
		/// if it was already inserted.</returns>
		public PdbDocument Add(PdbDocument doc) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return Add_NoLock(doc);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		PdbDocument Add_NoLock(PdbDocument doc) {
			if (docDict.TryGetValue(doc, out var orig))
				return orig;
			docDict.Add(doc, doc);
			return doc;
		}

		PdbDocument Add_NoLock(SymbolDocument symDoc) {
			var doc = PdbDocument.CreatePartialForCompare(symDoc);
			if (docDict.TryGetValue(doc, out var orig))
				return orig;
			// Expensive part, can read source code etc
			doc.Initialize(symDoc);
			docDict.Add(doc, doc);
			return doc;
		}

		/// <summary>
		/// Removes <paramref name="doc"/>
		/// </summary>
		/// <param name="doc">Document</param>
		/// <returns><c>true</c> if it was removed, <c>false</c> if it wasn't inserted.</returns>
		public bool Remove(PdbDocument doc) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return docDict.Remove(doc);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Returns an inserted <see cref="PdbDocument"/> instance or <c>null</c> if it's not been
		/// inserted yet.
		/// </summary>
		/// <param name="doc">A PDB document</param>
		/// <returns>The existing <see cref="PdbDocument"/> or <c>null</c> if it doesn't exist.</returns>
		public PdbDocument GetExisting(PdbDocument doc) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			docDict.TryGetValue(doc, out var orig);
			return orig;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		/// <summary>
		/// Removes all documents
		/// </summary>
		/// <returns></returns>
		public void RemoveAllDocuments() => RemoveAllDocuments(false);

		/// <summary>
		/// Removes all documents and optionally returns them
		/// </summary>
		/// <param name="returnDocs"><c>true</c> if all the original <see cref="PdbDocument"/>s
		/// should be returned.</param>
		/// <returns>All <see cref="PdbDocument"/>s if <paramref name="returnDocs"/> is <c>true</c>
		/// or <c>null</c> if <paramref name="returnDocs"/> is <c>false</c>.</returns>
		public List<PdbDocument> RemoveAllDocuments(bool returnDocs) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			var docs = returnDocs ? new List<PdbDocument>(docDict.Values) : null;
			docDict.Clear();
			return docs;
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		internal Compiler Compiler => compiler;

		internal void InitializeMethodBody(ModuleDefMD module, MethodDef ownerMethod, CilBody body) {
			if (reader is null)
				return;

			var method = reader.GetMethod(ownerMethod, 1);
			if (method is not null) {
				var pdbMethod = new PdbMethod();
				pdbMethod.Scope = CreateScope(module, GenericParamContext.Create(ownerMethod), body, method.RootScope);
				AddSequencePoints(body, method);
				body.PdbMethod = pdbMethod;
			}
		}

		internal void InitializeCustomDebugInfos(MethodDef ownerMethod, CilBody body, IList<PdbCustomDebugInfo> customDebugInfos) {
			if (reader is null)
				return;

			var method = reader.GetMethod(ownerMethod, 1);
			if (method is not null)
				method.GetCustomDebugInfos(ownerMethod, body, customDebugInfos);
		}

		static Compiler CalculateCompiler(ModuleDef module) {
			if (module is null)
				return Compiler.Other;

			foreach (var asmRef in module.GetAssemblyRefs()) {
				if (asmRef.Name == nameAssemblyVisualBasic || asmRef.Name == nameAssemblyVisualBasicCore)
					return Compiler.VisualBasic;
			}

// Disable this for now, we shouldn't be resolving types this early since we could be called by the ModuleDefMD ctor
#if false
			// The VB runtime can also be embedded, and if so, it seems that "Microsoft.VisualBasic.Embedded"
			// attribute is added to the assembly's custom attributes.
			var asm = module.Assembly;
			if (asm is not null && asm.CustomAttributes.IsDefined("Microsoft.VisualBasic.Embedded"))
				return Compiler.VisualBasic;
#endif

			return Compiler.Other;
		}
		static readonly UTF8String nameAssemblyVisualBasic = new UTF8String("Microsoft.VisualBasic");
		// .NET Core 3.0 has this assembly because Microsoft.VisualBasic contains WinForms refs
		static readonly UTF8String nameAssemblyVisualBasicCore = new UTF8String("Microsoft.VisualBasic.Core");

		void AddSequencePoints(CilBody body, SymbolMethod method) {
			int instrIndex = 0;
			var sequencePoints = method.SequencePoints;
			int count = sequencePoints.Count;
			for (int i = 0; i < count; i++) {
				var sp = sequencePoints[i];
				var instr = GetInstruction(body.Instructions, sp.Offset, ref instrIndex);
				if (instr is null)
					continue;
				var seqPoint = new SequencePoint() {
					Document = Add_NoLock(sp.Document),
					StartLine = sp.Line,
					StartColumn = sp.Column,
					EndLine = sp.EndLine,
					EndColumn = sp.EndColumn,
				};
				instr.SequencePoint = seqPoint;
			}
		}

		struct CreateScopeState {
			public SymbolScope SymScope;
			public PdbScope PdbScope;
			public IList<SymbolScope> Children;
			public int ChildrenIndex;
		}

		PdbScope CreateScope(ModuleDefMD module, GenericParamContext gpContext, CilBody body, SymbolScope symScope) {
			if (symScope is null)
				return null;

			// Don't use recursive calls
			var stack = new Stack<CreateScopeState>();
			var state = new CreateScopeState() { SymScope = symScope };
			int endIsInclusiveValue = PdbUtils.IsEndInclusive(originalPdbFileKind, Compiler) ? 1 : 0;
recursive_call:
			int instrIndex = 0;
			state.PdbScope = new PdbScope() {
				Start = GetInstruction(body.Instructions, state.SymScope.StartOffset, ref instrIndex),
				End   = GetInstruction(body.Instructions, state.SymScope.EndOffset + endIsInclusiveValue, ref instrIndex),
			};
			var cdis = state.SymScope.CustomDebugInfos;
			int count = cdis.Count;
			for (int i = 0; i < count; i++)
				state.PdbScope.CustomDebugInfos.Add(cdis[i]);

			var locals = state.SymScope.Locals;
			count = locals.Count;
			for (int i = 0; i < count; i++) {
				var symLocal = locals[i];
				int localIndex = symLocal.Index;
				if ((uint)localIndex >= (uint)body.Variables.Count) {
					// VB sometimes creates a PDB local without a metadata local
					continue;
				}
				var local = body.Variables[localIndex];
				var name = symLocal.Name;
				local.SetName(name);
				var attributes = symLocal.Attributes;
				local.SetAttributes(attributes);
				var pdbLocal = new PdbLocal(local, name, attributes);
				cdis = symLocal.CustomDebugInfos;
				int count2 = cdis.Count;
				for (int j = 0; j < count2; j++)
					pdbLocal.CustomDebugInfos.Add(cdis[j]);
				state.PdbScope.Variables.Add(pdbLocal);
			}

			var namespaces = state.SymScope.Namespaces;
			count = namespaces.Count;
			for (int i = 0; i < count; i++)
				state.PdbScope.Namespaces.Add(namespaces[i].Name);
			state.PdbScope.ImportScope = state.SymScope.ImportScope;

			var constants = state.SymScope.GetConstants(module, gpContext);
			for (int i = 0; i < constants.Count; i++) {
				var constant = constants[i];
				var type = constant.Type.RemovePinnedAndModifiers();
				if (type is not null) {
					// Fix a few values since they're stored as some other type in the PDB
					switch (type.ElementType) {
					case ElementType.Boolean:
						if (constant.Value is short)
							constant.Value = (short)constant.Value != 0;
						break;
					case ElementType.Char:
						if (constant.Value is ushort)
							constant.Value = (char)(ushort)constant.Value;
						break;
					case ElementType.I1:
						if (constant.Value is short)
							constant.Value = (sbyte)(short)constant.Value;
						break;
					case ElementType.U1:
						if (constant.Value is short)
							constant.Value = (byte)(short)constant.Value;
						break;
					case ElementType.I2:
					case ElementType.U2:
					case ElementType.I4:
					case ElementType.U4:
					case ElementType.I8:
					case ElementType.U8:
					case ElementType.R4:
					case ElementType.R8:
					case ElementType.Void:
					case ElementType.Ptr:
					case ElementType.ByRef:
					case ElementType.TypedByRef:
					case ElementType.I:
					case ElementType.U:
					case ElementType.FnPtr:
					case ElementType.ValueType:
						break;
					case ElementType.String:
						if (PdbFileKind == PdbFileKind.WindowsPDB) {
							// "" is stored as null, and null is stored as (int)0
							if (constant.Value is int && (int)constant.Value == 0)
								constant.Value = null;
							else if (constant.Value is null)
								constant.Value = string.Empty;
						}
						else
							Debug.Assert(PdbFileKind == PdbFileKind.PortablePDB || PdbFileKind == PdbFileKind.EmbeddedPortablePDB);
						break;
					case ElementType.Object:
					case ElementType.Class:
					case ElementType.SZArray:
					case ElementType.Array:
					default:
						if (constant.Value is int && (int)constant.Value == 0)
							constant.Value = null;
						break;
					case ElementType.GenericInst:
						var gis = (GenericInstSig)type;
						if (gis.GenericType is ValueTypeSig)
							break;
						goto case ElementType.Class;
					case ElementType.Var:
					case ElementType.MVar:
						var gp = ((GenericSig)type).GenericParam;
						if (gp is not null) {
							if (gp.HasNotNullableValueTypeConstraint)
								break;
							if (gp.HasReferenceTypeConstraint)
								goto case ElementType.Class;
						}
						break;
					}
				}
				state.PdbScope.Constants.Add(constant);
			}

			// Here's the now somewhat obfuscated for loop
			state.ChildrenIndex = 0;
			state.Children = state.SymScope.Children;
do_return:
			if (state.ChildrenIndex < state.Children.Count) {
				var child = state.Children[state.ChildrenIndex];
				stack.Push(state);
				state = new CreateScopeState() { SymScope = child };
				goto recursive_call;
			}

			if (stack.Count == 0)
				return state.PdbScope;

			// Return from recursive call, and execute the last part of the for loop
			var newPdbScope = state.PdbScope;
			state = stack.Pop();
			state.PdbScope.Scopes.Add(newPdbScope);
			state.ChildrenIndex++;
			goto do_return;
		}

		static Instruction GetInstruction(IList<Instruction> instrs, int offset, ref int index) {
			if (instrs.Count > 0 && offset > instrs[instrs.Count - 1].Offset)
				return null;
			for (int i = index; i < instrs.Count; i++) {
				var instr = instrs[i];
				if (instr.Offset < offset)
					continue;
				if (instr.Offset == offset) {
					index = i;
					return instr;
				}
				break;
			}
			for (int i = 0; i < index; i++) {
				var instr = instrs[i];
				if (instr.Offset < offset)
					continue;
				if (instr.Offset == offset) {
					index = i;
					return instr;
				}
				break;
			}
			return null;
		}

		internal void InitializeCustomDebugInfos(MDToken token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
			Debug.Assert(token.Table != Table.Method, "Methods get initialized when reading the method bodies");
			reader?.GetCustomDebugInfos(token.ToInt32(), gpContext, result);
		}

		internal void Dispose() => reader?.Dispose();
	}

	enum Compiler {
		Other,
		VisualBasic,
	}
}




namespace dnlib.DotNet.Pdb {
	static class PdbUtils {
		public static bool IsEndInclusive(PdbFileKind pdbFileKind, Compiler compiler) =>
			pdbFileKind == PdbFileKind.WindowsPDB && compiler == Compiler.VisualBasic;
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// PDB sequence point
	/// </summary>
	[DebuggerDisplay("({StartLine}, {StartColumn}) - ({EndLine}, {EndColumn}) {Document.Url}")]
	public sealed class SequencePoint {
		/// <summary>
		/// PDB document
		/// </summary>
		public PdbDocument Document { get; set; }

		/// <summary>
		/// Start line
		/// </summary>
		public int StartLine { get; set; }

		/// <summary>
		/// Start column
		/// </summary>
		public int StartColumn { get; set; }

		/// <summary>
		/// End line
		/// </summary>
		public int EndLine { get; set; }

		/// <summary>
		/// End column
		/// </summary>
		public int EndColumn { get; set; }

		/// <summary>
		/// Clones this instance
		/// </summary>
		/// <returns>A new cloned instance</returns>
		public SequencePoint Clone() {
			return new SequencePoint() {
				Document = Document,
				StartLine = StartLine,
				StartColumn = StartColumn,
				EndLine = EndLine,
				EndColumn = EndColumn,
			};
		}
	}
}





namespace dnlib.DotNet.Pdb {
	static class SymbolReaderFactory {
		public static SymbolReader CreateFromAssemblyFile(PdbReaderOptions options, MD.Metadata metadata, string assemblyFileName) {
			var pdbContext = new PdbReaderContext(metadata.PEImage, options);
			if (!pdbContext.HasDebugInfo)
				return null;
			if (!pdbContext.TryGetCodeViewData(out var guid, out uint age, out var pdbWindowsFilename))
				return null;

			string pdbFilename;
			int index = pdbWindowsFilename.LastIndexOfAny(windowsPathSepChars);
			if (index >= 0)
				pdbFilename = pdbWindowsFilename.Substring(index + 1);
			else
				pdbFilename = pdbWindowsFilename;

			string fileToCheck;
			try {
				fileToCheck = assemblyFileName == string.Empty ? pdbFilename : Path.Combine(Path.GetDirectoryName(assemblyFileName), pdbFilename);
				if (!File.Exists(fileToCheck)) {
					var ext = Path.GetExtension(pdbFilename);
					if (string.IsNullOrEmpty(ext))
						ext = "pdb";
					fileToCheck = Path.ChangeExtension(assemblyFileName, ext);
				}
			}
			catch (ArgumentException) {
				return null;// Invalid filename
			}
			return Create(options, metadata, fileToCheck);
		}
		static readonly char[] windowsPathSepChars = new char[] { '\\', '/' };

		public static SymbolReader Create(PdbReaderOptions options, MD.Metadata metadata, string pdbFileName) {
			var pdbContext = new PdbReaderContext(metadata.PEImage, options);
			if (!pdbContext.HasDebugInfo)
				return null;
			return CreateCore(pdbContext, metadata, DataReaderFactoryUtils.TryCreateDataReaderFactory(pdbFileName));
		}

		public static SymbolReader Create(PdbReaderOptions options, MD.Metadata metadata, byte[] pdbData) {
			var pdbContext = new PdbReaderContext(metadata.PEImage, options);
			if (!pdbContext.HasDebugInfo)
				return null;
			return CreateCore(pdbContext, metadata, ByteArrayDataReaderFactory.Create(pdbData, filename: null));
		}

		public static SymbolReader Create(PdbReaderOptions options, MD.Metadata metadata, DataReaderFactory pdbStream) {
			var pdbContext = new PdbReaderContext(metadata.PEImage, options);
			return CreateCore(pdbContext, metadata, pdbStream);
		}

		static SymbolReader CreateCore(PdbReaderContext pdbContext, MD.Metadata metadata, DataReaderFactory pdbStream) {
			SymbolReader symReader = null;
			bool error = true;
			try {
				if (!pdbContext.HasDebugInfo)
					return null;

				if ((pdbContext.Options & PdbReaderOptions.MicrosoftComReader) != 0 && pdbStream is not null && IsWindowsPdb(pdbStream.CreateReader()))
					symReader = Dss.SymbolReaderWriterFactory.Create(pdbContext, metadata, pdbStream);
				else
					symReader = CreateManaged(pdbContext, metadata, pdbStream);

				if (symReader is not null) {
					error = false;
					return symReader;
				}
			}
			catch (IOException) {
			}
			finally {
				if (error) {
					pdbStream?.Dispose();
					symReader?.Dispose();
				}
			}
			return null;
		}

		static bool IsWindowsPdb(DataReader reader) {
			const string SIG = "Microsoft C/C++ MSF 7.00\r\n\u001ADS\0";
			if (!reader.CanRead(SIG.Length))
				return false;
			return reader.ReadString(SIG.Length, Encoding.ASCII) == SIG;
		}

		public static SymbolReader TryCreateEmbeddedPdbReader(PdbReaderOptions options, MD.Metadata metadata) {
			var pdbContext = new PdbReaderContext(metadata.PEImage, options);
			if (!pdbContext.HasDebugInfo)
				return null;
			return TryCreateEmbeddedPortablePdbReader(pdbContext, metadata);
		}

		static SymbolReader CreateManaged(PdbReaderContext pdbContext, MD.Metadata metadata, DataReaderFactory pdbStream) {
			try {
				// Embedded PDBs have priority
				var embeddedReader = TryCreateEmbeddedPortablePdbReader(pdbContext, metadata);
				if (embeddedReader is not null) {
					pdbStream?.Dispose();
					return embeddedReader;
				}

				return CreateManagedCore(pdbContext, pdbStream);
			}
			catch {
				pdbStream?.Dispose();
				throw;
			}
		}

		static SymbolReader CreateManagedCore(PdbReaderContext pdbContext, DataReaderFactory pdbStream) {
			if (pdbStream is null)
				return null;
			try {
				var reader = pdbStream.CreateReader();
				if (reader.Length >= 4) {
					uint sig = reader.ReadUInt32();
					if (sig == 0x424A5342)
						return Portable.SymbolReaderFactory.TryCreate(pdbContext, pdbStream, isEmbeddedPortablePdb: false);
					return Managed.SymbolReaderFactory.Create(pdbContext, pdbStream);
				}
			}
			catch (IOException) {
			}
			pdbStream?.Dispose();
			return null;
		}

		static SymbolReader TryCreateEmbeddedPortablePdbReader(PdbReaderContext pdbContext, MD.Metadata metadata) =>
			Portable.SymbolReaderFactory.TryCreateEmbeddedPortablePdbReader(pdbContext, metadata);
	}
}





namespace dnlib.DotNet.Pdb {
	/// <summary>
	/// Custom debug info guids
	/// </summary>
	public static class CustomDebugInfoGuids {
#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
		// Roslyn: PortableCustomDebugInfoKinds.cs
		public static readonly Guid AsyncMethodSteppingInformationBlob = new Guid("54FD2AC5-E925-401A-9C2A-F94F171072F8");
		public static readonly Guid DefaultNamespace = new Guid("58B2EAB6-209F-4E4E-A22C-B2D0F910C782");
		public static readonly Guid DynamicLocalVariables = new Guid("83C563C4-B4F3-47D5-B824-BA5441477EA8");
		public static readonly Guid EmbeddedSource = new Guid("0E8A571B-6926-466E-B4AD-8AB04611F5FE");
		public static readonly Guid EncLambdaAndClosureMap = new Guid("A643004C-0240-496F-A783-30D64F4979DE");
		public static readonly Guid EncLocalSlotMap = new Guid("755F52A8-91C5-45BE-B4B8-209571E552BD");
		public static readonly Guid SourceLink = new Guid("CC110556-A091-4D38-9FEC-25AB9A351A6A");
		public static readonly Guid StateMachineHoistedLocalScopes = new Guid("6DA9A61E-F8C7-4874-BE62-68BC5630DF71");
		public static readonly Guid TupleElementNames = new Guid("ED9FDF71-8879-4747-8ED3-FE5EDE3CE710");
		public static readonly Guid CompilationMetadataReferences = new Guid("7E4D4708-096E-4C5C-AEDA-CB10BA6A740D");
		public static readonly Guid CompilationOptions = new Guid("B5FEEC05-8CD0-4A83-96DA-466284BB4BD8");
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed class DataReaderIStream : IStream, IDisposable {
		readonly DataReaderFactory dataReaderFactory;
		DataReader reader;
		readonly string name;

		const int STG_E_INVALIDFUNCTION = unchecked((int)0x80030001);
		const int STG_E_CANTSAVE = unchecked((int)0x80030103);

		public DataReaderIStream(DataReaderFactory dataReaderFactory)
			: this(dataReaderFactory, dataReaderFactory.CreateReader(), string.Empty) {
		}

		DataReaderIStream(DataReaderFactory dataReaderFactory, DataReader reader, string name) {
			this.dataReaderFactory = dataReaderFactory ?? throw new ArgumentNullException(nameof(dataReaderFactory));
			this.reader = reader;
			this.name = name ?? string.Empty;
		}

		public void Clone(out IStream ppstm) => ppstm = new DataReaderIStream(dataReaderFactory, reader, name);

		public void Commit(int grfCommitFlags) {
		}

		public void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten) {
			if (cb > int.MaxValue)
				cb = int.MaxValue;
			else if (cb < 0)
				cb = 0;
			int sizeToRead = (int)cb;

			if ((ulong)reader.Position + (uint)sizeToRead > reader.Length)
				sizeToRead = (int)(reader.Length - Math.Min(reader.Position, reader.Length));

			var buffer = new byte[sizeToRead];
			Read(buffer, sizeToRead, pcbRead);
			if (pcbRead != IntPtr.Zero)
				Marshal.WriteInt64(pcbRead, Marshal.ReadInt32(pcbRead));
			pstm.Write(buffer, buffer.Length, pcbWritten);
			if (pcbWritten != IntPtr.Zero)
				Marshal.WriteInt64(pcbWritten, Marshal.ReadInt32(pcbWritten));
		}

		public void LockRegion(long libOffset, long cb, int dwLockType) => Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);

		public void Read(byte[] pv, int cb, IntPtr pcbRead) {
			if (cb < 0)
				cb = 0;

			cb = (int)Math.Min(reader.BytesLeft, (uint)cb);
			reader.ReadBytes(pv, 0, cb);

			if (pcbRead != IntPtr.Zero)
				Marshal.WriteInt32(pcbRead, cb);
		}

		public void Revert() {
		}

		enum STREAM_SEEK {
			SET = 0,
			CUR = 1,
			END = 2,
		}

		public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition) {
			switch ((STREAM_SEEK)dwOrigin) {
			case STREAM_SEEK.SET:
				reader.Position = (uint)dlibMove;
				break;

			case STREAM_SEEK.CUR:
				reader.Position = (uint)(reader.Position + dlibMove);
				break;

			case STREAM_SEEK.END:
				reader.Position = (uint)(reader.Length + dlibMove);
				break;
			}

			if (plibNewPosition != IntPtr.Zero)
				Marshal.WriteInt64(plibNewPosition, reader.Position);
		}

		public void SetSize(long libNewSize) => Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);

		enum STATFLAG {
			DEFAULT = 0,
			NONAME = 1,
			NOOPEN = 2,
		}

		enum STGTY {
			STORAGE = 1,
			STREAM = 2,
			LOCKBYTES = 3,
			PROPERTY = 4,
		}

		public void Stat(out System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag) {
			var s = new System.Runtime.InteropServices.ComTypes.STATSTG();

			// s.atime = ???;
			s.cbSize = reader.Length;
			s.clsid = Guid.Empty;
			// s.ctime = ???;
			s.grfLocksSupported = 0;
			s.grfMode = 0;
			s.grfStateBits = 0;
			// s.mtime = ???;
			if ((grfStatFlag & (int)STATFLAG.NONAME) == 0)
				s.pwcsName = name;
			s.reserved = 0;
			s.type = (int)STGTY.STREAM;

			pstatstg = s;
		}

		public void UnlockRegion(long libOffset, long cb, int dwLockType) => Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);
		public void Write(byte[] pv, int cb, IntPtr pcbWritten) => Marshal.ThrowExceptionForHR(STG_E_CANTSAVE);
		public void Dispose() { }
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed unsafe class MDEmitter : MetaDataImport, IMetaDataEmit {
		readonly Writer.Metadata metadata;
		readonly Dictionary<uint, TypeDef> tokenToTypeDef;
		readonly Dictionary<uint, MethodDef> tokenToMethodDef;

		public MDEmitter(Writer.Metadata metadata) {
			this.metadata = metadata;

			// We could get these from the metadata tables but it's just easier to get name,
			// declaring type etc using TypeDef and MethodDef.

			tokenToTypeDef = new Dictionary<uint, TypeDef>(metadata.TablesHeap.TypeDefTable.Rows);
			tokenToMethodDef = new Dictionary<uint, MethodDef>(metadata.TablesHeap.MethodTable.Rows);
			foreach (var type in metadata.Module.GetTypes()) {
				if (type is null)
					continue;
				tokenToTypeDef.Add(new MDToken(MD.Table.TypeDef, metadata.GetRid(type)).Raw, type);
				foreach (var method in type.Methods) {
					if (method is null)
						continue;
					tokenToMethodDef.Add(new MDToken(MD.Table.Method, metadata.GetRid(method)).Raw, method);
				}
			}
		}

		public override void GetMethodProps(uint mb, uint* pClass, ushort* szMethod, uint cchMethod, uint* pchMethod, uint* pdwAttr, IntPtr* ppvSigBlob, uint* pcbSigBlob, uint* pulCodeRVA, uint* pdwImplFlags) {
			if ((mb >> 24) != 0x06)
				throw new ArgumentException();
			var method = tokenToMethodDef[mb];
			var row = metadata.TablesHeap.MethodTable[mb & 0x00FFFFFF];

			if (pClass is not null)
				*pClass = new MDToken(MD.Table.TypeDef, metadata.GetRid(method.DeclaringType)).Raw;
			if (pdwAttr is not null)
				*pdwAttr = row.Flags;
			if (ppvSigBlob is not null)
				*ppvSigBlob = IntPtr.Zero;
			if (pcbSigBlob is not null)
				*pcbSigBlob = 0;
			if (pulCodeRVA is not null)
				*pulCodeRVA = row.RVA;
			if (pdwImplFlags is not null)
				*pdwImplFlags = row.ImplFlags;

			string name = method.Name.String ?? string.Empty;
			int len = (int)Math.Min((uint)name.Length + 1, cchMethod);
			if (szMethod is not null) {
				for (int i = 0; i < len - 1; i++, szMethod++)
					*szMethod = (ushort)name[i];
				if (len > 0)
					*szMethod = 0;
			}
			if (pchMethod is not null)
				*pchMethod = (uint)len;
		}

		public override void GetTypeDefProps(uint td, ushort* szTypeDef, uint cchTypeDef, uint* pchTypeDef, uint* pdwTypeDefFlags, uint* ptkExtends) {
			if ((td >> 24) != 0x02)
				throw new ArgumentException();
			var type = tokenToTypeDef[td];
			var row = metadata.TablesHeap.TypeDefTable[td & 0x00FFFFFF];
			if (pdwTypeDefFlags is not null)
				*pdwTypeDefFlags = row.Flags;
			if (ptkExtends is not null)
				*ptkExtends = row.Extends;
			CopyTypeName(type.Namespace, type.Name, szTypeDef, cchTypeDef, pchTypeDef);
		}

		public override void GetNestedClassProps(uint tdNestedClass, uint* ptdEnclosingClass) {
			if ((tdNestedClass >> 24) != 0x02)
				throw new ArgumentException();
			var type = tokenToTypeDef[tdNestedClass];
			var declType = type.DeclaringType;
			if (ptdEnclosingClass is not null) {
				if (declType is null)
					*ptdEnclosingClass = 0;
				else
					*ptdEnclosingClass = new MDToken(MD.Table.TypeDef, metadata.GetRid(declType)).Raw;
			}
		}

		void IMetaDataEmit.GetTokenFromSig(IntPtr pvSig, uint cbSig, out uint pmsig) => pmsig = 0x11000000;

		// The rest of the methods aren't called

		void IMetaDataEmit.SetModuleProps(string szName) => throw new NotImplementedException();
		void IMetaDataEmit.Save(string szFile, uint dwSaveFlags) => throw new NotImplementedException();
		void IMetaDataEmit.SaveToStream(IStream pIStream, uint dwSaveFlags) => throw new NotImplementedException();
		void IMetaDataEmit.GetSaveSize(int fSave, out uint pdwSaveSize) => throw new NotImplementedException();
		void IMetaDataEmit.DefineTypeDef(string szTypeDef, uint dwTypeDefFlags, uint tkExtends, uint[] rtkImplements, out uint ptd) => throw new NotImplementedException();
		void IMetaDataEmit.DefineNestedType(string szTypeDef, uint dwTypeDefFlags, uint tkExtends, uint[] rtkImplements, uint tdEncloser, out uint ptd) => throw new NotImplementedException();
		void IMetaDataEmit.SetHandler(object pUnk) => throw new NotImplementedException();
		void IMetaDataEmit.DefineMethod(uint td, string szName, uint dwMethodFlags, IntPtr pvSigBlob, uint cbSigBlob, uint ulCodeRVA, uint dwImplFlags, out uint pmd) => throw new NotImplementedException();
		void IMetaDataEmit.DefineMethodImpl(uint td, uint tkBody, uint tkDecl) => throw new NotImplementedException();
		void IMetaDataEmit.DefineTypeRefByName(uint tkResolutionScope, string szName, out uint ptr) => throw new NotImplementedException();
		void IMetaDataEmit.DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint tdImport, IntPtr pAssemEmit, out uint ptr) => throw new NotImplementedException();
		void IMetaDataEmit.DefineMemberRef(uint tkImport, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmr) => throw new NotImplementedException();
		void IMetaDataEmit.DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport pImport, uint mbMember, IntPtr pAssemEmit, uint tkParent, out uint pmr) => throw new NotImplementedException();
		void IMetaDataEmit.DefineEvent(uint td, string szEvent, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, uint[] rmdOtherMethods, out uint pmdEvent) => throw new NotImplementedException();
		void IMetaDataEmit.SetClassLayout(uint td, uint dwPackSize, IntPtr rFieldOffsets, uint ulClassSize) => throw new NotImplementedException();
		void IMetaDataEmit.DeleteClassLayout(uint td) => throw new NotImplementedException();
		void IMetaDataEmit.SetFieldMarshal(uint tk, IntPtr pvNativeType, uint cbNativeType) => throw new NotImplementedException();
		void IMetaDataEmit.DeleteFieldMarshal(uint tk) => throw new NotImplementedException();
		void IMetaDataEmit.DefinePermissionSet(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission, out uint ppm) => throw new NotImplementedException();
		void IMetaDataEmit.SetRVA(uint md, uint ulRVA) => throw new NotImplementedException();
		void IMetaDataEmit.DefineModuleRef(string szName, out uint pmur) => throw new NotImplementedException();
		void IMetaDataEmit.SetParent(uint mr, uint tk) => throw new NotImplementedException();
		void IMetaDataEmit.GetTokenFromTypeSpec(IntPtr pvSig, uint cbSig, out uint ptypespec) => throw new NotImplementedException();
		void IMetaDataEmit.SaveToMemory(out IntPtr pbData, uint cbData) => throw new NotImplementedException();
		void IMetaDataEmit.DefineUserString(string szString, uint cchString, out uint pstk) => throw new NotImplementedException();
		void IMetaDataEmit.DeleteToken(uint tkObj) => throw new NotImplementedException();
		void IMetaDataEmit.SetMethodProps(uint md, uint dwMethodFlags, uint ulCodeRVA, uint dwImplFlags) => throw new NotImplementedException();
		void IMetaDataEmit.SetTypeDefProps(uint td, uint dwTypeDefFlags, uint tkExtends, uint[] rtkImplements) => throw new NotImplementedException();
		void IMetaDataEmit.SetEventProps(uint ev, uint dwEventFlags, uint tkEventType, uint mdAddOn, uint mdRemoveOn, uint mdFire, uint[] rmdOtherMethods) => throw new NotImplementedException();
		void IMetaDataEmit.SetPermissionSetProps(uint tk, uint dwAction, IntPtr pvPermission, uint cbPermission, out uint ppm) => throw new NotImplementedException();
		void IMetaDataEmit.DefinePinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL) => throw new NotImplementedException();
		void IMetaDataEmit.SetPinvokeMap(uint tk, uint dwMappingFlags, string szImportName, uint mrImportDLL) => throw new NotImplementedException();
		void IMetaDataEmit.DeletePinvokeMap(uint tk) => throw new NotImplementedException();
		void IMetaDataEmit.DefineCustomAttribute(uint tkOwner, uint tkCtor, IntPtr pCustomAttribute, uint cbCustomAttribute, out uint pcv) => throw new NotImplementedException();
		void IMetaDataEmit.SetCustomAttributeValue(uint pcv, IntPtr pCustomAttribute, uint cbCustomAttribute) => throw new NotImplementedException();
		void IMetaDataEmit.DefineField(uint td, string szName, uint dwFieldFlags, IntPtr pvSigBlob, uint cbSigBlob, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, out uint pmd) => throw new NotImplementedException();
		void IMetaDataEmit.DefineProperty(uint td, string szProperty, uint dwPropFlags, IntPtr pvSig, uint cbSig, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, uint[] rmdOtherMethods, out uint pmdProp) => throw new NotImplementedException();
		void IMetaDataEmit.DefineParam(uint md, uint ulParamSeq, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, out uint ppd) => throw new NotImplementedException();
		void IMetaDataEmit.SetFieldProps(uint fd, uint dwFieldFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue) => throw new NotImplementedException();
		void IMetaDataEmit.SetPropertyProps(uint pr, uint dwPropFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue, uint mdSetter, uint mdGetter, uint[] rmdOtherMethods) => throw new NotImplementedException();
		void IMetaDataEmit.SetParamProps(uint pd, string szName, uint dwParamFlags, uint dwCPlusTypeFlag, IntPtr pValue, uint cchValue) => throw new NotImplementedException();
		void IMetaDataEmit.DefineSecurityAttributeSet(uint tkObj, IntPtr rSecAttrs, uint cSecAttrs, out uint pulErrorAttr) => throw new NotImplementedException();
		void IMetaDataEmit.ApplyEditAndContinue(object pImport) => throw new NotImplementedException();
		void IMetaDataEmit.TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, uint cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, uint cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, uint cbTranslatedSigMax, out uint pcbTranslatedSig) => throw new NotImplementedException();
		void IMetaDataEmit.SetMethodImplFlags(uint md, uint dwImplFlags) => throw new NotImplementedException();
		void IMetaDataEmit.SetFieldRVA(uint fd, uint ulRVA) => throw new NotImplementedException();
		void IMetaDataEmit.Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler) => throw new NotImplementedException();
		void IMetaDataEmit.MergeEnd() => throw new NotImplementedException();
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	unsafe abstract class MetaDataImport : IMetaDataImport {
		public virtual void GetTypeDefProps([In] uint td, [In] ushort* szTypeDef, [In] uint cchTypeDef, [Out] uint* pchTypeDef, [Out] uint* pdwTypeDefFlags, [Out] uint* ptkExtends) => throw new NotImplementedException();
		public virtual void GetMethodProps(uint mb, uint* pClass, [In] ushort* szMethod, uint cchMethod, uint* pchMethod, uint* pdwAttr, [Out] IntPtr* ppvSigBlob, [Out] uint* pcbSigBlob, [Out] uint* pulCodeRVA, [Out] uint* pdwImplFlags) => throw new NotImplementedException();
		public virtual void GetNestedClassProps([In] uint tdNestedClass, [Out] uint* ptdEnclosingClass) => throw new NotImplementedException();
		public virtual void GetSigFromToken(uint mdSig, byte** ppvSig, uint* pcbSig) => throw new NotImplementedException();
		public virtual void GetTypeRefProps(uint tr, uint* ptkResolutionScope, ushort* szName, uint cchName, uint* pchName) => throw new NotImplementedException();

		protected void CopyTypeName(string typeNamespace, string typeName, ushort* destBuffer, uint destBufferLen, uint* requiredLength) {
			if (typeName is null)
				typeName = string.Empty;
			if (typeNamespace is null)
				typeNamespace = string.Empty;

			if (destBuffer is not null && destBufferLen > 0) {
				uint maxChars = destBufferLen - 1;
				uint w = 0;
				if (typeNamespace.Length > 0) {
					for (int i = 0; i < typeNamespace.Length && w < maxChars; i++, w++)
						*destBuffer++ = typeNamespace[i];
					if (w < maxChars) {
						*destBuffer++ = '.';
						w++;
					}
				}
				for (int i = 0; i < typeName.Length && w < maxChars; i++, w++)
					*destBuffer++ = typeName[i];
				Debug.Assert(w < destBufferLen);
				*destBuffer = 0;
			}

			if (requiredLength is not null) {
				int totalLen = typeNamespace.Length == 0 ? typeName.Length : typeNamespace.Length + 1 + typeName.Length;
				int copyLen = Math.Min(totalLen, (int)Math.Min(int.MaxValue, destBufferLen == 0 ? 0 : destBufferLen - 1));
				if (destBuffer is not null)
					*requiredLength = (uint)copyLen;
				else
					*requiredLength = (uint)totalLen;
			}
		}

		void IMetaDataImport.CloseEnum(IntPtr hEnum) => throw new NotImplementedException();
		void IMetaDataImport.CountEnum(IntPtr hEnum, ref uint pulCount) => throw new NotImplementedException();
		void IMetaDataImport.ResetEnum(IntPtr hEnum, uint ulPos) => throw new NotImplementedException();
		void IMetaDataImport.EnumTypeDefs(IntPtr phEnum, uint[] rTypeDefs, uint cMax, out uint pcTypeDefs) => throw new NotImplementedException();
		void IMetaDataImport.EnumInterfaceImpls(ref IntPtr phEnum, uint td, uint[] rImpls, uint cMax, ref uint pcImpls) => throw new NotImplementedException();
		void IMetaDataImport.EnumTypeRefs(ref IntPtr phEnum, uint[] rTypeRefs, uint cMax, ref uint pcTypeRefs) => throw new NotImplementedException();
		void IMetaDataImport.FindTypeDefByName(string szTypeDef, uint tkEnclosingClass, out uint ptd) => throw new NotImplementedException();
		void IMetaDataImport.GetScopeProps(IntPtr szName, uint cchName, out uint pchName, out Guid pmvid) => throw new NotImplementedException();
		void IMetaDataImport.GetModuleFromScope(out uint pmd) => throw new NotImplementedException();
		void IMetaDataImport.GetInterfaceImplProps(uint iiImpl, out uint pClass, out uint ptkIface) => throw new NotImplementedException();
		void IMetaDataImport.ResolveTypeRef(uint tr, ref Guid riid, out object ppIScope, out uint ptd) => throw new NotImplementedException();
		void IMetaDataImport.EnumMembers(ref IntPtr phEnum, uint cl, uint[] rMembers, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.EnumMembersWithName(ref IntPtr phEnum, uint cl, string szName, uint[] rMembers, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.EnumMethods(ref IntPtr phEnum, uint cl, uint[] rMethods, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.EnumMethodsWithName(ref IntPtr phEnum, uint cl, string szName, uint[] rMethods, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.EnumFields(ref IntPtr phEnum, uint cl, uint[] rFields, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.EnumFieldsWithName(ref IntPtr phEnum, uint cl, string szName, uint[] rFields, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.EnumParams(ref IntPtr phEnum, uint mb, uint[] rParams, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.EnumMemberRefs(ref IntPtr phEnum, uint tkParent, uint[] rMemberRefs, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.EnumMethodImpls(ref IntPtr phEnum, uint td, uint[] rMethodBody, uint[] rMethodDecl, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.EnumPermissionSets(ref IntPtr phEnum, uint tk, uint dwActions, uint[] rPermission, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.FindMember(uint td, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmb) => throw new NotImplementedException();
		void IMetaDataImport.FindMethod(uint td, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmb) => throw new NotImplementedException();
		void IMetaDataImport.FindField(uint td, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmb) => throw new NotImplementedException();
		void IMetaDataImport.FindMemberRef(uint td, string szName, IntPtr pvSigBlob, uint cbSigBlob, out uint pmr) => throw new NotImplementedException();
		void IMetaDataImport.GetMemberRefProps(uint mr, out uint ptk, IntPtr szMember, uint cchMember, out uint pchMember, out IntPtr ppvSigBlob, out uint pbSig) => throw new NotImplementedException();
		void IMetaDataImport.EnumProperties(ref IntPtr phEnum, uint td, uint[] rProperties, uint cMax, out uint pcProperties) => throw new NotImplementedException();
		void IMetaDataImport.EnumEvents(ref IntPtr phEnum, uint td, uint[] rEvents, uint cMax, out uint pcEvents) => throw new NotImplementedException();
		void IMetaDataImport.GetEventProps(uint ev, out uint pClass, string szEvent, uint cchEvent, out uint pchEvent, out uint pdwEventFlags, out uint ptkEventType, out uint pmdAddOn, out uint pmdRemoveOn, out uint pmdFire, uint[] rmdOtherMethod, uint cMax, out uint pcOtherMethod) => throw new NotImplementedException();
		void IMetaDataImport.EnumMethodSemantics(ref IntPtr phEnum, uint mb, uint[] rEventProp, uint cMax, out uint pcEventProp) => throw new NotImplementedException();
		void IMetaDataImport.GetMethodSemantics(uint mb, uint tkEventProp, out uint pdwSemanticsFlags) => throw new NotImplementedException();
		void IMetaDataImport.GetClassLayout(uint td, out uint pdwPackSize, out IntPtr rFieldOffset, uint cMax, out uint pcFieldOffset, out uint pulClassSize) => throw new NotImplementedException();
		void IMetaDataImport.GetFieldMarshal(uint tk, out IntPtr ppvNativeType, out uint pcbNativeType) => throw new NotImplementedException();
		void IMetaDataImport.GetRVA(uint tk, out uint pulCodeRVA, out uint pdwImplFlags) => throw new NotImplementedException();
		void IMetaDataImport.GetPermissionSetProps(uint pm, out uint pdwAction, out IntPtr ppvPermission, out uint pcbPermission) => throw new NotImplementedException();
		void IMetaDataImport.GetModuleRefProps(uint mur, IntPtr szName, uint cchName, out uint pchName) => throw new NotImplementedException();
		void IMetaDataImport.EnumModuleRefs(ref IntPtr phEnum, uint[] rModuleRefs, uint cmax, out uint pcModuleRefs) => throw new NotImplementedException();
		void IMetaDataImport.GetTypeSpecFromToken(uint typespec, out IntPtr ppvSig, out uint pcbSig) => throw new NotImplementedException();
		void IMetaDataImport.GetNameFromToken(uint tk, out IntPtr pszUtf8NamePtr) => throw new NotImplementedException();
		void IMetaDataImport.EnumUnresolvedMethods(ref IntPtr phEnum, uint[] rMethods, uint cMax, out uint pcTokens) => throw new NotImplementedException();
		void IMetaDataImport.GetUserString(uint stk, IntPtr szString, uint cchString, out uint pchString) => throw new NotImplementedException();
		void IMetaDataImport.GetPinvokeMap(uint tk, out uint pdwMappingFlags, IntPtr szImportName, uint cchImportName, out uint pchImportName, out uint pmrImportDLL) => throw new NotImplementedException();
		void IMetaDataImport.EnumSignatures(ref IntPtr phEnum, uint[] rSignatures, uint cmax, out uint pcSignatures) => throw new NotImplementedException();
		void IMetaDataImport.EnumTypeSpecs(ref IntPtr phEnum, uint[] rTypeSpecs, uint cmax, out uint pcTypeSpecs) => throw new NotImplementedException();
		void IMetaDataImport.EnumUserStrings(ref IntPtr phEnum, uint[] rStrings, uint cmax, out uint pcStrings) => throw new NotImplementedException();
		void IMetaDataImport.GetParamForMethodIndex(uint md, uint ulParamSeq, out uint ppd) => throw new NotImplementedException();
		void IMetaDataImport.EnumCustomAttributes(IntPtr phEnum, uint tk, uint tkType, uint[] rCustomAttributes, uint cMax, out uint pcCustomAttributes) => throw new NotImplementedException();
		void IMetaDataImport.GetCustomAttributeProps(uint cv, out uint ptkObj, out uint ptkType, out IntPtr ppBlob, out uint pcbSize) => throw new NotImplementedException();
		void IMetaDataImport.FindTypeRef(uint tkResolutionScope, string szName, out uint ptr) => throw new NotImplementedException();
		void IMetaDataImport.GetMemberProps(uint mb, out uint pClass, IntPtr szMember, uint cchMember, out uint pchMember, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pulCodeRVA, out uint pdwImplFlags, out uint pdwCPlusTypeFlag, out IntPtr ppValue, out uint pcchValue) => throw new NotImplementedException();
		void IMetaDataImport.GetFieldProps(uint mb, out uint pClass, IntPtr szField, uint cchField, out uint pchField, out uint pdwAttr, out IntPtr ppvSigBlob, out uint pcbSigBlob, out uint pdwCPlusTypeFlag, out IntPtr ppValue, out uint pcchValue) => throw new NotImplementedException();
		void IMetaDataImport.GetPropertyProps(uint prop, out uint pClass, IntPtr szProperty, uint cchProperty, out uint pchProperty, out uint pdwPropFlags, out IntPtr ppvSig, out uint pbSig, out uint pdwCPlusTypeFlag, out IntPtr ppDefaultValue, out uint pcchDefaultValue, out uint pmdSetter, out uint pmdGetter, uint[] rmdOtherMethod, uint cMax, out uint pcOtherMethod) => throw new NotImplementedException();
		void IMetaDataImport.GetParamProps(uint tk, out uint pmd, out uint pulSequence, IntPtr szName, uint cchName, out uint pchName, out uint pdwAttr, out uint pdwCPlusTypeFlag, out IntPtr ppValue, out uint pcchValue) => throw new NotImplementedException();
		void IMetaDataImport.GetCustomAttributeByName(uint tkObj, string szName, out IntPtr ppData, out uint pcbData) => throw new NotImplementedException();
		bool IMetaDataImport.IsValidToken(uint tk) => throw new NotImplementedException();
		void IMetaDataImport.GetNativeCallConvFromSig(IntPtr pvSig, uint cbSig, out uint pCallConv) => throw new NotImplementedException();
		void IMetaDataImport.IsGlobal(uint pd, out int pbGlobal) => throw new NotImplementedException();
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed unsafe class ReaderMetaDataImport : MetaDataImport, IDisposable {
		MD.Metadata metadata;
		byte* blobPtr;
		IntPtr addrToFree;

		public ReaderMetaDataImport(MD.Metadata metadata) {
			this.metadata = metadata ?? throw new ArgumentNullException(nameof(metadata));
			var reader = metadata.BlobStream.CreateReader();
			addrToFree = Marshal.AllocHGlobal((int)reader.BytesLeft);
			blobPtr = (byte*)addrToFree;
			if (blobPtr is null)
				throw new OutOfMemoryException();
			reader.ReadBytes(blobPtr, (int)reader.BytesLeft);
		}

		~ReaderMetaDataImport() => Dispose(false);

		public override void GetTypeRefProps(uint tr, uint* ptkResolutionScope, ushort* szName, uint cchName, uint* pchName) {
			var token = new MDToken(tr);
			if (token.Table != Table.TypeRef)
				throw new ArgumentException();
			if (!metadata.TablesStream.TryReadTypeRefRow(token.Rid, out var row))
				throw new ArgumentException();
			if (ptkResolutionScope is not null)
				*ptkResolutionScope = row.ResolutionScope;
			if (szName is not null || pchName is not null) {
				var typeNamespace = metadata.StringsStream.ReadNoNull(row.Namespace);
				var typeName = metadata.StringsStream.ReadNoNull(row.Name);
				CopyTypeName(typeNamespace, typeName, szName, cchName, pchName);
			}
		}

		public override void GetTypeDefProps(uint td, ushort* szTypeDef, uint cchTypeDef, uint* pchTypeDef, uint* pdwTypeDefFlags, uint* ptkExtends) {
			var token = new MDToken(td);
			if (token.Table != Table.TypeDef)
				throw new ArgumentException();
			if (!metadata.TablesStream.TryReadTypeDefRow(token.Rid, out var row))
				throw new ArgumentException();
			if (pdwTypeDefFlags is not null)
				*pdwTypeDefFlags = row.Flags;
			if (ptkExtends is not null)
				*ptkExtends = row.Extends;
			if (szTypeDef is not null || pchTypeDef is not null) {
				var typeNamespace = metadata.StringsStream.ReadNoNull(row.Namespace);
				var typeName = metadata.StringsStream.ReadNoNull(row.Name);
				CopyTypeName(typeNamespace, typeName, szTypeDef, cchTypeDef, pchTypeDef);
			}
		}

		public override void GetSigFromToken(uint mdSig, byte** ppvSig, uint* pcbSig) {
			var token = new MDToken(mdSig);
			if (token.Table != Table.StandAloneSig)
				throw new ArgumentException();
			if (!metadata.TablesStream.TryReadStandAloneSigRow(token.Rid, out var row))
				throw new ArgumentException();
			if (!metadata.BlobStream.TryCreateReader(row.Signature, out var reader))
				throw new ArgumentException();
			if (ppvSig is not null)
				*ppvSig = blobPtr + (reader.StartOffset - (uint)metadata.BlobStream.StartOffset);
			if (pcbSig is not null)
				*pcbSig = reader.Length;
		}

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		void Dispose(bool disposing) {
			metadata = null;
			var addrToFreeTmp = Interlocked.Exchange(ref addrToFree, IntPtr.Zero);
			blobPtr = null;
			if (addrToFreeTmp != IntPtr.Zero)
				Marshal.FreeHGlobal(addrToFreeTmp);
		}
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	/// <summary>
	/// Implements <see cref="IStream"/> and uses a <see cref="Stream"/> as the underlying
	/// stream.
	/// </summary>
	sealed class StreamIStream : IStream {
		readonly Stream stream;
		readonly string name;

		const int STG_E_INVALIDFUNCTION = unchecked((int)0x80030001);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Source stream</param>
		public StreamIStream(Stream stream)
			: this(stream, string.Empty) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Source stream</param>
		/// <param name="name">Name of original file or <c>null</c> if unknown.</param>
		public StreamIStream(Stream stream, string name) {
			this.stream = stream ?? throw new ArgumentNullException(nameof(stream));
			this.name = name ?? string.Empty;
		}

		/// <inheritdoc/>
		public void Clone(out IStream ppstm) {
			Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);
			throw new Exception();
		}

		/// <inheritdoc/>
		public void Commit(int grfCommitFlags) => stream.Flush();

		/// <inheritdoc/>
		public void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten) {
			if (cb > int.MaxValue)
				cb = int.MaxValue;
			else if (cb < 0)
				cb = 0;
			int sizeToRead = (int)cb;

			if (stream.Position + sizeToRead < sizeToRead || stream.Position + sizeToRead > stream.Length)
				sizeToRead = (int)(stream.Length - Math.Min(stream.Position, stream.Length));

			var buffer = new byte[sizeToRead];
			Read(buffer, sizeToRead, pcbRead);
			if (pcbRead != IntPtr.Zero)
				Marshal.WriteInt64(pcbRead, Marshal.ReadInt32(pcbRead));
			pstm.Write(buffer, buffer.Length, pcbWritten);
			if (pcbWritten != IntPtr.Zero)
				Marshal.WriteInt64(pcbWritten, Marshal.ReadInt32(pcbWritten));
		}

		/// <inheritdoc/>
		public void LockRegion(long libOffset, long cb, int dwLockType) =>
			Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);

		/// <inheritdoc/>
		public void Read(byte[] pv, int cb, IntPtr pcbRead) {
			if (cb < 0)
				cb = 0;

			cb = stream.Read(pv, 0, cb);

			if (pcbRead != IntPtr.Zero)
				Marshal.WriteInt32(pcbRead, cb);
		}

		/// <inheritdoc/>
		public void Revert() {
		}

		enum STREAM_SEEK {
			SET = 0,
			CUR = 1,
			END = 2,
		}

		/// <inheritdoc/>
		public void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition) {
			switch ((STREAM_SEEK)dwOrigin) {
			case STREAM_SEEK.SET:
				stream.Position = dlibMove;
				break;

			case STREAM_SEEK.CUR:
				stream.Position += dlibMove;
				break;

			case STREAM_SEEK.END:
				stream.Position = stream.Length + dlibMove;
				break;
			}

			if (plibNewPosition != IntPtr.Zero)
				Marshal.WriteInt64(plibNewPosition, stream.Position);
		}

		/// <inheritdoc/>
		public void SetSize(long libNewSize) => stream.SetLength(libNewSize);

		enum STATFLAG {
			DEFAULT = 0,
			NONAME = 1,
			NOOPEN = 2,
		}

		enum STGTY {
			STORAGE = 1,
			STREAM = 2,
			LOCKBYTES = 3,
			PROPERTY = 4,
		}

		/// <inheritdoc/>
		public void Stat(out System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag) {
			var s = new System.Runtime.InteropServices.ComTypes.STATSTG();

			// s.atime = ???;
			s.cbSize = stream.Length;
			s.clsid = Guid.Empty;
			// s.ctime = ???;
			s.grfLocksSupported = 0;
			s.grfMode = 2;
			s.grfStateBits = 0;
			// s.mtime = ???;
			if ((grfStatFlag & (int)STATFLAG.NONAME) == 0)
				s.pwcsName = name;
			s.reserved = 0;
			s.type = (int)STGTY.STREAM;

			pstatstg = s;
		}

		/// <inheritdoc/>
		public void UnlockRegion(long libOffset, long cb, int dwLockType) =>
			Marshal.ThrowExceptionForHR(STG_E_INVALIDFUNCTION);

		/// <inheritdoc/>
		public void Write(byte[] pv, int cb, IntPtr pcbWritten) {
			stream.Write(pv, 0, cb);
			if (pcbWritten != IntPtr.Zero)
				Marshal.WriteInt32(pcbWritten, cb);
		}
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolDocumentImpl : SymbolDocument {
		readonly ISymUnmanagedDocument document;
		public ISymUnmanagedDocument SymUnmanagedDocument => document;
		public SymbolDocumentImpl(ISymUnmanagedDocument document) => this.document = document;

		public override Guid CheckSumAlgorithmId {
			get {
				document.GetCheckSumAlgorithmId(out var guid);
				return guid;
			}
		}

		public override Guid DocumentType {
			get {
				document.GetDocumentType(out var guid);
				return guid;
			}
		}

		public override Guid Language {
			get {
				document.GetLanguage(out var guid);
				return guid;
			}
		}

		public override Guid LanguageVendor {
			get {
				document.GetLanguageVendor(out var guid);
				return guid;
			}
		}

		public override string URL {
			get {
				document.GetURL(0, out uint count, null);
				var chars = new char[count];
				document.GetURL((uint)chars.Length, out count, chars);
				if (chars.Length == 0)
					return string.Empty;
				return new string(chars, 0, chars.Length - 1);
			}
		}

		public override byte[] CheckSum {
			get {
				document.GetCheckSum(0, out uint bufSize, null);
				var buffer = new byte[bufSize];
				document.GetCheckSum((uint)buffer.Length, out bufSize, buffer);
				return buffer;
			}
		}

		byte[] SourceCode {
			get {
				int hr = document.GetSourceLength(out int size);
				if (hr < 0)
					return null;
				if (size <= 0)
					return null;
				var sourceCode = new byte[size];
				hr = document.GetSourceRange(0, 0, int.MaxValue, int.MaxValue, size, out var bytesRead, sourceCode);
				if (hr < 0)
					return null;
				if (bytesRead <= 0)
					return null;
				if (bytesRead != sourceCode.Length)
					Array.Resize(ref sourceCode, bytesRead);
				return sourceCode;
			}
		}

		public override PdbCustomDebugInfo[] CustomDebugInfos {
			get {
				if (customDebugInfos is null) {
					var sourceCode = SourceCode;
					if (sourceCode is not null)
						customDebugInfos = new PdbCustomDebugInfo[1] { new PdbEmbeddedSourceCustomDebugInfo(sourceCode) };
					else
						customDebugInfos = Array2.Empty<PdbCustomDebugInfo>();
				}
				return customDebugInfos;
			}
		}
		PdbCustomDebugInfo[] customDebugInfos;
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolDocumentWriter : ISymbolDocumentWriter {
		readonly ISymUnmanagedDocumentWriter writer;
		public ISymUnmanagedDocumentWriter SymUnmanagedDocumentWriter => writer;
		public SymbolDocumentWriter(ISymUnmanagedDocumentWriter writer) => this.writer = writer;
		public void SetCheckSum(Guid algorithmId, byte[] checkSum) {
			if (checkSum is not null && checkSum.Length != 0 && algorithmId != Guid.Empty)
				writer.SetCheckSum(algorithmId, (uint)checkSum.Length, checkSum);
		}
		public void SetSource(byte[] source) => writer.SetSource((uint)source.Length, source);
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolMethodImpl : SymbolMethod {
		readonly SymbolReaderImpl reader;
		readonly ISymUnmanagedMethod method;
		readonly ISymUnmanagedAsyncMethod asyncMethod;

		public SymbolMethodImpl(SymbolReaderImpl reader, ISymUnmanagedMethod method) {
			this.reader = reader;
			this.method = method;
			asyncMethod = method as ISymUnmanagedAsyncMethod;
		}

		public override int Token {
			get {
				method.GetToken(out uint result);
				return (int)result;
			}
		}

		public override SymbolScope RootScope {
			get {
				if (rootScope is null) {
					method.GetRootScope(out var scope);
					Interlocked.CompareExchange(ref rootScope, scope is null ? null : new SymbolScopeImpl(scope, this, null), null);
				}
				return rootScope;
			}
		}
		volatile SymbolScope rootScope;

		public override IList<SymbolSequencePoint> SequencePoints {
			get {
				if (sequencePoints is null) {
					method.GetSequencePointCount(out uint seqPointCount);
					var seqPoints = new SymbolSequencePoint[seqPointCount];

					var offsets = new int[seqPoints.Length];
					var documents = new ISymbolDocument[seqPoints.Length];
					var lines = new int[seqPoints.Length];
					var columns = new int[seqPoints.Length];
					var endLines = new int[seqPoints.Length];
					var endColumns = new int[seqPoints.Length];
					var unDocs = new ISymUnmanagedDocument[seqPoints.Length];
					if (seqPoints.Length != 0)
						method.GetSequencePoints((uint)seqPoints.Length, out uint size, offsets, unDocs, lines, columns, endLines, endColumns);
					for (int i = 0; i < seqPoints.Length; i++) {
						seqPoints[i] = new SymbolSequencePoint {
							Offset = offsets[i],
							Document = new SymbolDocumentImpl(unDocs[i]),
							Line = lines[i],
							Column = columns[i],
							EndLine = endLines[i],
							EndColumn = endColumns[i],
						};
					}
					sequencePoints = seqPoints;
				}
				return sequencePoints;
			}
		}
		volatile SymbolSequencePoint[] sequencePoints;

		public int AsyncKickoffMethod {
			get {
				if (asyncMethod is null || !asyncMethod.IsAsyncMethod())
					return 0;
				return (int)asyncMethod.GetKickoffMethod();
			}
		}

		public uint? AsyncCatchHandlerILOffset {
			get {
				if (asyncMethod is null || !asyncMethod.IsAsyncMethod())
					return null;
				if (!asyncMethod.HasCatchHandlerILOffset())
					return null;
				return asyncMethod.GetCatchHandlerILOffset();
			}
		}

		public IList<SymbolAsyncStepInfo> AsyncStepInfos {
			get {
				if (asyncMethod is null || !asyncMethod.IsAsyncMethod())
					return null;
				if (asyncStepInfos is null) {
					var stepInfoCount = asyncMethod.GetAsyncStepInfoCount();
					var yieldOffsets = new uint[stepInfoCount];
					var breakpointOffsets = new uint[stepInfoCount];
					var breakpointMethods = new uint[stepInfoCount];
					asyncMethod.GetAsyncStepInfo(stepInfoCount, out stepInfoCount, yieldOffsets, breakpointOffsets, breakpointMethods);
					var res = new SymbolAsyncStepInfo[stepInfoCount];
					for (int i = 0; i < res.Length; i++)
						res[i] = new SymbolAsyncStepInfo(yieldOffsets[i], breakpointOffsets[i], breakpointMethods[i]);
					asyncStepInfos = res;
				}
				return asyncStepInfos;
			}
		}
		volatile SymbolAsyncStepInfo[] asyncStepInfos;

		public override void GetCustomDebugInfos(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) =>
			reader.GetCustomDebugInfos(this, method, body, result);
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolNamespaceImpl : SymbolNamespace {
		readonly ISymUnmanagedNamespace ns;

		public SymbolNamespaceImpl(ISymUnmanagedNamespace @namespace) => ns = @namespace;

		public override string Name {
			get {
				ns.GetName(0, out uint count, null);
				var chars = new char[count];
				ns.GetName((uint)chars.Length, out count, chars);
				if (chars.Length == 0)
					return string.Empty;
				return new string(chars, 0, chars.Length - 1);
			}
		}
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolReaderImpl : SymbolReader {
		ModuleDef module;
		ISymUnmanagedReader reader;
		object[] objsToKeepAlive;

		const int E_FAIL = unchecked((int)0x80004005);

		public SymbolReaderImpl(ISymUnmanagedReader reader, object[] objsToKeepAlive) {
			this.reader = reader ?? throw new ArgumentNullException(nameof(reader));
			this.objsToKeepAlive = objsToKeepAlive ?? throw new ArgumentNullException(nameof(objsToKeepAlive));
		}

		~SymbolReaderImpl() => Dispose(false);

		public override PdbFileKind PdbFileKind => PdbFileKind.WindowsPDB;

		public override int UserEntryPoint {
			get {
				int hr = reader.GetUserEntryPoint(out uint token);
				if (hr == E_FAIL)
					token = 0;
				else
					Marshal.ThrowExceptionForHR(hr);
				return (int)token;
			}
		}

		public override IList<SymbolDocument> Documents {
			get {
				if (documents is null) {
					reader.GetDocuments(0, out uint numDocs, null);
					var unDocs = new ISymUnmanagedDocument[numDocs];
					reader.GetDocuments((uint)unDocs.Length, out numDocs, unDocs);
					var docs = new SymbolDocument[numDocs];
					for (uint i = 0; i < numDocs; i++)
						docs[i] = new SymbolDocumentImpl(unDocs[i]);
					documents = docs;
				}
				return documents;
			}
		}
		volatile SymbolDocument[] documents;

		public override void Initialize(ModuleDef module) => this.module = module;

		public override SymbolMethod GetMethod(MethodDef method, int version) {
			int hr = reader.GetMethodByVersion(method.MDToken.Raw, version, out var unMethod);
			if (hr == E_FAIL)
				return null;
			Marshal.ThrowExceptionForHR(hr);
			return unMethod is null ? null : new SymbolMethodImpl(this, unMethod);
		}

		internal void GetCustomDebugInfos(SymbolMethodImpl symMethod, MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) {
			var asyncMethod = PseudoCustomDebugInfoFactory.TryCreateAsyncMethod(method.Module, method, body, symMethod.AsyncKickoffMethod, symMethod.AsyncStepInfos, symMethod.AsyncCatchHandlerILOffset);
			if (asyncMethod is not null)
				result.Add(asyncMethod);

			const string CDI_NAME = "MD2";
			reader.GetSymAttribute(method.MDToken.Raw, CDI_NAME, 0, out uint bufSize, null);
			if (bufSize == 0)
				return;
			var cdiData = new byte[bufSize];
			reader.GetSymAttribute(method.MDToken.Raw, CDI_NAME, (uint)cdiData.Length, out bufSize, cdiData);
			PdbCustomDebugInfoReader.Read(method, body, result, cdiData);
		}

		public override void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
			if (token == 0x00000001)
				GetCustomDebugInfos_ModuleDef(result);
		}

		void GetCustomDebugInfos_ModuleDef(IList<PdbCustomDebugInfo> result) {
			var sourceLinkData = GetSourceLinkData();
			if (sourceLinkData is not null)
				result.Add(new PdbSourceLinkCustomDebugInfo(sourceLinkData));
			var sourceServerData = GetSourceServerData();
			if (sourceServerData is not null)
				result.Add(new PdbSourceServerCustomDebugInfo(sourceServerData));
		}

		byte[] GetSourceLinkData() {
			if (reader is ISymUnmanagedReader4 reader4) {
				// It returns data that it owns. The data is freed once its Destroy() method is called
				Debug.Assert(reader is ISymUnmanagedDispose);
				// Despite its name, it seems to only return source link data, and not source server data
				if (reader4.GetSourceServerData(out var srcLinkData, out int sizeData) == 0) {
					if (sizeData == 0)
						return Array2.Empty<byte>();
					var data = new byte[sizeData];
					Marshal.Copy(srcLinkData, data, 0, data.Length);
					return data;
				}
			}
			return null;
		}

		byte[] GetSourceServerData() {
			if (reader is ISymUnmanagedSourceServerModule srcSrvModule) {
				var srcSrvData = IntPtr.Zero;
				try {
					// This method only returns source server data, not source link data
					if (srcSrvModule.GetSourceServerData(out int sizeData, out srcSrvData) == 0) {
						if (sizeData == 0)
							return Array2.Empty<byte>();
						var data = new byte[sizeData];
						Marshal.Copy(srcSrvData, data, 0, data.Length);
						return data;
					}
				}
				finally {
					if (srcSrvData != IntPtr.Zero)
						Marshal.FreeCoTaskMem(srcSrvData);
				}
			}
			return null;
		}

		public override void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		void Dispose(bool disposing) {
			(reader as ISymUnmanagedDispose)?.Destroy();
			var o = objsToKeepAlive;
			if (o is not null) {
				foreach (var obj in o)
					(obj as IDisposable)?.Dispose();
			}
			module = null;
			reader = null;
			objsToKeepAlive = null;
		}

		public bool MatchesModule(Guid pdbId, uint stamp, uint age) {
			if (reader is ISymUnmanagedReader4 reader4) {
				int hr = reader4.MatchesModule(pdbId, stamp, age, out bool result);
				if (hr < 0)
					return false;
				return result;
			}

			// There seems to be no other method that can verify that we opened the correct PDB, so return true
			return true;
		}
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	static class SymbolReaderWriterFactory {
		[DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories | DllImportSearchPath.AssemblyDirectory)]
		[DllImport("Microsoft.DiaSymReader.Native.x86.dll", EntryPoint = "CreateSymReader")]
		static extern void CreateSymReader_x86(ref Guid id, [MarshalAs(UnmanagedType.IUnknown)] out object symReader);

		[DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories | DllImportSearchPath.AssemblyDirectory)]
		[DllImport("Microsoft.DiaSymReader.Native.amd64.dll", EntryPoint = "CreateSymReader")]
		static extern void CreateSymReader_x64(ref Guid id, [MarshalAs(UnmanagedType.IUnknown)] out object symReader);

		[DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories | DllImportSearchPath.AssemblyDirectory)]
		[DllImport("Microsoft.DiaSymReader.Native.arm.dll", EntryPoint = "CreateSymReader")]
		static extern void CreateSymReader_arm(ref Guid id, [MarshalAs(UnmanagedType.IUnknown)] out object symReader);

		[DefaultDllImportSearchPaths(DllImportSearchPath.SafeDirectories | DllImportSearchPath.AssemblyDirectory)]
		[DllImport("Microsoft.DiaSymReader.Native.arm64.dll", EntryPoint = "CreateSymReader")]
		static extern void CreateSymReader_arm64(ref Guid id, [MarshalAs(UnmanagedType.IUnknown)] out object symReader);

		[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory | DllImportSearchPath.SafeDirectories)]
		[DllImport("Microsoft.DiaSymReader.Native.x86.dll", EntryPoint = "CreateSymWriter")]
		static extern void CreateSymWriter_x86(ref Guid guid, [MarshalAs(UnmanagedType.IUnknown)] out object symWriter);

		[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory | DllImportSearchPath.SafeDirectories)]
		[DllImport("Microsoft.DiaSymReader.Native.amd64.dll", EntryPoint = "CreateSymWriter")]
		static extern void CreateSymWriter_x64(ref Guid guid, [MarshalAs(UnmanagedType.IUnknown)] out object symWriter);

		[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory | DllImportSearchPath.SafeDirectories)]
		[DllImport("Microsoft.DiaSymReader.Native.arm.dll", EntryPoint = "CreateSymWriter")]
		static extern void CreateSymWriter_arm(ref Guid guid, [MarshalAs(UnmanagedType.IUnknown)] out object symWriter);

		[DefaultDllImportSearchPaths(DllImportSearchPath.AssemblyDirectory | DllImportSearchPath.SafeDirectories)]
		[DllImport("Microsoft.DiaSymReader.Native.arm64.dll", EntryPoint = "CreateSymWriter")]
		static extern void CreateSymWriter_arm64(ref Guid guid, [MarshalAs(UnmanagedType.IUnknown)] out object symWriter);

		static readonly Guid CLSID_CorSymReader_SxS = new Guid("0A3976C5-4529-4ef8-B0B0-42EED37082CD");
		static Type CorSymReader_Type;

		static readonly Guid CLSID_CorSymWriter_SxS = new Guid(0x0AE2DEB0, 0xF901, 0x478B, 0xBB, 0x9F, 0x88, 0x1E, 0xE8, 0x06, 0x67, 0x88);
		static Type CorSymWriterType;

		static volatile bool canTry_Microsoft_DiaSymReader_Native = true;

		public static SymbolReader Create(PdbReaderContext pdbContext, MD.Metadata metadata, DataReaderFactory pdbStream) {
			ISymUnmanagedReader unmanagedReader = null;
			SymbolReaderImpl symReader = null;
			ReaderMetaDataImport mdImporter = null;
			DataReaderIStream comPdbStream = null;
			bool error = true;
			try {
				if (pdbStream is null)
					return null;
				var debugDir = pdbContext.CodeViewDebugDirectory;
				if (debugDir is null)
					return null;
				if (!pdbContext.TryGetCodeViewData(out var pdbGuid, out uint age))
					return null;

				unmanagedReader = CreateSymUnmanagedReader(pdbContext.Options);
				if (unmanagedReader is null)
					return null;

				mdImporter = new ReaderMetaDataImport(metadata);
				comPdbStream = new DataReaderIStream(pdbStream);
				int hr = unmanagedReader.Initialize(mdImporter, null, null, comPdbStream);
				if (hr < 0)
					return null;

				symReader = new SymbolReaderImpl(unmanagedReader, new object[] { pdbStream, mdImporter, comPdbStream });
				if (!symReader.MatchesModule(pdbGuid, debugDir.TimeDateStamp, age))
					return null;

				error = false;
				return symReader;
			}
			catch (IOException) {
			}
			catch (InvalidCastException) {
			}
			catch (COMException) {
			}
			finally {
				if (error) {
					pdbStream?.Dispose();
					symReader?.Dispose();
					mdImporter?.Dispose();
					comPdbStream?.Dispose();
					(unmanagedReader as ISymUnmanagedDispose)?.Destroy();
				}
			}
			return null;
		}

		static ISymUnmanagedReader CreateSymUnmanagedReader(PdbReaderOptions options) {
			bool useDiaSymReader = (options & PdbReaderOptions.NoDiaSymReader) == 0;
			bool useOldDiaSymReader = (options & PdbReaderOptions.NoOldDiaSymReader) == 0;

			if (useDiaSymReader && canTry_Microsoft_DiaSymReader_Native) {
				try {
					var guid = CLSID_CorSymReader_SxS;
					object symReaderObj;
					var machine = ProcessorArchUtils.GetProcessCpuArchitecture();
					switch (machine) {
					case Machine.AMD64:
						CreateSymReader_x64(ref guid, out symReaderObj);
						break;

					case Machine.I386:
						CreateSymReader_x86(ref guid, out symReaderObj);
						break;

					case Machine.ARMNT:
						CreateSymReader_arm(ref guid, out symReaderObj);
						break;

					case Machine.ARM64:
						CreateSymReader_arm64(ref guid, out symReaderObj);
						break;

					default:
						Debug.Fail($"Microsoft.DiaSymReader.Native doesn't support this CPU arch: {machine}");
						symReaderObj = null;
						break;
					}
					if (symReaderObj is ISymUnmanagedReader symReader)
						return symReader;
				}
				catch (DllNotFoundException) {
					Debug.WriteLine("Microsoft.DiaSymReader.Native not found, using diasymreader.dll instead");
				}
				catch {
				}
				canTry_Microsoft_DiaSymReader_Native = false;
			}

			if (useOldDiaSymReader)
				return (ISymUnmanagedReader)Activator.CreateInstance(CorSymReader_Type ??= Type.GetTypeFromCLSID(CLSID_CorSymReader_SxS));

			return null;
		}

		static ISymUnmanagedWriter2 CreateSymUnmanagedWriter2(PdbWriterOptions options) {
			bool useDiaSymReader = (options & PdbWriterOptions.NoDiaSymReader) == 0;
			bool useOldDiaSymReader = (options & PdbWriterOptions.NoOldDiaSymReader) == 0;

			if (useDiaSymReader && canTry_Microsoft_DiaSymReader_Native) {
				try {
					var guid = CLSID_CorSymWriter_SxS;
					object symWriterObj;
					var machine = ProcessorArchUtils.GetProcessCpuArchitecture();
					switch (machine) {
					case Machine.AMD64:
						CreateSymWriter_x64(ref guid, out symWriterObj);
						break;

					case Machine.I386:
						CreateSymWriter_x86(ref guid, out symWriterObj);
						break;

					case Machine.ARMNT:
						CreateSymWriter_arm(ref guid, out symWriterObj);
						break;

					case Machine.ARM64:
						CreateSymWriter_arm64(ref guid, out symWriterObj);
						break;

					default:
						Debug.Fail($"Microsoft.DiaSymReader.Native doesn't support this CPU arch: {machine}");
						symWriterObj = null;
						break;
					}
					if (symWriterObj is ISymUnmanagedWriter2 symWriter)
						return symWriter;
				}
				catch (DllNotFoundException) {
					Debug.WriteLine("Microsoft.DiaSymReader.Native not found, using diasymreader.dll instead");
				}
				catch {
				}
				canTry_Microsoft_DiaSymReader_Native = false;
			}

			if (useOldDiaSymReader)
				return (ISymUnmanagedWriter2)Activator.CreateInstance(CorSymWriterType ??= Type.GetTypeFromCLSID(CLSID_CorSymWriter_SxS));

			return null;
		}

		public static SymbolWriter Create(PdbWriterOptions options, string pdbFileName) {
			if (File.Exists(pdbFileName))
				File.Delete(pdbFileName);
			return new SymbolWriterImpl(CreateSymUnmanagedWriter2(options), pdbFileName, File.Create(pdbFileName), options, ownsStream: true);
		}

		public static SymbolWriter Create(PdbWriterOptions options, Stream pdbStream, string pdbFileName) =>
			new SymbolWriterImpl(CreateSymUnmanagedWriter2(options), pdbFileName, pdbStream, options, ownsStream: false);
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolScopeImpl : SymbolScope {
		readonly ISymUnmanagedScope scope;
		readonly SymbolMethod method;
		readonly SymbolScope parent;

		public SymbolScopeImpl(ISymUnmanagedScope scope, SymbolMethod method, SymbolScope parent) {
			this.scope = scope;
			this.method = method;
			this.parent = parent;
		}

		public override SymbolMethod Method => method;
		public override SymbolScope Parent => parent;

		public override int StartOffset {
			get {
				scope.GetStartOffset(out uint result);
				return (int)result;
			}
		}

		public override int EndOffset {
			get {
				scope.GetEndOffset(out uint result);
				return (int)result;
			}
		}

		public override IList<SymbolScope> Children {
			get {
				if (children is null) {
					scope.GetChildren(0, out uint numScopes, null);
					var unScopes = new ISymUnmanagedScope[numScopes];
					scope.GetChildren((uint)unScopes.Length, out numScopes, unScopes);
					var scopes = new SymbolScope[numScopes];
					for (uint i = 0; i < numScopes; i++)
						scopes[i] = new SymbolScopeImpl(unScopes[i], method, this);
					children = scopes;
				}
				return children;
			}
		}
		volatile SymbolScope[] children;

		public override IList<SymbolVariable> Locals {
			get {
				if (locals is null) {
					scope.GetLocals(0, out uint numVars, null);
					var unVars = new ISymUnmanagedVariable[numVars];
					scope.GetLocals((uint)unVars.Length, out numVars, unVars);
					var vars = new SymbolVariable[numVars];
					for (uint i = 0; i < numVars; i++)
						vars[i] = new SymbolVariableImpl(unVars[i]);
					locals = vars;
				}
				return locals;
			}
		}
		volatile SymbolVariable[] locals;

		public override IList<SymbolNamespace> Namespaces {
			get {
				if (namespaces is null) {
					scope.GetNamespaces(0, out uint numNss, null);
					var unNss = new ISymUnmanagedNamespace[numNss];
					scope.GetNamespaces((uint)unNss.Length, out numNss, unNss);
					var nss = new SymbolNamespace[numNss];
					for (uint i = 0; i < numNss; i++)
						nss[i] = new SymbolNamespaceImpl(unNss[i]);
					namespaces = nss;
				}
				return namespaces;
			}
		}
		volatile SymbolNamespace[] namespaces;

		public override IList<PdbCustomDebugInfo> CustomDebugInfos => Array2.Empty<PdbCustomDebugInfo>();
		public override PdbImportScope ImportScope => null;

		public override IList<PdbConstant> GetConstants(ModuleDef module, GenericParamContext gpContext) {
			var scope2 = scope as ISymUnmanagedScope2;
			if (scope2 is null)
				return Array2.Empty<PdbConstant>();
			scope2.GetConstants(0, out uint numCs, null);
			if (numCs == 0)
				return Array2.Empty<PdbConstant>();
			var unCs = new ISymUnmanagedConstant[numCs];
			scope2.GetConstants((uint)unCs.Length, out numCs, unCs);
			var nss = new PdbConstant[numCs];
			for (uint i = 0; i < numCs; i++) {
				var unc = unCs[i];
				var name = GetName(unc);
				unc.GetValue(out object value);
				var sigBytes = GetSignatureBytes(unc);
				TypeSig signature;
				if (sigBytes.Length == 0)
					signature = null;
				else
					signature = SignatureReader.ReadTypeSig(module, module.CorLibTypes, sigBytes, gpContext);
				nss[i] = new PdbConstant(name, signature, value);
			}
			return nss;
		}

		string GetName(ISymUnmanagedConstant unc) {
			unc.GetName(0, out uint count, null);
			var chars = new char[count];
			unc.GetName((uint)chars.Length, out count, chars);
			if (chars.Length == 0)
				return string.Empty;
			return new string(chars, 0, chars.Length - 1);
		}

		byte[] GetSignatureBytes(ISymUnmanagedConstant unc) {
			const int E_FAIL = unchecked((int)0x80004005);
			const int E_NOTIMPL = unchecked((int)0x80004001);
			int hr = unc.GetSignature(0, out uint bufSize, null);
			if (bufSize == 0 || (hr < 0 && hr != E_FAIL && hr != E_NOTIMPL))
				return Array2.Empty<byte>();
			var buffer = new byte[bufSize];
			hr = unc.GetSignature((uint)buffer.Length, out bufSize, buffer);
			Debug.Assert(hr == 0);
			if (hr != 0)
				return Array2.Empty<byte>();
			return buffer;
		}
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolVariableImpl : SymbolVariable {
		readonly ISymUnmanagedVariable variable;

		public SymbolVariableImpl(ISymUnmanagedVariable variable) => this.variable = variable;

		public override int Index {
			get {
				variable.GetAddressField1(out uint result);
				return (int)result;
			}
		}

		public override PdbLocalAttributes Attributes {
			get {
				variable.GetAttributes(out uint result);
				if ((result & (uint)CorSymVarFlag.VAR_IS_COMP_GEN) != 0)
					return PdbLocalAttributes.DebuggerHidden;
				return PdbLocalAttributes.None;
			}
		}

		public override string Name {
			get {
				variable.GetName(0, out uint count, null);
				var chars = new char[count];
				variable.GetName((uint)chars.Length, out count, chars);
				if (chars.Length == 0)
					return string.Empty;
				return new string(chars, 0, chars.Length - 1);
			}
		}

		public override PdbCustomDebugInfo[] CustomDebugInfos => Array2.Empty<PdbCustomDebugInfo>();
	}
}





namespace dnlib.DotNet.Pdb.Dss {
	sealed class SymbolWriterImpl : SymbolWriter {
		readonly ISymUnmanagedWriter2 writer;
		readonly ISymUnmanagedAsyncMethodPropertiesWriter asyncMethodWriter;
		readonly string pdbFileName;
		readonly Stream pdbStream;
		readonly bool ownsStream;
		readonly bool isDeterministic;
		bool closeCalled;

		public override bool IsDeterministic => isDeterministic;
		public override bool SupportsAsyncMethods => asyncMethodWriter is not null;

		public SymbolWriterImpl(ISymUnmanagedWriter2 writer, string pdbFileName, Stream pdbStream, PdbWriterOptions options, bool ownsStream) {
			this.writer = writer ?? throw new ArgumentNullException(nameof(writer));
			asyncMethodWriter = writer as ISymUnmanagedAsyncMethodPropertiesWriter;
			this.pdbStream = pdbStream ?? throw new ArgumentNullException(nameof(pdbStream));
			this.pdbFileName = pdbFileName;
			this.ownsStream = ownsStream;
			isDeterministic = (options & PdbWriterOptions.Deterministic) != 0 && writer is ISymUnmanagedWriter6;
		}

		public override void Close() {
			if (closeCalled)
				return;
			closeCalled = true;
			writer.Close();
		}

		public override void CloseMethod() => writer.CloseMethod();
		public override void CloseScope(int endOffset) => writer.CloseScope((uint)endOffset);

		public override void DefineAsyncStepInfo(uint[] yieldOffsets, uint[] breakpointOffset, uint[] breakpointMethod) {
			if (asyncMethodWriter is null)
				throw new InvalidOperationException();
			if (yieldOffsets.Length != breakpointOffset.Length || yieldOffsets.Length != breakpointMethod.Length)
				throw new ArgumentException();
			asyncMethodWriter.DefineAsyncStepInfo((uint)yieldOffsets.Length, yieldOffsets, breakpointOffset, breakpointMethod);
		}

		public override void DefineCatchHandlerILOffset(uint catchHandlerOffset) {
			if (asyncMethodWriter is null)
				throw new InvalidOperationException();
			asyncMethodWriter.DefineCatchHandlerILOffset(catchHandlerOffset);
		}

		public override void DefineConstant(string name, object value, uint sigToken) => writer.DefineConstant2(name, value, sigToken);

		public override ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType) {
			writer.DefineDocument(url, ref language, ref languageVendor, ref documentType, out var unDocWriter);
			return unDocWriter is null ? null : new SymbolDocumentWriter(unDocWriter);
		}

		public override void DefineKickoffMethod(uint kickoffMethod) {
			if (asyncMethodWriter is null)
				throw new InvalidOperationException();
			asyncMethodWriter.DefineKickoffMethod(kickoffMethod);
		}

		public override void DefineSequencePoints(ISymbolDocumentWriter document, uint arraySize, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns) {
			var doc = document as SymbolDocumentWriter;
			if (doc is null)
				throw new ArgumentException("document isn't a non-null SymbolDocumentWriter instance");
			writer.DefineSequencePoints(doc.SymUnmanagedDocumentWriter, arraySize, offsets, lines, columns, endLines, endColumns);
		}

		public override void OpenMethod(MDToken method) => writer.OpenMethod(method.Raw);

		public override int OpenScope(int startOffset) {
			writer.OpenScope((uint)startOffset, out uint result);
			return (int)result;
		}

		public override void SetSymAttribute(MDToken parent, string name, byte[] data) => writer.SetSymAttribute(parent.Raw, name, (uint)data.Length, data);
		public override void SetUserEntryPoint(MDToken entryMethod) => writer.SetUserEntryPoint(entryMethod.Raw);
		public override void UsingNamespace(string fullName) => writer.UsingNamespace(fullName);

		public override unsafe bool GetDebugInfo(ChecksumAlgorithm pdbChecksumAlgorithm, ref uint pdbAge, out Guid guid, out uint stamp, out IMAGE_DEBUG_DIRECTORY pIDD, out byte[] codeViewData) {
			pIDD = default;
			codeViewData = null;

			if (isDeterministic) {
				((ISymUnmanagedWriter3)writer).Commit();
				var oldPos = pdbStream.Position;
				pdbStream.Position = 0;
				var checksumBytes = Hasher.Hash(pdbChecksumAlgorithm, pdbStream, pdbStream.Length);
				pdbStream.Position = oldPos;
				if (writer is ISymUnmanagedWriter8 writer8) {
					RoslynContentIdProvider.GetContentId(checksumBytes, out guid, out stamp);
					writer8.UpdateSignature(guid, stamp, pdbAge);
					return true;
				}
				else if (writer is ISymUnmanagedWriter7 writer7) {
					fixed (byte* p = checksumBytes)
						writer7.UpdateSignatureByHashingContent(new IntPtr(p), (uint)checksumBytes.Length);
				}
			}

			writer.GetDebugInfo(out pIDD, 0, out uint size, null);
			codeViewData = new byte[size];
			writer.GetDebugInfo(out pIDD, size, out size, codeViewData);

			if (writer is IPdbWriter comPdbWriter) {
				var guidBytes = new byte[16];
				Array.Copy(codeViewData, 4, guidBytes, 0, 16);
				guid = new Guid(guidBytes);
				comPdbWriter.GetSignatureAge(out stamp, out uint age);
				Debug.Assert(age == pdbAge);
				pdbAge = age;
				return true;
			}

			Debug.Fail($"COM PDB writer doesn't impl {nameof(IPdbWriter)}");
			guid = default;
			stamp = 0;
			return false;
		}

		public override void DefineLocalVariable(string name, uint attributes, uint sigToken, uint addrKind, uint addr1, uint addr2, uint addr3, uint startOffset, uint endOffset) =>
			writer.DefineLocalVariable2(name, attributes, sigToken, addrKind, addr1, addr2, addr3, startOffset, endOffset);

		public override void Initialize(Writer.Metadata metadata) {
			if (isDeterministic)
				((ISymUnmanagedWriter6)writer).InitializeDeterministic(new MDEmitter(metadata), new StreamIStream(pdbStream));
			else
				writer.Initialize(new MDEmitter(metadata), pdbFileName, new StreamIStream(pdbStream), true);
		}

		public override unsafe void SetSourceServerData(byte[] data) {
			if (data is null)
				return;
			if (writer is ISymUnmanagedWriter8 writer8) {
				fixed (void* p = data)
					writer8.SetSourceServerData(new IntPtr(p), (uint)data.Length);
			}
		}

		public override unsafe void SetSourceLinkData(byte[] data) {
			if (data is null)
				return;
			if (writer is ISymUnmanagedWriter8 writer8) {
				fixed (void* p = data)
					writer8.SetSourceLinkData(new IntPtr(p), (uint)data.Length);
			}
		}

		public override void Dispose() {
			Marshal.FinalReleaseComObject(writer);
			if (ownsStream)
				pdbStream.Dispose();
		}
	}
}





// Dss = Diagnostics Symbol Store = http://msdn.microsoft.com/en-us/library/ms404519.aspx
namespace dnlib.DotNet.Pdb.Dss {
	[ComVisible(true),
	ComImport,
	Guid("969708D2-05E5-4861-A3B0-96E473CDF63F"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedDispose {
		[PreserveSig]
		int Destroy();
	}

	[ComVisible(true),
	ComImport,
	Guid("997DD0CC-A76F-4c82-8D79-EA87559D27AD"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedSourceServerModule {
		[PreserveSig]
		int GetSourceServerData(out int pDataByteCount, out IntPtr ppData);
	}

	[ComVisible(true),
	ComImport,
	Guid("B4CE6286-2A6B-3712-A3B7-1EE1DAD467B5"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedReader {
		void GetDocument([In, MarshalAs(UnmanagedType.LPWStr)] string url, [In] Guid language, [In] Guid languageVendor, [In] Guid documentType, [Out] out ISymUnmanagedDocument pRetVal);
		void GetDocuments([In] uint cDocs, [Out] out uint pcDocs, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedDocument[] pDocs);
		[PreserveSig]
		int GetUserEntryPoint([Out] out uint pToken);
		void GetMethod([In] uint token, [Out] out ISymUnmanagedMethod retVal);
		[PreserveSig]
		int GetMethodByVersion([In] uint token, [In] int version, [Out] out ISymUnmanagedMethod pRetVal);
		void GetVariables([In] uint parent, [In] uint cVars, [Out] out uint pcVars, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] ISymUnmanagedVariable[] pVars);
		void GetGlobalVariables([In] uint cVars, [Out] out uint pcVars, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] pVars);
		void GetMethodFromDocumentPosition([In] ISymUnmanagedDocument document, [In] uint line, [In] uint column, [Out] out ISymUnmanagedMethod pRetVal);
		void GetSymAttribute([In] uint parent, [In, MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint cBuffer, [Out] out uint pcBuffer, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] buffer);
		void GetNamespaces([In] uint cNameSpaces, [Out] out uint pcNameSpaces, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedNamespace[] namespaces);
		[PreserveSig]
		int Initialize([In, MarshalAs(UnmanagedType.IUnknown)] object importer, [In, MarshalAs(UnmanagedType.LPWStr)] string filename, [In, MarshalAs(UnmanagedType.LPWStr)] string searchPath, [In] IStream pIStream);
		void UpdateSymbolStore([In, MarshalAs(UnmanagedType.LPWStr)] string filename, [In] IStream pIStream);
		void ReplaceSymbolStore([In, MarshalAs(UnmanagedType.LPWStr)] string filename, [In] IStream pIStream);
		void GetSymbolStoreFileName([In] uint cchName, [Out] out uint pcchName, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szName);
		void GetMethodsFromDocumentPosition([In] ISymUnmanagedDocument document, [In] uint line, [In] uint column, [In] uint cMethod, [Out] out uint pcMethod, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] ISymUnmanagedMethod[] pRetVal);
		void GetDocumentVersion([In] ISymUnmanagedDocument pDoc, [Out] out int version, [Out] out bool pbCurrent);
		void GetMethodVersion([In] ISymUnmanagedMethod pMethod, [Out] out int version);
	}

	[ComVisible(true),
	ComImport,
	Guid("A09E53B2-2A57-4cca-8F63-B84F7C35D4AA"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedReader2 : ISymUnmanagedReader {
		void _VtblGap1_17();
		void GetMethodByVersionPreRemap(uint token, uint version, [MarshalAs(UnmanagedType.Interface)] out ISymUnmanagedMethod pRetVal);
		void GetSymAttributePreRemap(uint parent, [In, MarshalAs(UnmanagedType.LPWStr)] string name, uint cBuffer, out uint pcBuffer, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] buffer);
		void GetMethodsInDocument(ISymUnmanagedDocument document, uint bufferLength, out uint count, [MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] [In] [Out] ISymUnmanagedMethod[] methods);
	}

	[ComVisible(true),
	ComImport,
	Guid("6151CAD9-E1EE-437A-A808-F64838C0D046"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedReader3 : ISymUnmanagedReader2 {
		void _VtblGap1_20();
		void GetSymAttributeByVersion(uint token, uint version, [MarshalAs(UnmanagedType.LPWStr)] string name, uint cBuffer, out uint pcBuffer, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] buffer);
		void GetSymAttributeByVersionPreRemap(int methodToken, int version, [MarshalAs(UnmanagedType.LPWStr)] string name, int cBuffer, out int pcBuffer, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] buffer);
	}

	[ComVisible(true),
	ComImport,
	Guid("E65C58B7-2948-434D-8A6D-481740A00C16"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedReader4 : ISymUnmanagedReader3 {
		void _VtblGap1_22();
		[PreserveSig]
		int MatchesModule(Guid guid, uint stamp, uint age, [MarshalAs(UnmanagedType.Bool)] out bool result);
		void GetPortableDebugMetadata(out IntPtr pMetadata, out uint pcMetadata);
		[PreserveSig]
		int GetSourceServerData(out IntPtr data, out int pcData);
	}

	[ComVisible(true),
	ComImport,
	Guid("6576C987-7E8D-4298-A6E1-6F9783165F07"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedReader5 : ISymUnmanagedReader4 {
		void _VtblGap1_25();
		void GetPortableDebugMetadataByVersion(uint version, out IntPtr pMetadata, out uint pcMetadata);
	}

	[ComVisible(true),
	ComImport,
	Guid("40DE4037-7C81-3E1E-B022-AE1ABFF2CA08"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedDocument {
		void GetURL([In] uint cchUrl, [Out] out uint pcchUrl, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szUrl);
		void GetDocumentType([Out] out Guid pRetVal);
		void GetLanguage([Out] out Guid pRetVal);
		void GetLanguageVendor([Out] out Guid pRetVal);
		void GetCheckSumAlgorithmId([Out] out Guid pRetVal);
		void GetCheckSum([In] uint cData, [Out] out uint pcData, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] data);
		void FindClosestLine([In] uint line, [Out] out uint pRetVal);
		void HasEmbeddedSource([Out] out bool pRetVal);
		[PreserveSig]
		int GetSourceLength([Out] out int pRetVal);
		[PreserveSig]
		int GetSourceRange([In] uint startLine, [In] uint startColumn, [In] uint endLine, [In] uint endColumn, [In] int cSourceBytes, [Out] out int pcSourceBytes, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 4)] byte[] source);
	}

	[ComVisible(true),
	ComImport,
	Guid("B62B923C-B500-3158-A543-24F307A8B7E1"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedMethod {
		void GetToken([Out] out uint pToken);
		void GetSequencePointCount([Out] out uint pRetVal);
		void GetRootScope([Out] out ISymUnmanagedScope pRetVal);
		void GetScopeFromOffset([In] uint offset, [Out] out ISymUnmanagedScope pRetVal);
		void GetOffset([In] ISymUnmanagedDocument document, [In] uint line, [In] uint column, [Out] out uint pRetVal);
		void GetRanges([In] ISymUnmanagedDocument document, [In] uint line, [In] uint column, [In] uint cRanges, [Out] out uint pcRanges, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] int[] ranges);
		void GetParameters([In] uint cParams, [Out] out uint pcParams, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] parameters);
		void GetNamespace([Out] out ISymUnmanagedNamespace pRetVal);
		void GetSourceStartEnd([In] ISymUnmanagedDocument[/*2*/] docs, [In] int[/*2*/] lines, [In] int[/*2*/] columns, [Out] out bool pRetVal);
		void GetSequencePoints([In] uint cPoints, [Out] out uint pcPoints, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] offsets, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedDocument[] documents, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] lines, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] columns, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] endLines, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] int[] endColumns);
	}

	[ComVisible(true),
	ComImport,
	Guid("5DA320C8-9C2C-4E5A-B823-027E0677B359"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedMethod2 : ISymUnmanagedMethod {
		void _VtblGap1_10();
		void GetLocalSignatureToken(out uint token);
	}

	[ComVisible(true),
	ComImport,
	Guid("B20D55B3-532E-4906-87E7-25BD5734ABD2"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedAsyncMethod {
		bool IsAsyncMethod();
		uint GetKickoffMethod();
		bool HasCatchHandlerILOffset();
		uint GetCatchHandlerILOffset();
		uint GetAsyncStepInfoCount();
		void GetAsyncStepInfo([In] uint cStepInfo, [Out] out uint pcStepInfo, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] yieldOffsets, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] breakpointOffset, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] breakpointMethod);
	}

	[ComVisible(true),
	ComImport,
	Guid("9F60EEBE-2D9A-3F7C-BF58-80BC991C60BB"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedVariable {
		void GetName([In] uint cchName, [Out] out uint pcchName, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szName);
		void GetAttributes([Out] out uint pRetVal);
		void GetSignature([In] uint cSig, [Out] out uint pcSig, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] sig);
		void GetAddressKind([Out] out uint pRetVal);
		void GetAddressField1([Out] out uint pRetVal);
		void GetAddressField2([Out] out uint pRetVal);
		void GetAddressField3([Out] out uint pRetVal);
		void GetStartOffset([Out] out uint pRetVal);
		void GetEndOffset([Out] out uint pRetVal);
	}

	[ComVisible(true),
	ComImport,
	Guid("0DFF7289-54F8-11D3-BD28-0000F80849BD"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedNamespace {
		void GetName([In] uint cchName, [Out] out uint pcchName, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szName);
		void GetNamespaces([In] uint cNameSpaces, [Out] out uint pcNameSpaces, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedNamespace[] namespaces);
		void GetVariables([In] uint cVars, [Out] out uint pcVars, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] pVars);
	}

	[ComVisible(true),
	ComImport,
	Guid("68005D0F-B8E0-3B01-84D5-A11A94154942"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedScope {
		void GetMethod([Out] out ISymUnmanagedMethod pRetVal);
		void GetParent([Out] out ISymUnmanagedScope pRetVal);
		void GetChildren([In] uint cChildren, [Out] out uint pcChildren, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedScope[] children);
		void GetStartOffset([Out] out uint pRetVal);
		void GetEndOffset([Out] out uint pRetVal);
		void GetLocalCount([Out] out uint pRetVal);
		void GetLocals([In] uint cLocals, [Out] out uint pcLocals, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] locals);
		void GetNamespaces([In] uint cNameSpaces, [Out] out uint pcNameSpaces, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedNamespace[] namespaces);
	}

	[ComVisible(true),
	ComImport,
	Guid("AE932FBA-3FD8-4dba-8232-30A2309B02DB"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedScope2 : ISymUnmanagedScope {
#pragma warning disable 0108
		void GetMethod([Out] out ISymUnmanagedMethod pRetVal);
		void GetParent([Out] out ISymUnmanagedScope pRetVal);
		void GetChildren([In] uint cChildren, [Out] out uint pcChildren, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedScope[] children);
		void GetStartOffset([Out] out uint pRetVal);
		void GetEndOffset([Out] out uint pRetVal);
		void GetLocalCount([Out] out uint pRetVal);
		void GetLocals([In] uint cLocals, [Out] out uint pcLocals, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedVariable[] locals);
		void GetNamespaces([In] uint cNameSpaces, [Out] out uint pcNameSpaces, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedNamespace[] namespaces);
#pragma warning restore 0108

		uint GetConstantCount();
		void GetConstants([In] uint cConstants, [Out] out uint pcConstants, [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] ISymUnmanagedConstant[] constants);
	}

	[ComVisible(true),
	ComImport,
	Guid("48B25ED8-5BAD-41bc-9CEE-CD62FABC74E9"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedConstant {
		void GetName([In] uint cchName, [Out] out uint pcchName, [In, Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] char[] szName);
		void GetValue(out object pValue);
		[PreserveSig]
		int GetSignature([In] uint cSig, [Out] out uint pcSig, [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] sig);
	}

	[ComVisible(true),
	ComImport,
	Guid("7DAC8207-D3AE-4C75-9B67-92801A497D44"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	unsafe interface IMetaDataImport {
		void CloseEnum(IntPtr hEnum);
		void CountEnum(IntPtr hEnum, ref uint pulCount);
		void ResetEnum(IntPtr hEnum, uint ulPos);
		void EnumTypeDefs(IntPtr phEnum, uint[] rTypeDefs, uint cMax, out uint pcTypeDefs);
		void EnumInterfaceImpls(ref IntPtr phEnum, uint td, uint[] rImpls, uint cMax, ref uint pcImpls);
		void EnumTypeRefs(ref IntPtr phEnum, uint[] rTypeRefs, uint cMax, ref uint pcTypeRefs);
		void FindTypeDefByName([In, MarshalAs(UnmanagedType.LPWStr)] string szTypeDef, [In] uint tkEnclosingClass, [Out] out uint ptd);
		void GetScopeProps([Out] IntPtr szName, [In] uint cchName, [Out] out uint pchName, [Out] out Guid pmvid);
		void GetModuleFromScope([Out] out uint pmd);
		void GetTypeDefProps([In] uint td, [In] ushort* szTypeDef, [In] uint cchTypeDef, [Out] uint* pchTypeDef, [Out] uint* pdwTypeDefFlags, [Out] uint* ptkExtends);
		void GetInterfaceImplProps([In] uint iiImpl, [Out] out uint pClass, [Out] out uint ptkIface);
		void GetTypeRefProps([In] uint tr, [Out] uint* ptkResolutionScope, [Out] ushort* szName, [In] uint cchName, [Out] uint* pchName);
		void ResolveTypeRef(uint tr, ref Guid riid, [MarshalAs(UnmanagedType.IUnknown)] out object ppIScope, out uint ptd);
		void EnumMembers([In, Out] ref IntPtr phEnum, [In] uint cl, [Out] uint[] rMembers, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMembersWithName([In, Out] ref IntPtr phEnum, [In] uint cl, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] uint[] rMembers, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMethods([In, Out] ref IntPtr phEnum, [In] uint cl, [Out] uint[] rMethods, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMethodsWithName([In, Out] ref IntPtr phEnum, [In] uint cl, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, uint[] rMethods, [In] uint cMax, [Out] out uint pcTokens);
		void EnumFields([In, Out] ref IntPtr phEnum, [In] uint cl, [Out] uint[] rFields, [In] uint cMax, [Out] out uint pcTokens);
		void EnumFieldsWithName([In, Out] ref IntPtr phEnum, [In] uint cl, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] uint[] rFields, [In] uint cMax, [Out] out uint pcTokens);
		void EnumParams([In, Out] ref IntPtr phEnum, [In] uint mb, [Out] uint[] rParams, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMemberRefs([In, Out] ref IntPtr phEnum, [In] uint tkParent, [Out] uint[] rMemberRefs, [In] uint cMax, [Out] out uint pcTokens);
		void EnumMethodImpls([In, Out] ref IntPtr phEnum, [In] uint td, [Out] uint[] rMethodBody, [Out] uint[] rMethodDecl, [In] uint cMax, [Out] out uint pcTokens);
		void EnumPermissionSets([In, Out] ref IntPtr phEnum, [In] uint tk, [In] uint dwActions, [Out] uint[] rPermission, [In] uint cMax, [Out] out uint pcTokens);
		void FindMember([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmb);
		void FindMethod([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmb);
		void FindField([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmb);
		void FindMemberRef([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmr);
		void GetMethodProps(uint mb, uint* pClass, [In] ushort* szMethod, uint cchMethod, uint* pchMethod, uint* pdwAttr, [Out] IntPtr* ppvSigBlob, [Out] uint* pcbSigBlob, [Out] uint* pulCodeRVA, [Out] uint* pdwImplFlags);
		void GetMemberRefProps([In] uint mr, [Out] out uint ptk, [Out] IntPtr szMember, [In] uint cchMember, [Out] out uint pchMember, [Out] out IntPtr ppvSigBlob, [Out] out uint pbSig);
		void EnumProperties([In, Out] ref IntPtr phEnum, [In] uint td, [Out] uint[] rProperties, [In] uint cMax, [Out] out uint pcProperties);
		void EnumEvents([In, Out] ref IntPtr phEnum, [In] uint td, [Out] uint[] rEvents, [In] uint cMax, [Out] out uint pcEvents);
		void GetEventProps([In] uint ev, [Out] out uint pClass, [Out] [MarshalAs(UnmanagedType.LPWStr)] string szEvent, [In] uint cchEvent, [Out] out uint pchEvent, [Out] out uint pdwEventFlags, [Out] out uint ptkEventType, [Out] out uint pmdAddOn, [Out] out uint pmdRemoveOn, [Out] out uint pmdFire, [In, Out] uint[] rmdOtherMethod, [In] uint cMax, [Out] out uint pcOtherMethod);
		void EnumMethodSemantics([In, Out] ref IntPtr phEnum, [In] uint mb, [In, Out] uint[] rEventProp, [In] uint cMax, [Out] out uint pcEventProp);
		void GetMethodSemantics([In] uint mb, [In] uint tkEventProp, [Out] out uint pdwSemanticsFlags);
		void GetClassLayout([In] uint td, [Out] out uint pdwPackSize, [Out] out IntPtr rFieldOffset, [In] uint cMax, [Out] out uint pcFieldOffset, [Out] out uint pulClassSize);
		void GetFieldMarshal([In] uint tk, [Out] out IntPtr ppvNativeType, [Out] out uint pcbNativeType);
		void GetRVA(uint tk, out uint pulCodeRVA, out uint pdwImplFlags);
		void GetPermissionSetProps([In] uint pm, [Out] out uint pdwAction, [Out] out IntPtr ppvPermission, [Out] out uint pcbPermission);
		void GetSigFromToken([In] uint mdSig, [Out] byte** ppvSig, [Out] uint* pcbSig);
		void GetModuleRefProps([In] uint mur, [Out] IntPtr szName, [In] uint cchName, [Out] out uint pchName);
		void EnumModuleRefs([In, Out] ref IntPtr phEnum, [Out] uint[] rModuleRefs, [In] uint cmax, [Out] out uint pcModuleRefs);
		void GetTypeSpecFromToken([In] uint typespec, [Out] out IntPtr ppvSig, [Out] out uint pcbSig);
		void GetNameFromToken([In] uint tk, [Out] out IntPtr pszUtf8NamePtr);
		void EnumUnresolvedMethods([In, Out] ref IntPtr phEnum, [Out] uint[] rMethods, [In] uint cMax, [Out] out uint pcTokens);
		void GetUserString([In] uint stk, [Out] IntPtr szString, [In] uint cchString, [Out] out uint pchString);
		void GetPinvokeMap([In] uint tk, [Out] out uint pdwMappingFlags, [Out] IntPtr szImportName, [In] uint cchImportName, [Out] out uint pchImportName, [Out] out uint pmrImportDLL);
		void EnumSignatures([In, Out] ref IntPtr phEnum, [Out] uint[] rSignatures, [In] uint cmax, [Out] out uint pcSignatures);
		void EnumTypeSpecs([In, Out] ref IntPtr phEnum, [Out] uint[] rTypeSpecs, [In] uint cmax, [Out] out uint pcTypeSpecs);
		void EnumUserStrings([In, Out] ref IntPtr phEnum, [Out] uint[] rStrings, [In] uint cmax, [Out] out uint pcStrings);
		void GetParamForMethodIndex([In] uint md, [In] uint ulParamSeq, [Out] out uint ppd);
		void EnumCustomAttributes([In, Out] IntPtr phEnum, [In] uint tk, [In] uint tkType, [Out] uint[] rCustomAttributes, [In] uint cMax, [Out] out uint pcCustomAttributes);
		void GetCustomAttributeProps([In] uint cv, [Out] out uint ptkObj, [Out] out uint ptkType, [Out] out IntPtr ppBlob, [Out] out uint pcbSize);
		void FindTypeRef([In] uint tkResolutionScope, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] out uint ptr);
		void GetMemberProps(uint mb, out uint pClass, IntPtr szMember, uint cchMember, out uint pchMember, out uint pdwAttr, [Out] out IntPtr ppvSigBlob, [Out] out uint pcbSigBlob, [Out] out uint pulCodeRVA, [Out] out uint pdwImplFlags, [Out] out uint pdwCPlusTypeFlag, [Out] out IntPtr ppValue, [Out] out uint pcchValue);
		void GetFieldProps(uint mb, out uint pClass, IntPtr szField, uint cchField, out uint pchField, out uint pdwAttr, [Out] out IntPtr ppvSigBlob, [Out] out uint pcbSigBlob, [Out] out uint pdwCPlusTypeFlag, [Out] out IntPtr ppValue, [Out] out uint pcchValue);
		void GetPropertyProps([In] uint prop, [Out] out uint pClass, [Out] IntPtr szProperty, [In] uint cchProperty, [Out] out uint pchProperty, [Out] out uint pdwPropFlags, [Out] out IntPtr ppvSig, [Out] out uint pbSig, [Out] out uint pdwCPlusTypeFlag, [Out] out IntPtr ppDefaultValue, [Out] out uint pcchDefaultValue, [Out] out uint pmdSetter, [Out] out uint pmdGetter, [In, Out] uint[] rmdOtherMethod, [In] uint cMax, [Out] out uint pcOtherMethod);
		void GetParamProps([In] uint tk, [Out] out uint pmd, [Out] out uint pulSequence, [Out] IntPtr szName, [Out] uint cchName, [Out] out uint pchName, [Out] out uint pdwAttr, [Out] out uint pdwCPlusTypeFlag, [Out] out IntPtr ppValue, [Out] out uint pcchValue);
		void GetCustomAttributeByName([In] uint tkObj, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] out IntPtr ppData, [Out] out uint pcbData);
		bool IsValidToken([In] uint tk);
		void GetNestedClassProps([In] uint tdNestedClass, [Out] uint* ptdEnclosingClass);
		void GetNativeCallConvFromSig([In] IntPtr pvSig, [In] uint cbSig, [Out] out uint pCallConv);
		void IsGlobal([In] uint pd, [Out] out int pbGlobal);
	}

	[ComVisible(true),
	ComImport,
	Guid("BA3FEE4C-ECB9-4E41-83B7-183FA41CD859"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface IMetaDataEmit {
		void SetModuleProps([In] [MarshalAs(UnmanagedType.LPWStr)] string szName);
		void Save([In] [MarshalAs(UnmanagedType.LPWStr)] string szFile, [In] uint dwSaveFlags);
		void SaveToStream([In] IStream pIStream, [In] uint dwSaveFlags);
		void GetSaveSize([In] int fSave, [Out] out uint pdwSaveSize);
		void DefineTypeDef([In] [MarshalAs(UnmanagedType.LPWStr)] string szTypeDef, [In] uint dwTypeDefFlags, [In] uint tkExtends, [In] uint[] rtkImplements, [Out] out uint ptd);
		void DefineNestedType([In] [MarshalAs(UnmanagedType.LPWStr)] string szTypeDef, [In] uint dwTypeDefFlags, [In] uint tkExtends, [In] uint[] rtkImplements, [In] uint tdEncloser, [Out] out uint ptd);
		void SetHandler([In, MarshalAs(UnmanagedType.IUnknown)] object pUnk);
		void DefineMethod(uint td, [MarshalAs(UnmanagedType.LPWStr)] string szName, uint dwMethodFlags, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, uint ulCodeRVA, uint dwImplFlags, out uint pmd);
		void DefineMethodImpl([In] uint td, [In] uint tkBody, [In] uint tkDecl);
		void DefineTypeRefByName([In] uint tkResolutionScope, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] out uint ptr);
		void DefineImportType([In] IntPtr pAssemImport, [In] IntPtr pbHashValue, [In] uint cbHashValue, [In] IMetaDataImport pImport, [In] uint tdImport, [In] IntPtr pAssemEmit, [Out] out uint ptr);
		void DefineMemberRef([In] uint tkImport, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [Out] out uint pmr);
		void DefineImportMember([In] IntPtr pAssemImport, [In] IntPtr pbHashValue, [In] uint cbHashValue, [In] IMetaDataImport pImport, [In] uint mbMember, [In] IntPtr pAssemEmit, [In] uint tkParent, [Out] out uint pmr);
		void DefineEvent([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szEvent, [In] uint dwEventFlags, [In] uint tkEventType, [In] uint mdAddOn, [In] uint mdRemoveOn, [In] uint mdFire, [In] uint[] rmdOtherMethods, [Out] out uint pmdEvent);
		void SetClassLayout([In] uint td, [In] uint dwPackSize, [In] IntPtr rFieldOffsets, [In] uint ulClassSize);
		void DeleteClassLayout([In] uint td);
		void SetFieldMarshal([In] uint tk, [In] IntPtr pvNativeType, [In] uint cbNativeType);
		void DeleteFieldMarshal([In] uint tk);
		void DefinePermissionSet([In] uint tk, [In] uint dwAction, [In] IntPtr pvPermission, [In] uint cbPermission, [Out] out uint ppm);
		void SetRVA([In] uint md, [In] uint ulRVA);
		void GetTokenFromSig([In] IntPtr pvSig, [In] uint cbSig, [Out] out uint pmsig);
		void DefineModuleRef([In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [Out] out uint pmur);
		void SetParent([In] uint mr, [In] uint tk);
		void GetTokenFromTypeSpec([In] IntPtr pvSig, [In] uint cbSig, [Out] out uint ptypespec);
		void SaveToMemory([Out] out IntPtr pbData, [In] uint cbData);
		void DefineUserString([In] [MarshalAs(UnmanagedType.LPWStr)] string szString, [In] uint cchString, [Out] out uint pstk);
		void DeleteToken([In] uint tkObj);
		void SetMethodProps([In] uint md, [In] uint dwMethodFlags, [In] uint ulCodeRVA, [In] uint dwImplFlags);
		void SetTypeDefProps([In] uint td, [In] uint dwTypeDefFlags, [In] uint tkExtends, [In] uint[] rtkImplements);
		void SetEventProps([In] uint ev, [In] uint dwEventFlags, [In] uint tkEventType, [In] uint mdAddOn, [In] uint mdRemoveOn, [In] uint mdFire, [In] uint[] rmdOtherMethods);
		void SetPermissionSetProps([In] uint tk, [In] uint dwAction, [In] IntPtr pvPermission, [In] uint cbPermission, [Out] out uint ppm);
		void DefinePinvokeMap([In] uint tk, [In] uint dwMappingFlags, [In] [MarshalAs(UnmanagedType.LPWStr)] string szImportName, [In] uint mrImportDLL);
		void SetPinvokeMap([In] uint tk, [In] uint dwMappingFlags, [In] [MarshalAs(UnmanagedType.LPWStr)] string szImportName, [In] uint mrImportDLL);
		void DeletePinvokeMap([In] uint tk);
		void DefineCustomAttribute([In] uint tkOwner, [In] uint tkCtor, [In] IntPtr pCustomAttribute, [In] uint cbCustomAttribute, [Out] out uint pcv);
		void SetCustomAttributeValue([In] uint pcv, [In] IntPtr pCustomAttribute, [In] uint cbCustomAttribute);
		void DefineField(uint td, [MarshalAs(UnmanagedType.LPWStr)] string szName, uint dwFieldFlags, [In] IntPtr pvSigBlob, [In] uint cbSigBlob, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue, [Out] out uint pmd);
		void DefineProperty([In] uint td, [In] [MarshalAs(UnmanagedType.LPWStr)] string szProperty, [In] uint dwPropFlags, [In] IntPtr pvSig, [In] uint cbSig, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue, [In] uint mdSetter, [In] uint mdGetter, [In] uint[] rmdOtherMethods, [Out] out uint pmdProp);
		void DefineParam([In] uint md, [In] uint ulParamSeq, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] uint dwParamFlags, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue, [Out] out uint ppd);
		void SetFieldProps([In] uint fd, [In] uint dwFieldFlags, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue);
		void SetPropertyProps([In] uint pr, [In] uint dwPropFlags, [In] uint dwCPlusTypeFlag, [In] IntPtr pValue, [In] uint cchValue, [In] uint mdSetter, [In] uint mdGetter, [In] uint[] rmdOtherMethods);
		void SetParamProps([In] uint pd, [In] [MarshalAs(UnmanagedType.LPWStr)] string szName, [In] uint dwParamFlags, [In] uint dwCPlusTypeFlag, [Out] IntPtr pValue, [In] uint cchValue);
		void DefineSecurityAttributeSet([In] uint tkObj, [In] IntPtr rSecAttrs, [In] uint cSecAttrs, [Out] out uint pulErrorAttr);
		void ApplyEditAndContinue([In, MarshalAs(UnmanagedType.IUnknown)] object pImport);
		void TranslateSigWithScope([In] IntPtr pAssemImport, [In] IntPtr pbHashValue, [In] uint cbHashValue, [In] IMetaDataImport import, [In] IntPtr pbSigBlob, [In] uint cbSigBlob, [In] IntPtr pAssemEmit, [In] IMetaDataEmit emit, [Out] IntPtr pvTranslatedSig, uint cbTranslatedSigMax, [Out] out uint pcbTranslatedSig);
		void SetMethodImplFlags([In] uint md, uint dwImplFlags);
		void SetFieldRVA([In] uint fd, [In] uint ulRVA);
		void Merge([In] IMetaDataImport pImport, [In] IntPtr pHostMapToken, [In, MarshalAs(UnmanagedType.IUnknown)] object pHandler);
		void MergeEnd();
	}

	[ComVisible(true),
	ComImport,
	Guid("ED14AA72-78E2-4884-84E2-334293AE5214"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedWriter {
		void DefineDocument([In] [MarshalAs(UnmanagedType.LPWStr)] string url, [In] ref Guid language, [In] ref Guid languageVendor, [In] ref Guid documentType, [Out] out ISymUnmanagedDocumentWriter pRetVal);
		void SetUserEntryPoint([In] uint entryMethod);
		void OpenMethod([In] uint method);
		void CloseMethod();
		void OpenScope([In] uint startOffset, [Out] out uint pRetVal);
		void CloseScope([In] uint endOffset);
		void SetScopeRange([In] uint scopeID, [In] uint startOffset, [In] uint endOffset);
		void DefineLocalVariable([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3, [In] uint startOffset, [In] uint endOffset);
		void DefineParameter([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint sequence, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineField([In] uint parent, [In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineGlobalVariable([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void Close();
		void SetSymAttribute([In] uint parent, [In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint cData, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] data);
		void OpenNamespace([In] [MarshalAs(UnmanagedType.LPWStr)] string name);
		void CloseNamespace();
		void UsingNamespace([In] [MarshalAs(UnmanagedType.LPWStr)] string fullName);
		void SetMethodSourceRange([In] ISymUnmanagedDocumentWriter startDoc, [In] uint startLine, [In] uint startColumn, [In] ISymUnmanagedDocumentWriter endDoc, [In] uint endLine, [In] uint endColumn);
		void Initialize([In] IntPtr emitter, [In] [MarshalAs(UnmanagedType.LPWStr)] string filename, [In] IStream pIStream, [In] bool fFullBuild);
		void GetDebugInfo([Out] out IMAGE_DEBUG_DIRECTORY pIDD, [In] uint cData, [Out] out uint pcData, [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] data);
		void DefineSequencePoints([In] ISymUnmanagedDocumentWriter document, [In] uint spCount, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] offsets, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] lines, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] columns, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endLines, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endColumns);
		void RemapToken([In] uint oldToken, [In] uint newToken);
		void Initialize2([In, MarshalAs(UnmanagedType.IUnknown)] object emitter, [In] [MarshalAs(UnmanagedType.LPWStr)] string tempfilename, [In] IStream pIStream, [In] bool fFullBuild, [In] [MarshalAs(UnmanagedType.LPWStr)] string finalfilename);
		void DefineConstant([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] object value, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature);
		void Abort();
	}

	[ComVisible(true),
	ComImport,
	Guid("0B97726E-9E6D-4F05-9A26-424022093CAA"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedWriter2 {
		void DefineDocument([In] [MarshalAs(UnmanagedType.LPWStr)] string url, [In] ref Guid language, [In] ref Guid languageVendor, [In] ref Guid documentType, [Out] out ISymUnmanagedDocumentWriter pRetVal);
		void SetUserEntryPoint([In] uint entryMethod);
		void OpenMethod([In] uint method);
		void CloseMethod();
		void OpenScope([In] uint startOffset, [Out] out uint pRetVal);
		void CloseScope([In] uint endOffset);
		void SetScopeRange([In] uint scopeID, [In] uint startOffset, [In] uint endOffset);
		void DefineLocalVariable([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3, [In] uint startOffset, [In] uint endOffset);
		void DefineParameter([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint sequence, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineField([In] uint parent, [In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 3)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineGlobalVariable([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void Close();
		void SetSymAttribute([In] uint parent, [In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint cData, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] data);
		void OpenNamespace([In] [MarshalAs(UnmanagedType.LPWStr)] string name);
		void CloseNamespace();
		void UsingNamespace([In] [MarshalAs(UnmanagedType.LPWStr)] string fullName);
		void SetMethodSourceRange([In] ISymUnmanagedDocumentWriter startDoc, [In] uint startLine, [In] uint startColumn, [In] ISymUnmanagedDocumentWriter endDoc, [In] uint endLine, [In] uint endColumn);
		void Initialize([In, MarshalAs(UnmanagedType.IUnknown)] object emitter, [In] [MarshalAs(UnmanagedType.LPWStr)] string filename, [In] IStream pIStream, [In] bool fFullBuild);
		void GetDebugInfo([Out] out IMAGE_DEBUG_DIRECTORY pIDD, [In] uint cData, [Out] out uint pcData, [Out, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] data);
		void DefineSequencePoints([In] ISymUnmanagedDocumentWriter document, [In] uint spCount, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] offsets, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] lines, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] columns, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endLines, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] int[] endColumns);
		void RemapToken([In] uint oldToken, [In] uint newToken);
		void Initialize2([In, MarshalAs(UnmanagedType.IUnknown)] object emitter, [In] [MarshalAs(UnmanagedType.LPWStr)] string tempfilename, [In] IStream pIStream, [In] bool fFullBuild, [In] [MarshalAs(UnmanagedType.LPWStr)] string finalfilename);
		void DefineConstant([In] [MarshalAs(UnmanagedType.LPWStr)] string name, [In] object value, [In] uint cSig, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 2)] byte[] signature);
		void Abort();
		void DefineLocalVariable2([In, MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint sigToken, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3, [In] uint startOffset, [In] uint endOffset);
		void DefineGlobalVariable2([In, MarshalAs(UnmanagedType.LPWStr)] string name, [In] uint attributes, [In] uint sigToken, [In] uint addrKind, [In] uint addr1, [In] uint addr2, [In] uint addr3);
		void DefineConstant2([In, MarshalAs(UnmanagedType.LPWStr)] string name, [In] object value, [In] uint sigToken);
	}

	[ComVisible(true),
	ComImport,
	Guid("12F1E02C-1E05-4B0E-9468-EBC9D1BB040F"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedWriter3 : ISymUnmanagedWriter2 {
		void _VtblGap1_27();
		void OpenMethod2(uint method, uint isect, uint offset);
		void Commit();
	}

	[ComVisible(true),
	ComImport,
	Guid("BC7E3F53-F458-4C23-9DBD-A189E6E96594"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedWriter4 : ISymUnmanagedWriter3 {
		void _VtblGap1_29();
		void GetDebugInfoWithPadding([In] [Out] ref IMAGE_DEBUG_DIRECTORY pIDD, uint cData, out uint pcData, IntPtr data);
	}

	[ComVisible(true),
	ComImport,
	Guid("DCF7780D-BDE9-45DF-ACFE-21731A32000C"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedWriter5 : ISymUnmanagedWriter4 {
		void _VtblGap1_30();
		void OpenMapTokensToSourceSpans();
		void CloseMapTokensToSourceSpans();
		void MapTokenToSourceSpan(uint token, ISymUnmanagedDocumentWriter document, uint line, uint column, uint endLine, uint endColumn);
	}

	[ComVisible(true),
	ComImport,
	Guid("CA6C2ED9-103D-46A9-B03B-05446485848B"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedWriter6 : ISymUnmanagedWriter5 {
		void _VtblGap1_33();
		void InitializeDeterministic([MarshalAs(UnmanagedType.IUnknown)] object emitter, [MarshalAs(UnmanagedType.IUnknown)] object stream);
	}

	[ComVisible(true),
	ComImport,
	Guid("22DAEAF2-70F6-4EF1-B0C3-984F0BF27BFD"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedWriter7 : ISymUnmanagedWriter6 {
		void _VtblGap1_34();
		void UpdateSignatureByHashingContent(IntPtr buffer, uint cData);
	}

	[ComVisible(true),
	ComImport,
	Guid("5BA52F3B-6BF8-40FC-B476-D39C529B331E"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedWriter8 : ISymUnmanagedWriter7 {
		void _VtblGap1_35();
		void UpdateSignature(Guid pdbId, uint stamp, uint age);
		void SetSourceServerData(IntPtr data, uint cData);
		void SetSourceLinkData(IntPtr data, uint cData);
	}

	[ComVisible(true),
	ComImport,
	Guid("98ECEE1E-752D-11d3-8D56-00C04F680B2B"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface IPdbWriter {
		void _VtblGap1_4();
		void GetSignatureAge(out uint sig, out uint age);
	}

	[ComVisible(true),
	ComImport,
	Guid("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedDocumentWriter {
		void SetSource([In] uint sourceSize, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] byte[] source);
		void SetCheckSum([In] Guid algorithmId, [In] uint checkSumSize, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] checkSum);
	}

	[ComVisible(true),
	ComImport,
	Guid("FC073774-1739-4232-BD56-A027294BEC15"),
	InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	interface ISymUnmanagedAsyncMethodPropertiesWriter {
		void DefineKickoffMethod([In] uint kickoffMethod);
		void DefineCatchHandlerILOffset([In] uint catchHandlerOffset);
		void DefineAsyncStepInfo([In] uint count, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] yieldOffsets, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] breakpointOffset, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] uint[] breakpointMethod);
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiFunction : SymbolMethod {
		public override int Token => token;
		internal int token;

		internal PdbReader reader;

		public string Name { get; private set; }
		public PdbAddress Address { get; private set; }
		public DbiScope Root { get; private set; }
		public List<SymbolSequencePoint> Lines {
			get => lines;
			set => lines = value;
		}
		List<SymbolSequencePoint> lines;

		public void Read(ref DataReader reader, uint recEnd) {
			reader.Position += 4;
			var end = reader.ReadUInt32();
			reader.Position += 4;
			var len = reader.ReadUInt32();
			reader.Position += 8;
			token = reader.ReadInt32();
			Address = PdbAddress.ReadAddress(ref reader);
			reader.Position += 1 + 2;
			Name = PdbReader.ReadCString(ref reader);

			reader.Position = recEnd;
			Root = new DbiScope(this, null, "", Address.Offset, len);
			Root.Read(new RecursionCounter(), ref reader, end);
			FixOffsets(new RecursionCounter(), Root);
		}

		void FixOffsets(RecursionCounter counter, DbiScope scope) {
			if (!counter.Increment())
				return;

			scope.startOffset -= (int)Address.Offset;
			scope.endOffset -= (int)Address.Offset;
			var children = scope.Children;
			int count = children.Count;
			for (int i = 0; i < count; i++)
				FixOffsets(counter, (DbiScope)children[i]);

			counter.Decrement();
		}

		public override SymbolScope RootScope => Root;

		public override IList<SymbolSequencePoint> SequencePoints {
			get {
				var l = lines;
				if (l is null)
					return Array2.Empty<SymbolSequencePoint>();
				return l;
			}
		}

		const string asyncMethodInfoAttributeName = "asyncMethodInfo";
		public int AsyncKickoffMethod {
			get {
				var data = Root.GetSymAttribute(asyncMethodInfoAttributeName);
				if (data is null || data.Length < 4)
					return 0;
				return BitConverter.ToInt32(data, 0);
			}
		}

		public uint? AsyncCatchHandlerILOffset {
			get {
				var data = Root.GetSymAttribute(asyncMethodInfoAttributeName);
				if (data is null || data.Length < 8)
					return null;
				uint token = BitConverter.ToUInt32(data, 4);
				return token == uint.MaxValue ? (uint?)null : token;
			}
		}

		public IList<SymbolAsyncStepInfo> AsyncStepInfos {
			get {
				if (asyncStepInfos is null)
					asyncStepInfos = CreateSymbolAsyncStepInfos();
				return asyncStepInfos;
			}
		}
		volatile SymbolAsyncStepInfo[] asyncStepInfos;

		SymbolAsyncStepInfo[] CreateSymbolAsyncStepInfos() {
			var data = Root.GetSymAttribute(asyncMethodInfoAttributeName);
			if (data is null || data.Length < 12)
				return Array2.Empty<SymbolAsyncStepInfo>();
			int pos = 8;
			int count = BitConverter.ToInt32(data, pos);
			pos += 4;
			if (pos + (long)count * 12 > data.Length)
				return Array2.Empty<SymbolAsyncStepInfo>();
			if (count == 0)
				return Array2.Empty<SymbolAsyncStepInfo>();
			var res = new SymbolAsyncStepInfo[count];
			for (int i = 0; i < res.Length; i++) {
				res[i] = new SymbolAsyncStepInfo(BitConverter.ToUInt32(data, pos), BitConverter.ToUInt32(data, pos + 8), BitConverter.ToUInt32(data, pos + 4));
				pos += 12;
			}
			return res;
		}

		public override void GetCustomDebugInfos(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) =>
			reader.GetCustomDebugInfos(this, method, body, result);
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiModule {
		public DbiModule() {
			Functions = new List<DbiFunction>();
			Documents = new List<DbiDocument>();
		}

		public ushort StreamId { get; private set; }
		uint cbSyms;
		uint cbOldLines;
		uint cbLines;

		public string ModuleName { get; private set; }
		public string ObjectName { get; private set; }

		public List<DbiFunction> Functions { get; private set; }
		public List<DbiDocument> Documents { get; private set; }

		public void Read(ref DataReader reader) {
			reader.Position += 34;
			StreamId = reader.ReadUInt16();
			cbSyms = reader.ReadUInt32();
			cbOldLines = reader.ReadUInt32();
			cbLines = reader.ReadUInt32();
			reader.Position += 16;

			if ((int)cbSyms < 0)
				cbSyms = 0;
			if ((int)cbOldLines < 0)
				cbOldLines = 0;
			if ((int)cbLines < 0)
				cbLines = 0;

			ModuleName = PdbReader.ReadCString(ref reader);
			ObjectName = PdbReader.ReadCString(ref reader);

			reader.Position = (reader.Position + 3) & (~3U);
		}

		public void LoadFunctions(PdbReader pdbReader, ref DataReader reader) {
			reader.Position = 0;
			ReadFunctions(reader.Slice(reader.Position, cbSyms));

			if (Functions.Count > 0) {
				reader.Position += cbSyms + cbOldLines;
				ReadLines(pdbReader, reader.Slice(reader.Position, cbLines));
			}
		}

		void ReadFunctions(DataReader reader) {
			if (reader.ReadUInt32() != 4)
				throw new PdbException("Invalid signature");

			while (reader.Position < reader.Length) {
				var size = reader.ReadUInt16();
				var begin = reader.Position;
				var end = begin + size;

				var type = (SymbolType)reader.ReadUInt16();
				switch (type) {
					case SymbolType.S_GMANPROC:
					case SymbolType.S_LMANPROC:
						var func = new DbiFunction();
						func.Read(ref reader, end);
						Functions.Add(func);
						break;
					default:
						reader.Position = end;
						break;
				}
			}
		}

		void ReadLines(PdbReader pdbReader, DataReader reader) {
			var docs = new Dictionary<uint, DbiDocument>();

			reader.Position = 0;
			while (reader.Position < reader.Length) {
				var sig = (ModuleStreamType)reader.ReadUInt32();
				var size = reader.ReadUInt32();
				var begin = reader.Position;
				var end = (begin + size + 3) & ~3U;

				if (sig == ModuleStreamType.FileInfo)
					ReadFiles(pdbReader, docs, ref reader, end);

				reader.Position = end;
			}

			var sortedFuncs = new DbiFunction[Functions.Count];
			Functions.CopyTo(sortedFuncs, 0);
			Array.Sort(sortedFuncs, (a, b) => a.Address.CompareTo(b.Address));

			reader.Position = 0;
			while (reader.Position < reader.Length) {
				var sig = (ModuleStreamType)reader.ReadUInt32();
				var size = reader.ReadUInt32();
				var begin = reader.Position;
				var end = begin + size;

				if (sig == ModuleStreamType.Lines)
					ReadLines(sortedFuncs, docs, ref reader, end);

				reader.Position = end;
			}
		}

		void ReadFiles(PdbReader pdbReader, Dictionary<uint, DbiDocument> documents, ref DataReader reader, uint end) {
			var begin = reader.Position;
			while (reader.Position < end) {
				var id = reader.Position - begin;

				var nameId = reader.ReadUInt32();
				var len = reader.ReadByte();
				/*var type = */reader.ReadByte();
				var doc = pdbReader.GetDocument(nameId);
				documents.Add(id, doc);

				reader.Position += len;
				reader.Position = (reader.Position + 3) & (~3U);
			}
		}

		void ReadLines(DbiFunction[] funcs, Dictionary<uint, DbiDocument> documents, ref DataReader reader, uint end) {
			var address = PdbAddress.ReadAddress(ref reader);

			int first = 0;
			int last = funcs.Length - 1;
			int found = -1;
			while (first <= last) {
				var index = first + ((last - first) >> 1);
				var addr = funcs[index].Address;
				if (addr < address) {
					first = index + 1;
				}
				else if (addr > address) {
					last = index - 1;
				}
				else {
					found = index;
					break;
				}
			}
			if (found == -1)
				return;

			var flags = reader.ReadUInt16();
			reader.Position += 4;

			if (funcs[found].Lines is null) {
				while (found > 0) {
					var prevFunc = funcs[found - 1];
					if (prevFunc is not null || prevFunc.Address != address)
						break;
					found--;
				}
			}
			else {
				while (found < funcs.Length - 1 && funcs[found] is not null) {
					var nextFunc = funcs[found + 1];
					if (nextFunc.Address != address)
						break;
					found++;
				}
			}
			var func = funcs[found];
			if (func.Lines is not null)
				return;
			func.Lines = new List<SymbolSequencePoint>();

			while (reader.Position < end) {
				var document = documents[reader.ReadUInt32()];
				var count = reader.ReadUInt32();
				reader.Position += 4;

				const int LINE_ENTRY_SIZE = 8;
				const int COL_ENTRY_SIZE = 4;
				var lineTablePos = reader.Position;
				var colTablePos = reader.Position + count * LINE_ENTRY_SIZE;

				for (uint i = 0; i < count; i++) {
					reader.Position = lineTablePos + i * LINE_ENTRY_SIZE;

					var line = new SymbolSequencePoint {
						Document = document
					};
					line.Offset = reader.ReadInt32();
					var lineFlags = reader.ReadUInt32();

					line.Line = (int)(lineFlags & 0x00ffffff);
					line.EndLine = line.Line + (int)((lineFlags >> 24) & 0x7F);
					if ((flags & 1) != 0) {
						reader.Position = colTablePos + i * COL_ENTRY_SIZE;
						line.Column = reader.ReadUInt16();
						line.EndColumn = reader.ReadUInt16();
					}

					func.Lines.Add(line);
				}
			}
		}
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiNamespace : SymbolNamespace {
		public override string Name => name;
		readonly string name;

		public DbiNamespace(string ns) => name = ns;
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiScope : SymbolScope {
		readonly SymbolMethod method;
		readonly SymbolScope parent;
		internal int startOffset;
		internal int endOffset;
		readonly List<SymbolScope> childrenList;
		readonly List<SymbolVariable> localsList;
		readonly List<SymbolNamespace> namespacesList;

		public override SymbolMethod Method => method;
		public override SymbolScope Parent => parent;
		public override int StartOffset => startOffset;
		public override int EndOffset => endOffset;
		public override IList<SymbolScope> Children => childrenList;
		public override IList<SymbolVariable> Locals => localsList;
		public override IList<SymbolNamespace> Namespaces => namespacesList;
		public override IList<PdbCustomDebugInfo> CustomDebugInfos => Array2.Empty<PdbCustomDebugInfo>();
		public override PdbImportScope ImportScope => null;

		public DbiScope(SymbolMethod method, SymbolScope parent, string name, uint offset, uint length) {
			this.method = method;
			this.parent = parent;
			Name = name;
			startOffset = (int)offset;
			endOffset = (int)(offset + length);

			childrenList = new List<SymbolScope>();
			localsList = new List<SymbolVariable>();
			namespacesList = new List<SymbolNamespace>();
		}

		public string Name { get; private set; }

		List<OemInfo> oemInfos;
		List<ConstantInfo> constants;

		readonly struct ConstantInfo {
			public readonly string Name;
			public readonly uint SignatureToken;
			public readonly object Value;
			public ConstantInfo(string name, uint signatureToken, object value) {
				Name = name;
				SignatureToken = signatureToken;
				Value = value;
			}
		}

		internal readonly struct OemInfo {
			public readonly string Name;
			public readonly byte[] Data;
			public OemInfo(string name, byte[] data) {
				Name = name;
				Data = data;
			}
			public override string ToString() => Name + " = (" + Data.Length.ToString() + " bytes)";
		}

		static readonly byte[] dotNetOemGuid = new byte[] {
			0xC9, 0x3F, 0xEA, 0xC6, 0xB3, 0x59, 0xD6, 0x49, 0xBC, 0x25, 0x09, 0x02, 0xBB, 0xAB, 0xB4, 0x60
		};

		public void Read(RecursionCounter counter, ref DataReader reader, uint scopeEnd) {
			if (!counter.Increment())
				throw new PdbException("Scopes too deep");

			while (reader.Position < scopeEnd) {
				var size = reader.ReadUInt16();
				var begin = reader.Position;
				var end = begin + size;

				var type = (SymbolType)reader.ReadUInt16();
				DbiScope child = null;
				uint? childEnd = null;
				string name;
				switch (type) {
					case SymbolType.S_BLOCK32: {
						reader.Position += 4;
						childEnd = reader.ReadUInt32();
						var len = reader.ReadUInt32();
						var addr = PdbAddress.ReadAddress(ref reader);
						name = PdbReader.ReadCString(ref reader);
						child = new DbiScope(method, this, name, addr.Offset, len);
						break;
					}
					case SymbolType.S_UNAMESPACE:
						namespacesList.Add(new DbiNamespace(PdbReader.ReadCString(ref reader)));
						break;
					case SymbolType.S_MANSLOT: {
						var variable = new DbiVariable();
						if (variable.Read(ref reader))
							localsList.Add(variable);
						break;
					}
					case SymbolType.S_OEM:
						if ((ulong)reader.Position + 20 > end)
							break;
						if (!ReadAndCompareBytes(ref reader, end, dotNetOemGuid)) {
							Debug.Fail("Unknown OEM record GUID, not .NET GUID");
							break;
						}
						reader.Position += 4;// typeIndex or 0
						name = ReadUnicodeString(ref reader, end);
						Debug.Assert(name is not null);
						if (name is null)
							break;
						var data = reader.ReadBytes((int)(end - reader.Position));
						if (oemInfos is null)
							oemInfos = new List<OemInfo>(1);
						oemInfos.Add(new OemInfo(name, data));	
						break;
					case SymbolType.S_MANCONSTANT:
						uint signatureToken = reader.ReadUInt32();
						object value;
						if (!NumericReader.TryReadNumeric(ref reader, end, out value))
							break;
						name = PdbReader.ReadCString(ref reader);
						if (constants is null)
							constants = new List<ConstantInfo>();
						constants.Add(new ConstantInfo(name, signatureToken, value));
						break;
					case SymbolType.S_END:
						break;
					default:
						break;
				}

				reader.Position = end;
				if (child is not null) {
					child.Read(counter, ref reader, childEnd.Value);
					childrenList.Add(child);
					child = null;
				}
			}
			counter.Decrement();
			if (reader.Position != scopeEnd)
				Debugger.Break();
		}

		static string ReadUnicodeString(ref DataReader reader, uint end) {
			var sb = new StringBuilder();
			for (;;) {
				if ((ulong)reader.Position + 2 > end)
					return null;
				var c = reader.ReadChar();
				if (c == 0)
					break;
				sb.Append(c);
			}
			return sb.ToString();
		}

		static bool ReadAndCompareBytes(ref DataReader reader, uint end, byte[] bytes) {
			if ((ulong)reader.Position + (uint)bytes.Length > end)
				return false;
			for (int i = 0; i < bytes.Length; i++) {
				if (reader.ReadByte() != bytes[i])
					return false;
			}
			return true;
		}

		public override IList<PdbConstant> GetConstants(ModuleDef module, GenericParamContext gpContext) {
			if (constants is null)
				return Array2.Empty<PdbConstant>();
			var res = new PdbConstant[constants.Count];
			for (int i = 0; i < res.Length; i++) {
				var info = constants[i];
				TypeSig signature;
				var saSig = module.ResolveToken(info.SignatureToken, gpContext) as StandAloneSig;
				var fieldSig = saSig is null ? null : saSig.Signature as FieldSig;
				if (fieldSig is null) {
					Debug.Fail("Constant without a signature");
					signature = null;
				}
				else
					signature = fieldSig.Type;
				res[i] = new PdbConstant(info.Name, signature, info.Value);
			}
			return res;
		}

		internal byte[] GetSymAttribute(string name) {
			if (oemInfos is null)
				return null;
			foreach (var info in oemInfos) {
				if (info.Name == name)
					return info.Data;
			}
			return null;
		}
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiVariable : SymbolVariable {
		public override string Name => name;
		string name;

		public override PdbLocalAttributes Attributes => attributes;
		PdbLocalAttributes attributes;

		public override int Index => index;
		int index;

		public override PdbCustomDebugInfo[] CustomDebugInfos => Array2.Empty<PdbCustomDebugInfo>();

		public bool Read(ref DataReader reader) {
			index = reader.ReadInt32();
			reader.Position += 10;
			ushort flags = reader.ReadUInt16();
			attributes = GetAttributes(flags);
			name = PdbReader.ReadCString(ref reader);

			const int fIsParam = 1;
			return (flags & fIsParam) == 0;
		}

		static PdbLocalAttributes GetAttributes(uint flags) {
			PdbLocalAttributes res = 0;
			const int fCompGenx = 4;
			if ((flags & fCompGenx) != 0)
				res |= PdbLocalAttributes.DebuggerHidden;
			return res;
		}
	}
}




namespace dnlib.DotNet.Pdb.Managed {
	enum ModuleStreamType : uint {
		Symbols = 0xF1,
		Lines = 0xF2,
		StringTable = 0xF3,
		FileInfo = 0xF4,
		FrameData = 0xF5,
		InlineeLines = 0xF6,
		CrossScopeImports = 0xF7,
		CrossScopeExports = 0xF8,
		ILLines = 0xF9,
		FuncMDTokenMap = 0xFA,
		TypeMDTokenMap = 0xFB,
		MergedAssemblyInput = 0xFC,
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	sealed class MsfStream {
		public MsfStream(DataReader[] pages, uint length) {
			var buf = new byte[length];
			int offset = 0;
			for (int i = 0; i < pages.Length; i++) {
				var page = pages[i];
				page.Position = 0;
				int len = Math.Min((int)page.Length, (int)(length - offset));
				page.ReadBytes(buf, offset, len);
				offset += len;
			}
			Content = ByteArrayDataReaderFactory.CreateReader(buf);
		}

		public DataReader Content;
	}
}




namespace dnlib.DotNet.Pdb.Managed {
	enum NumericLeaf : ushort {
		LF_NUMERIC			= 0x8000,
		LF_CHAR				= 0x8000,
		LF_SHORT			= 0x8001,
		LF_USHORT			= 0x8002,
		LF_LONG				= 0x8003,
		LF_ULONG			= 0x8004,
		LF_REAL32			= 0x8005,
		LF_REAL64			= 0x8006,
		LF_REAL80			= 0x8007,
		LF_REAL128			= 0x8008,
		LF_QUADWORD			= 0x8009,
		LF_UQUADWORD		= 0x800A,
		LF_REAL48			= 0x800B,
		LF_COMPLEX32		= 0x800C,
		LF_COMPLEX64		= 0x800D,
		LF_COMPLEX80		= 0x800E,
		LF_COMPLEX128		= 0x800F,
		LF_VARSTRING		= 0x8010,
		LF_RESERVED_8011	= 0x8011,
		LF_RESERVED_8012	= 0x8012,
		LF_RESERVED_8013	= 0x8013,
		LF_RESERVED_8014	= 0x8014,
		LF_RESERVED_8015	= 0x8015,
		LF_RESERVED_8016	= 0x8016,
		LF_OCTWORD			= 0x8017,
		LF_UOCTWORD			= 0x8018,
		LF_VARIANT			= 0x8019,
		LF_DATE				= 0x801A,
		LF_UTF8STRING		= 0x801B,
		LF_REAL16			= 0x801C,
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	static class NumericReader {
		public static bool TryReadNumeric(ref DataReader reader, ulong end, out object value) {
			value = null;
			ulong position = reader.Position;
			if (position + 2 > end)
				return false;
			var numLeaf = (NumericLeaf)reader.ReadUInt16();
			if (numLeaf < NumericLeaf.LF_NUMERIC) {
				value = (short)numLeaf;
				return true;
			}

			switch (numLeaf) {
			case NumericLeaf.LF_CHAR:
				if (position > end)
					return false;
				value = reader.ReadSByte();
				return true;

			case NumericLeaf.LF_SHORT:
				if (position + 2 > end)
					return false;
				value = reader.ReadInt16();
				return true;

			case NumericLeaf.LF_USHORT:
				if (position + 2 > end)
					return false;
				value = reader.ReadUInt16();
				return true;

			case NumericLeaf.LF_LONG:
				if (position + 4 > end)
					return false;
				value = reader.ReadInt32();
				return true;

			case NumericLeaf.LF_ULONG:
				if (position + 4 > end)
					return false;
				value = reader.ReadUInt32();
				return true;

			case NumericLeaf.LF_REAL32:
				if (position + 4 > end)
					return false;
				value = reader.ReadSingle();
				return true;

			case NumericLeaf.LF_REAL64:
				if (position + 8 > end)
					return false;
				value = reader.ReadDouble();
				return true;

			case NumericLeaf.LF_QUADWORD:
				if (position + 8 > end)
					return false;
				value = reader.ReadInt64();
				return true;

			case NumericLeaf.LF_UQUADWORD:
				if (position + 8 > end)
					return false;
				value = reader.ReadUInt64();
				return true;

			case NumericLeaf.LF_VARSTRING:
				if (position + 2 > end)
					return false;
				int varStrLen = reader.ReadUInt16();
				if (position + (uint)varStrLen > end)
					return false;
				value = reader.ReadUtf8String(varStrLen);
				return true;

			case NumericLeaf.LF_VARIANT:
				if (position + 0x10 > end)
					return false;
				int v0 = reader.ReadInt32();
				int v1 = reader.ReadInt32();
				int v2 = reader.ReadInt32();
				int v3 = reader.ReadInt32();
				byte scale = (byte)(v0 >> 16);
				if (scale <= 28)
					value = new decimal(v2, v3, v1, v0 < 0, scale);
				else
					value = null;
				return true;

			default:
				return false;
			}
		}
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	/// <summary>
	/// An address in the image
	/// </summary>
	[DebuggerDisplay("{Section}:{Offset}")]
	readonly struct PdbAddress : IEquatable<PdbAddress>, IComparable<PdbAddress> {
		/// <summary>
		/// Section
		/// </summary>
		public readonly ushort Section;

		/// <summary>
		/// Offset in <see cref="Section"/>
		/// </summary>
		public readonly uint Offset;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="section">Section</param>
		/// <param name="offset">Offset in <paramref name="section"/></param>
		public PdbAddress(ushort section, int offset) {
			Section = section;
			Offset = (uint)offset;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="section">Section</param>
		/// <param name="offset">Offset in <paramref name="section"/></param>
		public PdbAddress(ushort section, uint offset) {
			Section = section;
			Offset = offset;
		}

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is less than or equal to <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator <=(PdbAddress a, PdbAddress b) => a.CompareTo(b) <= 0;

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is less than <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator <(PdbAddress a, PdbAddress b) => a.CompareTo(b) < 0;

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is greater than or equal to <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator >=(PdbAddress a, PdbAddress b) => a.CompareTo(b) >= 0;

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is greater than <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator >(PdbAddress a, PdbAddress b) => a.CompareTo(b) > 0;

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is equal to <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator ==(PdbAddress a, PdbAddress b) => a.Equals(b);

		/// <summary>
		/// Returns <c>true</c> if <paramref name="a"/> is not equal to <paramref name="b"/>
		/// </summary>
		/// <param name="a">First <see cref="PdbAddress"/></param>
		/// <param name="b">Second <see cref="PdbAddress"/></param>
		/// <returns></returns>
		public static bool operator !=(PdbAddress a, PdbAddress b) => !a.Equals(b);

		/// <summary>
		/// Compares this instance with <paramref name="other"/> and returns less than 0 if it's
		/// less than <paramref name="other"/>, 0 if it's equal to <paramref name="other"/> and
		/// greater than 0 if it's greater than <paramref name="other"/>
		/// </summary>
		/// <param name="other">Other instance</param>
		/// <returns></returns>
		public int CompareTo(PdbAddress other) {
			if (Section != other.Section)
				return Section.CompareTo(other.Section);
			return Offset.CompareTo(other.Offset);
		}

		/// <summary>
		/// Compares this to another instance
		/// </summary>
		/// <param name="other">The other one</param>
		/// <returns><c>true</c> if they're equal</returns>
		public bool Equals(PdbAddress other) => Section == other.Section && Offset == other.Offset;

		/// <summary>
		/// Compares this to another instance
		/// </summary>
		/// <param name="obj">The other one</param>
		/// <returns><c>true</c> if they're equal</returns>
		public override bool Equals(object obj) {
			if (!(obj is PdbAddress))
				return false;
			return Equals((PdbAddress)obj);
		}

		/// <summary>
		/// Gets the hash code
		/// </summary>
		/// <returns>Hash code</returns>
		public override int GetHashCode() => (Section << 16) ^ (int)Offset;

		/// <summary>
		/// ToString() override
		/// </summary>
		/// <returns></returns>
		public override string ToString() => $"{Section:X4}:{Offset:X8}";

		/// <summary>
		/// Reads a 32-bit offset followed by a 16-bit section and creates a new <see cref="PdbAddress"/>
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <returns></returns>
		public static PdbAddress ReadAddress(ref DataReader reader) {
			uint offs = reader.ReadUInt32();
			return new PdbAddress(reader.ReadUInt16(), offs);
		}
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	/// <summary>
	/// Exception that is thrown when <see cref="PdbReader"/> encounters an error.
	/// </summary>
	[Serializable]
	sealed class PdbException : Exception {
		/// <summary>
		/// Constructor
		/// </summary>
		public PdbException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Exception message</param>
		public PdbException(string message)
			: base("Failed to read PDB: " + message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="innerException">Inner exception</param>
		public PdbException(Exception innerException)
			: base("Failed to read PDB: " + innerException.Message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		public PdbException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	/// <summary>
	/// A managed PDB reader implementation for .NET modules.
	/// </summary>
	sealed class PdbReader : SymbolReader {
		MsfStream[] streams;
		Dictionary<string, uint> names;
		Dictionary<uint, string> strings;
		List<DbiModule> modules;
		ModuleDef module;

		const int STREAM_ROOT = 0;
		const int STREAM_NAMES = 1;
		const int STREAM_TPI = 2;
		const int STREAM_DBI = 3;
		const ushort STREAM_INVALID_INDEX = ushort.MaxValue;

		Dictionary<string, DbiDocument> documents;
		Dictionary<int, DbiFunction> functions;
		byte[] sourcelinkData;
		byte[] srcsrvData;
		uint entryPt;

		public override PdbFileKind PdbFileKind => PdbFileKind.WindowsPDB;

		uint Age { get; set; }
		Guid Guid { get; set; }

		internal bool MatchesModule => expectedGuid == Guid && expectedAge == Age;
		readonly Guid expectedGuid;
		readonly uint expectedAge;

		public PdbReader(Guid expectedGuid, uint expectedAge) {
			this.expectedGuid = expectedGuid;
			this.expectedAge = expectedAge;
		}

		public override void Initialize(ModuleDef module) => this.module = module;

		/// <summary>
		/// Read the PDB in the specified stream.
		/// </summary>
		/// <param name="reader">PDB file data reader</param>
		public void Read(DataReader reader) {
			try {
				ReadInternal(ref reader);
			}
			catch (Exception ex) {
				if (ex is PdbException)
					throw;
				throw new PdbException(ex);
			}
			finally {
				streams = null;
				names = null;
				strings = null;
				modules = null;
			}
		}

		static uint RoundUpDiv(uint value, uint divisor) => (value + divisor - 1) / divisor;

		void ReadInternal(ref DataReader reader) {
			string sig = reader.ReadString(30, Encoding.ASCII);
			if (sig != "Microsoft C/C++ MSF 7.00\r\n\u001ADS\0")
				throw new PdbException("Invalid signature");
			reader.Position += 2;

			uint pageSize = reader.ReadUInt32();
			/*uint fpm = */reader.ReadUInt32();
			uint pageCount = reader.ReadUInt32();
			uint rootSize = reader.ReadUInt32();
			reader.ReadUInt32();
			var numOfRootPages = RoundUpDiv(rootSize, pageSize);
			var numOfPtrPages = RoundUpDiv(numOfRootPages * 4, pageSize);
			if (pageCount * pageSize != reader.Length)
				throw new PdbException("File size mismatch");

			var pages = new DataReader[pageCount];
			uint offset = 0;
			for (uint i = 0; i < pageCount; i++) {
				pages[i] = reader.Slice(offset, pageSize);
				offset += pageSize;
			}

			var rootPages = new DataReader[numOfRootPages];
			int pageIndex = 0;
			for (int i = 0; i < numOfPtrPages && pageIndex < numOfRootPages; i++) {
				var ptrPage = pages[reader.ReadUInt32()];
				ptrPage.Position = 0;
				for (; ptrPage.Position < ptrPage.Length && pageIndex < numOfRootPages; pageIndex++)
					rootPages[pageIndex] = pages[ptrPage.ReadUInt32()];
			}

			ReadRootDirectory(new MsfStream(rootPages, rootSize), pages, pageSize);

			ReadNames();
			if (!MatchesModule)
				return;
			ReadStringTable();
			var tokenMapStream = ReadModules();

			documents = new Dictionary<string, DbiDocument>(StringComparer.OrdinalIgnoreCase);
			foreach (var module in modules) {
				if (IsValidStreamIndex(module.StreamId))
					module.LoadFunctions(this, ref streams[module.StreamId].Content);
			}

			if (IsValidStreamIndex(tokenMapStream ?? STREAM_INVALID_INDEX))
				ApplyRidMap(ref streams[tokenMapStream.Value].Content);

			functions = new Dictionary<int, DbiFunction>();
			foreach (var module in modules) {
				foreach (var func in module.Functions) {
					func.reader = this;
					functions.Add(func.Token, func);
				}
			}

			sourcelinkData = TryGetRawFileData("sourcelink");
			srcsrvData = TryGetRawFileData("srcsrv");
		}

		byte[] TryGetRawFileData(string name) {
			if (!names.TryGetValue(name, out uint streamId))
				return null;
			if (streamId > ushort.MaxValue || !IsValidStreamIndex((ushort)streamId))
				return null;
			return streams[streamId].Content.ToArray();
		}

		bool IsValidStreamIndex(ushort index) => index != STREAM_INVALID_INDEX && index < streams.Length;

		void ReadRootDirectory(MsfStream stream, DataReader[] pages, uint pageSize) {
			uint streamNum = stream.Content.ReadUInt32();
			var streamSizes = new uint[streamNum];
			for (int i = 0; i < streamSizes.Length; i++)
				streamSizes[i] = stream.Content.ReadUInt32();

			streams = new MsfStream[streamNum];
			for (int i = 0; i < streamSizes.Length; i++) {
				if (streamSizes[i] == 0xffffffff) {
					streams[i] = null;
					continue;
				}
				var pageCount = RoundUpDiv(streamSizes[i], pageSize);
				var streamPages = new DataReader[pageCount];
				for (int j = 0; j < streamPages.Length; j++)
					streamPages[j] = pages[stream.Content.ReadUInt32()];
				streams[i] = new MsfStream(streamPages, streamSizes[i]);
			}
		}

		void ReadNames() {
			ref var stream = ref streams[STREAM_NAMES].Content;
			stream.Position = 8;
			Age = stream.ReadUInt32();
			Guid = stream.ReadGuid();

			uint nameSize = stream.ReadUInt32();
			var nameData = stream.Slice(stream.Position, nameSize);
			stream.Position += nameSize;

			/*uint entryCount = */stream.ReadUInt32();
			uint entryCapacity = stream.ReadUInt32();
			var entryOk = new BitArray(stream.ReadBytes(stream.ReadInt32() * 4));
			if (stream.ReadUInt32() != 0)
				throw new NotSupportedException();

			names = new Dictionary<string, uint>(StringComparer.OrdinalIgnoreCase);
			entryCapacity = Math.Min(entryCapacity, (uint)entryOk.Count);
			for (int i = 0; i < entryCapacity; i++) {
				if (!entryOk[i])
					continue;

				var pos = stream.ReadUInt32();
				var streamId = stream.ReadUInt32();
				nameData.Position = pos;
				var streamName = ReadCString(ref nameData);
				names[streamName] = streamId;
			}
		}

		void ReadStringTable() {
			if (!names.TryGetValue("/names", out uint streamId))
				throw new PdbException("String table not found");

			ref var stream = ref streams[streamId].Content;
			stream.Position = 8;

			uint strSize = stream.ReadUInt32();
			var strData = stream.Slice(stream.Position, strSize);
			stream.Position += strSize;

			uint count = stream.ReadUInt32();
			strings = new Dictionary<uint, string>((int)count);
			for (uint i = 0; i < count; i++) {
				var pos = stream.ReadUInt32();
				if (pos == 0)
					continue;
				strData.Position = pos;
				strings[pos] = ReadCString(ref strData);
			}
		}

		static uint ReadSizeField(ref DataReader reader) {
			int size = reader.ReadInt32();
			return size <= 0 ? 0 : (uint)size;
		}

		ushort? ReadModules() {
			ref var stream = ref streams[STREAM_DBI].Content;
			modules = new List<DbiModule>();
			if (stream.Length == 0)
				return null;
			stream.Position = 20;
			ushort symrecStream = stream.ReadUInt16();
			stream.Position += 2;
			uint gpmodiSize = ReadSizeField(ref stream); // gpmodiSize
			uint otherSize = 0;
			otherSize += ReadSizeField(ref stream); // secconSize
			otherSize += ReadSizeField(ref stream); // secmapSize
			otherSize += ReadSizeField(ref stream); // filinfSize
			otherSize += ReadSizeField(ref stream); // tsmapSize
			stream.ReadUInt32(); // mfcIndex
			uint dbghdrSize = ReadSizeField(ref stream);
			otherSize += ReadSizeField(ref stream); // ecinfoSize
			stream.Position += 8;

			var moduleStream = stream.Slice(stream.Position, gpmodiSize);
			while (moduleStream.Position < moduleStream.Length) {
				var module = new DbiModule();
				module.Read(ref moduleStream);
				modules.Add(module);
			}

			if (IsValidStreamIndex(symrecStream))
				ReadGlobalSymbols(ref streams[symrecStream].Content);

			if (dbghdrSize != 0) {
				stream.Position += gpmodiSize;
				stream.Position += otherSize;
				stream.Position += 12;
				return stream.ReadUInt16();
			}
			return null;
		}

		internal DbiDocument GetDocument(uint nameId) {
			var name = strings[nameId];

			if (!documents.TryGetValue(name, out var doc)) {
				doc = new DbiDocument(name);

				if (names.TryGetValue("/src/files/" + name, out uint streamId))
					doc.Read(ref streams[streamId].Content);
				documents.Add(name, doc);
			}
			return doc;
		}

		void ReadGlobalSymbols(ref DataReader reader) {
			reader.Position = 0;
			while (reader.Position < reader.Length) {
				var size = reader.ReadUInt16();
				var begin = reader.Position;
				var end = begin + size;

				if ((SymbolType)reader.ReadUInt16() == SymbolType.S_PUB32) {
					reader.Position += 4;
					var offset = reader.ReadUInt32();
					reader.Position += 2;
					var name = ReadCString(ref reader);

					if (name == "COM+_Entry_Point") {
						entryPt = offset;
						break;
					}
				}

				reader.Position = end;
			}
		}

		void ApplyRidMap(ref DataReader reader) {
			reader.Position = 0;
			var map = new uint[reader.Length / 4];
			for (int i = 0; i < map.Length; i++)
				map[i] = reader.ReadUInt32();

			foreach (var module in modules) {
				foreach (var func in module.Functions) {
					var rid = (uint)func.Token & 0x00ffffff;
					rid = map[rid];
					func.token = (int)((func.Token & 0xff000000) | rid);
				}
			}

			if (entryPt != 0) {
				var rid = entryPt & 0x00ffffff;
				rid = map[rid];
				entryPt = (entryPt & 0xff000000) | rid;
			}
		}

		internal static string ReadCString(ref DataReader reader) => reader.TryReadZeroTerminatedUtf8String() ?? string.Empty;

		public override SymbolMethod GetMethod(MethodDef method, int version) {
			if (version != 1)
				return null;
			if (functions.TryGetValue(method.MDToken.ToInt32(), out var symMethod))
				return symMethod;
			return null;
		}

		public override IList<SymbolDocument> Documents {
			get {
				if (documentsResult is null) {
					var docs = new SymbolDocument[documents.Count];
					int i = 0;
					foreach (var kv in documents)
						docs[i++] = kv.Value;
					documentsResult = docs;
				}
				return documentsResult;
			}
		}
		volatile SymbolDocument[] documentsResult;

		public override int UserEntryPoint => (int)entryPt;

		internal void GetCustomDebugInfos(DbiFunction symMethod, MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) {
			const string CDI_NAME = "MD2";
			var asyncMethod = PseudoCustomDebugInfoFactory.TryCreateAsyncMethod(method.Module, method, body, symMethod.AsyncKickoffMethod, symMethod.AsyncStepInfos, symMethod.AsyncCatchHandlerILOffset);
			if (asyncMethod is not null)
				result.Add(asyncMethod);

			var cdiData = symMethod.Root.GetSymAttribute(CDI_NAME);
			if (cdiData is null)
				return;
			PdbCustomDebugInfoReader.Read(method, body, result, cdiData);
		}

		public override void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
			if (token == 0x00000001)
				GetCustomDebugInfos_ModuleDef(result);
		}

		void GetCustomDebugInfos_ModuleDef(IList<PdbCustomDebugInfo> result) {
			if (sourcelinkData is not null)
				result.Add(new PdbSourceLinkCustomDebugInfo(sourcelinkData));
			if (srcsrvData is not null)
				result.Add(new PdbSourceServerCustomDebugInfo(srcsrvData));
		}
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	/// <summary>
	/// Creates a <see cref="SymbolReader"/> instance
	/// </summary>
	static class SymbolReaderFactory {
		/// <summary>
		/// Creates a new <see cref="SymbolReader"/> instance
		/// </summary>
		/// <param name="pdbContext">PDB context</param>
		/// <param name="pdbStream">PDB file stream which is now owned by this method</param>
		/// <returns>A new <see cref="SymbolReader"/> instance or <c>null</c>.</returns>
		public static SymbolReader Create(PdbReaderContext pdbContext, DataReaderFactory pdbStream) {
			if (pdbStream is null)
				return null;
			try {
				var debugDir = pdbContext.CodeViewDebugDirectory;
				if (debugDir is null)
					return null;
				if (!pdbContext.TryGetCodeViewData(out var pdbGuid, out uint age))
					return null;

				var pdbReader = new PdbReader(pdbGuid, age);
				pdbReader.Read(pdbStream.CreateReader());
				if (pdbReader.MatchesModule)
					return pdbReader;
				return null;
			}
			catch (PdbException) {
			}
			catch (IOException) {
			}
			finally {
				pdbStream?.Dispose();
			}
			return null;
		}
	}
}




namespace dnlib.DotNet.Pdb.Managed {
	enum SymbolType : ushort {
		S_COMPILE = 0x0001,
		S_REGISTER_16t = 0x0002,
		S_CONSTANT_16t = 0x0003,
		S_UDT_16t = 0x0004,
		S_SSEARCH = 0x0005,
		S_END = 0x0006,
		S_SKIP = 0x0007,
		S_CVRESERVE = 0x0008,
		S_OBJNAME_ST = 0x0009,
		S_ENDARG = 0x000A,
		S_COBOLUDT_16t = 0x000B,
		S_MANYREG_16t = 0x000C,
		S_RETURN = 0x000D,
		S_ENTRYTHIS = 0x000E,

		S_BPREL16 = 0x0100,
		S_LDATA16 = 0x0101,
		S_GDATA16 = 0x0102,
		S_PUB16 = 0x0103,
		S_LPROC16 = 0x0104,
		S_GPROC16 = 0x0105,
		S_THUNK16 = 0x0106,
		S_BLOCK16 = 0x0107,
		S_WITH16 = 0x0108,
		S_LABEL16 = 0x0109,
		S_CEXMODEL16 = 0x010A,
		S_VFTABLE16 = 0x010B,
		S_REGREL16 = 0x010C,

		S_BPREL32_16t = 0x0200,
		S_LDATA32_16t = 0x0201,
		S_GDATA32_16t = 0x0202,
		S_PUB32_16t = 0x0203,
		S_LPROC32_16t = 0x0204,
		S_GPROC32_16t = 0x0205,
		S_THUNK32_ST = 0x0206,
		S_BLOCK32_ST = 0x0207,
		S_WITH32_ST = 0x0208,
		S_LABEL32_ST = 0x0209,
		S_CEXMODEL32 = 0x020A,
		S_VFTABLE32_16t = 0x020B,
		S_REGREL32_16t = 0x020C,
		S_LTHREAD32_16t = 0x020D,
		S_GTHREAD32_16t = 0x020E,
		S_SLINK32 = 0x020F,

		S_LPROCMIPS_16t = 0x0300,
		S_GPROCMIPS_16t = 0x0301,

		S_PROCREF_ST = 0x0400,
		S_DATAREF_ST = 0x0401,
		S_ALIGN = 0x0402,
		S_LPROCREF_ST = 0x0403,
		S_OEM = 0x0404,

		S_TI16_MAX = 0x1000,
		S_REGISTER_ST = 0x1001,
		S_CONSTANT_ST = 0x1002,
		S_UDT_ST = 0x1003,
		S_COBOLUDT_ST = 0x1004,
		S_MANYREG_ST = 0x1005,
		S_BPREL32_ST = 0x1006,
		S_LDATA32_ST = 0x1007,
		S_GDATA32_ST = 0x1008,
		S_PUB32_ST = 0x1009,
		S_LPROC32_ST = 0x100A,
		S_GPROC32_ST = 0x100B,
		S_VFTABLE32 = 0x100C,
		S_REGREL32_ST = 0x100D,
		S_LTHREAD32_ST = 0x100E,
		S_GTHREAD32_ST = 0x100F,
		S_LPROCMIPS_ST = 0x1010,
		S_GPROCMIPS_ST = 0x1011,
		S_FRAMEPROC = 0x1012,
		S_COMPILE2_ST = 0x1013,
		S_MANYREG2_ST = 0x1014,
		S_LPROCIA64_ST = 0x1015,
		S_GPROCIA64_ST = 0x1016,
		S_LOCALSLOT_ST = 0x1017,
		S_PARAMSLOT_ST = 0x1018,
		S_ANNOTATION = 0x1019,
		S_GMANPROC_ST = 0x101A,
		S_LMANPROC_ST = 0x101B,
		S_RESERVED1 = 0x101C,
		S_RESERVED2 = 0x101D,
		S_RESERVED3 = 0x101E,
		S_RESERVED4 = 0x101F,
		S_LMANDATA_ST = 0x1020,
		S_GMANDATA_ST = 0x1021,
		S_MANFRAMEREL_ST = 0x1022,
		S_MANREGISTER_ST = 0x1023,
		S_MANSLOT_ST = 0x1024,
		S_MANMANYREG_ST = 0x1025,
		S_MANREGREL_ST = 0x1026,
		S_MANMANYREG2_ST = 0x1027,
		S_MANTYPREF = 0x1028,
		S_UNAMESPACE_ST = 0x1029,

		S_ST_MAX = 0x1100,
		S_OBJNAME = 0x1101,
		S_THUNK32 = 0x1102,
		S_BLOCK32 = 0x1103,
		S_WITH32 = 0x1104,
		S_LABEL32 = 0x1105,
		S_REGISTER = 0x1106,
		S_CONSTANT = 0x1107,
		S_UDT = 0x1108,
		S_COBOLUDT = 0x1109,
		S_MANYREG = 0x110A,
		S_BPREL32 = 0x110B,
		S_LDATA32 = 0x110C,
		S_GDATA32 = 0x110D,
		S_PUB32 = 0x110E,
		S_LPROC32 = 0x110F,
		S_GPROC32 = 0x1110,
		S_REGREL32 = 0x1111,
		S_LTHREAD32 = 0x1112,
		S_GTHREAD32 = 0x1113,
		S_LPROCMIPS = 0x1114,
		S_GPROCMIPS = 0x1115,
		S_COMPILE2 = 0x1116,
		S_MANYREG2 = 0x1117,
		S_LPROCIA64 = 0x1118,
		S_GPROCIA64 = 0x1119,
		S_LOCALSLOT = 0x111A,
		S_PARAMSLOT = 0x111B,
		S_LMANDATA = 0x111C,
		S_GMANDATA = 0x111D,
		S_MANFRAMEREL = 0x111E,
		S_MANREGISTER = 0x111F,
		S_MANSLOT = 0x1120,
		S_MANMANYREG = 0x1121,
		S_MANREGREL = 0x1122,
		S_MANMANYREG2 = 0x1123,
		S_UNAMESPACE = 0x1124,
		S_PROCREF = 0x1125,
		S_DATAREF = 0x1126,
		S_LPROCREF = 0x1127,
		S_ANNOTATIONREF = 0x1128,
		S_TOKENREF = 0x1129,
		S_GMANPROC = 0x112A,
		S_LMANPROC = 0x112B,
		S_TRAMPOLINE = 0x112C,
		S_MANCONSTANT = 0x112D,
		S_ATTR_FRAMEREL = 0x112E,
		S_ATTR_REGISTER = 0x112F,
		S_ATTR_REGREL = 0x1130,
		S_ATTR_MANYREG = 0x1131,
		S_SEPCODE = 0x1132,
		S_LOCAL_2005 = 0x1133,
		S_DEFRANGE_2005 = 0x1134,
		S_DEFRANGE2_2005 = 0x1135,
		S_SECTION = 0x1136,
		S_COFFGROUP = 0x1137,
		S_EXPORT = 0x1138,
		S_CALLSITEINFO = 0x1139,
		S_FRAMECOOKIE = 0x113A,
		S_DISCARDED = 0x113B,
		S_COMPILE3 = 0x113C,
		S_ENVBLOCK = 0x113D,
		S_LOCAL = 0x113E,
		S_DEFRANGE = 0x113F,
		S_DEFRANGE_SUBFIELD = 0x1140,
		S_DEFRANGE_REGISTER = 0x1141,
		S_DEFRANGE_FRAMEPOINTER_REL = 0x1142,
		S_DEFRANGE_SUBFIELD_REGISTER = 0x1143,
		S_DEFRANGE_FRAMEPOINTER_REL_FULL_SCOPE = 0x1144,
		S_DEFRANGE_REGISTER_REL = 0x1145,
		S_LPROC32_ID = 0x1146,
		S_GPROC32_ID = 0x1147,
		S_LPROCMIPS_ID = 0x1148,
		S_GPROCMIPS_ID = 0x1149,
		S_LPROCIA64_ID = 0x114A,
		S_GPROCIA64_ID = 0x114B,
		S_BUILDINFO = 0x114C,
		S_INLINESITE = 0x114D,
		S_INLINESITE_END = 0x114E,
		S_PROC_ID_END = 0x114F,
		S_DEFRANGE_HLSL = 0x1150,
		S_GDATA_HLSL = 0x1151,
		S_LDATA_HLSL = 0x1152,
		S_FILESTATIC = 0x1153,
		S_LOCAL_DPC_GROUPSHARED = 0x1154,
		S_LPROC32_DPC = 0x1155,
		S_LPROC32_DPC_ID = 0x1156,
		S_DEFRANGE_DPC_PTR_TAG = 0x1157,
		S_DPC_SYM_TAG_MAP = 0x1158,
		S_ARMSWITCHTABLE = 0x1159,
		S_CALLEES = 0x115A,
		S_CALLERS = 0x115B,
		S_POGODATA = 0x115C,
		S_INLINESITE2 = 0x115D,
		S_HEAPALLOCSITE = 0x115E,

		S_RECTYPE_MAX,
	}
}





namespace dnlib.DotNet.Pdb.Managed {
	sealed class DbiDocument : SymbolDocument {
		readonly string url;
		Guid language;
		Guid languageVendor;
		Guid documentType;
		Guid checkSumAlgorithmId;
		byte[] checkSum;
		byte[] sourceCode;

		public override string URL => url;
		public override Guid Language => language;
		public override Guid LanguageVendor => languageVendor;
		public override Guid DocumentType => documentType;
		public override Guid CheckSumAlgorithmId => checkSumAlgorithmId;
		public override byte[] CheckSum => checkSum;
		byte[] SourceCode => sourceCode;

		public override PdbCustomDebugInfo[] CustomDebugInfos {
			get {
				if (customDebugInfos is null) {
					var sourceCode = SourceCode;
					if (sourceCode is not null)
						customDebugInfos = new PdbCustomDebugInfo[1] { new PdbEmbeddedSourceCustomDebugInfo(sourceCode) };
					else
						customDebugInfos = Array2.Empty<PdbCustomDebugInfo>();
				}
				return customDebugInfos;
			}
		}
		PdbCustomDebugInfo[] customDebugInfos;

		public DbiDocument(string url) {
			this.url = url;
			documentType = SymDocumentType.Text;
		}

		public void Read(ref DataReader reader) {
			reader.Position = 0;
			language = reader.ReadGuid();
			languageVendor = reader.ReadGuid();
			documentType = reader.ReadGuid();
			checkSumAlgorithmId = reader.ReadGuid();
			int checkSumLen = reader.ReadInt32();
			int sourceLen = reader.ReadInt32();
			checkSum = reader.ReadBytes(checkSumLen);
			sourceCode = sourceLen == 0 ? null : reader.ReadBytes(sourceLen);
			Debug.Assert(reader.BytesLeft == 0);
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#imports-blob
	readonly struct ImportScopeBlobWriter {
		readonly IWriterError helper;
		readonly Writer.Metadata systemMetadata;
		readonly BlobHeap blobHeap;

		ImportScopeBlobWriter(IWriterError helper, Writer.Metadata systemMetadata, BlobHeap blobHeap) {
			this.helper = helper;
			this.systemMetadata = systemMetadata;
			this.blobHeap = blobHeap;
		}

		public static void Write(IWriterError helper, Writer.Metadata systemMetadata, DataWriter writer, BlobHeap blobHeap, IList<PdbImport> imports) {
			var blobWriter = new ImportScopeBlobWriter(helper, systemMetadata, blobHeap);
			blobWriter.Write(writer, imports);
		}

		uint WriteUTF8(string s) {
			if (s is null) {
				helper.Error("String is null");
				s = string.Empty;
			}
			var bytes = Encoding.UTF8.GetBytes(s);
			return blobHeap.Add(bytes);
		}

		void Write(DataWriter writer, IList<PdbImport> imports) {
			int count = imports.Count;
			for (int i = 0; i < count; i++) {
				var import = imports[i];
				if (!ImportDefinitionKindUtils.ToImportDefinitionKind(import.Kind, out uint rawKind)) {
					helper.Error("Unknown import definition kind: " + import.Kind.ToString());
					return;
				}
				writer.WriteCompressedUInt32(rawKind);
				switch (import.Kind) {
				case PdbImportDefinitionKind.ImportNamespace:
					// <import> ::= ImportNamespace <target-namespace>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.ImportAssemblyNamespace:
					// <import> ::= ImportAssemblyNamespace <target-assembly> <target-namespace>
					writer.WriteCompressedUInt32(systemMetadata.GetToken(((PdbImportAssemblyNamespace)import).TargetAssembly).Rid);
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportAssemblyNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.ImportType:
					// <import> ::= ImportType <target-type>
					writer.WriteCompressedUInt32(GetTypeDefOrRefEncodedToken(((PdbImportType)import).TargetType));
					break;

				case PdbImportDefinitionKind.ImportXmlNamespace:
					// <import> ::= ImportXmlNamespace <alias> <target-namespace>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportXmlNamespace)import).Alias));
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportXmlNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:
					// <import> ::= ImportReferenceAlias <alias>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbImportAssemblyReferenceAlias)import).Alias));
					break;

				case PdbImportDefinitionKind.AliasAssemblyReference:
					// <import> ::= AliasAssemblyReference <alias> <target-assembly>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasAssemblyReference)import).Alias));
					writer.WriteCompressedUInt32(systemMetadata.GetToken(((PdbAliasAssemblyReference)import).TargetAssembly).Rid);
					break;

				case PdbImportDefinitionKind.AliasNamespace:
					// <import> ::= AliasNamespace <alias> <target-namespace>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasNamespace)import).Alias));
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.AliasAssemblyNamespace:
					// <import> ::= AliasAssemblyNamespace <alias> <target-assembly> <target-namespace>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasAssemblyNamespace)import).Alias));
					writer.WriteCompressedUInt32(systemMetadata.GetToken(((PdbAliasAssemblyNamespace)import).TargetAssembly).Rid);
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasAssemblyNamespace)import).TargetNamespace));
					break;

				case PdbImportDefinitionKind.AliasType:
					// <import> ::= AliasType <alias> <target-type>
					writer.WriteCompressedUInt32(WriteUTF8(((PdbAliasType)import).Alias));
					writer.WriteCompressedUInt32(GetTypeDefOrRefEncodedToken(((PdbAliasType)import).TargetType));
					break;

				default:
					helper.Error("Unknown import definition kind: " + import.Kind.ToString());
					return;
				}
			}
		}

		uint GetTypeDefOrRefEncodedToken(ITypeDefOrRef tdr) {
			if (tdr is null) {
				helper.Error("ITypeDefOrRef is null");
				return 0;
			}
			var token = systemMetadata.GetToken(tdr);
			if (MD.CodedToken.TypeDefOrRef.Encode(token, out uint codedToken))
				return codedToken;
			helper.Error($"Could not encode token 0x{token.Raw:X8}");
			return 0;
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	static class ListCache<T> {
		static volatile List<T> cachedList;
		public static List<T> AllocList() => Interlocked.Exchange(ref cachedList, null) ?? new List<T>();
		public static void Free(ref List<T> list) {
			list.Clear();
			cachedList = list;
		}
		public static T[] FreeAndToArray(ref List<T> list) {
			var res = list.ToArray();
			Free(ref list);
			return res;
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	struct LocalConstantSigBlobReader {
		readonly ModuleDef module;
		DataReader reader;
		readonly GenericParamContext gpContext;
		RecursionCounter recursionCounter;

		public LocalConstantSigBlobReader(ModuleDef module, ref DataReader reader, GenericParamContext gpContext) {
			this.module = module;
			this.reader = reader;
			this.gpContext = gpContext;
			recursionCounter = default;
		}

		public bool Read(out TypeSig type, out object value) {
			bool b = ReadCatch(out type, out value);
			Debug.Assert(!b || reader.Position == reader.Length);
			return b;
		}

		bool ReadCatch(out TypeSig type, out object value) {
			try {
				return ReadCore(out type, out value);
			}
			catch {
			}
			type = null;
			value = null;
			return false;
		}

		bool ReadCore(out TypeSig type, out object value) {
			if (!recursionCounter.Increment()) {
				type = null;
				value = null;
				return false;
			}

			bool res;
			ITypeDefOrRef tdr;
			UTF8String ns, name;
			var et = (ElementType)reader.ReadByte();
			switch (et) {
			case ElementType.Boolean:
				type = module.CorLibTypes.Boolean;
				value = reader.ReadBoolean();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.Char:
				type = module.CorLibTypes.Char;
				value = reader.ReadChar();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.I1:
				type = module.CorLibTypes.SByte;
				value = reader.ReadSByte();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.U1:
				type = module.CorLibTypes.Byte;
				value = reader.ReadByte();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.I2:
				type = module.CorLibTypes.Int16;
				value = reader.ReadInt16();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.U2:
				type = module.CorLibTypes.UInt16;
				value = reader.ReadUInt16();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.I4:
				type = module.CorLibTypes.Int32;
				value = reader.ReadInt32();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.U4:
				type = module.CorLibTypes.UInt32;
				value = reader.ReadUInt32();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.I8:
				type = module.CorLibTypes.Int64;
				value = reader.ReadInt64();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.U8:
				type = module.CorLibTypes.UInt64;
				value = reader.ReadUInt64();
				if (reader.Position < reader.Length)
					type = ReadTypeDefOrRefSig();
				res = true;
				break;

			case ElementType.R4:
				type = module.CorLibTypes.Single;
				value = reader.ReadSingle();
				res = true;
				break;

			case ElementType.R8:
				type = module.CorLibTypes.Double;
				value = reader.ReadDouble();
				res = true;
				break;

			case ElementType.String:
				type = module.CorLibTypes.String;
				value = ReadString();
				res = true;
				break;

			case ElementType.Ptr:
				res = ReadCatch(out type, out value);
				if (res)
					type = new PtrSig(type);
				break;

			case ElementType.ByRef:
				res = ReadCatch(out type, out value);
				if (res)
					type = new ByRefSig(type);
				break;

			case ElementType.Object:
				type = module.CorLibTypes.Object;
				value = null;
				res = true;
				break;

			case ElementType.ValueType:
				tdr = ReadTypeDefOrRef();
				type = tdr.ToTypeSig();
				value = null;
				if (GetName(tdr, out ns, out name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {
					if (name == stringDecimal) {
						if (reader.Length - reader.Position != 13)
							goto default;
						try {
							byte b = reader.ReadByte();
							value = new Decimal(reader.ReadInt32(), reader.ReadInt32(), reader.ReadInt32(), (b & 0x80) != 0, (byte)(b & 0x7F));
						}
						catch {
							goto default;
						}
					}
					else if (name == stringDateTime) {
						if (reader.Length - reader.Position != 8)
							goto default;
						try {
							value = new DateTime(reader.ReadInt64());
						}
						catch {
							goto default;
						}
					}
				}
				if (value is null && reader.Position != reader.Length)
					value = reader.ReadRemainingBytes();
				res = true;
				break;

			case ElementType.Class:
				type = new ClassSig(ReadTypeDefOrRef());
				value = reader.Position == reader.Length ? null : reader.ReadRemainingBytes();
				res = true;
				break;

			case ElementType.CModReqd:
				tdr = ReadTypeDefOrRef();
				res = ReadCatch(out type, out value);
				if (res)
					type = new CModReqdSig(tdr, type);
				break;

			case ElementType.CModOpt:
				tdr = ReadTypeDefOrRef();
				res = ReadCatch(out type, out value);
				if (res)
					type = new CModOptSig(tdr, type);
				break;

			case ElementType.Var:
			case ElementType.Array:
			case ElementType.GenericInst:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.FnPtr:
			case ElementType.SZArray:
			case ElementType.MVar:
			case ElementType.End:
			case ElementType.Void:
			case ElementType.ValueArray:
			case ElementType.R:
			case ElementType.Internal:
			case ElementType.Module:
			case ElementType.Sentinel:
			case ElementType.Pinned:
			default:
				Debug.Fail("Unsupported element type in LocalConstant sig blob: " + et.ToString());
				res = false;
				type = null;
				value = null;
				break;
			}

			recursionCounter.Decrement();
			return res;
		}
		static readonly UTF8String stringSystem = new UTF8String("System");
		static readonly UTF8String stringDecimal = new UTF8String("Decimal");
		static readonly UTF8String stringDateTime = new UTF8String("DateTime");

		static bool GetName(ITypeDefOrRef tdr, out UTF8String @namespace, out UTF8String name) {
			if (tdr is TypeRef tr) {
				@namespace = tr.Namespace;
				name = tr.Name;
				return true;
			}

			if (tdr is TypeDef td) {
				@namespace = td.Namespace;
				name = td.Name;
				return true;
			}

			@namespace = null;
			name = null;
			return false;
		}

		TypeSig ReadTypeDefOrRefSig() {
			uint codedToken;
			if (!reader.TryReadCompressedUInt32(out codedToken))
				return null;
			ISignatureReaderHelper helper = module;
			var tdr = helper.ResolveTypeDefOrRef(codedToken, gpContext);
			return tdr.ToTypeSig();
		}

		ITypeDefOrRef ReadTypeDefOrRef() {
			uint codedToken;
			if (!reader.TryReadCompressedUInt32(out codedToken))
				return null;
			ISignatureReaderHelper helper = module;
			var tdr = helper.ResolveTypeDefOrRef(codedToken, gpContext);
			var corType = module.CorLibTypes.GetCorLibTypeSig(tdr);
			if (corType is not null)
				return corType.TypeDefOrRef;
			return tdr;
		}

		string ReadString() {
			if (reader.Position == reader.Length)
				return string.Empty;
			byte b = reader.ReadByte();
			if (b == 0xFF && reader.Position == reader.Length)
				return null;
			reader.Position--;
			Debug.Assert((reader.BytesLeft & 1) == 0);
			return reader.ReadUtf16String((int)(reader.BytesLeft / 2));
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	readonly struct LocalConstantSigBlobWriter {
		readonly IWriterError helper;
		readonly Writer.Metadata systemMetadata;

		LocalConstantSigBlobWriter(IWriterError helper, Writer.Metadata systemMetadata) {
			this.helper = helper;
			this.systemMetadata = systemMetadata;
		}

		public static void Write(IWriterError helper, Writer.Metadata systemMetadata, DataWriter writer, TypeSig type, object value) {
			var sigWriter = new LocalConstantSigBlobWriter(helper, systemMetadata);
			sigWriter.Write(writer, type, value);
		}

		void Write(DataWriter writer, TypeSig type, object value) {
			for (; ; type = type.Next) {
				if (type is null)
					return;

				var et = type.ElementType;
				writer.WriteByte((byte)et);
				switch (et) {
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
					WritePrimitiveValue(writer, et, value);
					return;

				case ElementType.R4:
					if (value is float)
						writer.WriteSingle((float)value);
					else {
						helper.Error("Expected a Single constant");
						writer.WriteSingle(0);
					}
					return;

				case ElementType.R8:
					if (value is double)
						writer.WriteDouble((double)value);
					else {
						helper.Error("Expected a Double constant");
						writer.WriteDouble(0);
					}
					return;

				case ElementType.String:
					if (value is null)
						writer.WriteByte((byte)0xFF);
					else if (value is string)
						writer.WriteBytes(Encoding.Unicode.GetBytes((string)value));
					else
						helper.Error("Expected a String constant");
					return;

				case ElementType.Ptr:
				case ElementType.ByRef:
					WriteTypeDefOrRef(writer, new TypeSpecUser(type));
					return;

				case ElementType.Object:
					return;

				case ElementType.ValueType:
					var tdr = ((ValueTypeSig)type).TypeDefOrRef;
					var td = tdr.ResolveTypeDef();
					if (td is null)
						helper.Error($"Couldn't resolve type 0x{tdr?.MDToken.Raw ?? 0:X8}");
					else if (td.IsEnum) {
						var underlyingType = td.GetEnumUnderlyingType().RemovePinnedAndModifiers();
						switch (underlyingType.GetElementType()) {
						case ElementType.Boolean:
						case ElementType.Char:
						case ElementType.I1:
						case ElementType.U1:
						case ElementType.I2:
						case ElementType.U2:
						case ElementType.I4:
						case ElementType.U4:
						case ElementType.I8:
						case ElementType.U8:
							writer.Position--;
							writer.WriteByte((byte)underlyingType.GetElementType());
							WritePrimitiveValue(writer, underlyingType.GetElementType(), value);
							WriteTypeDefOrRef(writer, tdr);
							return;
						default:
							helper.Error("Invalid enum underlying type");
							return;
						}
					}
					else {
						WriteTypeDefOrRef(writer, tdr);
						bool valueWritten = false;
						if (GetName(tdr, out var ns, out var name) && ns == stringSystem && tdr.DefinitionAssembly.IsCorLib()) {
							if (name == stringDecimal) {
								if (value is decimal) {
									var bits = decimal.GetBits((decimal)value);
									writer.WriteByte((byte)((((uint)bits[3] >> 31) << 7) | (((uint)bits[3] >> 16) & 0x7F)));
									writer.WriteInt32(bits[0]);
									writer.WriteInt32(bits[1]);
									writer.WriteInt32(bits[2]);
								}
								else {
									helper.Error("Expected a Decimal constant");
									writer.WriteBytes(new byte[13]);
								}
								valueWritten = true;
							}
							else if (name == stringDateTime) {
								if (value is DateTime)
									writer.WriteInt64(((DateTime)value).Ticks);
								else {
									helper.Error("Expected a DateTime constant");
									writer.WriteInt64(0);
								}
								valueWritten = true;
							}
						}
						if (!valueWritten) {
							if (value is byte[])
								writer.WriteBytes((byte[])value);
							else if (value is not null) {
								helper.Error("Unsupported constant: " + value.GetType().FullName);
								return;
							}
						}
					}
					return;

				case ElementType.Class:
					WriteTypeDefOrRef(writer, ((ClassSig)type).TypeDefOrRef);
					if (value is byte[])
						writer.WriteBytes((byte[])value);
					else if (value is not null)
						helper.Error("Expected a null constant");
					return;

				case ElementType.CModReqd:
				case ElementType.CModOpt:
					WriteTypeDefOrRef(writer, ((ModifierSig)type).Modifier);
					break;

				case ElementType.Var:
				case ElementType.Array:
				case ElementType.GenericInst:
				case ElementType.TypedByRef:
				case ElementType.I:
				case ElementType.U:
				case ElementType.FnPtr:
				case ElementType.SZArray:
				case ElementType.MVar:
					WriteTypeDefOrRef(writer, new TypeSpecUser(type));
					return;

				case ElementType.End:
				case ElementType.Void:
				case ElementType.ValueArray:
				case ElementType.R:
				case ElementType.Internal:
				case ElementType.Module:
				case ElementType.Sentinel:
				case ElementType.Pinned:
				default:
					helper.Error("Unsupported element type in LocalConstant sig blob: " + et.ToString());
					return;
				}
			}
		}
		static readonly UTF8String stringSystem = new UTF8String("System");
		static readonly UTF8String stringDecimal = new UTF8String("Decimal");
		static readonly UTF8String stringDateTime = new UTF8String("DateTime");

		static bool GetName(ITypeDefOrRef tdr, out UTF8String @namespace, out UTF8String name) {
			if (tdr is TypeRef tr) {
				@namespace = tr.Namespace;
				name = tr.Name;
				return true;
			}

			if (tdr is TypeDef td) {
				@namespace = td.Namespace;
				name = td.Name;
				return true;
			}

			@namespace = null;
			name = null;
			return false;
		}

		void WritePrimitiveValue(DataWriter writer, ElementType et, object value) {
			switch (et) {
			case ElementType.Boolean:
				if (value is bool)
					writer.WriteBoolean((bool)value);
				else {
					helper.Error("Expected a Boolean constant");
					writer.WriteBoolean(false);
				}
				break;

			case ElementType.Char:
				if (value is char)
					writer.WriteUInt16((char)value);
				else {
					helper.Error("Expected a Char constant");
					writer.WriteUInt16(0);
				}
				break;

			case ElementType.I1:
				if (value is sbyte)
					writer.WriteSByte((sbyte)value);
				else {
					helper.Error("Expected a SByte constant");
					writer.WriteSByte(0);
				}
				break;

			case ElementType.U1:
				if (value is byte)
					writer.WriteByte((byte)value);
				else {
					helper.Error("Expected a Byte constant");
					writer.WriteByte(0);
				}
				break;

			case ElementType.I2:
				if (value is short)
					writer.WriteInt16((short)value);
				else {
					helper.Error("Expected an Int16 constant");
					writer.WriteInt16(0);
				}
				break;

			case ElementType.U2:
				if (value is ushort)
					writer.WriteUInt16((ushort)value);
				else {
					helper.Error("Expected a UInt16 constant");
					writer.WriteUInt16(0);
				}
				break;

			case ElementType.I4:
				if (value is int)
					writer.WriteInt32((int)value);
				else {
					helper.Error("Expected an Int32 constant");
					writer.WriteInt32(0);
				}
				break;

			case ElementType.U4:
				if (value is uint)
					writer.WriteUInt32((uint)value);
				else {
					helper.Error("Expected a UInt32 constant");
					writer.WriteUInt32(0);
				}
				break;

			case ElementType.I8:
				if (value is long)
					writer.WriteInt64((long)value);
				else {
					helper.Error("Expected an Int64 constant");
					writer.WriteInt64(0);
				}
				break;

			case ElementType.U8:
				if (value is ulong)
					writer.WriteUInt64((ulong)value);
				else {
					helper.Error("Expected a UInt64 constant");
					writer.WriteUInt64(0);
				}
				break;

			default:
				throw new InvalidOperationException();
			}
		}

		void WriteTypeDefOrRef(DataWriter writer, ITypeDefOrRef tdr) {
			if (!MD.CodedToken.TypeDefOrRef.Encode(systemMetadata.GetToken(tdr), out uint codedToken)) {
				helper.Error("Couldn't encode a TypeDefOrRef");
				return;
			}
			writer.WriteCompressedUInt32(codedToken);
		}
	}
}




// See Roslyn files: MethodDebugInfo.Portable.cs, MetadataWriter.PortablePdb.cs


namespace dnlib.DotNet.Pdb.Portable {
	struct PortablePdbCustomDebugInfoReader {
		public static PdbCustomDebugInfo Read(ModuleDef module, TypeDef typeOpt, CilBody bodyOpt, GenericParamContext gpContext, Guid kind, ref DataReader reader) {
			try {
				var cdiReader = new PortablePdbCustomDebugInfoReader(module, typeOpt, bodyOpt, gpContext, ref reader);
				var cdi = cdiReader.Read(kind);
				Debug.Assert(cdiReader.reader.Position == cdiReader.reader.Length);
				return cdi;
			}
			catch (ArgumentException) {
			}
			catch (OutOfMemoryException) {
			}
			catch (IOException) {
			}
			return null;
		}

		readonly ModuleDef module;
		readonly TypeDef typeOpt;
		readonly CilBody bodyOpt;
		readonly GenericParamContext gpContext;
		DataReader reader;

		PortablePdbCustomDebugInfoReader(ModuleDef module, TypeDef typeOpt, CilBody bodyOpt, GenericParamContext gpContext, ref DataReader reader) {
			this.module = module;
			this.typeOpt = typeOpt;
			this.bodyOpt = bodyOpt;
			this.gpContext = gpContext;
			this.reader = reader;
		}

		PdbCustomDebugInfo Read(Guid kind) {
			if (kind == CustomDebugInfoGuids.AsyncMethodSteppingInformationBlob)
				return ReadAsyncMethodSteppingInformationBlob();
			if (kind == CustomDebugInfoGuids.DefaultNamespace)
				return ReadDefaultNamespace();
			if (kind == CustomDebugInfoGuids.DynamicLocalVariables)
				return ReadDynamicLocalVariables(reader.Length);
			if (kind == CustomDebugInfoGuids.EmbeddedSource)
				return ReadEmbeddedSource();
			if (kind == CustomDebugInfoGuids.EncLambdaAndClosureMap)
				return ReadEncLambdaAndClosureMap(reader.Length);
			if (kind == CustomDebugInfoGuids.EncLocalSlotMap)
				return ReadEncLocalSlotMap(reader.Length);
			if (kind == CustomDebugInfoGuids.SourceLink)
				return ReadSourceLink();
			if (kind == CustomDebugInfoGuids.StateMachineHoistedLocalScopes)
				return ReadStateMachineHoistedLocalScopes();
			if (kind == CustomDebugInfoGuids.TupleElementNames)
				return ReadTupleElementNames();
			if (kind == CustomDebugInfoGuids.CompilationMetadataReferences)
				return ReadCompilationMetadataReferences();
			if (kind == CustomDebugInfoGuids.CompilationOptions)
				return ReadCompilationOptions();
			Debug.Fail("Unknown custom debug info guid: " + kind.ToString());
			return new PdbUnknownCustomDebugInfo(kind, reader.ReadRemainingBytes());
		}

		PdbCustomDebugInfo ReadAsyncMethodSteppingInformationBlob() {
			if (bodyOpt is null)
				return null;
			uint catchHandlerOffset = reader.ReadUInt32() - 1;
			Instruction catchHandler;
			if (catchHandlerOffset == uint.MaxValue)
				catchHandler = null;
			else {
				catchHandler = GetInstruction(catchHandlerOffset);
				Debug.Assert(catchHandler is not null);
				if (catchHandler is null)
					return null;
			}
			var asyncInfo = new PdbAsyncMethodSteppingInformationCustomDebugInfo();
			asyncInfo.CatchHandler = catchHandler;
			while (reader.Position < reader.Length) {
				var yieldInstr = GetInstruction(reader.ReadUInt32());
				Debug.Assert(yieldInstr is not null);
				if (yieldInstr is null)
					return null;
				uint resumeOffset = reader.ReadUInt32();
				var moveNextRid = reader.ReadCompressedUInt32();
				var moveNextToken = new MDToken(Table.Method, moveNextRid);
				MethodDef moveNextMethod;
				Instruction resumeInstr;
				if (gpContext.Method is not null && moveNextToken == gpContext.Method.MDToken) {
					moveNextMethod = gpContext.Method;
					resumeInstr = GetInstruction(resumeOffset);
				}
				else {
					moveNextMethod = module.ResolveToken(moveNextToken, gpContext) as MethodDef;
					Debug.Assert(moveNextMethod is not null);
					if (moveNextMethod is null)
						return null;
					resumeInstr = GetInstruction(moveNextMethod, resumeOffset);
				}
				Debug.Assert(resumeInstr is not null);
				if (resumeInstr is null)
					return null;
				asyncInfo.AsyncStepInfos.Add(new PdbAsyncStepInfo(yieldInstr, moveNextMethod, resumeInstr));
			}
			return asyncInfo;
		}

		PdbCustomDebugInfo ReadDefaultNamespace() {
			var defaultNs = reader.ReadUtf8String((int)reader.BytesLeft);
			return new PdbDefaultNamespaceCustomDebugInfo(defaultNs);
		}

		PdbCustomDebugInfo ReadDynamicLocalVariables(long recPosEnd) {
			var flags = new bool[(int)reader.Length * 8];
			int w = 0;
			while (reader.Position < reader.Length) {
				int b = reader.ReadByte();
				for (int i = 1; i < 0x100; i <<= 1)
					flags[w++] = (b & i) != 0;
			}
			return new PdbDynamicLocalVariablesCustomDebugInfo(flags);
		}

		PdbCustomDebugInfo ReadEmbeddedSource() => new PdbEmbeddedSourceCustomDebugInfo(reader.ReadRemainingBytes());

		PdbCustomDebugInfo ReadEncLambdaAndClosureMap(long recPosEnd) {
			var data = reader.ReadBytes((int)(recPosEnd - reader.Position));
			return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);
		}

		PdbCustomDebugInfo ReadEncLocalSlotMap(long recPosEnd) {
			var data = reader.ReadBytes((int)(recPosEnd - reader.Position));
			return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);
		}

		PdbCustomDebugInfo ReadSourceLink() => new PdbSourceLinkCustomDebugInfo(reader.ReadRemainingBytes());

		PdbCustomDebugInfo ReadStateMachineHoistedLocalScopes() {
			if (bodyOpt is null)
				return null;
			int count = (int)(reader.Length / 8);
			var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);
			for (int i = 0; i < count; i++) {
				uint startOffset = reader.ReadUInt32();
				uint length = reader.ReadUInt32();
				if (startOffset == 0 && length == 0)
					smScope.Scopes.Add(new StateMachineHoistedLocalScope());
				else {
					var start = GetInstruction(startOffset);
					var end = GetInstruction(startOffset + length);
					Debug.Assert(start is not null);
					if (start is null)
						return null;
					smScope.Scopes.Add(new StateMachineHoistedLocalScope(start, end));
				}
			}
			return smScope;
		}

		PdbCustomDebugInfo ReadTupleElementNames() {
			var tupleListRec = new PortablePdbTupleElementNamesCustomDebugInfo();
			while (reader.Position < reader.Length) {
				var name = ReadUTF8Z(reader.Length);
				tupleListRec.Names.Add(name);
			}
			return tupleListRec;
		}

		string ReadUTF8Z(long recPosEnd) {
			if (reader.Position > recPosEnd)
				return null;
			return reader.TryReadZeroTerminatedUtf8String();
		}

		PdbCustomDebugInfo ReadCompilationMetadataReferences() {
			var cdi = new PdbCompilationMetadataReferencesCustomDebugInfo();

			while (reader.BytesLeft > 0) {
				var name = reader.TryReadZeroTerminatedUtf8String();
				Debug.Assert(name is not null);
				if (name is null)
					break;
				var aliases = reader.TryReadZeroTerminatedUtf8String();
				Debug.Assert(aliases is not null);
				if (aliases is null)
					break;

				const uint RequiredBytes = 1 + 4 + 4 + 16;
				Debug.Assert(reader.BytesLeft >= RequiredBytes);
				if (reader.BytesLeft < RequiredBytes)
					break;

				var flags = (PdbCompilationMetadataReferenceFlags)reader.ReadByte();
				uint timestamp = reader.ReadUInt32();
				uint sizeOfImage = reader.ReadUInt32();
				var mvid = reader.ReadGuid();

				var mdRef = new PdbCompilationMetadataReference(name, aliases, flags, timestamp, sizeOfImage, mvid);
				cdi.References.Add(mdRef);
			}

			return cdi;
		}

		PdbCustomDebugInfo ReadCompilationOptions() {
			var cdi = new PdbCompilationOptionsCustomDebugInfo();

			while (reader.BytesLeft > 0) {
				var key = reader.TryReadZeroTerminatedUtf8String();
				Debug.Assert(key is not null);
				if (key is null)
					break;
				var value = reader.TryReadZeroTerminatedUtf8String();
				Debug.Assert(value is not null);
				if (value is null)
					break;
				cdi.Options.Add(new KeyValuePair<string, string>(key, value));
			}

			return cdi;
		}

		Instruction GetInstruction(uint offset) {
			var instructions = bodyOpt.Instructions;
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}

		static Instruction GetInstruction(MethodDef method, uint offset) {
			if (method is null)
				return null;
			var body = method.Body;
			if (body is null)
				return null;
			var instructions = body.Instructions;
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	interface IPortablePdbCustomDebugInfoWriterHelper : IWriterError {
	}

	readonly struct PortablePdbCustomDebugInfoWriter {
		readonly IPortablePdbCustomDebugInfoWriterHelper helper;
		readonly SerializerMethodContext methodContext;
		readonly Writer.Metadata systemMetadata;
		readonly MemoryStream outStream;
		readonly DataWriter writer;

		public static byte[] Write(IPortablePdbCustomDebugInfoWriterHelper helper, SerializerMethodContext methodContext, Writer.Metadata systemMetadata, PdbCustomDebugInfo cdi, DataWriterContext context) {
			var writer = new PortablePdbCustomDebugInfoWriter(helper, methodContext, systemMetadata, context);
			return writer.Write(cdi);
		}

		PortablePdbCustomDebugInfoWriter(IPortablePdbCustomDebugInfoWriterHelper helper, SerializerMethodContext methodContext, Writer.Metadata systemMetadata, DataWriterContext context) {
			this.helper = helper;
			this.methodContext = methodContext;
			this.systemMetadata = systemMetadata;
			outStream = context.OutStream;
			writer = context.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;
		}

		byte[] Write(PdbCustomDebugInfo cdi) {
			switch (cdi.Kind) {
			case PdbCustomDebugInfoKind.UsingGroups:
			case PdbCustomDebugInfoKind.ForwardMethodInfo:
			case PdbCustomDebugInfoKind.ForwardModuleInfo:
			case PdbCustomDebugInfoKind.StateMachineTypeName:
			case PdbCustomDebugInfoKind.DynamicLocals:
			case PdbCustomDebugInfoKind.TupleElementNames:
			case PdbCustomDebugInfoKind.IteratorMethod:
			case PdbCustomDebugInfoKind.SourceServer:
			default:
				helper.Error("Unreachable code, caller should filter these out");
				return null;

			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:
				WriteStateMachineHoistedLocalScopes((PdbStateMachineHoistedLocalScopesCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:
				WriteEditAndContinueLocalSlotMap((PdbEditAndContinueLocalSlotMapCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:
				WriteEditAndContinueLambdaMap((PdbEditAndContinueLambdaMapCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.Unknown:
				WriteUnknown((PdbUnknownCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.TupleElementNames_PortablePdb:
				WriteTupleElementNames((PortablePdbTupleElementNamesCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.DefaultNamespace:
				WriteDefaultNamespace((PdbDefaultNamespaceCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.DynamicLocalVariables:
				WriteDynamicLocalVariables((PdbDynamicLocalVariablesCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.EmbeddedSource:
				WriteEmbeddedSource((PdbEmbeddedSourceCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.SourceLink:
				WriteSourceLink((PdbSourceLinkCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.AsyncMethod:
				WriteAsyncMethodSteppingInformation((PdbAsyncMethodCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.CompilationMetadataReferences:
				WriteCompilationMetadataReferences((PdbCompilationMetadataReferencesCustomDebugInfo)cdi);
				break;

			case PdbCustomDebugInfoKind.CompilationOptions:
				WriteCompilationOptions((PdbCompilationOptionsCustomDebugInfo)cdi);
				break;
			}
			return outStream.ToArray();
		}

		void WriteUTF8Z(string s) {
			if (s.IndexOf('\0') >= 0)
				helper.Error("String must not contain any NUL bytes");
			var bytes = Encoding.UTF8.GetBytes(s);
			writer.WriteBytes(bytes);
			writer.WriteByte(0);
		}

		void WriteStateMachineHoistedLocalScopes(PdbStateMachineHoistedLocalScopesCustomDebugInfo cdi) {
			if (!methodContext.HasBody) {
				helper.Error("Method has no body, can't write custom debug info: " + cdi.Kind);
				return;
			}
			var cdiScopes = cdi.Scopes;
			int count = cdiScopes.Count;
			for (int i = 0; i < count; i++) {
				var scope = cdiScopes[i];
				uint startOffset, endOffset;
				if (scope.IsSynthesizedLocal) {
					startOffset = 0;
					endOffset = 0;
				}
				else {
					var startInstr = scope.Start;
					if (startInstr is null) {
						helper.Error("Instruction is null");
						return;
					}
					startOffset = methodContext.GetOffset(startInstr);
					endOffset = methodContext.GetOffset(scope.End);
				}
				if (startOffset > endOffset) {
					helper.Error("End instruction is before start instruction");
					return;
				}
				writer.WriteUInt32(startOffset);
				writer.WriteUInt32(endOffset - startOffset);
			}
		}

		void WriteEditAndContinueLocalSlotMap(PdbEditAndContinueLocalSlotMapCustomDebugInfo cdi) {
			var d = cdi.Data;
			if (d is null) {
				helper.Error("Data blob is null");
				return;
			}
			writer.WriteBytes(d);
		}

		void WriteEditAndContinueLambdaMap(PdbEditAndContinueLambdaMapCustomDebugInfo cdi) {
			var d = cdi.Data;
			if (d is null) {
				helper.Error("Data blob is null");
				return;
			}
			writer.WriteBytes(d);
		}

		void WriteUnknown(PdbUnknownCustomDebugInfo cdi) {
			var d = cdi.Data;
			if (d is null) {
				helper.Error("Data blob is null");
				return;
			}
			writer.WriteBytes(d);
		}

		void WriteTupleElementNames(PortablePdbTupleElementNamesCustomDebugInfo cdi) {
			var cdiNames = cdi.Names;
			int count = cdiNames.Count;
			for (int i = 0; i < count; i++) {
				var name = cdiNames[i];
				if (name is null) {
					helper.Error("Tuple name is null");
					return;
				}
				WriteUTF8Z(name);
			}
		}

		void WriteDefaultNamespace(PdbDefaultNamespaceCustomDebugInfo cdi) {
			var ns = cdi.Namespace;
			if (ns is null) {
				helper.Error("Default namespace is null");
				return;
			}
			var bytes = Encoding.UTF8.GetBytes(ns);
			writer.WriteBytes(bytes);
		}

		void WriteDynamicLocalVariables(PdbDynamicLocalVariablesCustomDebugInfo cdi) {
			var flags = cdi.Flags;
			for (int i = 0; i < flags.Length; i += 8)
				writer.WriteByte(ToByte(flags, i));
		}

		static byte ToByte(bool[] flags, int index) {
			int res = 0;
			int bit = 1;
			for (int i = index; i < flags.Length; i++, bit <<= 1) {
				if (flags[i])
					res |= bit;
			}
			return (byte)res;
		}

		void WriteEmbeddedSource(PdbEmbeddedSourceCustomDebugInfo cdi) {
			var d = cdi.SourceCodeBlob;
			if (d is null) {
				helper.Error("Source code blob is null");
				return;
			}
			writer.WriteBytes(d);
		}

		void WriteSourceLink(PdbSourceLinkCustomDebugInfo cdi) {
			var d = cdi.FileBlob;
			if (d is null) {
				helper.Error("Source link blob is null");
				return;
			}
			writer.WriteBytes(d);
		}

		void WriteAsyncMethodSteppingInformation(PdbAsyncMethodCustomDebugInfo cdi) {
			if (!methodContext.HasBody) {
				helper.Error("Method has no body, can't write custom debug info: " + cdi.Kind);
				return;
			}

			uint catchHandlerOffset;
			if (cdi.CatchHandlerInstruction is null)
				catchHandlerOffset = 0;
			else
				catchHandlerOffset = methodContext.GetOffset(cdi.CatchHandlerInstruction) + 1;
			writer.WriteUInt32(catchHandlerOffset);

			var cdiStepInfos = cdi.StepInfos;
			int count = cdiStepInfos.Count;
			for (int i = 0; i < count; i++) {
				var info = cdiStepInfos[i];
				if (info.YieldInstruction is null) {
					helper.Error("YieldInstruction is null");
					return;
				}
				if (info.BreakpointMethod is null) {
					helper.Error("BreakpointMethod is null");
					return;
				}
				if (info.BreakpointInstruction is null) {
					helper.Error("BreakpointInstruction is null");
					return;
				}
				uint yieldOffset = methodContext.GetOffset(info.YieldInstruction);
				uint resumeOffset;
				if (methodContext.IsSameMethod(info.BreakpointMethod))
					resumeOffset = methodContext.GetOffset(info.BreakpointInstruction);
				else
					resumeOffset = GetOffsetSlow(info.BreakpointMethod, info.BreakpointInstruction);
				uint resumeMethodRid = systemMetadata.GetRid(info.BreakpointMethod);
				writer.WriteUInt32(yieldOffset);
				writer.WriteUInt32(resumeOffset);
				writer.WriteCompressedUInt32(resumeMethodRid);
			}
		}

		uint GetOffsetSlow(MethodDef method, Instruction instr) {
			var body = method.Body;
			if (body is null) {
				helper.Error("Method has no body");
				return uint.MaxValue;
			}
			var instrs = body.Instructions;
			uint offset = 0;
			for (int i = 0; i < instrs.Count; i++) {
				var instr2 = instrs[i];
				if (instr2 == instr)
					return offset;
				offset += (uint)instr2.GetSize();
			}
			helper.Error("Couldn't find an instruction, maybe it was removed. It's still being referenced by some code or by the PDB");
			return uint.MaxValue;
		}

		void WriteCompilationMetadataReferences(PdbCompilationMetadataReferencesCustomDebugInfo cdi) {
			foreach (var mdRef in cdi.References) {
				var name = mdRef.Name;
				if (name is null) {
					helper.Error("Metadata reference name is null");
					return;
				}
				WriteUTF8Z(name);

				var aliases = mdRef.Aliases;
				if (aliases is null) {
					helper.Error("Metadata reference aliases is null");
					return;
				}
				WriteUTF8Z(aliases);

				writer.WriteByte((byte)mdRef.Flags);
				writer.WriteUInt32(mdRef.Timestamp);
				writer.WriteUInt32(mdRef.SizeOfImage);
				writer.WriteBytes(mdRef.Mvid.ToByteArray());
			}
		}

		void WriteCompilationOptions(PdbCompilationOptionsCustomDebugInfo cdi) {
			foreach (var kv in cdi.Options) {
				if (kv.Key is null) {
					helper.Error("Compiler option `key` is null");
					return;
				}
				if (kv.Value is null) {
					helper.Error("Compiler option `value` is null");
					return;
				}
				WriteUTF8Z(kv.Key);
				WriteUTF8Z(kv.Value);
			}
		}
	}
}




// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md


namespace dnlib.DotNet.Pdb.Portable {
	sealed class PortablePdbReader : SymbolReader {
		readonly PdbFileKind pdbFileKind;
		ModuleDef module;
		readonly MD.Metadata pdbMetadata;
		SymbolDocument[] documents;

		public override PdbFileKind PdbFileKind => pdbFileKind;
		public override int UserEntryPoint => pdbMetadata.PdbStream.EntryPoint.ToInt32();
		public override IList<SymbolDocument> Documents => documents;

		public PortablePdbReader(DataReaderFactory pdbStream, PdbFileKind pdbFileKind) {
			this.pdbFileKind = pdbFileKind;
			pdbMetadata = MetadataFactory.CreateStandalonePortablePDB(pdbStream, true);
		}

		internal bool MatchesModule(Guid pdbGuid, uint timestamp, uint age) {
			if (pdbMetadata.PdbStream is PdbStream pdbStream) {
				var pdbGuidArray = pdbStream.Id;
				Array.Resize(ref pdbGuidArray, 16);
				if (new Guid(pdbGuidArray) != pdbGuid)
					return false;
				if (BitConverter.ToUInt32(pdbStream.Id, 16) != timestamp)
					return false;
				if (age != 1)
					return false;

				return true;
			}
			return false;
		}

		public override void Initialize(ModuleDef module) {
			this.module = module;
			documents = ReadDocuments();
		}

		static Guid GetLanguageVendor(Guid language) {
			if (language == PdbDocumentConstants.LanguageCSharp || language == PdbDocumentConstants.LanguageVisualBasic || language == PdbDocumentConstants.LanguageFSharp)
				return PdbDocumentConstants.LanguageVendorMicrosoft;
			return Guid.Empty;
		}

		SymbolDocument[] ReadDocuments() {
			Debug.Assert(module is not null);
			var docTbl = pdbMetadata.TablesStream.DocumentTable;
			var docs = new SymbolDocument[docTbl.Rows];
			var nameReader = new DocumentNameReader(pdbMetadata.BlobStream);
			var custInfos = ListCache<PdbCustomDebugInfo>.AllocList();
			var gpContext = new GenericParamContext();
			for (int i = 0; i < docs.Length; i++) {
				bool b = pdbMetadata.TablesStream.TryReadDocumentRow((uint)i + 1, out var row);
				Debug.Assert(b);
				var url = nameReader.ReadDocumentName(row.Name);
				var language = pdbMetadata.GuidStream.Read(row.Language) ?? Guid.Empty;
				var languageVendor = GetLanguageVendor(language);
				var documentType = PdbDocumentConstants.DocumentTypeText;
				var checkSumAlgorithmId = pdbMetadata.GuidStream.Read(row.HashAlgorithm) ?? Guid.Empty;
				var checkSum = pdbMetadata.BlobStream.ReadNoNull(row.Hash);

				var token = new MDToken(Table.Document, i + 1).ToInt32();
				custInfos.Clear();
				GetCustomDebugInfos(token, gpContext, custInfos);
				var custInfosArray = custInfos.Count == 0 ? Array2.Empty<PdbCustomDebugInfo>() : custInfos.ToArray();

				docs[i] = new SymbolDocumentImpl(url, language, languageVendor, documentType, checkSumAlgorithmId, checkSum, custInfosArray);
			}
			ListCache<PdbCustomDebugInfo>.Free(ref custInfos);
			return docs;
		}

		bool TryGetSymbolDocument(uint rid, out SymbolDocument document) {
			int index = (int)rid - 1;
			if ((uint)index >= (uint)documents.Length) {
				Debug.Fail("Couldn't find document with rid 0x" + rid.ToString("X6"));
				document = null;
				return false;
			}
			document = documents[index];
			return true;
		}

		public override SymbolMethod GetMethod(MethodDef method, int version) {
			if (version != 1)
				return null;
			var mdTable = pdbMetadata.TablesStream.MethodDebugInformationTable;
			uint methodRid = method.Rid;
			if (!mdTable.IsValidRID(methodRid))
				return null;

			var sequencePoints = ReadSequencePoints(methodRid) ?? Array2.Empty<SymbolSequencePoint>();
			var gpContext = GenericParamContext.Create(method);
			var rootScope = ReadScope(methodRid, gpContext);

			var kickoffMethod = GetKickoffMethod(methodRid);
			var symbolMethod = new SymbolMethodImpl(this, method.MDToken.ToInt32(), rootScope, sequencePoints, kickoffMethod);
			rootScope.method = symbolMethod;
			return symbolMethod;
		}

		int GetKickoffMethod(uint methodRid) {
			uint rid = pdbMetadata.GetStateMachineMethodRid(methodRid);
			if (rid == 0)
				return 0;
			if (!pdbMetadata.TablesStream.TryReadStateMachineMethodRow(rid, out var row))
				return 0;
			return 0x06000000 + (int)row.KickoffMethod;
		}

		SymbolSequencePoint[] ReadSequencePoints(uint methodRid) {
			if (!pdbMetadata.TablesStream.MethodDebugInformationTable.IsValidRID(methodRid))
				return null;
			if (!pdbMetadata.TablesStream.TryReadMethodDebugInformationRow(methodRid, out var row))
				return null;
			if (row.SequencePoints == 0)
				return null;
			uint documentRid = row.Document;

			if (!pdbMetadata.BlobStream.TryCreateReader(row.SequencePoints, out var seqPointsReader))
				return null;
			var seqPointsBuilder = ListCache<SymbolSequencePoint>.AllocList();
			uint localSig = seqPointsReader.ReadCompressedUInt32();
			if (documentRid == 0)
				documentRid = seqPointsReader.ReadCompressedUInt32();

			TryGetSymbolDocument(documentRid, out var document);

			uint ilOffset = uint.MaxValue;
			int line = -1, column = 0;
			bool canReadDocumentRecord = false;
			while (seqPointsReader.Position < seqPointsReader.Length) {
				uint data = seqPointsReader.ReadCompressedUInt32();
				if (data == 0 && canReadDocumentRecord) {
					// document-record

					documentRid = seqPointsReader.ReadCompressedUInt32();
					TryGetSymbolDocument(documentRid, out document);
				}
				else {
					// SequencePointRecord

					Debug.Assert(document is not null);
					if (document is null)
						return null;

					var symSeqPoint = new SymbolSequencePoint {
						Document = document,
					};

					if (ilOffset == uint.MaxValue)
						ilOffset = data;
					else {
						Debug.Assert(data != 0);
						if (data == 0)
							return null;
						ilOffset += data;
					}
					symSeqPoint.Offset = (int)ilOffset;

					uint dlines = seqPointsReader.ReadCompressedUInt32();
					int dcolumns = dlines == 0 ? (int)seqPointsReader.ReadCompressedUInt32() : seqPointsReader.ReadCompressedInt32();

					if (dlines == 0 && dcolumns == 0) {
						// hidden-sequence-point-record

						symSeqPoint.Line = SequencePointConstants.HIDDEN_LINE;
						symSeqPoint.EndLine = SequencePointConstants.HIDDEN_LINE;
						symSeqPoint.Column = SequencePointConstants.HIDDEN_COLUMN;
						symSeqPoint.EndColumn = SequencePointConstants.HIDDEN_COLUMN;
					}
					else {
						// sequence-point-record

						if (line < 0) {
							line = (int)seqPointsReader.ReadCompressedUInt32();
							column = (int)seqPointsReader.ReadCompressedUInt32();
						}
						else {
							line += seqPointsReader.ReadCompressedInt32();
							column += seqPointsReader.ReadCompressedInt32();
						}

						symSeqPoint.Line = line;
						symSeqPoint.EndLine = line + (int)dlines;
						symSeqPoint.Column = column;
						symSeqPoint.EndColumn = column + dcolumns;
					}

					seqPointsBuilder.Add(symSeqPoint);
				}

				canReadDocumentRecord = true;
			}
			Debug.Assert(seqPointsReader.Position == seqPointsReader.Length);

			return ListCache<SymbolSequencePoint>.FreeAndToArray(ref seqPointsBuilder);
		}

		SymbolScopeImpl ReadScope(uint methodRid, GenericParamContext gpContext) {
			var scopesRidList = pdbMetadata.GetLocalScopeRidList(methodRid);
			SymbolScopeImpl rootScopeOrNull = null;
			if (scopesRidList.Count != 0) {
				var custInfos = ListCache<PdbCustomDebugInfo>.AllocList();
				var stack = ListCache<SymbolScopeImpl>.AllocList();
				var importScopeBlobReader = new ImportScopeBlobReader(module, pdbMetadata.BlobStream);
				for (int i = 0; i < scopesRidList.Count; i++) {
					var rid = scopesRidList[i];
					int token = new MDToken(Table.LocalScope, rid).ToInt32();
					bool b = pdbMetadata.TablesStream.TryReadLocalScopeRow(rid, out var row);
					Debug.Assert(b);
					uint startOffset = row.StartOffset;
					uint endOffset = startOffset + row.Length;

					SymbolScopeImpl parent = null;
					while (stack.Count > 0) {
						var nextParent = stack[stack.Count - 1];
						if (startOffset >= nextParent.StartOffset && endOffset <= nextParent.EndOffset) {
							parent = nextParent;
							break;
						}
						stack.RemoveAt(stack.Count - 1);
					}

					Debug.Assert(parent is not null || rootScopeOrNull is null);
					custInfos.Clear();
					GetCustomDebugInfos(token, gpContext, custInfos);
					var customDebugInfos = custInfos.Count == 0 ? Array2.Empty<PdbCustomDebugInfo>() : custInfos.ToArray();
					var scope = new SymbolScopeImpl(this, parent, (int)startOffset, (int)endOffset, customDebugInfos);
					if (rootScopeOrNull is null)
						rootScopeOrNull = scope;
					stack.Add(scope);
					if (parent is not null)
						parent.childrenList.Add(scope);

					scope.importScope = ReadPdbImportScope(ref importScopeBlobReader, row.ImportScope, gpContext);
					ReadVariables(scope, gpContext, pdbMetadata.GetLocalVariableRidList(rid));
					ReadConstants(scope, pdbMetadata.GetLocalConstantRidList(rid));
				}

				ListCache<SymbolScopeImpl>.Free(ref stack);
				ListCache<PdbCustomDebugInfo>.Free(ref custInfos);
			}
			return rootScopeOrNull ?? new SymbolScopeImpl(this, null, 0, int.MaxValue, Array2.Empty<PdbCustomDebugInfo>());
		}

		PdbImportScope ReadPdbImportScope(ref ImportScopeBlobReader importScopeBlobReader, uint importScope, GenericParamContext gpContext) {
			if (importScope == 0)
				return null;
			const int MAX = 1000;
			PdbImportScope result = null;
			PdbImportScope prevScope = null;
			for (int i = 0; importScope != 0; i++) {
				Debug.Assert(i < MAX);
				if (i >= MAX)
					return null;
				int token = new MDToken(Table.ImportScope, importScope).ToInt32();
				if (!pdbMetadata.TablesStream.TryReadImportScopeRow(importScope, out var row))
					return null;
				var scope = new PdbImportScope();
				GetCustomDebugInfos(token, gpContext, scope.CustomDebugInfos);
				if (result is null)
					result = scope;
				if (prevScope is not null)
					prevScope.Parent = scope;
				importScopeBlobReader.Read(row.Imports, scope.Imports);
				prevScope = scope;
				importScope = row.Parent;
			}

			return result;
		}

		void ReadVariables(SymbolScopeImpl scope, GenericParamContext gpContext, RidList rids) {
			if (rids.Count == 0)
				return;
			var table = pdbMetadata.TablesStream.LocalVariableTable;
			var custInfos = ListCache<PdbCustomDebugInfo>.AllocList();
			for (int i = 0; i < rids.Count; i++) {
				var rid = rids[i];
				int token = new MDToken(Table.LocalVariable, rid).ToInt32();
				custInfos.Clear();
				GetCustomDebugInfos(token, gpContext, custInfos);
				var customDebugInfos = custInfos.Count == 0 ? Array2.Empty<PdbCustomDebugInfo>() : custInfos.ToArray();
				bool b = pdbMetadata.TablesStream.TryReadLocalVariableRow(rid, out var row);
				Debug.Assert(b);
				var name = pdbMetadata.StringsStream.Read(row.Name);
				scope.localsList.Add(new SymbolVariableImpl(name, ToSymbolVariableAttributes(row.Attributes), row.Index, customDebugInfos));
			}
			ListCache<PdbCustomDebugInfo>.Free(ref custInfos);
		}

		static PdbLocalAttributes ToSymbolVariableAttributes(ushort attributes) {
			var res = PdbLocalAttributes.None;
			const ushort DebuggerHidden = 0x0001;
			if ((attributes & DebuggerHidden) != 0)
				res |= PdbLocalAttributes.DebuggerHidden;
			return res;
		}

		void ReadConstants(SymbolScopeImpl scope, RidList rids) {
			if (rids.Count == 0)
				return;
			scope.SetConstants(pdbMetadata, rids);
		}

		internal void GetCustomDebugInfos(SymbolMethodImpl symMethod, MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) {
			Debug.Assert(method.Module == module);
			GetCustomDebugInfos(method.MDToken.ToInt32(), GenericParamContext.Create(method), result, method, body, out var asyncStepInfo);
			if (asyncStepInfo is not null) {
				var asyncMethod = TryCreateAsyncMethod(module, symMethod.KickoffMethod, asyncStepInfo.AsyncStepInfos, asyncStepInfo.CatchHandler);
				Debug.Assert(asyncMethod is not null);
				if (asyncMethod is not null)
					result.Add(asyncMethod);
			}
			else if (symMethod.KickoffMethod != 0) {
				var iteratorMethod = TryCreateIteratorMethod(module, symMethod.KickoffMethod);
				Debug.Assert(iteratorMethod is not null);
				if (iteratorMethod is not null)
					result.Add(iteratorMethod);
			}
		}

		PdbAsyncMethodCustomDebugInfo TryCreateAsyncMethod(ModuleDef module, int asyncKickoffMethod, IList<PdbAsyncStepInfo> asyncStepInfos, Instruction asyncCatchHandler) {
			var kickoffToken = new MDToken(asyncKickoffMethod);
			if (kickoffToken.Table != Table.Method)
				return null;

			var asyncMethod = new PdbAsyncMethodCustomDebugInfo(asyncStepInfos.Count);
			asyncMethod.KickoffMethod = module.ResolveToken(kickoffToken) as MethodDef;
			asyncMethod.CatchHandlerInstruction = asyncCatchHandler;
			int count = asyncStepInfos.Count;
			for (int i = 0; i < count; i++)
				asyncMethod.StepInfos.Add(asyncStepInfos[i]);
			return asyncMethod;
		}

		PdbIteratorMethodCustomDebugInfo TryCreateIteratorMethod(ModuleDef module, int iteratorKickoffMethod) {
			var kickoffToken = new MDToken(iteratorKickoffMethod);
			if (kickoffToken.Table != Table.Method)
				return null;
			var kickoffMethod = module.ResolveToken(kickoffToken) as MethodDef;
			return new PdbIteratorMethodCustomDebugInfo(kickoffMethod);
		}

		public override void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result) {
			GetCustomDebugInfos(token, gpContext, result, null, null, out var asyncStepInfo);
			Debug.Assert(asyncStepInfo is null);
		}

		void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result, MethodDef methodOpt, CilBody bodyOpt, out PdbAsyncMethodSteppingInformationCustomDebugInfo asyncStepInfo) {
			asyncStepInfo = null;
			var mdToken = new MDToken(token);
			var ridList = pdbMetadata.GetCustomDebugInformationRidList(mdToken.Table, mdToken.Rid);
			if (ridList.Count == 0)
				return;
			var typeOpt = methodOpt?.DeclaringType;
			for (int i = 0; i < ridList.Count; i++) {
				var rid = ridList[i];
				if (!pdbMetadata.TablesStream.TryReadCustomDebugInformationRow(rid, out var row))
					continue;
				var guid = pdbMetadata.GuidStream.Read(row.Kind);
				if (!pdbMetadata.BlobStream.TryCreateReader(row.Value, out var reader))
					continue;
				Debug.Assert(guid is not null);
				if (guid is null)
					continue;
				var cdi = PortablePdbCustomDebugInfoReader.Read(module, typeOpt, bodyOpt, gpContext, guid.Value, ref reader);
				Debug.Assert(cdi is not null);
				if (cdi is not null) {
					if (cdi is PdbAsyncMethodSteppingInformationCustomDebugInfo asyncStepInfoTmp) {
						Debug.Assert(asyncStepInfo is null);
						asyncStepInfo = asyncStepInfoTmp;
					}
					else
						result.Add(cdi);
				}
			}
		}

		public override void Dispose() => pdbMetadata.Dispose();
	}
}




namespace dnlib.DotNet.Pdb.Portable {
	static class SequencePointConstants {
		public const int HIDDEN_LINE = 0xFEEFEE;
		public const int HIDDEN_COLUMN = 0;
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	sealed class SymbolDocumentImpl : SymbolDocument {
		readonly string url;
		/*readonly*/ Guid language;
		/*readonly*/ Guid languageVendor;
		/*readonly*/ Guid documentType;
		/*readonly*/ Guid checkSumAlgorithmId;
		readonly byte[] checkSum;
		readonly PdbCustomDebugInfo[] customDebugInfos;

		string GetDebuggerString() {
			var sb = new StringBuilder();
			if (language == PdbDocumentConstants.LanguageCSharp)
				sb.Append("C#");
			else if (language == PdbDocumentConstants.LanguageVisualBasic)
				sb.Append("VB");
			else if (language == PdbDocumentConstants.LanguageFSharp)
				sb.Append("F#");
			else
				sb.Append(language.ToString());
			sb.Append(", ");
			if (checkSumAlgorithmId == PdbDocumentConstants.HashSHA1)
				sb.Append("SHA-1");
			else if (checkSumAlgorithmId == PdbDocumentConstants.HashSHA256)
				sb.Append("SHA-256");
			else
				sb.Append(checkSumAlgorithmId.ToString());
			sb.Append(": ");
			sb.Append(url);
			return sb.ToString();
		}

		public override string URL => url;
		public override Guid Language => language;
		public override Guid LanguageVendor => languageVendor;
		public override Guid DocumentType => documentType;
		public override Guid CheckSumAlgorithmId => checkSumAlgorithmId;
		public override byte[] CheckSum => checkSum;
		public override PdbCustomDebugInfo[] CustomDebugInfos => customDebugInfos;

		public SymbolDocumentImpl(string url, Guid language, Guid languageVendor, Guid documentType, Guid checkSumAlgorithmId, byte[] checkSum, PdbCustomDebugInfo[] customDebugInfos) {
			this.url = url;
			this.language = language;
			this.languageVendor = languageVendor;
			this.documentType = documentType;
			this.checkSumAlgorithmId = checkSumAlgorithmId;
			this.checkSum = checkSum;
			this.customDebugInfos = customDebugInfos;
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	sealed class SymbolMethodImpl : SymbolMethod {
		readonly PortablePdbReader reader;
		readonly int token;
		readonly SymbolScope rootScope;
		readonly SymbolSequencePoint[] sequencePoints;
		readonly int kickoffMethod;

		public override int Token => token;
		public override SymbolScope RootScope => rootScope;
		public override IList<SymbolSequencePoint> SequencePoints => sequencePoints;
		public int KickoffMethod => kickoffMethod;

		public SymbolMethodImpl(PortablePdbReader reader, int token, SymbolScope rootScope, SymbolSequencePoint[] sequencePoints, int kickoffMethod) {
			this.reader = reader;
			this.token = token;
			this.rootScope = rootScope;
			this.sequencePoints = sequencePoints;
			this.kickoffMethod = kickoffMethod;
		}

		public override void GetCustomDebugInfos(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result) =>
			reader.GetCustomDebugInfos(this, method, body, result);
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	static class SymbolReaderFactory {
		public static SymbolReader TryCreate(PdbReaderContext pdbContext, DataReaderFactory pdbStream, bool isEmbeddedPortablePdb) {
			bool disposePdbStream = true;
			try {
				if (!pdbContext.HasDebugInfo)
					return null;
				if (pdbStream is null)
					return null;
				if (pdbStream.Length < 4)
					return null;
				if (pdbStream.CreateReader().ReadUInt32() != 0x424A5342)
					return null;

				var debugDir = pdbContext.CodeViewDebugDirectory;
				if (debugDir is null)
					return null;
				// Don't check that debugDir.MinorVersion == PortablePdbConstants.PortableCodeViewVersionMagic
				// and debugDir.MajorVersion == PortablePdbConstants.FormatVersion since it could be a converted
				// WindowsPDB file: https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#codeview-debug-directory-entry-type-2
				if (!pdbContext.TryGetCodeViewData(out var pdbGuid, out uint age))
					return null;

				var reader = new PortablePdbReader(pdbStream, isEmbeddedPortablePdb ? PdbFileKind.EmbeddedPortablePDB : PdbFileKind.PortablePDB);
				if (!reader.MatchesModule(pdbGuid, debugDir.TimeDateStamp, age))
					return null;
				disposePdbStream = false;
				return reader;
			}
			catch (IOException) {
			}
			finally {
				if (disposePdbStream)
					pdbStream?.Dispose();
			}
			return null;
		}

		public static SymbolReader TryCreateEmbeddedPortablePdbReader(PdbReaderContext pdbContext, MD.Metadata metadata) {
			if (metadata is null)
				return null;
			try {
				if (!pdbContext.HasDebugInfo)
					return null;
				var embeddedDir = pdbContext.TryGetDebugDirectoryEntry(ImageDebugType.EmbeddedPortablePdb);
				if (embeddedDir is null)
					return null;
				var reader = pdbContext.CreateReader(embeddedDir.AddressOfRawData, embeddedDir.SizeOfData);
				if (reader.Length < 8)
					return null;
				// "MPDB" = 0x4244504D
				if (reader.ReadUInt32() != 0x4244504D)
					return null;
				uint uncompressedSize = reader.ReadUInt32();
				// If this fails, see the (hopefully) updated spec:
				//		https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#embedded-portable-pdb-debug-directory-entry-type-17
				bool newVersion = (uncompressedSize & 0x80000000) != 0;
				Debug.Assert(!newVersion);
				if (newVersion)
					return null;
				var decompressedBytes = new byte[uncompressedSize];
				using (var deflateStream = new DeflateStream(reader.AsStream(), CompressionMode.Decompress)) {
					int pos = 0;
					while (pos < decompressedBytes.Length) {
						int read = deflateStream.Read(decompressedBytes, pos, decompressedBytes.Length - pos);
						if (read == 0)
							break;
						pos += read;
					}
					if (pos != decompressedBytes.Length)
						return null;
					var stream = ByteArrayDataReaderFactory.Create(decompressedBytes, filename: null);
					return TryCreate(pdbContext, stream, isEmbeddedPortablePdb: true);
				}
			}
			catch (IOException) {
			}
			return null;
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	sealed class SymbolScopeImpl : SymbolScope {
		readonly PortablePdbReader owner;
		internal SymbolMethod method;
		readonly SymbolScopeImpl parent;
		readonly int startOffset;
		readonly int endOffset;
		internal readonly List<SymbolScope> childrenList;
		internal readonly List<SymbolVariable> localsList;
		internal PdbImportScope importScope;
		readonly PdbCustomDebugInfo[] customDebugInfos;

		public override SymbolMethod Method {
			get {
				if (method is not null)
					return method;
				var p = parent;
				if (p is null)
					return method;
				for (;;) {
					if (p.parent is null)
						return method = p.method;
					p = p.parent;
				}
			}
		}

		public override SymbolScope Parent => parent;
		public override int StartOffset => startOffset;
		public override int EndOffset => endOffset;
		public override IList<SymbolScope> Children => childrenList;
		public override IList<SymbolVariable> Locals => localsList;
		public override IList<SymbolNamespace> Namespaces => Array2.Empty<SymbolNamespace>();
		public override IList<PdbCustomDebugInfo> CustomDebugInfos => customDebugInfos;
		public override PdbImportScope ImportScope => importScope;

		public SymbolScopeImpl(PortablePdbReader owner, SymbolScopeImpl parent, int startOffset, int endOffset, PdbCustomDebugInfo[] customDebugInfos) {
			this.owner = owner;
			method = null;
			this.parent = parent;
			this.startOffset = startOffset;
			this.endOffset = endOffset;
			childrenList = new List<SymbolScope>();
			localsList = new List<SymbolVariable>();
			this.customDebugInfos = customDebugInfos;
		}

		MD.Metadata constantsMetadata;
		RidList constantRidList;

		internal void SetConstants(MD.Metadata metadata, RidList rids) {
			constantsMetadata = metadata;
			constantRidList = rids;
		}

		public override IList<PdbConstant> GetConstants(ModuleDef module, GenericParamContext gpContext) {
			if (constantRidList.Count == 0)
				return Array2.Empty<PdbConstant>();
			Debug.Assert(constantsMetadata is not null);

			var res = new PdbConstant[constantRidList.Count];
			int w = 0;
			for (int i = 0; i < res.Length; i++) {
				uint rid = constantRidList[i];
				bool b = constantsMetadata.TablesStream.TryReadLocalConstantRow(rid, out var row);
				Debug.Assert(b);
				var name = constantsMetadata.StringsStream.Read(row.Name);
				if (!constantsMetadata.BlobStream.TryCreateReader(row.Signature, out var reader))
					continue;
				var localConstantSigBlobReader = new LocalConstantSigBlobReader(module, ref reader, gpContext);
				b = localConstantSigBlobReader.Read(out var type, out object value);
				Debug.Assert(b);
				if (b) {
					var pdbConstant = new PdbConstant(name, type, value);
					int token = new MDToken(Table.LocalConstant, rid).ToInt32();
					owner.GetCustomDebugInfos(token, gpContext, pdbConstant.CustomDebugInfos);
					res[w++] = pdbConstant;
				}
			}
			if (res.Length != w)
				Array.Resize(ref res, w);
			return res;
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	sealed class SymbolVariableImpl : SymbolVariable {
		readonly string name;
		readonly PdbLocalAttributes attributes;
		readonly int index;
		readonly PdbCustomDebugInfo[] customDebugInfos;

		public override string Name => name;
		public override PdbLocalAttributes Attributes => attributes;
		public override int Index => index;
		public override PdbCustomDebugInfo[] CustomDebugInfos => customDebugInfos;

		public SymbolVariableImpl(string name, PdbLocalAttributes attributes, int index, PdbCustomDebugInfo[] customDebugInfos) {
			this.name = name;
			this.attributes = attributes;
			this.index = index;
			this.customDebugInfos = customDebugInfos;
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	struct DocumentNameReader {
		const int MAX_NAME_LENGTH = 64 * 1024;
		readonly Dictionary<uint, string> docNamePartDict;
		readonly BlobStream blobStream;
		readonly StringBuilder sb;

		char[] prevSepChars;
		int prevSepCharsLength;
		byte[] prevSepCharBytes;
		int prevSepCharBytesCount;

		public DocumentNameReader(BlobStream blobStream) {
			docNamePartDict = new Dictionary<uint, string>();
			this.blobStream = blobStream;
			sb = new StringBuilder();

			prevSepChars = new char[2];
			prevSepCharsLength = 0;
			prevSepCharBytes = new byte[3];
			prevSepCharBytesCount = 0;
		}

		public string ReadDocumentName(uint offset) {
			sb.Length = 0;
			if (!blobStream.TryCreateReader(offset, out var reader))
				return string.Empty;
			var sepChars = ReadSeparatorChar(ref reader, out int sepCharsLength);
			bool needSep = false;
			while (reader.Position < reader.Length) {
				if (needSep)
					sb.Append(sepChars, 0, sepCharsLength);
				needSep = !(sepCharsLength == 1 && sepChars[0] == '\0');
				var part = ReadDocumentNamePart(reader.ReadCompressedUInt32());
				sb.Append(part);
				if (sb.Length > MAX_NAME_LENGTH) {
					sb.Length = MAX_NAME_LENGTH;
					break;
				}
			}
			return sb.ToString();
		}

		string ReadDocumentNamePart(uint offset) {
			if (docNamePartDict.TryGetValue(offset, out var name))
				return name;
			if (!blobStream.TryCreateReader(offset, out var reader))
				return string.Empty;
			name = reader.ReadUtf8String((int)reader.BytesLeft);
			docNamePartDict.Add(offset, name);
			return name;
		}

		char[] ReadSeparatorChar(ref DataReader reader, out int charLength) {
			if (prevSepCharBytesCount != 0 && prevSepCharBytesCount <= reader.Length) {
				var pos = reader.Position;
				bool ok = true;
				for (int i = 0; i < prevSepCharBytesCount; i++) {
					if (i >= prevSepCharBytes.Length || reader.ReadByte() != prevSepCharBytes[i]) {
						ok = false;
						break;
					}
				}
				if (ok) {
					charLength = prevSepCharsLength;
					return prevSepChars;
				}
				reader.Position = pos;
			}

			var decoder = Encoding.UTF8.GetDecoder();
			var bytes = new byte[1];
			prevSepCharBytesCount = 0;
			for (int i = 0; ; i++) {
				byte b = reader.ReadByte();
				prevSepCharBytesCount++;
				if (i == 0 && b == 0)
					break;
				if (i < prevSepCharBytes.Length)
					prevSepCharBytes[i] = b;
				bytes[0] = b;
				bool isLastByte = reader.Position + 1 == reader.Length;
				decoder.Convert(bytes, 0, 1, prevSepChars, 0, prevSepChars.Length, isLastByte, out int bytesUsed, out prevSepCharsLength, out bool completed);
				if (prevSepCharsLength > 0)
					break;
			}
			charLength = prevSepCharsLength;
			return prevSepChars;
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	static class ImportDefinitionKindUtils {
		public const PdbImportDefinitionKind UNKNOWN_IMPORT_KIND = (PdbImportDefinitionKind)(-1);

		public static PdbImportDefinitionKind ToPdbImportDefinitionKind(uint value) {
			// See System.Reflection.Metadata.ImportDefinitionKind
			switch (value) {
			case 1:		return PdbImportDefinitionKind.ImportNamespace;
			case 2:		return PdbImportDefinitionKind.ImportAssemblyNamespace;
			case 3:		return PdbImportDefinitionKind.ImportType;
			case 4:		return PdbImportDefinitionKind.ImportXmlNamespace;
			case 5:		return PdbImportDefinitionKind.ImportAssemblyReferenceAlias;
			case 6:		return PdbImportDefinitionKind.AliasAssemblyReference;
			case 7:		return PdbImportDefinitionKind.AliasNamespace;
			case 8:		return PdbImportDefinitionKind.AliasAssemblyNamespace;
			case 9:		return PdbImportDefinitionKind.AliasType;
			default:
				Debug.Fail("Unknown import definition kind: 0x" + value.ToString("X"));
				return UNKNOWN_IMPORT_KIND;
			}
		}

		public static bool ToImportDefinitionKind(PdbImportDefinitionKind kind, out uint rawKind) {
			switch (kind) {
			case PdbImportDefinitionKind.ImportNamespace:				rawKind = 1; return true;
			case PdbImportDefinitionKind.ImportAssemblyNamespace:		rawKind = 2; return true;
			case PdbImportDefinitionKind.ImportType:					rawKind = 3; return true;
			case PdbImportDefinitionKind.ImportXmlNamespace:			rawKind = 4; return true;
			case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:	rawKind = 5; return true;
			case PdbImportDefinitionKind.AliasAssemblyReference:		rawKind = 6; return true;
			case PdbImportDefinitionKind.AliasNamespace:				rawKind = 7; return true;
			case PdbImportDefinitionKind.AliasAssemblyNamespace:		rawKind = 8; return true;
			case PdbImportDefinitionKind.AliasType:						rawKind = 9; return true;
			default:													rawKind = uint.MaxValue; return false;
			}
		}
	}
}





namespace dnlib.DotNet.Pdb.Portable {
	// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#imports-blob
	readonly struct ImportScopeBlobReader {
		readonly ModuleDef module;
		readonly BlobStream blobStream;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module that resolves assembly and type references</param>
		/// <param name="blobStream">Portable PDB blob stream</param>
		public ImportScopeBlobReader(ModuleDef module, BlobStream blobStream) {
			this.module = module;
			this.blobStream = blobStream;
		}

		public void Read(uint imports, IList<PdbImport> result) {
			if (imports == 0)
				return;
			if (!blobStream.TryCreateReader(imports, out var reader))
				return;
			while (reader.Position < reader.Length) {
				var kind = ImportDefinitionKindUtils.ToPdbImportDefinitionKind(reader.ReadCompressedUInt32());
				string targetNamespace, alias;
				AssemblyRef targetAssembly;
				PdbImport import;
				ITypeDefOrRef targetType;
				switch (kind) {
				case PdbImportDefinitionKind.ImportNamespace:
					// <import> ::= ImportNamespace <target-namespace>
					targetNamespace = ReadUTF8(reader.ReadCompressedUInt32());
					import = new PdbImportNamespace(targetNamespace);
					break;

				case PdbImportDefinitionKind.ImportAssemblyNamespace:
					// <import> ::= ImportAssemblyNamespace <target-assembly> <target-namespace>
					targetAssembly = TryReadAssemblyRef(reader.ReadCompressedUInt32());
					targetNamespace = ReadUTF8(reader.ReadCompressedUInt32());
					import = new PdbImportAssemblyNamespace(targetAssembly, targetNamespace);
					break;

				case PdbImportDefinitionKind.ImportType:
					// <import> ::= ImportType <target-type>
					targetType = TryReadType(reader.ReadCompressedUInt32());
					import = new PdbImportType(targetType);
					break;

				case PdbImportDefinitionKind.ImportXmlNamespace:
					// <import> ::= ImportXmlNamespace <alias> <target-namespace>
					alias = ReadUTF8(reader.ReadCompressedUInt32());
					targetNamespace = ReadUTF8(reader.ReadCompressedUInt32());
					import = new PdbImportXmlNamespace(alias, targetNamespace);
					break;

				case PdbImportDefinitionKind.ImportAssemblyReferenceAlias:
					// <import> ::= ImportReferenceAlias <alias>
					alias = ReadUTF8(reader.ReadCompressedUInt32());
					import = new PdbImportAssemblyReferenceAlias(alias);
					break;

				case PdbImportDefinitionKind.AliasAssemblyReference:
					// <import> ::= AliasAssemblyReference <alias> <target-assembly>
					alias = ReadUTF8(reader.ReadCompressedUInt32());
					targetAssembly = TryReadAssemblyRef(reader.ReadCompressedUInt32());
					import = new PdbAliasAssemblyReference(alias, targetAssembly);
					break;

				case PdbImportDefinitionKind.AliasNamespace:
					// <import> ::= AliasNamespace <alias> <target-namespace>
					alias = ReadUTF8(reader.ReadCompressedUInt32());
					targetNamespace = ReadUTF8(reader.ReadCompressedUInt32());
					import = new PdbAliasNamespace(alias, targetNamespace);
					break;

				case PdbImportDefinitionKind.AliasAssemblyNamespace:
					// <import> ::= AliasAssemblyNamespace <alias> <target-assembly> <target-namespace>
					alias = ReadUTF8(reader.ReadCompressedUInt32());
					targetAssembly = TryReadAssemblyRef(reader.ReadCompressedUInt32());
					targetNamespace = ReadUTF8(reader.ReadCompressedUInt32());
					import = new PdbAliasAssemblyNamespace(alias, targetAssembly, targetNamespace);
					break;

				case PdbImportDefinitionKind.AliasType:
					// <import> ::= AliasType <alias> <target-type>
					alias = ReadUTF8(reader.ReadCompressedUInt32());
					targetType = TryReadType(reader.ReadCompressedUInt32());
					import = new PdbAliasType(alias, targetType);
					break;

				case ImportDefinitionKindUtils.UNKNOWN_IMPORT_KIND:
					import = null;
					break;

				default:
					Debug.Fail("Unknown import definition kind: " + kind.ToString());
					import = null;
					break;
				}
				if (import is not null)
					result.Add(import);
			}
			Debug.Assert(reader.Position == reader.Length);
		}

		ITypeDefOrRef TryReadType(uint codedToken) {
			bool b = CodedToken.TypeDefOrRef.Decode(codedToken, out uint token);
			Debug.Assert(b);
			if (!b)
				return null;
			var type = module.ResolveToken(token) as ITypeDefOrRef;
			Debug.Assert(type is not null);
			return type;
		}

		AssemblyRef TryReadAssemblyRef(uint rid) {
			var asmRef = module.ResolveToken(0x23000000 + rid) as AssemblyRef;
			Debug.Assert(asmRef is not null);
			return asmRef;
		}

		string ReadUTF8(uint offset) {
			if (!blobStream.TryCreateReader(offset, out var reader))
				return string.Empty;
			return reader.ReadUtf8String((int)reader.BytesLeft);
		}
	}
}





namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A method
	/// </summary>
	public abstract class SymbolMethod {
		/// <summary>
		/// Gets the method token
		/// </summary>
		public abstract int Token { get; }

		/// <summary>
		/// Gets the root scope
		/// </summary>
		public abstract SymbolScope RootScope { get; }

		/// <summary>
		/// Gets all sequence points
		/// </summary>
		public abstract IList<SymbolSequencePoint> SequencePoints { get; }

		/// <summary>
		/// Reads custom debug info
		/// </summary>
		/// <param name="method">Method</param>
		/// <param name="body">Method body</param>
		/// <param name="result">Updated with custom debug info</param>
		public abstract void GetCustomDebugInfos(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result);
	}
}




namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A namespace
	/// </summary>
	public abstract class SymbolNamespace {
		/// <summary>
		/// Gets the name
		/// </summary>
		public abstract string Name { get; }
	}
}





namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// Reads symbols from a PDB file
	/// </summary>
	public abstract class SymbolReader : IDisposable {
		/// <summary>
		/// Called by the owner module before any other methods and properties are called
		/// </summary>
		/// <param name="module">Owner module</param>
		public abstract void Initialize(ModuleDef module);

		/// <summary>
		/// Gets the PDB file kind
		/// </summary>
		public abstract PdbFileKind PdbFileKind { get; }

		/// <summary>
		/// Gets the user entry point token or 0 if none
		/// </summary>
		public abstract int UserEntryPoint { get; }

		/// <summary>
		/// Gets all documents
		/// </summary>
		public abstract IList<SymbolDocument> Documents { get; }

		/// <summary>
		/// Gets a method or returns null if the method doesn't exist in the PDB file
		/// </summary>
		/// <param name="method">Method</param>
		/// <param name="version">Edit and continue version. The first version is 1</param>
		/// <returns></returns>
		public abstract SymbolMethod GetMethod(MethodDef method, int version);

		/// <summary>
		/// Reads custom debug info
		/// </summary>
		/// <param name="token">Token of a <see cref="IHasCustomDebugInformation"/> instance</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <param name="result">Updated with custom debug info</param>
		public abstract void GetCustomDebugInfos(int token, GenericParamContext gpContext, IList<PdbCustomDebugInfo> result);

		/// <summary>
		/// Cleans up resources
		/// </summary>
		public virtual void Dispose() {
		}
	}
}





namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A scope
	/// </summary>
	public abstract class SymbolScope {
		/// <summary>
		/// Gets the method
		/// </summary>
		public abstract SymbolMethod Method { get; }

		/// <summary>
		/// Gets the parent scope
		/// </summary>
		public abstract SymbolScope Parent { get; }

		/// <summary>
		/// Gets the start offset of the scope in the method
		/// </summary>
		public abstract int StartOffset { get; }

		/// <summary>
		/// Gets the end offset of the scope in the method
		/// </summary>
		public abstract int EndOffset { get; }

		/// <summary>
		/// Gets all child scopes
		/// </summary>
		public abstract IList<SymbolScope> Children { get; }

		/// <summary>
		/// Gets all locals defined in this scope
		/// </summary>
		public abstract IList<SymbolVariable> Locals { get; }

		/// <summary>
		/// Gets all namespaces in this scope
		/// </summary>
		public abstract IList<SymbolNamespace> Namespaces { get; }

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public abstract IList<PdbCustomDebugInfo> CustomDebugInfos { get; }

		/// <summary>
		/// Gets the import scope or null if none
		/// </summary>
		public abstract PdbImportScope ImportScope { get; }

		/// <summary>
		/// Gets all the constants
		/// </summary>
		/// <param name="module">Owner module if a signature must be read from the #Blob</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns></returns>
		public abstract IList<PdbConstant> GetConstants(ModuleDef module, GenericParamContext gpContext);
	}
}





namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// Sequence point
	/// </summary>
	[DebuggerDisplay("{GetDebuggerString(),nq}")]
	public struct SymbolSequencePoint {
		/// <summary>
		/// IL offset
		/// </summary>
		public int Offset;

		/// <summary>
		/// Document
		/// </summary>
		public SymbolDocument Document;

		/// <summary>
		/// Start line
		/// </summary>
		public int Line;

		/// <summary>
		/// Start column
		/// </summary>
		public int Column;

		/// <summary>
		/// End line
		/// </summary>
		public int EndLine;

		/// <summary>
		/// End column
		/// </summary>
		public int EndColumn;

		readonly string GetDebuggerString() {
			var sb = new StringBuilder();
			if (Line == 0xFEEFEE && EndLine == 0xFEEFEE)
				sb.Append("<hidden>");
			else {
				sb.Append("(");
				sb.Append(Line);
				sb.Append(",");
				sb.Append(Column);
				sb.Append(")-(");
				sb.Append(EndLine);
				sb.Append(",");
				sb.Append(EndColumn);
				sb.Append(")");
			}
			sb.Append(": ");
			sb.Append(Document.URL);
			return sb.ToString();
		}
	}
}




namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A variable
	/// </summary>
	public abstract class SymbolVariable {
		/// <summary>
		/// Gets the name
		/// </summary>
		public abstract string Name { get; }

		/// <summary>
		/// Gets the attributes
		/// </summary>
		public abstract PdbLocalAttributes Attributes { get; }

		/// <summary>
		/// Gets the index of the variable
		/// </summary>
		public abstract int Index { get; }

		/// <summary>
		/// Gets all custom debug infos
		/// </summary>
		public abstract PdbCustomDebugInfo[] CustomDebugInfos { get; }
	}
}




namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// Async step info
	/// </summary>
	public struct SymbolAsyncStepInfo {
		/// <summary>
		/// Yield offset
		/// </summary>
		public uint YieldOffset;

		/// <summary>
		/// Breakpoint offset
		/// </summary>
		public uint BreakpointOffset;

		/// <summary>
		/// Breakpoint method token
		/// </summary>
		public uint BreakpointMethod;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="yieldOffset">Yield offset</param>
		/// <param name="breakpointOffset">Breakpoint offset</param>
		/// <param name="breakpointMethod">Breakpoint method token</param>
		public SymbolAsyncStepInfo(uint yieldOffset, uint breakpointOffset, uint breakpointMethod) {
			YieldOffset = yieldOffset;
			BreakpointOffset = breakpointOffset;
			BreakpointMethod = breakpointMethod;
		}
	}
}





namespace dnlib.DotNet.Pdb.Symbols {
	/// <summary>
	/// A document
	/// </summary>
	public abstract class SymbolDocument {
		/// <summary>
		/// Gets the URL
		/// </summary>
		public abstract string URL { get; }

		/// <summary>
		/// Gets the language
		/// </summary>
		public abstract Guid Language { get; }

		/// <summary>
		/// Gets the language vendor
		/// </summary>
		public abstract Guid LanguageVendor { get; }

		/// <summary>
		/// Gets the document type
		/// </summary>
		public abstract Guid DocumentType { get; }

		/// <summary>
		/// Gets the checksum algorithm id
		/// </summary>
		public abstract Guid CheckSumAlgorithmId { get; }

		/// <summary>
		/// Gets the checksum
		/// </summary>
		public abstract byte[] CheckSum { get; }

		/// <summary>
		/// Gets the custom debug infos
		/// </summary>
		public abstract PdbCustomDebugInfo[] CustomDebugInfos { get; }
	}
}




// C# & Visual Basic compiler's Custom Debug Info is "documented" in source code only, see Roslyn classes:
//	CustomDebugInfoReader, CustomDebugInfoWriter, CustomDebugInfoEncoder


namespace dnlib.DotNet.Pdb.WindowsPdb {
	sealed class PdbCustomDebugInfoWriterContext {
		public ILogger Logger;
		public readonly MemoryStream MemoryStream;
		public readonly DataWriter Writer;
		public readonly Dictionary<Instruction, uint> InstructionToOffsetDict;

		public PdbCustomDebugInfoWriterContext() {
			MemoryStream = new MemoryStream();
			Writer = new DataWriter(MemoryStream);
			InstructionToOffsetDict = new Dictionary<Instruction, uint>();
		}
	}

	/// <summary>
	/// Writes custom debug infos produced by the C# and Visual Basic compilers. They're stored in PDB files
	/// as PDB method custom attributes with the name "MD2".
	/// </summary>
	struct PdbCustomDebugInfoWriter {
		readonly Writer.Metadata metadata;
		readonly MethodDef method;
		readonly ILogger logger;
		readonly MemoryStream memoryStream;
		readonly DataWriter writer;
		readonly Dictionary<Instruction, uint> instructionToOffsetDict;
		uint bodySize;
		bool instructionToOffsetDictInitd;

		/// <summary>
		/// Returns the raw custom debug info or null if there was an error
		/// </summary>
		/// <param name="metadata">Metadata</param>
		/// <param name="context">Writer context</param>
		/// <param name="method">Method</param>
		/// <param name="customDebugInfos">Custom debug infos to write</param>
		/// <returns></returns>
		public static byte[] Write(Writer.Metadata metadata, MethodDef method, PdbCustomDebugInfoWriterContext context, IList<PdbCustomDebugInfo> customDebugInfos) {
			var writer = new PdbCustomDebugInfoWriter(metadata, method, context);
			return writer.Write(customDebugInfos);
		}

		PdbCustomDebugInfoWriter(Writer.Metadata metadata, MethodDef method, PdbCustomDebugInfoWriterContext context) {
			this.metadata = metadata;
			this.method = method;
			logger = context.Logger;
			memoryStream = context.MemoryStream;
			writer = context.Writer;
			instructionToOffsetDict = context.InstructionToOffsetDict;
			bodySize = 0;
			instructionToOffsetDictInitd = false;
			memoryStream.SetLength(0);
			memoryStream.Position = 0;
		}

		void InitializeInstructionDictionary() {
			Debug.Assert(!instructionToOffsetDictInitd);
			instructionToOffsetDict.Clear();
			var body = method.Body;
			if (body is null)
				return;
			var instrs = body.Instructions;
			uint offset = 0;
			for (int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				instructionToOffsetDict[instr] = offset;
				offset += (uint)instr.GetSize();
			}
			bodySize = offset;
			instructionToOffsetDictInitd = true;
		}

		uint GetInstructionOffset(Instruction instr, bool nullIsEndOfMethod) {
			if (!instructionToOffsetDictInitd)
				InitializeInstructionDictionary();
			if (instr is null) {
				if (nullIsEndOfMethod)
					return bodySize;
				Error("Instruction is null");
				return uint.MaxValue;
			}
			if (instructionToOffsetDict.TryGetValue(instr, out uint offset))
				return offset;
			Error("Instruction is missing in body but it's still being referenced by PDB data. Method {0} (0x{1:X8}), instruction: {2}", method, method.MDToken.Raw, instr);
			return uint.MaxValue;
		}

		void Error(string message, params object[] args) => logger.Log(this, LoggerEvent.Error, message, args);

		byte[] Write(IList<PdbCustomDebugInfo> customDebugInfos) {
			if (customDebugInfos.Count == 0)
				return null;
			if (customDebugInfos.Count > byte.MaxValue) {
				Error("Too many custom debug infos. Count must be <= 255");
				return null;
			}

			writer.WriteByte(CustomDebugInfoConstants.Version);
			writer.WriteByte((byte)customDebugInfos.Count);
			writer.WriteUInt16(0);

			for (int i = 0; i < customDebugInfos.Count; i++) {
				var info = customDebugInfos[i];
				if (info is null) {
					Error("Custom debug info is null");
					return null;
				}
				if ((uint)info.Kind > byte.MaxValue) {
					Error("Invalid custom debug info kind");
					return null;
				}

				var recordPos = writer.Position;
				writer.WriteByte(CustomDebugInfoConstants.RecordVersion);
				writer.WriteByte((byte)info.Kind);
				writer.WriteUInt16(0);
				writer.WriteUInt32(0);

				int count, j, k;
				uint token;
				switch (info.Kind) {
				case PdbCustomDebugInfoKind.UsingGroups:
					var usingRec = info as PdbUsingGroupsCustomDebugInfo;
					if (usingRec is null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					count = usingRec.UsingCounts.Count;
					if (count > ushort.MaxValue) {
						Error("UsingCounts contains more than 0xFFFF elements");
						return null;
					}
					writer.WriteUInt16((ushort)count);
					for (j = 0; j < count; j++)
						writer.WriteUInt16(usingRec.UsingCounts[j]);
					break;

				case PdbCustomDebugInfoKind.ForwardMethodInfo:
					var fwdMethodRec = info as PdbForwardMethodInfoCustomDebugInfo;
					if (fwdMethodRec is null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					token = GetMethodToken(fwdMethodRec.Method);
					if (token == 0)
						return null;
					writer.WriteUInt32(token);
					break;

				case PdbCustomDebugInfoKind.ForwardModuleInfo:
					var fwdModRec = info as PdbForwardModuleInfoCustomDebugInfo;
					if (fwdModRec is null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					token = GetMethodToken(fwdModRec.Method);
					if (token == 0)
						return null;
					writer.WriteUInt32(token);
					break;

				case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:
					var smLocalScopesRec = info as PdbStateMachineHoistedLocalScopesCustomDebugInfo;
					if (smLocalScopesRec is null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					count = smLocalScopesRec.Scopes.Count;
					writer.WriteInt32(count);
					for (j = 0; j < count; j++) {
						var scope = smLocalScopesRec.Scopes[j];
						if (scope.IsSynthesizedLocal) {
							writer.WriteInt32(0);
							writer.WriteInt32(0);
						}
						else {
							writer.WriteUInt32(GetInstructionOffset(scope.Start, nullIsEndOfMethod: false));
							writer.WriteUInt32(GetInstructionOffset(scope.End, nullIsEndOfMethod: true) - 1);
						}
					}
					break;

				case PdbCustomDebugInfoKind.StateMachineTypeName:
					var smTypeRec = info as PdbStateMachineTypeNameCustomDebugInfo;
					if (smTypeRec is null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					var type = smTypeRec.Type;
					if (type is null) {
						Error("State machine type is null");
						return null;
					}
					WriteUnicodeZ(MetadataNameToRoslynName(type.Name));
					break;

				case PdbCustomDebugInfoKind.DynamicLocals:
					var dynLocListRec = info as PdbDynamicLocalsCustomDebugInfo;
					if (dynLocListRec is null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					count = dynLocListRec.Locals.Count;
					writer.WriteInt32(count);
					for (j = 0; j < count; j++) {
						var dynLoc = dynLocListRec.Locals[j];
						if (dynLoc is null) {
							Error("Dynamic local is null");
							return null;
						}
						if (dynLoc.Flags.Count > 64) {
							Error("Dynamic local flags is longer than 64 bytes");
							return null;
						}
						var name = dynLoc.Name;
						if (name is null)
							name = string.Empty;
						if (name.Length > 64) {
							Error("Dynamic local name is longer than 64 chars");
							return null;
						}
						if (name.IndexOf('\0') >= 0) {
							Error("Dynamic local name contains a NUL char");
							return null;
						}

						for (k = 0; k < dynLoc.Flags.Count; k++)
							writer.WriteByte(dynLoc.Flags[k]);
						while (k++ < 64)
							writer.WriteByte(0);
						writer.WriteInt32(dynLoc.Flags.Count);

						if (dynLoc.Local is null)
							writer.WriteInt32(0);
						else
							writer.WriteInt32(dynLoc.Local.Index);

						for (k = 0; k < name.Length; k++)
							writer.WriteUInt16(name[k]);
						while (k++ < 64)
							writer.WriteUInt16(0);
					}
					break;

				case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:
					var encLocalMapRec = info as PdbEditAndContinueLocalSlotMapCustomDebugInfo;
					if (encLocalMapRec is null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					writer.WriteBytes(encLocalMapRec.Data);
					break;

				case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:
					var encLambdaRec = info as PdbEditAndContinueLambdaMapCustomDebugInfo;
					if (encLambdaRec is null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					writer.WriteBytes(encLambdaRec.Data);
					break;

				case PdbCustomDebugInfoKind.TupleElementNames:
					var tupleListRec = info as PdbTupleElementNamesCustomDebugInfo;
					if (tupleListRec is null) {
						Error("Unsupported custom debug info type {0}", info.GetType());
						return null;
					}
					count = tupleListRec.Names.Count;
					writer.WriteInt32(count);
					for (j = 0; j < count; j++) {
						var tupleInfo = tupleListRec.Names[j];
						if (tupleInfo is null) {
							Error("Tuple name info is null");
							return null;
						}
						writer.WriteInt32(tupleInfo.TupleElementNames.Count);
						for (k = 0; k < tupleInfo.TupleElementNames.Count; k++)
							WriteUTF8Z(tupleInfo.TupleElementNames[k]);

						if (tupleInfo.Local is null) {
							writer.WriteInt32(-1);
							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeStart, nullIsEndOfMethod: false));
							writer.WriteUInt32(GetInstructionOffset(tupleInfo.ScopeEnd, nullIsEndOfMethod: true));
						}
						else {
							writer.WriteInt32(tupleInfo.Local.Index);
							writer.WriteInt64(0L);
						}
						WriteUTF8Z(tupleInfo.Name);
					}
					break;

				default:
					var unkRec = info as PdbUnknownCustomDebugInfo;
					if (unkRec is null) {
						Error("Unsupported custom debug info class {0}", info.GetType());
						return null;
					}
					writer.WriteBytes(unkRec.Data);
					break;
				}

				var pos = writer.Position;
				var recLen = (pos - recordPos);
				var alignedLen = (recLen + 3) & ~3;
				if (alignedLen > uint.MaxValue) {
					Error("Custom debug info record is too big");
					return null;
				}
				writer.Position = recordPos + 3;
				if (info.Kind <= PdbCustomDebugInfoKind.DynamicLocals)
					writer.WriteByte(0);
				else
					writer.WriteByte((byte)(alignedLen - recLen));
				writer.WriteUInt32((uint)alignedLen);

				writer.Position = pos;
				while (writer.Position < recordPos + alignedLen)
					writer.WriteByte(0);
			}

			return memoryStream.ToArray();
		}

		string MetadataNameToRoslynName(string name) {
			if (name is null)
				return name;
			int index = name.LastIndexOf('`');
			if (index < 0)
				return name;
			return name.Substring(0, index);
		}

		void WriteUnicodeZ(string s) {
			if (s is null) {
				Error("String is null");
				return;
			}

			if (s.IndexOf('\0') >= 0) {
				Error("String contains a NUL char: {0}", s);
				return;
			}

			for (int i = 0; i < s.Length; i++)
				writer.WriteUInt16(s[i]);
			writer.WriteUInt16(0);
		}

		void WriteUTF8Z(string s) {
			if (s is null) {
				Error("String is null");
				return;
			}

			if (s.IndexOf('\0') >= 0) {
				Error("String contains a NUL char: {0}", s);
				return;
			}

			writer.WriteBytes(Encoding.UTF8.GetBytes(s));
			writer.WriteByte(0);
		}

		uint GetMethodToken(IMethodDefOrRef method) {
			if (method is null) {
				Error("Method is null");
				return 0;
			}

			if (method is MethodDef md) {
				uint rid = metadata.GetRid(md);
				if (rid == 0) {
					Error("Method {0} ({1:X8}) is not defined in this module ({2})", method, method.MDToken.Raw, metadata.Module);
					return 0;
				}
				return new MDToken(md.MDToken.Table, rid).Raw;
			}

			if (method is MemberRef mr && mr.IsMethodRef)
				return metadata.GetToken(mr).Raw;

			Error("Not a method");
			return 0;
		}
	}
}





namespace dnlib.DotNet.Pdb.WindowsPdb {
	static class PseudoCustomDebugInfoFactory {
		public static PdbAsyncMethodCustomDebugInfo TryCreateAsyncMethod(ModuleDef module, MethodDef method, CilBody body, int asyncKickoffMethod, IList<SymbolAsyncStepInfo> asyncStepInfos, uint? asyncCatchHandlerILOffset) {
			var kickoffToken = new MDToken(asyncKickoffMethod);
			if (kickoffToken.Table != Table.Method)
				return null;
			var kickoffMethod = module.ResolveToken(kickoffToken) as MethodDef;

			var asyncMethod = new PdbAsyncMethodCustomDebugInfo(asyncStepInfos.Count);
			asyncMethod.KickoffMethod = kickoffMethod;

			if (asyncCatchHandlerILOffset is not null) {
				asyncMethod.CatchHandlerInstruction = GetInstruction(body, asyncCatchHandlerILOffset.Value);
				Debug.Assert(asyncMethod.CatchHandlerInstruction is not null);
			}

			int count = asyncStepInfos.Count;
			for (int i = 0; i < count; i++) {
				var rawInfo = asyncStepInfos[i];
				var yieldInstruction = GetInstruction(body, rawInfo.YieldOffset);
				Debug.Assert(yieldInstruction is not null);
				if (yieldInstruction is null)
					continue;
				MethodDef breakpointMethod;
				Instruction breakpointInstruction;
				if (method.MDToken.Raw == rawInfo.BreakpointMethod) {
					breakpointMethod = method;
					breakpointInstruction = GetInstruction(body, rawInfo.BreakpointOffset);
				}
				else {
					var breakpointMethodToken = new MDToken(rawInfo.BreakpointMethod);
					Debug.Assert(breakpointMethodToken.Table == Table.Method);
					if (breakpointMethodToken.Table != Table.Method)
						continue;
					breakpointMethod = module.ResolveToken(breakpointMethodToken) as MethodDef;
					Debug.Assert(breakpointMethod is not null);
					if (breakpointMethod is null)
						continue;
					breakpointInstruction = GetInstruction(breakpointMethod.Body, rawInfo.BreakpointOffset);
				}
				Debug.Assert(breakpointInstruction is not null);
				if (breakpointInstruction is null)
					continue;

				asyncMethod.StepInfos.Add(new PdbAsyncStepInfo(yieldInstruction, breakpointMethod, breakpointInstruction));
			}

			return asyncMethod;
		}

		static Instruction GetInstruction(CilBody body, uint offset) {
			if (body is null)
				return null;
			var instructions = body.Instructions;
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}
	}
}





namespace dnlib.DotNet.Pdb.WindowsPdb {
	abstract class SymbolWriter : IDisposable {
		public abstract bool IsDeterministic { get; }
		public abstract bool SupportsAsyncMethods { get; }

		public abstract void Initialize(Writer.Metadata metadata);
		public abstract void Close();
		public abstract bool GetDebugInfo(ChecksumAlgorithm pdbChecksumAlgorithm, ref uint pdbAge, out Guid guid, out uint stamp, out IMAGE_DEBUG_DIRECTORY pIDD, out byte[] codeViewData);

		public abstract void SetUserEntryPoint(MDToken entryMethod);
		public abstract ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
		public abstract void SetSourceServerData(byte[] data);
		public abstract void SetSourceLinkData(byte[] data);

		public abstract void OpenMethod(MDToken method);
		public abstract void CloseMethod();
		public abstract int OpenScope(int startOffset);
		public abstract void CloseScope(int endOffset);
		public abstract void SetSymAttribute(MDToken parent, string name, byte[] data);
		public abstract void UsingNamespace(string fullName);
		public abstract void DefineSequencePoints(ISymbolDocumentWriter document, uint arraySize, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns);
		public abstract void DefineLocalVariable(string name, uint attributes, uint sigToken, uint addrKind, uint addr1, uint addr2, uint addr3, uint startOffset, uint endOffset);
		public abstract void DefineConstant(string name, object value, uint sigToken);
		public abstract void DefineKickoffMethod(uint kickoffMethod);
		public abstract void DefineCatchHandlerILOffset(uint catchHandlerOffset);
		public abstract void DefineAsyncStepInfo(uint[] yieldOffsets, uint[] breakpointOffset, uint[] breakpointMethod);

		public abstract void Dispose();
	}
}





namespace dnlib.DotNet.Pdb.WindowsPdb {
	sealed class WindowsPdbWriter : IDisposable {
		SymbolWriter writer;
		readonly PdbState pdbState;
		readonly ModuleDef module;
		readonly Writer.Metadata metadata;
		readonly Dictionary<PdbDocument, ISymbolDocumentWriter> pdbDocs = new Dictionary<PdbDocument, ISymbolDocumentWriter>();
		readonly SequencePointHelper seqPointsHelper = new SequencePointHelper();
		readonly Dictionary<Instruction, uint> instrToOffset;
		readonly PdbCustomDebugInfoWriterContext customDebugInfoWriterContext;
		readonly int localsEndScopeIncValue;

		public ILogger Logger { get; set; }

		public WindowsPdbWriter(SymbolWriter writer, PdbState pdbState, Writer.Metadata metadata)
			: this(pdbState, metadata) {
			if (pdbState is null)
				throw new ArgumentNullException(nameof(pdbState));
			if (metadata is null)
				throw new ArgumentNullException(nameof(metadata));
			this.writer = writer ?? throw new ArgumentNullException(nameof(writer));
			writer.Initialize(metadata);
		}

		WindowsPdbWriter(PdbState pdbState, Writer.Metadata metadata) {
			this.pdbState = pdbState;
			this.metadata = metadata;
			module = metadata.Module;
			instrToOffset = new Dictionary<Instruction, uint>();
			customDebugInfoWriterContext = new PdbCustomDebugInfoWriterContext();
			localsEndScopeIncValue = PdbUtils.IsEndInclusive(PdbFileKind.WindowsPDB, pdbState.Compiler) ? 1 : 0;
		}

		ISymbolDocumentWriter Add(PdbDocument pdbDoc) {
			if (pdbDocs.TryGetValue(pdbDoc, out var docWriter))
				return docWriter;
			docWriter = writer.DefineDocument(pdbDoc.Url, pdbDoc.Language, pdbDoc.LanguageVendor, pdbDoc.DocumentType);
			docWriter.SetCheckSum(pdbDoc.CheckSumAlgorithmId, pdbDoc.CheckSum);
			if (TryGetCustomDebugInfo(pdbDoc, out PdbEmbeddedSourceCustomDebugInfo sourceCdi))
				docWriter.SetSource(sourceCdi.SourceCodeBlob);
			pdbDocs.Add(pdbDoc, docWriter);
			return docWriter;
		}

		static bool TryGetCustomDebugInfo<TCDI>(IHasCustomDebugInformation hci, out TCDI cdi) where TCDI : PdbCustomDebugInfo {
			var cdis = hci.CustomDebugInfos;
			int count = cdis.Count;
			for (int i = 0; i < count; i++) {
				if (cdis[i] is TCDI cdi2) {
					cdi = cdi2;
					return true;
				}
			}
			cdi = null;
			return false;
		}

		public void Write() {
			writer.SetUserEntryPoint(GetUserEntryPointToken());

			var cdiBuilder = new List<PdbCustomDebugInfo>();
			foreach (var type in module.GetTypes()) {
				if (type is null)
					continue;
				var typeMethods = type.Methods;
				int count = typeMethods.Count;
				for (int i = 0; i < count; i++) {
					var method = typeMethods[i];
					if (method is null)
						continue;
					if (!ShouldAddMethod(method))
						continue;
					Write(method, cdiBuilder);
				}
			}

			if (TryGetCustomDebugInfo(module, out PdbSourceLinkCustomDebugInfo sourceLinkCdi))
				writer.SetSourceLinkData(sourceLinkCdi.FileBlob);
			if (TryGetCustomDebugInfo(module, out PdbSourceServerCustomDebugInfo sourceServerCdi))
				writer.SetSourceServerData(sourceServerCdi.FileBlob);
		}

		bool ShouldAddMethod(MethodDef method) {
			var body = method.Body;
			if (body is null)
				return false;

			if (body.HasPdbMethod)
				return true;

			var bodyVariables = body.Variables;
			int count = bodyVariables.Count;
			for (int i = 0; i < count; i++) {
				var local = bodyVariables[i];
				// Don't check whether it's the empty string. Only check for null.
				if (local.Name is not null)
					return true;
				if (local.Attributes != 0)
					return true;
			}

			var bodyInstructions = body.Instructions;
			count = bodyInstructions.Count;
			for (int i = 0; i < count; i++) {
				if (bodyInstructions[i].SequencePoint is not null)
					return true;
			}

			return false;
		}

		sealed class SequencePointHelper {
			readonly Dictionary<PdbDocument, bool> checkedPdbDocs = new Dictionary<PdbDocument, bool>();
			int[] instrOffsets = Array2.Empty<int>();
			int[] startLines;
			int[] startColumns;
			int[] endLines;
			int[] endColumns;

			public void Write(WindowsPdbWriter pdbWriter, IList<Instruction> instrs) {
				checkedPdbDocs.Clear();
				while (true) {
					PdbDocument currPdbDoc = null;
					bool otherDocsAvailable = false;
					int index = 0, instrOffset = 0;
					Instruction instr = null;
					for (int i = 0; i < instrs.Count; i++, instrOffset += instr.GetSize()) {
						instr = instrs[i];
						var seqp = instr.SequencePoint;
						if (seqp is null || seqp.Document is null)
							continue;
						if (checkedPdbDocs.ContainsKey(seqp.Document))
							continue;
						if (currPdbDoc is null)
							currPdbDoc = seqp.Document;
						else if (currPdbDoc != seqp.Document) {
							otherDocsAvailable = true;
							continue;
						}

						if (index >= instrOffsets.Length) {
							int newSize = index * 2;
							if (newSize < 64)
								newSize = 64;
							Array.Resize(ref instrOffsets, newSize);
							Array.Resize(ref startLines, newSize);
							Array.Resize(ref startColumns, newSize);
							Array.Resize(ref endLines, newSize);
							Array.Resize(ref endColumns, newSize);
						}

						instrOffsets[index]	= instrOffset;
						startLines[index]	= seqp.StartLine;
						startColumns[index]	= seqp.StartColumn;
						endLines[index]		= seqp.EndLine;
						endColumns[index]	= seqp.EndColumn;
						index++;
					}
					if (index != 0)
						pdbWriter.writer.DefineSequencePoints(pdbWriter.Add(currPdbDoc), (uint)index, instrOffsets, startLines, startColumns, endLines, endColumns);

					if (!otherDocsAvailable)
						break;
					if (currPdbDoc is not null)
						checkedPdbDocs.Add(currPdbDoc, true);
				}
			}
		}

		struct CurrentMethod {
			readonly WindowsPdbWriter pdbWriter;
			public readonly MethodDef Method;
			readonly Dictionary<Instruction, uint> toOffset;
			public readonly uint BodySize;

			public CurrentMethod(WindowsPdbWriter pdbWriter, MethodDef method, Dictionary<Instruction, uint> toOffset) {
				this.pdbWriter = pdbWriter;
				Method = method;
				this.toOffset = toOffset;
				toOffset.Clear();
				uint offset = 0;
				var instructions = method.Body.Instructions;
				int count = instructions.Count;
				for (int i = 0; i < count; i++) {
					var instr = instructions[i];
					toOffset[instr] = offset;
					offset += (uint)instr.GetSize();
				}
				BodySize = offset;
			}

			public readonly int GetOffset(Instruction instr) {
				if (instr is null)
					return (int)BodySize;
				if (toOffset.TryGetValue(instr, out uint offset))
					return (int)offset;
				pdbWriter.Error("Instruction was removed from the body but is referenced from PdbScope: {0}", instr);
				return (int)BodySize;
			}
		}

		void Write(MethodDef method, List<PdbCustomDebugInfo> cdiBuilder) {
			uint rid = metadata.GetRid(method);
			if (rid == 0) {
				Error("Method {0} ({1:X8}) is not defined in this module ({2})", method, method.MDToken.Raw, module);
				return;
			}

			var info = new CurrentMethod(this, method, instrToOffset);
			var body = method.Body;
			var symbolToken = new MDToken(MD.Table.Method, rid);
			writer.OpenMethod(symbolToken);
			seqPointsHelper.Write(this, info.Method.Body.Instructions);

			var pdbMethod = body.PdbMethod;
			if (pdbMethod is null)
				body.PdbMethod = pdbMethod = new PdbMethod();
			var scope = pdbMethod.Scope;
			if (scope is null)
				pdbMethod.Scope = scope = new PdbScope();
			if (scope.Namespaces.Count == 0 && scope.Variables.Count == 0 && scope.Constants.Count == 0) {
				if (scope.Scopes.Count == 0) {
					// We must open at least one sub scope (the sym writer creates the 'method' scope
					// which covers the whole method) or the native PDB reader will fail to read all
					// sequence points.
					writer.OpenScope(0);
					writer.CloseScope((int)info.BodySize);
				}
				else {
					var scopes = scope.Scopes;
					int count = scopes.Count;
					for (int i = 0; i < count; i++)
						WriteScope(ref info, scopes[i], 0);
				}
			}
			else {
				// C++/.NET (some methods)
				WriteScope(ref info, scope, 0);
			}

			GetPseudoCustomDebugInfos(method.CustomDebugInfos, cdiBuilder, out var asyncMethod);
			if (cdiBuilder.Count != 0) {
				customDebugInfoWriterContext.Logger = GetLogger();
				var cdiData = PdbCustomDebugInfoWriter.Write(metadata, method, customDebugInfoWriterContext, cdiBuilder);
				if (cdiData is not null)
					writer.SetSymAttribute(symbolToken, "MD2", cdiData);
			}

			if (asyncMethod is not null) {
				if (!writer.SupportsAsyncMethods)
					Error("PDB symbol writer doesn't support writing async methods");
				else
					WriteAsyncMethod(ref info, asyncMethod);
			}

			writer.CloseMethod();
		}

		void GetPseudoCustomDebugInfos(IList<PdbCustomDebugInfo> customDebugInfos, List<PdbCustomDebugInfo> cdiBuilder, out PdbAsyncMethodCustomDebugInfo asyncMethod) {
			cdiBuilder.Clear();
			asyncMethod = null;
			int count = customDebugInfos.Count;
			for (int i = 0; i < count; i++) {
				var cdi = customDebugInfos[i];
				switch (cdi.Kind) {
				case PdbCustomDebugInfoKind.AsyncMethod:
					if (asyncMethod is not null)
						Error("Duplicate async method custom debug info");
					else
						asyncMethod = (PdbAsyncMethodCustomDebugInfo)cdi;
					break;

				default:
					if ((uint)cdi.Kind > byte.MaxValue)
						Error("Custom debug info {0} isn't supported by Windows PDB files", cdi.Kind);
					else
						cdiBuilder.Add(cdi);
					break;
				}
			}
		}

		uint GetMethodToken(MethodDef method) {
			uint rid = metadata.GetRid(method);
			if (rid == 0)
				Error("Method {0} ({1:X8}) is not defined in this module ({2})", method, method.MDToken.Raw, module);
			return new MDToken(MD.Table.Method, rid).Raw;
		}

		void WriteAsyncMethod(ref CurrentMethod info, PdbAsyncMethodCustomDebugInfo asyncMethod) {
			if (asyncMethod.KickoffMethod is null) {
				Error("KickoffMethod is null");
				return;
			}

			uint kickoffMethod = GetMethodToken(asyncMethod.KickoffMethod);
			writer.DefineKickoffMethod(kickoffMethod);

			if (asyncMethod.CatchHandlerInstruction is not null) {
				int catchHandlerILOffset = info.GetOffset(asyncMethod.CatchHandlerInstruction);
				writer.DefineCatchHandlerILOffset((uint)catchHandlerILOffset);
			}

			var stepInfos = asyncMethod.StepInfos;
			var yieldOffsets = new uint[stepInfos.Count];
			var breakpointOffset = new uint[stepInfos.Count];
			var breakpointMethods = new uint[stepInfos.Count];
			for (int i = 0; i < yieldOffsets.Length; i++) {
				var stepInfo = stepInfos[i];
				if (stepInfo.YieldInstruction is null) {
					Error("YieldInstruction is null");
					return;
				}
				if (stepInfo.BreakpointMethod is null) {
					Error("BreakpointMethod is null");
					return;
				}
				if (stepInfo.BreakpointInstruction is null) {
					Error("BreakpointInstruction is null");
					return;
				}
				yieldOffsets[i] = (uint)info.GetOffset(stepInfo.YieldInstruction);
				breakpointOffset[i] = (uint)GetExternalInstructionOffset(ref info, stepInfo.BreakpointMethod, stepInfo.BreakpointInstruction);
				breakpointMethods[i] = GetMethodToken(stepInfo.BreakpointMethod);
			}
			writer.DefineAsyncStepInfo(yieldOffsets, breakpointOffset, breakpointMethods);
		}

		int GetExternalInstructionOffset(ref CurrentMethod info, MethodDef method, Instruction instr) {
			if (info.Method == method)
				return info.GetOffset(instr);
			var body = method.Body;
			if (body is null) {
				Error("Method body is null");
				return 0;
			}

			var instrs = body.Instructions;
			int offset = 0;
			for (int i = 0; i < instrs.Count; i++) {
				var currInstr = instrs[i];
				if (currInstr == instr)
					return offset;
				offset += currInstr.GetSize();
			}
			if (instr is null)
				return offset;
			Error("Async method instruction has been removed but it's still being referenced by PDB info: BP Instruction: {0}, BP Method: {1} (0x{2:X8}), Current Method: {3} (0x{4:X8})", instr, method, method.MDToken.Raw, info.Method, info.Method.MDToken.Raw);
			return 0;
		}

		void WriteScope(ref CurrentMethod info, PdbScope scope, int recursionCounter) {
			if (recursionCounter >= 1000) {
				Error("Too many PdbScopes");
				return;
			}

			int startOffset = info.GetOffset(scope.Start);
			int endOffset = info.GetOffset(scope.End);
			writer.OpenScope(startOffset);
			AddLocals(info.Method, scope.Variables, (uint)startOffset, (uint)endOffset);
			if (scope.Constants.Count > 0) {
				var constants = scope.Constants;
				var sig = new FieldSig();
				for (int i = 0; i < constants.Count; i++) {
					var constant = constants[i];
					sig.Type = constant.Type;
					var token = metadata.GetToken(sig);
					writer.DefineConstant(constant.Name, constant.Value ?? boxedZeroInt32, token.Raw);
				}
			}
			var scopeNamespaces = scope.Namespaces;
			int count = scopeNamespaces.Count;
			for (int i = 0; i < count; i++)
				writer.UsingNamespace(scopeNamespaces[i]);
			var scopes = scope.Scopes;
			count = scopes.Count;
			for (int i = 0; i < count; i++)
				WriteScope(ref info, scopes[i], recursionCounter + 1);
			writer.CloseScope(startOffset == 0 && endOffset == info.BodySize ? endOffset : endOffset - localsEndScopeIncValue);
		}
		static readonly object boxedZeroInt32 = 0;

		void AddLocals(MethodDef method, IList<PdbLocal> locals, uint startOffset, uint endOffset) {
			if (locals.Count == 0)
				return;
			uint token = metadata.GetLocalVarSigToken(method);
			if (token == 0) {
				Error("Method {0} ({1:X8}) has no local signature token", method, method.MDToken.Raw);
				return;
			}
			int count = locals.Count;
			for (int i = 0; i < count; i++) {
				var local = locals[i];
				uint attrs = GetPdbLocalFlags(local.Attributes);
				if (attrs == 0 && local.Name is null)
					continue;
				writer.DefineLocalVariable(local.Name ?? string.Empty, attrs,
								token, 1, (uint)local.Index, 0, 0, startOffset, endOffset);
			}
		}

		static uint GetPdbLocalFlags(PdbLocalAttributes attributes) {
			if ((attributes & PdbLocalAttributes.DebuggerHidden) != 0)
				return (uint)CorSymVarFlag.VAR_IS_COMP_GEN;
			return 0;
		}

		MDToken GetUserEntryPointToken() {
			var ep = pdbState.UserEntryPoint;
			if (ep is null)
				return default;
			uint rid = metadata.GetRid(ep);
			if (rid == 0) {
				Error("PDB user entry point method {0} ({1:X8}) is not defined in this module ({2})", ep, ep.MDToken.Raw, module);
				return default;
			}
			return new MDToken(MD.Table.Method, rid);
		}

		public bool GetDebugInfo(ChecksumAlgorithm pdbChecksumAlgorithm, ref uint pdbAge, out Guid guid, out uint stamp, out IMAGE_DEBUG_DIRECTORY idd, out byte[] codeViewData) =>
			writer.GetDebugInfo(pdbChecksumAlgorithm, ref pdbAge, out guid, out stamp, out idd, out codeViewData);

		public void Close() => writer.Close();
		ILogger GetLogger() => Logger ?? DummyLogger.ThrowModuleWriterExceptionOnErrorInstance;
		void Error(string message, params object[] args) => GetLogger().Log(this, LoggerEvent.Error, message, args);

		/// <inheritdoc/>
		public void Dispose() {
			if (writer is not null)
				Close();
			writer?.Dispose();
			writer = null;
		}
	}
}





namespace dnlib.DotNet.Pdb.WindowsPdb {
	[Flags]
	enum CorSymVarFlag : uint {
		VAR_IS_COMP_GEN			= 0x00000001,
	}
}




namespace dnlib.DotNet.Pdb.WindowsPdb {
	static class CustomDebugInfoConstants {
		public const int Version = 4;
		public const int RecordVersion = 4;
	}
}




// C# & Visual Basic compiler's Custom Debug Info is "documented" in source code only, see Roslyn classes:
//	CustomDebugInfoReader, CustomDebugInfoWriter, CustomDebugInfoEncoder


namespace dnlib.DotNet.Pdb.WindowsPdb {
	/// <summary>
	/// Reads custom debug infos produced by the C# and Visual Basic compilers. They're stored in PDB files
	/// as PDB method custom attributes with the name "MD2".
	/// </summary>
	struct PdbCustomDebugInfoReader {
		/// <summary>
		/// Reads custom debug info
		/// </summary>
		/// <param name="method">Method</param>
		/// <param name="body">The method's body. Needs to be provided by the caller since we're called from
		/// PDB-init code when the Body property hasn't been initialized yet</param>
		/// <param name="result">Place all custom debug info in this list</param>
		/// <param name="data">Custom debug info from the PDB file</param>
		public static void Read(MethodDef method, CilBody body, IList<PdbCustomDebugInfo> result, byte[] data) {
			try {
				var reader = ByteArrayDataReaderFactory.CreateReader(data);
				var cdiReader = new PdbCustomDebugInfoReader(method, body, ref reader);
				cdiReader.Read(result);
			}
			catch (ArgumentException) {
			}
			catch (OutOfMemoryException) {
			}
			catch (IOException) {
			}
		}

		readonly ModuleDef module;
		readonly TypeDef typeOpt;
		readonly CilBody bodyOpt;
		readonly GenericParamContext gpContext;
		DataReader reader;

		PdbCustomDebugInfoReader(MethodDef method, CilBody body, ref DataReader reader) {
			module = method.Module;
			typeOpt = method.DeclaringType;
			bodyOpt = body;
			gpContext = GenericParamContext.Create(method);
			this.reader = reader;
		}

		void Read(IList<PdbCustomDebugInfo> result) {
			if (reader.Length < 4)
				return;
			int version = reader.ReadByte();
			Debug.Assert(version == CustomDebugInfoConstants.Version);
			if (version != CustomDebugInfoConstants.Version)
				return;
			int count = reader.ReadByte();
			reader.Position += 2;

			while (reader.CanRead(8U)) {
				int recVersion = reader.ReadByte();
				Debug.Assert(recVersion == CustomDebugInfoConstants.RecordVersion);
				var recKind = (PdbCustomDebugInfoKind)reader.ReadByte();
				reader.Position++;
				int alignmentSize = reader.ReadByte();
				int recSize = reader.ReadInt32();
				if (recSize < 8 || (ulong)reader.Position - 8 + (uint)recSize > reader.Length)
					return;
				if (recKind <= PdbCustomDebugInfoKind.DynamicLocals)
					alignmentSize = 0;
				if (alignmentSize > 3)
					return;
				var nextRecPos = reader.Position - 8 + (uint)recSize;

				if (recVersion == CustomDebugInfoConstants.RecordVersion) {
					ulong recPosEnd = (ulong)reader.Position - 8 + (uint)recSize - (uint)alignmentSize;
					var cdi = ReadRecord(recKind, recPosEnd);
					Debug.Assert(cdi is not null);
					Debug.Assert(reader.Position <= recPosEnd);
					if (reader.Position > recPosEnd)
						return;
					if (cdi is not null) {
						Debug.Assert(cdi.Kind == recKind);
						result.Add(cdi);
					}
				}

				reader.Position = nextRecPos;
			}
		}

		PdbCustomDebugInfo ReadRecord(PdbCustomDebugInfoKind recKind, ulong recPosEnd) {
			IMethodDefOrRef method;
			byte[] data;
			Local local;
			int count;
			int localIndex;
			switch (recKind) {
			case PdbCustomDebugInfoKind.UsingGroups:
				count = reader.ReadUInt16();
				if (count < 0)
					return null;
				var usingCountRec = new PdbUsingGroupsCustomDebugInfo(count);
				for (int i = 0; i < count; i++)
					usingCountRec.UsingCounts.Add(reader.ReadUInt16());
				return usingCountRec;

			case PdbCustomDebugInfoKind.ForwardMethodInfo:
				method = module.ResolveToken(reader.ReadUInt32(), gpContext) as IMethodDefOrRef;
				if (method is null)
					return null;
				return new PdbForwardMethodInfoCustomDebugInfo(method);

			case PdbCustomDebugInfoKind.ForwardModuleInfo:
				method = module.ResolveToken(reader.ReadUInt32(), gpContext) as IMethodDefOrRef;
				if (method is null)
					return null;
				return new PdbForwardModuleInfoCustomDebugInfo(method);

			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:
				if (bodyOpt is null)
					return null;
				count = reader.ReadInt32();
				if (count < 0)
					return null;
				var smScope = new PdbStateMachineHoistedLocalScopesCustomDebugInfo(count);
				for (int i = 0; i < count; i++) {
					uint startOffset = reader.ReadUInt32();
					uint endOffset = reader.ReadUInt32();
					if (startOffset > endOffset)
						return null;
					// Try to detect synthesized locals, whose start==end==0. The problem is that endOffset
					// read from the PDB is inclusive (add 1 to get 'end'), so a synthesized local and a
					// local at [0, 1) will be encoded the same {0, 0}.
					if (endOffset == 0)
						smScope.Scopes.Add(new StateMachineHoistedLocalScope());
					else {
						var start = GetInstruction(startOffset);
						var end = GetInstruction(endOffset + 1);
						if (start is null)
							return null;
						smScope.Scopes.Add(new StateMachineHoistedLocalScope(start, end));
					}
				}
				return smScope;

			case PdbCustomDebugInfoKind.StateMachineTypeName:
				var name = ReadUnicodeZ(recPosEnd, needZeroChar: true);
				if (name is null)
					return null;
				var type = GetNestedType(name);
				if (type is null)
					return null;
				return new PdbStateMachineTypeNameCustomDebugInfo(type);

			case PdbCustomDebugInfoKind.DynamicLocals:
				if (bodyOpt is null)
					return null;
				count = reader.ReadInt32();
				const int dynLocalRecSize = 64 + 4 + 4 + 2 * 64;
				if (reader.Position + (ulong)(uint)count * dynLocalRecSize > recPosEnd)
					return null;
				var dynLocListRec = new PdbDynamicLocalsCustomDebugInfo(count);
				for (int i = 0; i < count; i++) {
					reader.Position += 64;
					int flagsCount = reader.ReadInt32();
					if ((uint)flagsCount > 64)
						return null;
					var dynLocRec = new PdbDynamicLocal(flagsCount);
					var afterPos = reader.Position;

					reader.Position -= 64 + 4;
					for (int j = 0; j < flagsCount; j++)
						dynLocRec.Flags.Add(reader.ReadByte());
					reader.Position = afterPos;

					localIndex = reader.ReadInt32();
					// 'const' locals have index -1 but they're encoded as 0 by Roslyn
					if (localIndex != 0 && (uint)localIndex >= (uint)bodyOpt.Variables.Count)
						return null;

					var nameEndPos = reader.Position + 2 * 64;
					name = ReadUnicodeZ(nameEndPos, needZeroChar: false);
					reader.Position = nameEndPos;

					local = localIndex < bodyOpt.Variables.Count ? bodyOpt.Variables[localIndex] : null;
					// Roslyn writes 0 to localIndex if it's a 'const' local, try to undo that now
					if (localIndex == 0 && local is not null && local.Name != name)
						local = null;
					if (local is not null && local.Name == name)
						name = null;
					dynLocRec.Name = name;
					dynLocRec.Local = local;
					dynLocListRec.Locals.Add(dynLocRec);
				}
				return dynLocListRec;

			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:
				data = reader.ReadBytes((int)(recPosEnd - reader.Position));
				return new PdbEditAndContinueLocalSlotMapCustomDebugInfo(data);

			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:
				data = reader.ReadBytes((int)(recPosEnd - reader.Position));
				return new PdbEditAndContinueLambdaMapCustomDebugInfo(data);

			case PdbCustomDebugInfoKind.TupleElementNames:
				if (bodyOpt is null)
					return null;
				count = reader.ReadInt32();
				if (count < 0)
					return null;
				var tupleListRec = new PdbTupleElementNamesCustomDebugInfo(count);
				for (int i = 0; i < count; i++) {
					int nameCount = reader.ReadInt32();
					if ((uint)nameCount >= 10000)
						return null;
					var tupleInfo = new PdbTupleElementNames(nameCount);

					for (int j = 0; j < nameCount; j++) {
						var s = ReadUTF8Z(recPosEnd);
						if (s is null)
							return null;
						tupleInfo.TupleElementNames.Add(s);
					}

					localIndex = reader.ReadInt32();
					uint scopeStart = reader.ReadUInt32();
					uint scopeEnd = reader.ReadUInt32();
					name = ReadUTF8Z(recPosEnd);
					if (name is null)
						return null;
					Debug.Assert(localIndex >= -1);
					// -1 = 'const' local. Only 'const' locals have a scope
					Debug.Assert((localIndex == -1) ^ (scopeStart == 0 && scopeEnd == 0));

					if (localIndex == -1) {
						local = null;
						tupleInfo.ScopeStart = GetInstruction(scopeStart);
						tupleInfo.ScopeEnd = GetInstruction(scopeEnd);
						if (tupleInfo.ScopeStart is null)
							return null;
					}
					else {
						if ((uint)localIndex >= (uint)bodyOpt.Variables.Count)
							return null;
						local = bodyOpt.Variables[localIndex];
					}

					if (local is not null && local.Name == name)
						name = null;
					tupleInfo.Local = local;
					tupleInfo.Name = name;

					tupleListRec.Names.Add(tupleInfo);
				}
				return tupleListRec;

			default:
				Debug.Fail("Unknown custom debug info kind: 0x" + ((int)recKind).ToString("X"));
				data = reader.ReadBytes((int)(recPosEnd - reader.Position));
				return new PdbUnknownCustomDebugInfo(recKind, data);
			}
		}

		TypeDef GetNestedType(string name) {
			if (typeOpt is null)
				return null;
			var nestedTypes = typeOpt.NestedTypes;
			int count = nestedTypes.Count;
			for (int i = 0; i < count; i++) {
				var type = nestedTypes[i];
				if (UTF8String.IsNullOrEmpty(type.Namespace)) {
					if (type.Name == name)
						return type;
					var typeName = type.Name.String;
					if (typeName.StartsWith(name) && typeName.Length >= name.Length + 2) {
						int index = name.Length;
						if (typeName[index] == '`') {
							Debug.Assert(index + 1 < typeName.Length);
							bool ok = true;
							index++;
							while (index < typeName.Length) {
								if (!char.IsDigit(typeName[index])) {
									ok = false;
									break;
								}
								index++;
							}
							if (ok)
								return type;
						}
					}
				}
			}
			return null;
		}

		string ReadUnicodeZ(ulong recPosEnd, bool needZeroChar) {
			var sb = new StringBuilder();

			for (;;) {
				if (reader.Position >= recPosEnd)
					return needZeroChar ? null : sb.ToString();
				var c = reader.ReadChar();
				if (c == 0)
					return sb.ToString();
				sb.Append(c);
			}
		}

		string ReadUTF8Z(ulong recPosEnd) {
			if (reader.Position > recPosEnd)
				return null;
			return reader.TryReadZeroTerminatedUtf8String();
		}

		Instruction GetInstruction(uint offset) {
			var instructions = bodyOpt.Instructions;
			int lo = 0, hi = instructions.Count - 1;
			while (lo <= hi && hi != -1) {
				int i = (lo + hi) / 2;
				var instr = instructions[i];
				if (instr.Offset == offset)
					return instr;
				if (offset < instr.Offset)
					hi = i - 1;
				else
					lo = i + 1;
			}
			return null;
		}
	}
}





namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Implemented by all resource data
	/// </summary>
	public interface IResourceData : IFileSection {
		/// <summary>
		/// Gets the type of data
		/// </summary>
		ResourceTypeCode Code { get; }

		/// <summary>
		/// Start offset of the section in the file
		/// </summary>
		new FileOffset StartOffset { get; set; }

		/// <summary>
		/// End offset of the section in the file. This is one byte after the last
		/// valid offset in the section.
		/// </summary>
		new FileOffset EndOffset { get; set; }

		/// <summary>
		/// Writes the data
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="formatter">Formatter if needed by implementer</param>
		void WriteData(BinaryWriter writer, IFormatter formatter);
	}
}





namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Creates resource data
	/// </summary>
	public class ResourceDataFactory {
		readonly ModuleDef module;
		readonly ModuleDefMD moduleMD;
		readonly Dictionary<string, UserResourceType> dict = new Dictionary<string, UserResourceType>(StringComparer.Ordinal);
		readonly Dictionary<string, string> asmNameToAsmFullName = new Dictionary<string, string>(StringComparer.Ordinal);

		/// <summary>
		/// Gets the owner module
		/// </summary>
		protected ModuleDef Module => module;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Owner module</param>
		public ResourceDataFactory(ModuleDef module) {
			this.module = module;
			moduleMD = module as ModuleDefMD;
		}

		/// <summary>
		/// Gets number of user data types
		/// </summary>
		public int Count => dict.Count;

		/// <summary>
		/// Create null data
		/// </summary>
		/// <returns></returns>
		public BuiltInResourceData CreateNull() => new BuiltInResourceData(ResourceTypeCode.Null, null);

		/// <summary>
		/// Creates <see cref="string"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(string value) => new BuiltInResourceData(ResourceTypeCode.String, value);

		/// <summary>
		/// Creates <see cref="bool"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(bool value) => new BuiltInResourceData(ResourceTypeCode.Boolean, value);

		/// <summary>
		/// Creates <see cref="char"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(char value) => new BuiltInResourceData(ResourceTypeCode.Char, value);

		/// <summary>
		/// Creates <see cref="byte"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(byte value) => new BuiltInResourceData(ResourceTypeCode.Byte, value);

		/// <summary>
		/// Creates <see cref="sbyte"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(sbyte value) => new BuiltInResourceData(ResourceTypeCode.SByte, value);

		/// <summary>
		/// Creates <see cref="short"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(short value) => new BuiltInResourceData(ResourceTypeCode.Int16, value);

		/// <summary>
		/// Creates <see cref="ushort"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(ushort value) => new BuiltInResourceData(ResourceTypeCode.UInt16, value);

		/// <summary>
		/// Creates <see cref="int"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(int value) => new BuiltInResourceData(ResourceTypeCode.Int32, value);

		/// <summary>
		/// Creates <see cref="uint"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(uint value) => new BuiltInResourceData(ResourceTypeCode.UInt32, value);

		/// <summary>
		/// Creates <see cref="long"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(long value) => new BuiltInResourceData(ResourceTypeCode.Int64, value);

		/// <summary>
		/// Creates <see cref="ulong"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(ulong value) => new BuiltInResourceData(ResourceTypeCode.UInt64, value);

		/// <summary>
		/// Creates <see cref="float"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(float value) => new BuiltInResourceData(ResourceTypeCode.Single, value);

		/// <summary>
		/// Creates <see cref="double"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(double value) => new BuiltInResourceData(ResourceTypeCode.Double, value);

		/// <summary>
		/// Creates <see cref="decimal"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(decimal value) => new BuiltInResourceData(ResourceTypeCode.Decimal, value);

		/// <summary>
		/// Creates <see cref="DateTime"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(DateTime value) => new BuiltInResourceData(ResourceTypeCode.DateTime, value);

		/// <summary>
		/// Creates <see cref="TimeSpan"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(TimeSpan value) => new BuiltInResourceData(ResourceTypeCode.TimeSpan, value);

		/// <summary>
		/// Creates <see cref="byte"/> array data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData Create(byte[] value) => new BuiltInResourceData(ResourceTypeCode.ByteArray, value);

		/// <summary>
		/// Creates <see cref="Stream"/> data
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public BuiltInResourceData CreateStream(byte[] value) => new BuiltInResourceData(ResourceTypeCode.Stream, value);

		/// <summary>
		/// Creates serialized data
		/// </summary>
		/// <param name="value">Serialized data</param>
		/// <param name="type">Type of serialized data</param>
		/// <returns></returns>
		public BinaryResourceData CreateSerialized(byte[] value, UserResourceType type) => new BinaryResourceData(CreateUserResourceType(type.Name, true), value);

		/// <summary>
		/// Creates serialized data
		/// </summary>
		/// <param name="value">Serialized data</param>
		/// <returns></returns>
		public BinaryResourceData CreateSerialized(byte[] value) {
			if (!GetSerializedTypeAndAssemblyName(value, out var assemblyName, out var typeName))
				throw new ApplicationException("Could not get serialized type name");
			string fullName = $"{typeName}, {assemblyName}";
			return new BinaryResourceData(CreateUserResourceType(fullName), value);
		}

		sealed class MyBinder : SerializationBinder {
			public class OkException : Exception {
				public string AssemblyName { get; set; }
				public string TypeName { get; set; }
			}

			public override Type BindToType(string assemblyName, string typeName) =>
				throw new OkException {
					AssemblyName = assemblyName,
					TypeName = typeName,
				};
		}

		bool GetSerializedTypeAndAssemblyName(byte[] value, out string assemblyName, out string typeName) {
			try {
				var formatter = new BinaryFormatter();
				formatter.Binder = new MyBinder();
				formatter.Deserialize(new MemoryStream(value));
			}
			catch (MyBinder.OkException ex) {
				assemblyName = ex.AssemblyName;
				typeName = ex.TypeName;
				return true;
			}
			catch {
			}

			assemblyName = null;
			typeName = null;
			return false;
		}

		/// <summary>
		/// Creates a user type. If the type already exists, the existing value is returned.
		/// </summary>
		/// <param name="fullName">Full name of type</param>
		/// <returns></returns>
		public UserResourceType CreateUserResourceType(string fullName) => CreateUserResourceType(fullName, false);

		/// <summary>
		/// Creates a user type. If the type already exists, the existing value is returned.
		/// </summary>
		/// <param name="fullName">Full name of type</param>
		/// <param name="useFullName">Use <paramref name="fullName"/> without converting it to a
		/// type in an existing assembly reference</param>
		/// <returns></returns>
		UserResourceType CreateUserResourceType(string fullName, bool useFullName) {
			if (dict.TryGetValue(fullName, out var type))
				return type;

			var newFullName = useFullName ? fullName : GetRealTypeFullName(fullName);
			type = new UserResourceType(newFullName, ResourceTypeCode.UserTypes + dict.Count);
			dict[fullName] = type;
			dict[newFullName] = type;
			return type;
		}

		string GetRealTypeFullName(string fullName) {
			var tr = TypeNameParser.ParseReflection(module, fullName, null);
			if (tr is null)
				return fullName;
			var asmRef = tr.DefinitionAssembly;
			if (asmRef is null)
				return fullName;

			var newFullName = fullName;

			string assemblyName = GetRealAssemblyName(asmRef);
			if (!string.IsNullOrEmpty(assemblyName))
				newFullName = $"{tr.ReflectionFullName}, {assemblyName}";

			return newFullName;
		}

		string GetRealAssemblyName(IAssembly asm) {
			string assemblyName = asm.FullName;
			if (!asmNameToAsmFullName.TryGetValue(assemblyName, out var newAsmName))
				asmNameToAsmFullName[assemblyName] = newAsmName = TryGetRealAssemblyName(asm);
			return newAsmName;
		}

		string TryGetRealAssemblyName(IAssembly asm) {
			var simpleName = asm.Name;
			if (simpleName == module.CorLibTypes.AssemblyRef.Name)
				return module.CorLibTypes.AssemblyRef.FullName;

			if (moduleMD is not null) {
				var asmRef = moduleMD.GetAssemblyRef(simpleName);
				if (asmRef is not null)
					return asmRef.FullName;
			}

			return GetAssemblyFullName(simpleName);
		}

		/// <summary>
		/// Converts an assembly simple name (eg. mscorlib) to the full name of the assembly,
		/// which includes the version, public key token, etc. Returns <c>null</c> if it's
		/// unknown.
		/// </summary>
		/// <param name="simpleName">Simple name of assembly</param>
		/// <returns></returns>
		protected virtual string GetAssemblyFullName(string simpleName) => null;

		/// <summary>
		/// Gets all types sorted by <see cref="UserResourceType"/>
		/// </summary>
		/// <returns></returns>
		public List<UserResourceType> GetSortedTypes() {
			var list = new List<UserResourceType>(dict.Values);
			list.Sort((a, b) => ((int)a.Code).CompareTo((int)b.Code));
			return list;
		}
	}
}




namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Resource element
	/// </summary>
	public sealed class ResourceElement {
		/// <summary>
		/// Name of resource
		/// </summary>
		public string Name { get; set; }

		/// <summary>
		/// Data of resource
		/// </summary>
		public IResourceData ResourceData { get; set; }

		/// <inheritdoc/>
		public override string ToString() => $"N: {Name}, V: {ResourceData}";
	}
}





namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Resource element set
	/// </summary>
	public sealed class ResourceElementSet {
		readonly Dictionary<string, ResourceElement> dict = new Dictionary<string, ResourceElement>(StringComparer.Ordinal);

		/// <summary>
		/// Gets the number of elements in the set
		/// </summary>
		public int Count => dict.Count;

		/// <summary>
		/// Gets all resource elements
		/// </summary>
		public IEnumerable<ResourceElement> ResourceElements => dict.Values;

		/// <summary>
		/// Adds a new resource to the set, overwriting any existing resource
		/// </summary>
		/// <param name="elem"></param>
		public void Add(ResourceElement elem) => dict[elem.Name] = elem;
	}
}





namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Thrown by <see cref="ResourceReader"/>
	/// </summary>
	[Serializable]
	public sealed class ResourceReaderException : Exception {
		/// <summary>
		/// Constructor
		/// </summary>
		public ResourceReaderException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="msg">Message</param>
		public ResourceReaderException(string msg)
			: base(msg) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		public ResourceReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Gets called to create a <see cref="IResourceData"/> from serialized data. Returns <c>null</c>
	/// if a default <see cref="IResourceData"/> instance should be created.
	/// </summary>
	/// <param name="resourceDataFactory">ResourceDataFactory</param>
	/// <param name="type">Serialized type</param>
	/// <param name="serializedData">Serialized data</param>
	/// <returns></returns>
	public delegate IResourceData CreateResourceDataDelegate(ResourceDataFactory resourceDataFactory, UserResourceType type, byte[] serializedData);

	/// <summary>
	/// Reads .NET resources
	/// </summary>
	public struct ResourceReader {
		DataReader reader;
		readonly uint baseFileOffset;
		readonly ResourceDataFactory resourceDataFactory;
		readonly CreateResourceDataDelegate createResourceDataDelegate;

		ResourceReader(ModuleDef module, ref DataReader reader, CreateResourceDataDelegate createResourceDataDelegate) {
			this.reader = reader;
			resourceDataFactory = new ResourceDataFactory(module);
			this.createResourceDataDelegate = createResourceDataDelegate;
			baseFileOffset = reader.StartOffset;
		}

		/// <summary>
		/// Returns true if it's possibly resources file data
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <returns></returns>
		public static bool CouldBeResourcesFile(DataReader reader) =>
			reader.CanRead(4U) && reader.ReadUInt32() == 0xBEEFCACE;

		/// <summary>
		/// Reads a .NET resource
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">Data of resource</param>
		/// <returns></returns>
		public static ResourceElementSet Read(ModuleDef module, DataReader reader) => Read(module, reader, null);

		/// <summary>
		/// Reads a .NET resource
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="reader">Data of resource</param>
		/// <param name="createResourceDataDelegate">Call back that gets called to create a <see cref="IResourceData"/> instance. Can be null.</param>
		/// <returns></returns>
		public static ResourceElementSet Read(ModuleDef module, DataReader reader, CreateResourceDataDelegate createResourceDataDelegate) =>
			new ResourceReader(module, ref reader, createResourceDataDelegate).Read();

		ResourceElementSet Read() {
			var resources = new ResourceElementSet();

			uint sig = reader.ReadUInt32();
			if (sig != 0xBEEFCACE)
				throw new ResourceReaderException($"Invalid resource sig: {sig:X8}");
			if (!CheckReaders())
				throw new ResourceReaderException("Invalid resource reader");
			int version = reader.ReadInt32();
			if (version != 2 && version != 1)
				throw new ResourceReaderException($"Invalid resource version: {version}");
			int numResources = reader.ReadInt32();
			if (numResources < 0)
				throw new ResourceReaderException($"Invalid number of resources: {numResources}");
			int numUserTypes = reader.ReadInt32();
			if (numUserTypes < 0)
				throw new ResourceReaderException($"Invalid number of user types: {numUserTypes}");

			var userTypes = new List<UserResourceType>();
			for (int i = 0; i < numUserTypes; i++)
				userTypes.Add(new UserResourceType(reader.ReadSerializedString(), ResourceTypeCode.UserTypes + i));
			reader.Position = (reader.Position + 7) & ~7U;

			var hashes = new int[numResources];
			for (int i = 0; i < numResources; i++)
				hashes[i] = reader.ReadInt32();
			var offsets = new int[numResources];
			for (int i = 0; i < numResources; i++)
				offsets[i] = reader.ReadInt32();

			long baseOffset = reader.Position;
			long dataBaseOffset = reader.ReadInt32();
			long nameBaseOffset = reader.Position;
			long end = reader.Length;

			var infos = new List<ResourceInfo>(numResources);

			for (int i = 0; i < numResources; i++) {
				reader.Position = (uint)(nameBaseOffset + offsets[i]);
				var name = reader.ReadSerializedString(Encoding.Unicode);
				long offset = dataBaseOffset + reader.ReadInt32();
				infos.Add(new ResourceInfo(name, offset));
			}

			infos.Sort((a, b) => a.offset.CompareTo(b.offset));
			for (int i = 0; i < infos.Count; i++) {
				var info = infos[i];
				var element = new ResourceElement();
				element.Name = info.name;
				reader.Position = (uint)info.offset;
				long nextDataOffset = i == infos.Count - 1 ? end : infos[i + 1].offset;
				int size = (int)(nextDataOffset - info.offset);
				element.ResourceData =
					version == 1 ? ReadResourceDataV1(userTypes, size) : ReadResourceDataV2(userTypes, size);
				element.ResourceData.StartOffset = baseFileOffset + (FileOffset)info.offset;
				element.ResourceData.EndOffset = baseFileOffset + (FileOffset)reader.Position;

				resources.Add(element);
			}

			return resources;
		}

		sealed class ResourceInfo {
			public string name;
			public long offset;
			public ResourceInfo(string name, long offset) {
				this.name = name;
				this.offset = offset;
			}
			public override string ToString() => $"{offset:X8} - {name}";
		}

		IResourceData ReadResourceDataV2(List<UserResourceType> userTypes, int size) {
			uint endPos = reader.Position + (uint)size;
			uint code = ReadUInt32(ref reader);
			switch ((ResourceTypeCode)code) {
			case ResourceTypeCode.Null:		return resourceDataFactory.CreateNull();
			case ResourceTypeCode.String:	return resourceDataFactory.Create(reader.ReadSerializedString());
			case ResourceTypeCode.Boolean:	return resourceDataFactory.Create(reader.ReadBoolean());
			case ResourceTypeCode.Char:		return resourceDataFactory.Create(reader.ReadChar());
			case ResourceTypeCode.Byte:		return resourceDataFactory.Create(reader.ReadByte());
			case ResourceTypeCode.SByte:	return resourceDataFactory.Create(reader.ReadSByte());
			case ResourceTypeCode.Int16:	return resourceDataFactory.Create(reader.ReadInt16());
			case ResourceTypeCode.UInt16:	return resourceDataFactory.Create(reader.ReadUInt16());
			case ResourceTypeCode.Int32:	return resourceDataFactory.Create(reader.ReadInt32());
			case ResourceTypeCode.UInt32:	return resourceDataFactory.Create(reader.ReadUInt32());
			case ResourceTypeCode.Int64:	return resourceDataFactory.Create(reader.ReadInt64());
			case ResourceTypeCode.UInt64:	return resourceDataFactory.Create(reader.ReadUInt64());
			case ResourceTypeCode.Single:	return resourceDataFactory.Create(reader.ReadSingle());
			case ResourceTypeCode.Double:	return resourceDataFactory.Create(reader.ReadDouble());
			case ResourceTypeCode.Decimal:	return resourceDataFactory.Create(reader.ReadDecimal());
			case ResourceTypeCode.DateTime: return resourceDataFactory.Create(DateTime.FromBinary(reader.ReadInt64()));
			case ResourceTypeCode.TimeSpan:	return resourceDataFactory.Create(new TimeSpan(reader.ReadInt64()));
			case ResourceTypeCode.ByteArray:return resourceDataFactory.Create(reader.ReadBytes(reader.ReadInt32()));
			case ResourceTypeCode.Stream:	return resourceDataFactory.CreateStream(reader.ReadBytes(reader.ReadInt32()));
			default:
				int userTypeIndex = (int)(code - (uint)ResourceTypeCode.UserTypes);
				if (userTypeIndex < 0 || userTypeIndex >= userTypes.Count)
					throw new ResourceReaderException($"Invalid resource data code: {code}");
				return ReadSerializedObject(endPos, userTypes[userTypeIndex]);
			}
		}

		IResourceData ReadResourceDataV1(List<UserResourceType> userTypes, int size) {
			uint endPos = reader.Position + (uint)size;
			int typeIndex = ReadInt32(ref reader);
			if (typeIndex == -1)
				return resourceDataFactory.CreateNull();
			if (typeIndex < 0 || typeIndex >= userTypes.Count)
				throw new ResourceReaderException($"Invalid resource type index: {typeIndex}");
			var type = userTypes[typeIndex];
			var commaIndex = type.Name.IndexOf(',');
			string actualName = commaIndex == -1 ? type.Name : type.Name.Remove(commaIndex);
			switch (actualName) {
			case "System.String":   return resourceDataFactory.Create(reader.ReadSerializedString());
			case "System.Int32":    return resourceDataFactory.Create(reader.ReadInt32());
			case "System.Byte":     return resourceDataFactory.Create(reader.ReadByte());
			case "System.SByte":    return resourceDataFactory.Create(reader.ReadSByte());
			case "System.Int16":    return resourceDataFactory.Create(reader.ReadInt16());
			case "System.Int64":    return resourceDataFactory.Create(reader.ReadInt64());
			case "System.UInt16":   return resourceDataFactory.Create(reader.ReadUInt16());
			case "System.UInt32":   return resourceDataFactory.Create(reader.ReadUInt32());
			case "System.UInt64":   return resourceDataFactory.Create(reader.ReadUInt64());
			case "System.Single":   return resourceDataFactory.Create(reader.ReadSingle());
			case "System.Double":   return resourceDataFactory.Create(reader.ReadDouble());
			case "System.DateTime": return resourceDataFactory.Create(new DateTime(reader.ReadInt64()));
			case "System.TimeSpan": return resourceDataFactory.Create(new TimeSpan(reader.ReadInt64()));
			case "System.Decimal":  return resourceDataFactory.Create(reader.ReadDecimal());
			default:
				return ReadSerializedObject(endPos, type);
			}
		}

		IResourceData ReadSerializedObject(uint endPos, UserResourceType type) {
			var serializedData = reader.ReadBytes((int)(endPos - reader.Position));
			var res = createResourceDataDelegate?.Invoke(resourceDataFactory, type, serializedData);
			return res ?? resourceDataFactory.CreateSerialized(serializedData, type);
		}

		static int ReadInt32(ref DataReader reader) {
			try {
				return reader.Read7BitEncodedInt32();
			}
			catch {
				throw new ResourceReaderException("Invalid encoded int32");
			}
		}

		static uint ReadUInt32(ref DataReader reader) {
			try {
				return reader.Read7BitEncodedUInt32();
			}
			catch {
				throw new ResourceReaderException("Invalid encoded int32");
			}
		}

		bool CheckReaders() {
			bool validReader = false;

			int numReaders = reader.ReadInt32();
			if (numReaders < 0)
				throw new ResourceReaderException($"Invalid number of readers: {numReaders}");
			int readersSize = reader.ReadInt32();
			if (readersSize < 0)
				throw new ResourceReaderException($"Invalid readers size: {readersSize:X8}");

			for (int i = 0; i < numReaders; i++) {
				var resourceReaderFullName = reader.ReadSerializedString();
				/*var resourceSetFullName = */reader.ReadSerializedString();
				if (Regex.IsMatch(resourceReaderFullName, @"^System\.Resources\.ResourceReader,\s*mscorlib"))
					validReader = true;
			}

			return validReader;
		}
	}
}




namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Type of resource
	/// </summary>
	public enum ResourceTypeCode {
		/// <summary>
		/// null
		/// </summary>
		Null		= 0,

		/// <summary>
		/// <see cref="string"/>
		/// </summary>
		String		= 1,

		/// <summary>
		/// <see cref="bool"/>
		/// </summary>
		Boolean		= 2,

		/// <summary>
		/// <see cref="char"/>
		/// </summary>
		Char		= 3,

		/// <summary>
		/// <see cref="byte"/>
		/// </summary>
		Byte		= 4,

		/// <summary>
		/// <see cref="sbyte"/>
		/// </summary>
		SByte		= 5,

		/// <summary>
		/// <see cref="short"/>
		/// </summary>
		Int16		= 6,

		/// <summary>
		/// <see cref="ushort"/>
		/// </summary>
		UInt16		= 7,

		/// <summary>
		/// <see cref="int"/>
		/// </summary>
		Int32		= 8,

		/// <summary>
		/// <see cref="uint"/>
		/// </summary>
		UInt32		= 9,

		/// <summary>
		/// <see cref="long"/>
		/// </summary>
		Int64		= 0x0A,

		/// <summary>
		/// <see cref="ulong"/>
		/// </summary>
		UInt64		= 0x0B,

		/// <summary>
		/// <see cref="float"/>
		/// </summary>
		Single		= 0x0C,

		/// <summary>
		/// <see cref="double"/>
		/// </summary>
		Double		= 0x0D,

		/// <summary>
		/// <see cref="decimal"/>
		/// </summary>
		Decimal		= 0x0E,

		/// <summary>
		/// <see cref="DateTime"/>
		/// </summary>
		DateTime	= 0x0F,

		/// <summary>
		/// <see cref="TimeSpan"/>
		/// </summary>
		TimeSpan	= 0x10,

		/// <summary>
		/// <see cref="byte"/> array
		/// </summary>
		ByteArray	= 0x20,

		/// <summary>
		/// <see cref="Stream"/>
		/// </summary>
		Stream		= 0x21,

		/// <summary>
		/// Start of user types
		/// </summary>
		UserTypes	= 0x40,
	}
}





namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Writes .NET resources
	/// </summary>
	public sealed class ResourceWriter {
		ModuleDef module;
		BinaryWriter writer;
		ResourceElementSet resources;
		ResourceDataFactory typeCreator;
		Dictionary<UserResourceData, UserResourceType> dataToNewType = new Dictionary<UserResourceData, UserResourceType>();

		ResourceWriter(ModuleDef module, Stream stream, ResourceElementSet resources) {
			this.module = module;
			typeCreator = new ResourceDataFactory(module);
			writer = new BinaryWriter(stream);
			this.resources = resources;
		}

		/// <summary>
		/// Write .NET resources
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="stream">Output stream</param>
		/// <param name="resources">.NET resources</param>
		public static void Write(ModuleDef module, Stream stream, ResourceElementSet resources) =>
			new ResourceWriter(module, stream, resources).Write();

		void Write() {
			InitializeUserTypes();

			writer.Write(0xBEEFCACE);
			writer.Write(1);
			WriteReaderType();
			writer.Write(2);//TODO: Support version 1
			writer.Write(resources.Count);
			writer.Write(typeCreator.Count);
			foreach (var userType in typeCreator.GetSortedTypes())
				writer.Write(userType.Name);
			int extraBytes = 8 - ((int)writer.BaseStream.Position & 7);
			if (extraBytes != 8) {
				for (int i = 0; i < extraBytes; i++)
					writer.Write((byte)'X');
			}

			var nameOffsetStream = new MemoryStream();
			var nameOffsetWriter = new BinaryWriter(nameOffsetStream, Encoding.Unicode);
			var dataStream = new MemoryStream();
			var dataWriter = new BinaryWriter(dataStream);
			var hashes = new int[resources.Count];
			var offsets = new int[resources.Count];
			var formatter = new BinaryFormatter(null, new StreamingContext(StreamingContextStates.File | StreamingContextStates.Persistence));
			int index = 0;
			foreach (var info in resources.ResourceElements) {
				offsets[index] = (int)nameOffsetWriter.BaseStream.Position;
				hashes[index] = (int)Hash(info.Name);
				index++;
				nameOffsetWriter.Write(info.Name);
				nameOffsetWriter.Write((int)dataWriter.BaseStream.Position);
				WriteData(dataWriter, info, formatter);
			}

			Array.Sort(hashes, offsets);
			foreach (var hash in hashes)
				writer.Write(hash);
			foreach (var offset in offsets)
				writer.Write(offset);
			writer.Write((int)writer.BaseStream.Position + (int)nameOffsetStream.Length + 4);
			writer.Write(nameOffsetStream.ToArray());
			writer.Write(dataStream.ToArray());
		}

		void WriteData(BinaryWriter writer, ResourceElement info, IFormatter formatter) {
			var code = GetResourceType(info.ResourceData);
			WriteUInt32(writer, (uint)code);
			info.ResourceData.WriteData(writer, formatter);
		}

		static void WriteUInt32(BinaryWriter writer, uint value) {
			while (value >= 0x80) {
				writer.Write((byte)(value | 0x80));
				value >>= 7;
			}
			writer.Write((byte)value);
		}

		ResourceTypeCode GetResourceType(IResourceData data) {
			if (data is BuiltInResourceData)
				return data.Code;

			var userData = (UserResourceData)data;
			return dataToNewType[userData].Code;
		}

		static uint Hash(string key) {
			uint val = 0x1505;
			foreach (var c in key)
				val = ((val << 5) + val) ^ (uint)c;
			return val;
		}

		void InitializeUserTypes() {
			foreach (var resource in resources.ResourceElements) {
				var data = resource.ResourceData as UserResourceData;
				if (data is null)
					continue;
				var newType = typeCreator.CreateUserResourceType(data.TypeName);
				dataToNewType[data] = newType;
			}
		}

		void WriteReaderType() {
			var memStream = new MemoryStream();
			var headerWriter = new BinaryWriter(memStream);
			var mscorlibFullName = GetMscorlibFullname();
			headerWriter.Write("System.Resources.ResourceReader, " + mscorlibFullName);
			headerWriter.Write("System.Resources.RuntimeResourceSet");
			writer.Write((int)memStream.Position);
			writer.Write(memStream.ToArray());
		}

		string GetMscorlibFullname() {
			if (module.CorLibTypes.AssemblyRef.Name == "mscorlib")
				return module.CorLibTypes.AssemblyRef.FullName;
			return "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
		}
	}
}





namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Base class of all user data
	/// </summary>
	public abstract class UserResourceData : IResourceData {
		readonly UserResourceType type;

		/// <summary>
		/// Full name including assembly of type
		/// </summary>
		public string TypeName => type.Name;

		/// <summary>
		/// User type code
		/// </summary>
		public ResourceTypeCode Code => type.Code;

		/// <inheritdoc/>
		public FileOffset StartOffset { get; set; }

		/// <inheritdoc/>
		public FileOffset EndOffset { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">User resource type</param>
		public UserResourceData(UserResourceType type) => this.type = type;

		/// <inheritdoc/>
		public abstract void WriteData(BinaryWriter writer, IFormatter formatter);
	}

	/// <summary>
	/// Binary data
	/// </summary>
	public sealed class BinaryResourceData : UserResourceData {
		byte[] data;

		/// <summary>
		/// Gets the raw data
		/// </summary>
		public byte[] Data => data;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="type">User resource type</param>
		/// <param name="data">Raw serialized data</param>
		public BinaryResourceData(UserResourceType type, byte[] data)
			: base(type) => this.data = data;

		/// <inheritdoc/>
		public override void WriteData(BinaryWriter writer, IFormatter formatter) => writer.Write(data);

		/// <inheritdoc/>
		public override string ToString() => "Binary: Length: " + data.Length.ToString();
	}
}




namespace dnlib.DotNet.Resources {
	/// <summary>
	/// User resource type
	/// </summary>
	public sealed class UserResourceType {
		readonly string name;
		readonly ResourceTypeCode code;

		/// <summary>
		/// Full name including assembly of type
		/// </summary>
		public string Name => name;

		/// <summary>
		/// User type code
		/// </summary>
		public ResourceTypeCode Code => code;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Full name including assembly of type</param>
		/// <param name="code">User type code</param>
		public UserResourceType(string name, ResourceTypeCode code) {
			this.name = name;
			this.code = code;
		}

		/// <inheritdoc/>
		public override string ToString() => $"{(int)code:X2} {name}";
	}
}





namespace dnlib.DotNet.Resources {
	/// <summary>
	/// Built-in resource data
	/// </summary>
	public sealed class BuiltInResourceData : IResourceData {
		readonly ResourceTypeCode code;
		readonly object data;

		/// <summary>
		/// Gets the data
		/// </summary>
		public object Data => data;

		/// <inheritdoc/>
		public ResourceTypeCode Code => code;

		/// <inheritdoc/>
		public FileOffset StartOffset { get; set; }

		/// <inheritdoc/>
		public FileOffset EndOffset { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="code">Type of data</param>
		/// <param name="data">Data</param>
		public BuiltInResourceData(ResourceTypeCode code, object data) {
			this.code = code;
			this.data = data;
		}

		/// <inheritdoc/>
		public void WriteData(BinaryWriter writer, IFormatter formatter) {
			switch (code) {
			case ResourceTypeCode.Null:
				break;

			case ResourceTypeCode.String:
				writer.Write((string)data);
				break;

			case ResourceTypeCode.Boolean:
				writer.Write((bool)data);
				break;

			case ResourceTypeCode.Char:
				writer.Write((ushort)(char)data);
				break;

			case ResourceTypeCode.Byte:
				writer.Write((byte)data);
				break;

			case ResourceTypeCode.SByte:
				writer.Write((sbyte)data);
				break;

			case ResourceTypeCode.Int16:
				writer.Write((short)data);
				break;

			case ResourceTypeCode.UInt16:
				writer.Write((ushort)data);
				break;

			case ResourceTypeCode.Int32:
				writer.Write((int)data);
				break;

			case ResourceTypeCode.UInt32:
				writer.Write((uint)data);
				break;

			case ResourceTypeCode.Int64:
				writer.Write((long)data);
				break;

			case ResourceTypeCode.UInt64:
				writer.Write((ulong)data);
				break;

			case ResourceTypeCode.Single:
				writer.Write((float)data);
				break;

			case ResourceTypeCode.Double:
				writer.Write((double)data);
				break;

			case ResourceTypeCode.Decimal:
				writer.Write((decimal)data);
				break;

			case ResourceTypeCode.DateTime:
				writer.Write(((DateTime)data).ToBinary());
				break;

			case ResourceTypeCode.TimeSpan:
				writer.Write(((TimeSpan)data).Ticks);
				break;

			case ResourceTypeCode.ByteArray:
			case ResourceTypeCode.Stream:
				var ary = (byte[])data;
				writer.Write(ary.Length);
				writer.Write(ary);
				break;

			default:
				throw new InvalidOperationException("Unknown resource type code");
			}
		}

		/// <inheritdoc/>
		public override string ToString() {
			switch (code) {
			case ResourceTypeCode.Null:
				return "null";

			case ResourceTypeCode.String:
			case ResourceTypeCode.Boolean:
			case ResourceTypeCode.Char:
			case ResourceTypeCode.Byte:
			case ResourceTypeCode.SByte:
			case ResourceTypeCode.Int16:
			case ResourceTypeCode.UInt16:
			case ResourceTypeCode.Int32:
			case ResourceTypeCode.UInt32:
			case ResourceTypeCode.Int64:
			case ResourceTypeCode.UInt64:
			case ResourceTypeCode.Single:
			case ResourceTypeCode.Double:
			case ResourceTypeCode.Decimal:
			case ResourceTypeCode.DateTime:
			case ResourceTypeCode.TimeSpan:
				return $"{code}: '{data}'";

			case ResourceTypeCode.ByteArray:
			case ResourceTypeCode.Stream:
				var ary = data as byte[];
				if (ary is not null)
					return $"{code}: Length: {ary.Length}";
				return $"{code}: '{data}'";

			default:
				return $"{code}: '{data}'";
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Stores a byte array
	/// </summary>
	public sealed class ByteArrayChunk : IReuseChunk {
		readonly byte[] array;
		FileOffset offset;
		RVA rva;

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Gets the data
		/// </summary>
		public byte[] Data => array;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="array">The data. It will be owned by this instance and can't be modified by
		/// other code if this instance is inserted as a <c>key</c> in a dictionary (because
		/// <see cref="GetHashCode"/> return value will be different if you modify the array). If
		/// it's never inserted as a <c>key</c> in a dictionary, then the contents can be modified,
		/// but shouldn't be resized after <see cref="SetOffset"/> has been called.</param>
		public ByteArrayChunk(byte[] array) => this.array = array ?? Array2.Empty<byte>();

		bool IReuseChunk.CanReuse(RVA origRva, uint origSize) => (uint)array.Length <= origSize;

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() => (uint)array.Length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) => writer.WriteBytes(array);

		/// <inheritdoc/>
		public override int GetHashCode() => Utils.GetHashCode(array);

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			var other = obj as ByteArrayChunk;
			return other is not null && Utils.Equals(array, other.array);
		}
	}
}




namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Checksum algorithm
	/// </summary>
	public enum ChecksumAlgorithm {
		/// <summary>
		/// SHA-1
		/// </summary>
		SHA1,

		/// <summary>
		/// SHA-256
		/// </summary>
		SHA256,

		/// <summary>
		/// SHA-384
		/// </summary>
		SHA384,

		/// <summary>
		/// SHA-512
		/// </summary>
		SHA512,
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Contains a list of <see cref="IChunk"/>s
	/// </summary>
	public class ChunkList<T> : ChunkListBase<T> where T : class, IChunk {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ChunkList() => chunks = new List<Elem>();

		/// <summary>
		/// Add a <see cref="IChunk"/>
		/// </summary>
		/// <param name="chunk">The chunk to add or <c>null</c> if none</param>
		/// <param name="alignment">Chunk alignment</param>
		public void Add(T chunk, uint alignment) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			if (chunk is not null)
				chunks.Add(new Elem(chunk, alignment));
		}

		/// <summary>
		/// Remove a <see cref="IChunk"/>
		/// </summary>
		/// <param name="chunk">The chunk to remove or <c>null</c> if none</param>
		/// <returns>Alignment of the chunk, or <c>null</c> if the chunk cannot be removed.</returns>
		public uint? Remove(T chunk) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			if (chunk is not null) {
				var chunks = this.chunks;
				for (int i = 0; i < chunks.Count; i++) {
					if (chunks[i].chunk == chunk) {
						uint alignment = chunks[i].alignment;
						chunks.RemoveAt(i);
						return alignment;
					}
				}
			}
			return null;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Base class of chunk list types
	/// </summary>
	/// <typeparam name="T">Chunk type</typeparam>
	public abstract class ChunkListBase<T> : IChunk where T : IChunk {
		/// <summary>All chunks</summary>
		protected List<Elem> chunks;
		uint length;
		uint virtualSize;
		/// <summary><c>true</c> if <see cref="SetOffset"/> has been called</summary>
		protected bool setOffsetCalled;
		FileOffset offset;
		RVA rva;

		internal bool IsEmpty => chunks.Count == 0;

		/// <summary>
		/// Helper struct
		/// </summary>
		protected readonly struct Elem {
			/// <summary>Data</summary>
			public readonly T chunk;
			/// <summary>Alignment</summary>
			public readonly uint alignment;

			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="chunk">Chunk</param>
			/// <param name="alignment">Alignment</param>
			public Elem(T chunk, uint alignment) {
				this.chunk = chunk;
				this.alignment = alignment;
			}
		}

		/// <summary>
		/// Equality comparer for <see cref="Elem"/>
		/// </summary>
		protected sealed class ElemEqualityComparer : IEqualityComparer<Elem> {
			IEqualityComparer<T> chunkComparer;

			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="chunkComparer">Compares the chunk type</param>
			public ElemEqualityComparer(IEqualityComparer<T> chunkComparer) => this.chunkComparer = chunkComparer;

			/// <inheritdoc/>
			public bool Equals(Elem x, Elem y) =>
				x.alignment == y.alignment &&
				chunkComparer.Equals(x.chunk, y.chunk);

			/// <inheritdoc/>
			public int GetHashCode(Elem obj) => (int)obj.alignment + chunkComparer.GetHashCode(obj.chunk);
		}

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <inheritdoc/>
		public virtual void SetOffset(FileOffset offset, RVA rva) {
			setOffsetCalled = true;
			this.offset = offset;
			this.rva = rva;
			length = 0;
			virtualSize = 0;
			foreach (var elem in chunks) {
				uint paddingF = (uint)offset.AlignUp(elem.alignment) - (uint)offset;
				uint paddingV = (uint)rva.AlignUp(elem.alignment) - (uint)rva;
				offset += paddingF;
				rva += paddingV;
				elem.chunk.SetOffset(offset, rva);
				if (elem.chunk.GetVirtualSize() == 0) {
					offset -= paddingF;
					rva -= paddingV;
				}
				else {
					uint chunkLenF = elem.chunk.GetFileLength();
					uint chunkLenV = elem.chunk.GetVirtualSize();
					offset += chunkLenF;
					rva += chunkLenV;
					length += paddingF + chunkLenF;
					virtualSize += paddingV + chunkLenV;
				}
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() => length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => virtualSize;

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			var offset2 = offset;
			foreach (var elem in chunks) {
				if (elem.chunk.GetVirtualSize() == 0)
					continue;
				int paddingF = (int)offset2.AlignUp(elem.alignment) - (int)offset2;
				writer.WriteZeroes(paddingF);
				elem.chunk.VerifyWriteTo(writer);
				offset2 += (uint)paddingF + elem.chunk.GetFileLength();
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Helps <see cref="CustomAttributeWriter"/> write custom attributes
	/// </summary>
	public interface ICustomAttributeWriterHelper : IWriterError, IFullNameFactoryHelper {
	}

	/// <summary>
	/// Writes <see cref="CustomAttribute"/>s
	/// </summary>
	public struct CustomAttributeWriter : IDisposable {
		readonly ICustomAttributeWriterHelper helper;
		RecursionCounter recursionCounter;
		readonly MemoryStream outStream;
		readonly DataWriter writer;
		readonly bool disposeStream;
		GenericArguments genericArguments;

		/// <summary>
		/// Writes a custom attribute
		/// </summary>
		/// <param name="helper">Helper class</param>
		/// <param name="ca">The custom attribute</param>
		/// <returns>Custom attribute blob</returns>
		public static byte[] Write(ICustomAttributeWriterHelper helper, CustomAttribute ca) {
			using (var writer = new CustomAttributeWriter(helper)) {
				writer.Write(ca);
				return writer.GetResult();
			}
		}

		internal static byte[] Write(ICustomAttributeWriterHelper helper, CustomAttribute ca, DataWriterContext context) {
			using (var writer = new CustomAttributeWriter(helper, context)) {
				writer.Write(ca);
				return writer.GetResult();
			}
		}

		/// <summary>
		/// Writes custom attribute named arguments
		/// </summary>
		/// <param name="helper">Helper class</param>
		/// <param name="namedArgs">Named arguments</param>
		/// <returns>The named args blob</returns>
		internal static byte[] Write(ICustomAttributeWriterHelper helper, IList<CANamedArgument> namedArgs) {
			using (var writer = new CustomAttributeWriter(helper)) {
				writer.Write(namedArgs);
				return writer.GetResult();
			}
		}

		internal static byte[] Write(ICustomAttributeWriterHelper helper, IList<CANamedArgument> namedArgs, DataWriterContext context) {
			using (var writer = new CustomAttributeWriter(helper, context)) {
				writer.Write(namedArgs);
				return writer.GetResult();
			}
		}

		CustomAttributeWriter(ICustomAttributeWriterHelper helper) {
			this.helper = helper;
			recursionCounter = new RecursionCounter();
			outStream = new MemoryStream();
			writer = new DataWriter(outStream);
			genericArguments = null;
			disposeStream = true;
		}

		CustomAttributeWriter(ICustomAttributeWriterHelper helper, DataWriterContext context) {
			this.helper = helper;
			recursionCounter = new RecursionCounter();
			outStream = context.OutStream;
			writer = context.Writer;
			genericArguments = null;
			disposeStream = false;
			outStream.SetLength(0);
			outStream.Position = 0;
		}

		byte[] GetResult() => outStream.ToArray();

		void Write(CustomAttribute ca) {
			if (ca is null) {
				helper.Error("The custom attribute is null");
				return;
			}

			// Check whether it's raw first. If it is, we don't care whether the ctor is
			// invalid. Just use the raw data.
			if (ca.IsRawBlob) {
				if ((ca.ConstructorArguments is not null && ca.ConstructorArguments.Count > 0) || (ca.NamedArguments is not null && ca.NamedArguments.Count > 0))
					helper.Error("Raw custom attribute contains arguments and/or named arguments");
				writer.WriteBytes(ca.RawData);
				return;
			}

			if (ca.Constructor is null) {
				helper.Error("Custom attribute ctor is null");
				return;
			}

			var methodSig = GetMethodSig(ca.Constructor);
			if (methodSig is null) {
				helper.Error("Custom attribute ctor's method signature is invalid");
				return;
			}

			if (ca.ConstructorArguments.Count != methodSig.Params.Count)
				helper.Error("Custom attribute arguments count != method sig arguments count");
			if (methodSig.ParamsAfterSentinel is not null && methodSig.ParamsAfterSentinel.Count > 0)
				helper.Error("Custom attribute ctor has parameters after the sentinel");
			if (ca.NamedArguments.Count > ushort.MaxValue)
				helper.Error("Custom attribute has too many named arguments");

			if (ca.Constructor is MemberRef mrCtor && mrCtor.Class is TypeSpec owner && owner.TypeSig is GenericInstSig gis) {
				genericArguments = new GenericArguments();
				genericArguments.PushTypeArgs(gis.GenericArguments);
			}

			writer.WriteUInt16((ushort)1);

			int numArgs = Math.Min(methodSig.Params.Count, ca.ConstructorArguments.Count);
			for (int i = 0; i < numArgs; i++)
				WriteValue(FixTypeSig(methodSig.Params[i]), ca.ConstructorArguments[i]);

			int numNamedArgs = Math.Min((int)ushort.MaxValue, ca.NamedArguments.Count);
			writer.WriteUInt16((ushort)numNamedArgs);
			for (int i = 0; i < numNamedArgs; i++)
				Write(ca.NamedArguments[i]);
		}

		void Write(IList<CANamedArgument> namedArgs) {
			if (namedArgs is null || namedArgs.Count > 0x1FFFFFFF) {
				helper.Error("Too many custom attribute named arguments");
				namedArgs = Array2.Empty<CANamedArgument>();
			}
			writer.WriteCompressedUInt32((uint)namedArgs.Count);
			for (int i = 0; i < namedArgs.Count; i++)
				Write(namedArgs[i]);
		}

		TypeSig FixTypeSig(TypeSig type) => SubstituteGenericParameter(type.RemoveModifiers()).RemoveModifiers();

		TypeSig SubstituteGenericParameter(TypeSig type) {
			if (genericArguments is null)
				return type;
			return genericArguments.Resolve(type);
		}

		void WriteValue(TypeSig argType, CAArgument value) {
			if (argType is null || value.Type is null) {
				helper.Error("Custom attribute argument type is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			if (argType is SZArraySig arrayType) {
				var argsArray = value.Value as IList<CAArgument>;
				if (argsArray is null && value.Value is not null)
					helper.Error("CAArgument.Value is not null or an array");
				WriteArrayValue(arrayType, argsArray);
			}
			else
				WriteElem(argType, value);

			recursionCounter.Decrement();
		}

		void WriteArrayValue(SZArraySig arrayType, IList<CAArgument> args) {
			if (arrayType is null) {
				helper.Error("Custom attribute: Array type is null");
				return;
			}

			if (args is null)
				writer.WriteUInt32(uint.MaxValue);
			else {
				writer.WriteUInt32((uint)args.Count);
				var arrayElementType = FixTypeSig(arrayType.Next);
				for (int i = 0; i < args.Count; i++)
					WriteValue(arrayElementType, args[i]);
			}
		}

		bool VerifyTypeAndValue(CAArgument value, ElementType etype) {
			if (!VerifyType(value.Type, etype)) {
				helper.Error("Custom attribute arg type != value.Type");
				return false;
			}
			if (!VerifyValue(value.Value, etype)) {
				helper.Error("Custom attribute value.Value's type != value.Type");
				return false;
			}
			return true;
		}

		bool VerifyTypeAndValue(CAArgument value, ElementType etype, Type valueType) {
			if (!VerifyType(value.Type, etype)) {
				helper.Error("Custom attribute arg type != value.Type");
				return false;
			}
			return value.Value is null || value.Value.GetType() == valueType;
		}

		static bool VerifyType(TypeSig type, ElementType etype) {
			type = type.RemoveModifiers();
			// Assume it's an enum if it's a ValueType
			return type is not null && (etype == type.ElementType || type.ElementType == ElementType.ValueType);
		}

		static bool VerifyValue(object o, ElementType etype) {
			if (o is null)
				return false;

			return Type.GetTypeCode(o.GetType()) switch {
				TypeCode.Boolean => etype == ElementType.Boolean,
				TypeCode.Char => etype == ElementType.Char,
				TypeCode.SByte => etype == ElementType.I1,
				TypeCode.Byte => etype == ElementType.U1,
				TypeCode.Int16 => etype == ElementType.I2,
				TypeCode.UInt16 => etype == ElementType.U2,
				TypeCode.Int32 => etype == ElementType.I4,
				TypeCode.UInt32 => etype == ElementType.U4,
				TypeCode.Int64 => etype == ElementType.I8,
				TypeCode.UInt64 => etype == ElementType.U8,
				TypeCode.Single => etype == ElementType.R4,
				TypeCode.Double => etype == ElementType.R8,
				_ => false,
			};
		}

		static ulong ToUInt64(object o) {
			ToUInt64(o, out ulong result);
			return result;
		}

		static bool ToUInt64(object o, out ulong result) {
			if (o is null) {
				result = 0;
				return false;
			}

			switch (Type.GetTypeCode(o.GetType())) {
			case TypeCode.Boolean:
				result = (bool)o ? 1UL : 0UL;
				return true;

			case TypeCode.Char:
				result = (ushort)(char)o;
				return true;

			case TypeCode.SByte:
				result = (ulong)(sbyte)o;
				return true;

			case TypeCode.Byte:
				result = (byte)o;
				return true;

			case TypeCode.Int16:
				result = (ulong)(short)o;
				return true;

			case TypeCode.UInt16:
				result = (ushort)o;
				return true;

			case TypeCode.Int32:
				result = (ulong)(int)o;
				return true;

			case TypeCode.UInt32:
				result = (uint)o;
				return true;

			case TypeCode.Int64:
				result = (ulong)(long)o;
				return true;

			case TypeCode.UInt64:
				result = (ulong)o;
				return true;

			case TypeCode.Single:
				result = (ulong)(float)o;
				return true;

			case TypeCode.Double:
				result = (ulong)(double)o;
				return true;
			}

			result = 0;
			return false;
		}

		static double ToDouble(object o) {
			ToDouble(o, out double result);
			return result;
		}

		static bool ToDouble(object o, out double result) {
			if (o is null) {
				result = double.NaN;
				return false;
			}

			switch (Type.GetTypeCode(o.GetType())) {
			case TypeCode.Boolean:
				result = (bool)o ? 1 : 0;
				return true;

			case TypeCode.Char:
				result = (ushort)(char)o;
				return true;

			case TypeCode.SByte:
				result = (sbyte)o;
				return true;

			case TypeCode.Byte:
				result = (byte)o;
				return true;

			case TypeCode.Int16:
				result = (short)o;
				return true;

			case TypeCode.UInt16:
				result = (ushort)o;
				return true;

			case TypeCode.Int32:
				result = (int)o;
				return true;

			case TypeCode.UInt32:
				result = (uint)o;
				return true;

			case TypeCode.Int64:
				result = (long)o;
				return true;

			case TypeCode.UInt64:
				result = (ulong)o;
				return true;

			case TypeCode.Single:
				result = (float)o;
				return true;

			case TypeCode.Double:
				result = (double)o;
				return true;
			}

			result = double.NaN;
			return false;
		}

		/// <summary>
		/// Write a value
		/// </summary>
		/// <param name="argType">The ctor arg type, field type, or property type</param>
		/// <param name="value">The value to write</param>
		void WriteElem(TypeSig argType, CAArgument value) {
			if (argType is null) {
				helper.Error("Custom attribute: Arg type is null");
				argType = value.Type;
				if (argType is null)
					return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			TypeSig underlyingType;
			ITypeDefOrRef tdr;
			switch (argType.ElementType) {
			case ElementType.Boolean:
				if (!VerifyTypeAndValue(value, ElementType.Boolean))
					writer.WriteBoolean(ToUInt64(value.Value) != 0);
				else
					writer.WriteBoolean((bool)value.Value);
				break;

			case ElementType.Char:
				if (!VerifyTypeAndValue(value, ElementType.Char))
					writer.WriteUInt16((ushort)ToUInt64(value.Value));
				else
					writer.WriteUInt16((ushort)(char)value.Value);
				break;

			case ElementType.I1:
				if (!VerifyTypeAndValue(value, ElementType.I1))
					writer.WriteSByte((sbyte)ToUInt64(value.Value));
				else
					writer.WriteSByte((sbyte)value.Value);
				break;

			case ElementType.U1:
				if (!VerifyTypeAndValue(value, ElementType.U1))
					writer.WriteByte((byte)ToUInt64(value.Value));
				else
					writer.WriteByte((byte)value.Value);
				break;

			case ElementType.I2:
				if (!VerifyTypeAndValue(value, ElementType.I2))
					writer.WriteInt16((short)ToUInt64(value.Value));
				else
					writer.WriteInt16((short)value.Value);
				break;

			case ElementType.U2:
				if (!VerifyTypeAndValue(value, ElementType.U2))
					writer.WriteUInt16((ushort)ToUInt64(value.Value));
				else
					writer.WriteUInt16((ushort)value.Value);
				break;

			case ElementType.I4:
				if (!VerifyTypeAndValue(value, ElementType.I4))
					writer.WriteInt32((int)ToUInt64(value.Value));
				else
					writer.WriteInt32((int)value.Value);
				break;

			case ElementType.U4:
				if (!VerifyTypeAndValue(value, ElementType.U4))
					writer.WriteUInt32((uint)ToUInt64(value.Value));
				else
					writer.WriteUInt32((uint)value.Value);
				break;

			case ElementType.I8:
				if (!VerifyTypeAndValue(value, ElementType.I8))
					writer.WriteInt64((long)ToUInt64(value.Value));
				else
					writer.WriteInt64((long)value.Value);
				break;

			case ElementType.U8:
				if (!VerifyTypeAndValue(value, ElementType.U8))
					writer.WriteUInt64(ToUInt64(value.Value));
				else
					writer.WriteUInt64((ulong)value.Value);
				break;

			case ElementType.R4:
				if (!VerifyTypeAndValue(value, ElementType.R4))
					writer.WriteSingle((float)ToDouble(value.Value));
				else
					writer.WriteSingle((float)value.Value);
				break;

			case ElementType.R8:
				if (!VerifyTypeAndValue(value, ElementType.R8))
					writer.WriteDouble(ToDouble(value.Value));
				else
					writer.WriteDouble((double)value.Value);
				break;

			case ElementType.String:
				if (VerifyTypeAndValue(value, ElementType.String, typeof(UTF8String)))
					WriteUTF8String((UTF8String)value.Value);
				else if (VerifyTypeAndValue(value, ElementType.String, typeof(string)))
					WriteUTF8String((string)value.Value);
				else
					WriteUTF8String(UTF8String.Empty);
				break;

			case ElementType.ValueType:
				tdr = ((TypeDefOrRefSig)argType).TypeDefOrRef;
				underlyingType = GetEnumUnderlyingType(argType);
				if (underlyingType is not null)
					WriteElem(underlyingType, value);
				else if (tdr is TypeRef && TryWriteEnumUnderlyingTypeValue(value.Value)) {
					// No error. Assume it's an enum that couldn't be resolved.
				}
				else
					helper.Error("Custom attribute value is not an enum");
				break;

			case ElementType.Class:
				tdr = ((TypeDefOrRefSig)argType).TypeDefOrRef;
				if (CheckCorLibType(argType, "Type")) {
					if (CheckCorLibType(value.Type, "Type")) {
						if (value.Value is TypeSig ts)
							WriteType(ts);
						else if (value.Value is null)
							WriteUTF8String(null);
						else {
							helper.Error("Custom attribute value is not a type");
							WriteUTF8String(UTF8String.Empty);
						}
					}
					else {
						helper.Error("Custom attribute value type is not System.Type");
						WriteUTF8String(UTF8String.Empty);
					}
					break;
				}
				else if (tdr is TypeRef && TryWriteEnumUnderlyingTypeValue(value.Value)) {
					// No error. Assume it's an enum that couldn't be resolved.
					break;
				}
				goto default;

			case ElementType.SZArray:
				WriteValue(argType, value);
				break;

			case ElementType.Object:
				WriteFieldOrPropType(value.Type);
				WriteElem(value.Type, value);
				break;

			case ElementType.End:
			case ElementType.Void:
			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Var:
			case ElementType.Array:
			case ElementType.GenericInst:
			case ElementType.TypedByRef:
			case ElementType.ValueArray:
			case ElementType.I:
			case ElementType.U:
			case ElementType.R:
			case ElementType.FnPtr:
			case ElementType.MVar:
			case ElementType.CModReqd:
			case ElementType.CModOpt:
			case ElementType.Internal:
			case ElementType.Module:
			case ElementType.Sentinel:
			case ElementType.Pinned:
			default:
				helper.Error("Invalid or unsupported element type in custom attribute");
				break;
			}

			recursionCounter.Decrement();
		}

		bool TryWriteEnumUnderlyingTypeValue(object o) {
			if (o is null)
				return false;
			switch (Type.GetTypeCode(o.GetType())) {
			case TypeCode.Boolean:	writer.WriteBoolean((bool)o); break;
			case TypeCode.Char:		writer.WriteUInt16((ushort)(char)o); break;
			case TypeCode.SByte:	writer.WriteSByte((sbyte)o); break;
			case TypeCode.Byte:		writer.WriteByte((byte)o); break;
			case TypeCode.Int16:	writer.WriteInt16((short)o); break;
			case TypeCode.UInt16:	writer.WriteUInt16((ushort)o); break;
			case TypeCode.Int32:	writer.WriteInt32((int)o); break;
			case TypeCode.UInt32:	writer.WriteUInt32((uint)o); break;
			case TypeCode.Int64:	writer.WriteInt64((long)o); break;
			case TypeCode.UInt64:	writer.WriteUInt64((ulong)o); break;
			default: return false;
			}
			return true;
		}

		/// <summary>
		/// Gets the enum's underlying type
		/// </summary>
		/// <param name="type">An enum type</param>
		/// <returns>The underlying type or <c>null</c> if we couldn't resolve the type ref</returns>
		static TypeSig GetEnumUnderlyingType(TypeSig type) {
			var td = GetEnumTypeDef(type);
			if (td is null)
				return null;
			return td.GetEnumUnderlyingType().RemoveModifiers();
		}

		static TypeDef GetEnumTypeDef(TypeSig type) {
			if (type is null)
				return null;
			var td = GetTypeDef(type);
			if (td is null)
				return null;
			if (!td.IsEnum)
				return null;
			return td;
		}

		/// <summary>
		/// Converts <paramref name="type"/> to a <see cref="TypeDef"/>, possibly resolving
		/// a <see cref="TypeRef"/>
		/// </summary>
		/// <param name="type">The type</param>
		/// <returns>A <see cref="TypeDef"/> or <c>null</c> if we couldn't resolve the
		/// <see cref="TypeRef"/> or if <paramref name="type"/> is a type spec</returns>
		static TypeDef GetTypeDef(TypeSig type) {
			if (type is TypeDefOrRefSig tdr) {
				var td = tdr.TypeDef;
				if (td is not null)
					return td;

				var tr = tdr.TypeRef;
				if (tr is not null)
					return tr.Resolve();
			}

			return null;
		}

		void Write(CANamedArgument namedArg) {
			if (namedArg is null) {
				helper.Error("Custom attribute named arg is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			if (namedArg.IsProperty)
				writer.WriteByte((byte)SerializationType.Property);
			else
				writer.WriteByte((byte)SerializationType.Field);

			WriteFieldOrPropType(namedArg.Type);
			WriteUTF8String(namedArg.Name);
			WriteValue(namedArg.Type, namedArg.Argument);

			recursionCounter.Decrement();
		}

		void WriteFieldOrPropType(TypeSig type) {
			type = type.RemoveModifiers();
			if (type is null) {
				helper.Error("Custom attribute: Field/property type is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			ITypeDefOrRef tdr;
			switch (type.ElementType) {
			case ElementType.Boolean:	writer.WriteByte((byte)SerializationType.Boolean); break;
			case ElementType.Char:		writer.WriteByte((byte)SerializationType.Char); break;
			case ElementType.I1:		writer.WriteByte((byte)SerializationType.I1); break;
			case ElementType.U1:		writer.WriteByte((byte)SerializationType.U1); break;
			case ElementType.I2:		writer.WriteByte((byte)SerializationType.I2); break;
			case ElementType.U2:		writer.WriteByte((byte)SerializationType.U2); break;
			case ElementType.I4:		writer.WriteByte((byte)SerializationType.I4); break;
			case ElementType.U4:		writer.WriteByte((byte)SerializationType.U4); break;
			case ElementType.I8:		writer.WriteByte((byte)SerializationType.I8); break;
			case ElementType.U8:		writer.WriteByte((byte)SerializationType.U8); break;
			case ElementType.R4:		writer.WriteByte((byte)SerializationType.R4); break;
			case ElementType.R8:		writer.WriteByte((byte)SerializationType.R8); break;
			case ElementType.String:	writer.WriteByte((byte)SerializationType.String); break;
			case ElementType.Object:	writer.WriteByte((byte)SerializationType.TaggedObject); break;

			case ElementType.SZArray:
				writer.WriteByte((byte)SerializationType.SZArray);
				WriteFieldOrPropType(type.Next);
				break;

			case ElementType.Class:
				tdr = ((TypeDefOrRefSig)type).TypeDefOrRef;
				if (CheckCorLibType(type, "Type"))
					writer.WriteByte((byte)SerializationType.Type);
				else if (tdr is TypeRef) {
					// Could be an enum TypeRef that couldn't be resolved, so the code
					// assumed it's a class and created a ClassSig.
					writer.WriteByte((byte)SerializationType.Enum);
					WriteType(tdr);
				}
				else
					goto default;
				break;

			case ElementType.ValueType:
				tdr = ((TypeDefOrRefSig)type).TypeDefOrRef;
				var enumType = GetEnumTypeDef(type);
				// If TypeRef => assume it's an enum that couldn't be resolved
				if (enumType is not null || tdr is TypeRef) {
					writer.WriteByte((byte)SerializationType.Enum);
					WriteType(tdr);
				}
				else {
					helper.Error("Custom attribute type doesn't seem to be an enum.");
					writer.WriteByte((byte)SerializationType.Enum);
					WriteType(tdr);
				}
				break;

			default:
				helper.Error("Custom attribute: Invalid type");
				writer.WriteByte((byte)0xFF);
				break;
			}

			recursionCounter.Decrement();
		}

		void WriteType(IType type) {
			if (type is null) {
				helper.Error("Custom attribute: Type is null");
				WriteUTF8String(UTF8String.Empty);
			}
			else
				WriteUTF8String(FullNameFactory.AssemblyQualifiedName(type, helper));
		}

		static bool CheckCorLibType(TypeSig ts, string name) {
			var tdrs = ts as TypeDefOrRefSig;
			if (tdrs is null)
				return false;
			return CheckCorLibType(tdrs.TypeDefOrRef, name);
		}

		static bool CheckCorLibType(ITypeDefOrRef tdr, string name) {
			if (tdr is null)
				return false;
			if (!tdr.DefinitionAssembly.IsCorLib())
				return false;
			if (tdr is TypeSpec)
				return false;
			return tdr.TypeName == name && tdr.Namespace == "System";
		}

		static MethodSig GetMethodSig(ICustomAttributeType ctor) => ctor?.MethodSig;

		void WriteUTF8String(UTF8String s) {
			if (s is null || s.Data is null)
				writer.WriteByte((byte)0xFF);
			else {
				writer.WriteCompressedUInt32((uint)s.Data.Length);
				writer.WriteBytes(s.Data);
			}
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (!disposeStream)
				return;
			if (outStream is not null)
				outStream.Dispose();
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// A <see cref="DataReader"/> chunk
	/// </summary>
	public class DataReaderChunk : IChunk {
		FileOffset offset;
		RVA rva;
		DataReader data;
		readonly uint virtualSize;
		bool setOffsetCalled;

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The data</param>
		public DataReaderChunk(DataReader data)
			: this(ref data) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The data</param>
		/// <param name="virtualSize">Virtual size of <paramref name="data"/></param>
		public DataReaderChunk(DataReader data, uint virtualSize)
			: this(ref data, virtualSize) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The data</param>
		internal DataReaderChunk(ref DataReader data)
			: this(ref data, (uint)data.Length) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The data</param>
		/// <param name="virtualSize">Virtual size of <paramref name="data"/></param>
		internal DataReaderChunk(ref DataReader data, uint virtualSize) {
			this.data = data;
			this.virtualSize = virtualSize;
		}

		/// <summary>
		/// Gets the data reader
		/// </summary>
		public DataReader CreateReader() => data;

		/// <summary>
		/// Replaces the old data with new data. The new data must be the same size as the old data if
		/// <see cref="SetOffset(FileOffset, RVA)"/> has been called. That method gets called after
		/// event <see cref="ModuleWriterEvent.BeginCalculateRvasAndFileOffsets"/>
		/// </summary>
		/// <param name="newData"></param>
		public void SetData(DataReader newData) {
			if (setOffsetCalled && newData.Length != data.Length)
				throw new InvalidOperationException("New data must be the same size as the old data after SetOffset() has been called");
			data = newData;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
			setOffsetCalled = true;
		}

		/// <inheritdoc/>
		public uint GetFileLength() => (uint)data.Length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => virtualSize;

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			data.Position = 0;
			data.CopyTo(writer);
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Copies existing data to a new metadata heap
	/// </summary>
	public sealed class DataReaderHeap : HeapBase {
		/// <summary>
		/// Gets the name of the heap
		/// </summary>
		public override string Name { get; }

		internal DotNetStream OptionalOriginalStream { get; }

		readonly DataReader heapReader;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">The stream whose data will be copied to the new metadata file</param>
		public DataReaderHeap(DotNetStream stream) {
			OptionalOriginalStream = stream ?? throw new ArgumentNullException(nameof(stream));
			heapReader = stream.CreateReader();
			Name = stream.Name;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Heap name</param>
		/// <param name="heapReader">Heap content</param>
		public DataReaderHeap(string name, DataReader heapReader) {
			this.heapReader = heapReader;
			this.heapReader.Position = 0;
			Name = name ?? throw new ArgumentNullException(nameof(name));
		}

		/// <inheritdoc/>
		public override uint GetRawLength() => heapReader.Length;

		/// <inheritdoc/>
		protected override void WriteToImpl(DataWriter writer) => heapReader.CopyTo(writer);
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes data
	/// </summary>
	public sealed class DataWriter {
		readonly Stream stream;
		readonly byte[] buffer;
		const int BUFFER_LEN = 8;

		internal Stream InternalStream => stream;

		/// <summary>
		/// Gets/sets the position
		/// </summary>
		public long Position {
			get => stream.Position;
			set => stream.Position = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Destination stream</param>
		public DataWriter(Stream stream) {
			if (stream is null)
				ThrowArgumentNullException(nameof(stream));
			this.stream = stream;
			buffer = new byte[BUFFER_LEN];
		}

		static void ThrowArgumentNullException(string paramName) => throw new ArgumentNullException(paramName);
		static void ThrowArgumentOutOfRangeException(string message) => throw new ArgumentOutOfRangeException(message);

		/// <summary>
		/// Writes a <see cref="bool"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteBoolean(bool value) => stream.WriteByte(value ? (byte)1 : (byte)0);

		/// <summary>
		/// Writes a <see cref="sbyte"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteSByte(sbyte value) => stream.WriteByte((byte)value);

		/// <summary>
		/// Writes a <see cref="byte"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteByte(byte value) => stream.WriteByte(value);

		/// <summary>
		/// Writes a <see cref="short"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteInt16(short value) {
			var buffer = this.buffer;
			buffer[0] = (byte)value;
			buffer[1] = (byte)(value >> 8);
			stream.Write(buffer, 0, 2);
		}

		/// <summary>
		/// Writes a <see cref="ushort"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteUInt16(ushort value) {
			var buffer = this.buffer;
			buffer[0] = (byte)value;
			buffer[1] = (byte)(value >> 8);
			stream.Write(buffer, 0, 2);
		}

		/// <summary>
		/// Writes a <see cref="int"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteInt32(int value) {
			var buffer = this.buffer;
			buffer[0] = (byte)value;
			buffer[1] = (byte)(value >> 8);
			buffer[2] = (byte)(value >> 16);
			buffer[3] = (byte)(value >> 24);
			stream.Write(buffer, 0, 4);
		}

		/// <summary>
		/// Writes a <see cref="uint"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteUInt32(uint value) {
			var buffer = this.buffer;
			buffer[0] = (byte)value;
			buffer[1] = (byte)(value >> 8);
			buffer[2] = (byte)(value >> 16);
			buffer[3] = (byte)(value >> 24);
			stream.Write(buffer, 0, 4);
		}

		/// <summary>
		/// Writes a <see cref="long"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteInt64(long value) {
			var buffer = this.buffer;
			buffer[0] = (byte)value;
			buffer[1] = (byte)(value >> 8);
			buffer[2] = (byte)(value >> 16);
			buffer[3] = (byte)(value >> 24);
			buffer[4] = (byte)(value >> 32);
			buffer[5] = (byte)(value >> 40);
			buffer[6] = (byte)(value >> 48);
			buffer[7] = (byte)(value >> 56);
			stream.Write(buffer, 0, 8);
		}

		/// <summary>
		/// Writes a <see cref="ulong"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteUInt64(ulong value) {
			var buffer = this.buffer;
			buffer[0] = (byte)value;
			buffer[1] = (byte)(value >> 8);
			buffer[2] = (byte)(value >> 16);
			buffer[3] = (byte)(value >> 24);
			buffer[4] = (byte)(value >> 32);
			buffer[5] = (byte)(value >> 40);
			buffer[6] = (byte)(value >> 48);
			buffer[7] = (byte)(value >> 56);
			stream.Write(buffer, 0, 8);
		}

		/// <summary>
		/// Writes a <see cref="float"/>
		/// </summary>
		/// <param name="value">Value</param>
		public unsafe void WriteSingle(float value) {
			uint tmp = *(uint*)&value;
			var buffer = this.buffer;
			buffer[0] = (byte)tmp;
			buffer[1] = (byte)(tmp >> 8);
			buffer[2] = (byte)(tmp >> 16);
			buffer[3] = (byte)(tmp >> 24);
			stream.Write(buffer, 0, 4);
		}

		/// <summary>
		/// Writes a <see cref="double"/>
		/// </summary>
		/// <param name="value">Value</param>
		public unsafe void WriteDouble(double value) {
			ulong tmp = *(ulong*)&value;
			var buffer = this.buffer;
			buffer[0] = (byte)tmp;
			buffer[1] = (byte)(tmp >> 8);
			buffer[2] = (byte)(tmp >> 16);
			buffer[3] = (byte)(tmp >> 24);
			buffer[4] = (byte)(tmp >> 32);
			buffer[5] = (byte)(tmp >> 40);
			buffer[6] = (byte)(tmp >> 48);
			buffer[7] = (byte)(tmp >> 56);
			stream.Write(buffer, 0, 8);
		}

		/// <summary>
		/// Writes bytes
		/// </summary>
		/// <param name="source">Bytes to write</param>
		public void WriteBytes(byte[] source) => stream.Write(source, 0, source.Length);

		/// <summary>
		/// Writes bytes
		/// </summary>
		/// <param name="source">Bytes to write</param>
		/// <param name="index">Index to start copying from</param>
		/// <param name="length">Number of bytes to copy</param>
		public void WriteBytes(byte[] source, int index, int length) => stream.Write(source, index, length);

		/// <summary>
		/// Writes a compressed <see cref="uint"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteCompressedUInt32(uint value) {
			var stream = this.stream;
			if (value <= 0x7F)
				stream.WriteByte((byte)value);
			else if (value <= 0x3FFF) {
				stream.WriteByte((byte)((value >> 8) | 0x80));
				stream.WriteByte((byte)value);
			}
			else if (value <= 0x1FFFFFFF) {
				var buffer = this.buffer;
				buffer[0] = (byte)((value >> 24) | 0xC0);
				buffer[1] = (byte)(value >> 16);
				buffer[2] = (byte)(value >> 8);
				buffer[3] = (byte)value;
				stream.Write(buffer, 0, 4);
			}
			else
				ThrowArgumentOutOfRangeException("UInt32 value can't be compressed");
		}

		/// <summary>
		/// Writes a compressed <see cref="int"/>
		/// </summary>
		/// <param name="value"></param>
		public void WriteCompressedInt32(int value) {
			var stream = this.stream;
			// This is almost identical to compressing a UInt32, except that we first
			// recode value so the sign bit is in bit 0. Then we compress it the same
			// way a UInt32 is compressed.
			uint sign = (uint)value >> 31;
			if (-0x40 <= value && value <= 0x3F) {
				uint v = (uint)((value & 0x3F) << 1) | sign;
				stream.WriteByte((byte)v);
			}
			else if (-0x2000 <= value && value <= 0x1FFF) {
				uint v = ((uint)(value & 0x1FFF) << 1) | sign;
				stream.WriteByte((byte)((v >> 8) | 0x80));
				stream.WriteByte((byte)v);
			}
			else if (-0x10000000 <= value && value <= 0x0FFFFFFF) {
				uint v = ((uint)(value & 0x0FFFFFFF) << 1) | sign;
				var buffer = this.buffer;
				buffer[0] = (byte)((v >> 24) | 0xC0);
				buffer[1] = (byte)(v >> 16);
				buffer[2] = (byte)(v >> 8);
				buffer[3] = (byte)v;
				stream.Write(buffer, 0, 4);
			}
			else
				ThrowArgumentOutOfRangeException("Int32 value can't be compressed");
		}

		/// <summary>
		/// Gets the size of a compressed <see cref="uint"/>, see <see cref="WriteCompressedUInt32(uint)"/>
		/// </summary>
		/// <param name="value">Value</param>
		/// <returns></returns>
		public static int GetCompressedUInt32Length(uint value) {
			if (value <= 0x7F)
				return 1;
			if (value <= 0x3FFF)
				return 2;
			if (value <= 0x1FFFFFFF)
				return 4;
			ThrowArgumentOutOfRangeException("UInt32 value can't be compressed");
			return 0;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Debug directory entry
	/// </summary>
	public sealed class DebugDirectoryEntry {
		/// <summary>
		/// Gets the header
		/// </summary>
		public IMAGE_DEBUG_DIRECTORY DebugDirectory;

		/// <summary>
		/// Gets the data
		/// </summary>
		public readonly IChunk Chunk;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="chunk">Data</param>
		public DebugDirectoryEntry(IChunk chunk) => Chunk = chunk;
	}

	/// <summary>
	/// Debug directory chunk
	/// </summary>
	public sealed class DebugDirectory : IReuseChunk {
		/// <summary>Default debug directory alignment</summary>
		public const uint DEFAULT_DEBUGDIRECTORY_ALIGNMENT = 4;
		internal const int HEADER_SIZE = 28;

		internal int Count => entries.Count;

		FileOffset offset;
		RVA rva;
		uint length;
		readonly List<DebugDirectoryEntry> entries;
		bool isReadonly;

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Constructor
		/// </summary>
		public DebugDirectory() => entries = new List<DebugDirectoryEntry>();

		/// <summary>
		/// Adds data
		/// </summary>
		/// <param name="data">Data</param>
		/// <returns></returns>
		public DebugDirectoryEntry Add(byte[] data) => Add(new ByteArrayChunk(data));

		/// <summary>
		/// Adds data
		/// </summary>
		/// <param name="chunk">Data</param>
		/// <returns></returns>
		public DebugDirectoryEntry Add(IChunk chunk) {
			if (isReadonly)
				throw new InvalidOperationException("Can't add a new DebugDirectory entry when the DebugDirectory is read-only!");
			var entry = new DebugDirectoryEntry(chunk);
			entries.Add(entry);
			return entry;
		}

		/// <summary>
		/// Adds data
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="type">Debug type</param>
		/// <param name="majorVersion">Major version</param>
		/// <param name="minorVersion">Minor version</param>
		/// <param name="timeDateStamp">Timestamp</param>
		/// <returns></returns>
		public DebugDirectoryEntry Add(byte[] data, ImageDebugType type, ushort majorVersion, ushort minorVersion, uint timeDateStamp) =>
			Add(new ByteArrayChunk(data), type, majorVersion, minorVersion, timeDateStamp);

		/// <summary>
		/// Adds data
		/// </summary>
		/// <param name="chunk">Data</param>
		/// <param name="type">Debug type</param>
		/// <param name="majorVersion">Major version</param>
		/// <param name="minorVersion">Minor version</param>
		/// <param name="timeDateStamp">Timestamp</param>
		/// <returns></returns>
		public DebugDirectoryEntry Add(IChunk chunk, ImageDebugType type, ushort majorVersion, ushort minorVersion, uint timeDateStamp) {
			var entry = Add(chunk);
			entry.DebugDirectory.Type = type;
			entry.DebugDirectory.MajorVersion = majorVersion;
			entry.DebugDirectory.MinorVersion = minorVersion;
			entry.DebugDirectory.TimeDateStamp = timeDateStamp;
			return entry;
		}

		bool IReuseChunk.CanReuse(RVA origRva, uint origSize) {
			uint newLength = GetLength(entries, (FileOffset)origRva, origRva);
			if (newLength > origSize)
				return false;

			isReadonly = true;
			return true;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			isReadonly = true;
			this.offset = offset;
			this.rva = rva;

			length = GetLength(entries, offset, rva);
		}

		static uint GetLength(List<DebugDirectoryEntry> entries, FileOffset offset, RVA rva) {
			uint length = HEADER_SIZE * (uint)entries.Count;
			foreach (var entry in entries) {
				length = Utils.AlignUp(length, DEFAULT_DEBUGDIRECTORY_ALIGNMENT);
				entry.Chunk.SetOffset(offset + length, rva + length);
				length += entry.Chunk.GetFileLength();
			}
			return length;
		}

		/// <inheritdoc/>
		public uint GetFileLength() => length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			uint offset = 0;
			foreach (var entry in entries) {
				writer.WriteUInt32(entry.DebugDirectory.Characteristics);
				writer.WriteUInt32(entry.DebugDirectory.TimeDateStamp);
				writer.WriteUInt16(entry.DebugDirectory.MajorVersion);
				writer.WriteUInt16(entry.DebugDirectory.MinorVersion);
				writer.WriteUInt32((uint)entry.DebugDirectory.Type);
				uint length = entry.Chunk.GetFileLength();
				writer.WriteUInt32(length);
				writer.WriteUInt32(length == 0 ? 0 : (uint)entry.Chunk.RVA);
				writer.WriteUInt32(length == 0 ? 0 : (uint)entry.Chunk.FileOffset);
				offset += HEADER_SIZE;
			}

			foreach (var entry in entries) {
				WriteAlign(writer, ref offset);
				entry.Chunk.VerifyWriteTo(writer);
				offset += entry.Chunk.GetFileLength();
			}
		}

		static void WriteAlign(DataWriter writer, ref uint offs) {
			uint align = Utils.AlignUp(offs, DEFAULT_DEBUGDIRECTORY_ALIGNMENT) - offs;
			offs += align;
			writer.WriteZeroes((int)align);
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes <c>DeclSecurity</c> blobs
	/// </summary>
	public readonly struct DeclSecurityWriter : ICustomAttributeWriterHelper {
		readonly ModuleDef module;
		readonly IWriterError helper;
		readonly DataWriterContext context;
		readonly bool optimizeCustomAttributeSerializedTypeNames;

		/// <summary>
		/// Creates a <c>DeclSecurity</c> blob from <paramref name="secAttrs"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="secAttrs">List of <see cref="SecurityAttribute"/>s</param>
		/// <param name="helper">Helps this class</param>
		/// <returns>A <c>DeclSecurity</c> blob</returns>
		public static byte[] Write(ModuleDef module, IList<SecurityAttribute> secAttrs, IWriterError helper) =>
			Write(module, secAttrs, helper, false);

		/// <summary>
		/// Creates a <c>DeclSecurity</c> blob from <paramref name="secAttrs"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="secAttrs">List of <see cref="SecurityAttribute"/>s</param>
		/// <param name="helper">Helps this class</param>
		/// <param name="optimizeCustomAttributeSerializedTypeNames">Optimize serialized type strings in custom attributes.
		/// For more info, see <see cref="MetadataFlags.OptimizeCustomAttributeSerializedTypeNames"/></param>
		/// <returns>A <c>DeclSecurity</c> blob</returns>
		public static byte[] Write(ModuleDef module, IList<SecurityAttribute> secAttrs, IWriterError helper, bool optimizeCustomAttributeSerializedTypeNames) =>
			new DeclSecurityWriter(module, helper, optimizeCustomAttributeSerializedTypeNames, null).Write(secAttrs);

		internal static byte[] Write(ModuleDef module, IList<SecurityAttribute> secAttrs, IWriterError helper, bool optimizeCustomAttributeSerializedTypeNames, DataWriterContext context) =>
			new DeclSecurityWriter(module, helper, optimizeCustomAttributeSerializedTypeNames, context).Write(secAttrs);

		DeclSecurityWriter(ModuleDef module, IWriterError helper, bool optimizeCustomAttributeSerializedTypeNames, DataWriterContext context) {
			this.module = module;
			this.helper = helper;
			this.context = context;
			this.optimizeCustomAttributeSerializedTypeNames = optimizeCustomAttributeSerializedTypeNames;
		}

		byte[] Write(IList<SecurityAttribute> secAttrs) {
			if (secAttrs is null)
				secAttrs = Array2.Empty<SecurityAttribute>();

			var xml = DeclSecurity.GetNet1xXmlStringInternal(secAttrs);
			if (xml is not null)
				return WriteFormat1(xml);
			return WriteFormat2(secAttrs);
		}

		byte[] WriteFormat1(string xml) => Encoding.Unicode.GetBytes(xml);

		byte[] WriteFormat2(IList<SecurityAttribute> secAttrs) {
			var stream = new MemoryStream();
			var writer = new DataWriter(stream);
			writer.WriteByte((byte)'.');
			WriteCompressedUInt32(writer, (uint)secAttrs.Count);

			int count = secAttrs.Count;
			for (int i = 0; i < count; i++) {
				var sa = secAttrs[i];
				if (sa is null) {
					helper.Error("SecurityAttribute is null");
					Write(writer, UTF8String.Empty);
					WriteCompressedUInt32(writer, 1);
					WriteCompressedUInt32(writer, 0);
					continue;
				}
				var attrType = sa.AttributeType;
				string fqn;
				if (attrType is null) {
					helper.Error("SecurityAttribute attribute type is null");
					fqn = string.Empty;
				}
				else
					fqn = attrType.AssemblyQualifiedName;
				Write(writer, fqn);

				var namedArgsBlob = context is null ?
					CustomAttributeWriter.Write(this, sa.NamedArguments) :
					CustomAttributeWriter.Write(this, sa.NamedArguments, context);
				if (namedArgsBlob.Length > 0x1FFFFFFF) {
					helper.Error("Named arguments blob size doesn't fit in 29 bits");
					namedArgsBlob = Array2.Empty<byte>();
				}
				WriteCompressedUInt32(writer, (uint)namedArgsBlob.Length);
				writer.WriteBytes(namedArgsBlob);
			}

			return stream.ToArray();
		}

		uint WriteCompressedUInt32(DataWriter writer, uint value) => writer.WriteCompressedUInt32(helper, value);
		void Write(DataWriter writer, UTF8String s) => writer.Write(helper, s);
		void IWriterError.Error(string message) => helper.Error(message);
		bool IFullNameFactoryHelper.MustUseAssemblyName(IType type) =>
			FullNameFactory.MustUseAssemblyName(module, type, optimizeCustomAttributeSerializedTypeNames);
	}
}




namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Extension methods
	/// </summary>
	static partial class Extensions {
		/// <summary>
		/// Write zeros
		/// </summary>
		/// <param name="writer">this</param>
		/// <param name="count">Number of zeros</param>
		public static void WriteZeroes(this DataWriter writer, int count) {
			while (count >= 8) {
				writer.WriteUInt64(0);
				count -= 8;
			}
			for (int i = 0; i < count; i++)
				writer.WriteByte(0);
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #GUID heap
	/// </summary>
	public sealed class GuidHeap : HeapBase, IOffsetHeap<Guid> {
		readonly Dictionary<Guid, uint> guids = new Dictionary<Guid, uint>();
		Dictionary<uint, byte[]> userRawData;

		/// <inheritdoc/>
		public override string Name => "#GUID";

		/// <summary>
		/// Adds a guid to the #GUID heap
		/// </summary>
		/// <param name="guid">The guid</param>
		/// <returns>The index of the guid in the #GUID heap</returns>
		public uint Add(Guid? guid) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #GUID when it's read-only");
			if (guid is null)
				return 0;

			if (guids.TryGetValue(guid.Value, out uint index))
				return index;

			index = (uint)guids.Count + 1;
			guids.Add(guid.Value, index);
			return index;
		}

		/// <inheritdoc/>
		public override uint GetRawLength() => (uint)guids.Count * 16;

		/// <inheritdoc/>
		protected override void WriteToImpl(DataWriter writer) {
			uint offset = 0;
			foreach (var kv in guids) {
				if (userRawData is null || !userRawData.TryGetValue(offset, out var rawData))
					rawData = kv.Key.ToByteArray();
				writer.WriteBytes(rawData);
				offset += 16;
			}
		}

		/// <inheritdoc/>
		public int GetRawDataSize(Guid data) => 16;

		/// <inheritdoc/>
		public void SetRawData(uint offset, byte[] rawData) {
			if (rawData is null || rawData.Length != 16)
				throw new ArgumentException("Invalid size of GUID raw data");
			if (userRawData is null)
				userRawData = new Dictionary<uint, byte[]>();
			userRawData[offset] = rawData;
		}

		/// <inheritdoc/>
		public IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData() {
			uint offset = 0;
			foreach (var kv in guids) {
				yield return new KeyValuePair<uint, byte[]>(offset, kv.Key.ToByteArray());
				offset += 16;
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	static class Hasher {
		static HashAlgorithm CreateHasher(ChecksumAlgorithm checksumAlgorithm) =>
			checksumAlgorithm switch {
				ChecksumAlgorithm.SHA1 => SHA1.Create(),
				ChecksumAlgorithm.SHA256 => SHA256.Create(),
				ChecksumAlgorithm.SHA384 => SHA384.Create(),
				ChecksumAlgorithm.SHA512 => SHA512.Create(),
				_ => throw new ArgumentOutOfRangeException(nameof(checksumAlgorithm)),
			};

		public static string GetChecksumName(ChecksumAlgorithm checksumAlgorithm) =>
			// https://github.com/dotnet/corefx/blob/master/src/System.Reflection.Metadata/specs/PE-COFF.md#pdb-checksum-debug-directory-entry-type-19
			checksumAlgorithm switch {
				ChecksumAlgorithm.SHA1 => "SHA1",
				ChecksumAlgorithm.SHA256 => "SHA256",
				ChecksumAlgorithm.SHA384 => "SHA384",
				ChecksumAlgorithm.SHA512 => "SHA512",
				_ => throw new ArgumentOutOfRangeException(nameof(checksumAlgorithm)),
			};

		public static bool TryGetChecksumAlgorithm(string checksumName, out ChecksumAlgorithm pdbChecksumAlgorithm, out int checksumSize) {
			switch (checksumName) {
			case "SHA1":
				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA1;
				checksumSize = 20;
				return true;

			case "SHA256":
				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA256;
				checksumSize = 32;
				return true;

			case "SHA384":
				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA384;
				checksumSize = 48;
				return true;

			case "SHA512":
				pdbChecksumAlgorithm = ChecksumAlgorithm.SHA512;
				checksumSize = 64;
				return true;

			default:
				pdbChecksumAlgorithm = 0;
				checksumSize = -1;
				return false;
			}
		}

		public static byte[] Hash(ChecksumAlgorithm checksumAlgorithm, Stream stream, long length) {
			var buffer = new byte[(int)Math.Min(0x2000, length)];
			using (var hasher = CreateHasher(checksumAlgorithm)) {
				while (length > 0) {
					int len = (int)Math.Min(length, buffer.Length);
					int read = stream.Read(buffer, 0, len);
					if (read == 0)
						throw new InvalidOperationException("Couldn't read all bytes");
					hasher.TransformBlock(buffer, 0, read, buffer, 0);
					length -= read;
				}
				hasher.TransformFinalBlock(Array2.Empty<byte>(), 0, 0);
				return hasher.Hash;
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Base class of most heaps
	/// </summary>
	public abstract class HeapBase : IHeap {
		internal const uint ALIGNMENT = 4;
		FileOffset offset;
		RVA rva;

		/// <summary>
		/// <c>true</c> if <see cref="SetReadOnly"/> has been called
		/// </summary>
		protected bool isReadOnly;

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <inheritdoc/>
		public abstract string Name { get; }

		/// <inheritdoc/>
		public bool IsEmpty => GetRawLength() <= 1;

		/// <summary>
		/// <c>true</c> if offsets require 4 bytes instead of 2 bytes.
		/// </summary>
		public bool IsBig => GetFileLength() > 0xFFFF;

		/// <inheritdoc/>
		public void SetReadOnly() => isReadOnly = true;

		/// <inheritdoc/>
		public virtual void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			// NOTE: This method can be called twice by NativeModuleWriter, see Metadata.SetOffset() for more info
		}

		/// <inheritdoc/>
		public uint GetFileLength() => Utils.AlignUp(GetRawLength(), ALIGNMENT);

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <summary>
		/// Gets the raw length of the heap
		/// </summary>
		/// <returns>Raw length of the heap</returns>
		public abstract uint GetRawLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			WriteToImpl(writer);
			writer.WriteZeroes((int)(Utils.AlignUp(GetRawLength(), ALIGNMENT) - GetRawLength()));
		}

		/// <summary>
		/// Writes all data to <paramref name="writer"/> at its current location.
		/// </summary>
		/// <param name="writer">Destination</param>
		protected abstract void WriteToImpl(DataWriter writer);

		/// <inheritdoc/>
		public override string ToString() => Name;
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Data that gets written to the file
	/// </summary>
	public interface IChunk {
		/// <summary>
		/// Gets the file offset. This is valid only after <see cref="SetOffset"/> has been called.
		/// </summary>
		FileOffset FileOffset { get; }

		/// <summary>
		/// Gets the RVA. This is valid only after <see cref="SetOffset"/> has been called.
		/// </summary>
		RVA RVA { get; }

		/// <summary>
		/// Called when the file offset and RVA are known
		/// </summary>
		/// <param name="offset">File offset of this chunk</param>
		/// <param name="rva">RVA of this chunk</param>
		void SetOffset(FileOffset offset, RVA rva);

		/// <summary>
		/// Gets the raw file length of this chunk. Must only be called after <see cref="SetOffset"/>
		/// has been called.
		/// </summary>
		/// <returns>Length of this chunk</returns>
		uint GetFileLength();

		/// <summary>
		/// Gets the virtual size of this chunk. Must only be called after <see cref="SetOffset"/>
		/// has been called.
		/// </summary>
		/// <returns>Virtual size of this chunk</returns>
		uint GetVirtualSize();

		/// <summary>
		/// Writes all data to <paramref name="writer"/> at its current location. It's only
		/// called after <see cref="SetOffset"/> and <see cref="GetFileLength"/> have been called.
		/// You cannot assume that <paramref name="writer"/>'s file position is the same as this
		/// chunk's file position.
		/// </summary>
		/// <param name="writer">Destination</param>
		void WriteTo(DataWriter writer);
	}

	/// <summary>
	/// Implemented by <see cref="IChunk"/>s that can reuse the old data location in the original PE file
	/// </summary>
	interface IReuseChunk : IChunk {
		/// <summary>
		/// Returns true if this chunk fits in the old location
		/// </summary>
		/// <param name="origRva">Original RVA of data</param>
		/// <param name="origSize">Size of the original location</param>
		/// <returns></returns>
		bool CanReuse(RVA origRva, uint origSize);
	}

	public static partial class Extensions {
		/// <summary>
		/// Writes all data to <paramref name="writer"/> and verifies that all bytes were written
		/// </summary>
		/// <param name="chunk">this</param>
		/// <param name="writer">Destination</param>
		/// <exception cref="IOException">Not all bytes were written</exception>
		public static void VerifyWriteTo(this IChunk chunk, DataWriter writer) {
			long pos = writer.Position;
			// Uncomment this to add some debug info, useful when comparing old vs new version
			//System.Diagnostics.Debug.WriteLine($" RVA 0x{(uint)chunk.RVA:X8} OFFS 0x{(uint)chunk.FileOffset:X8} VSIZE 0x{chunk.GetVirtualSize():X8} {chunk.GetType().FullName}");
			chunk.WriteTo(writer);
			if (writer.Position - pos != chunk.GetFileLength())
				VerifyWriteToThrow(chunk);
		}

		static void VerifyWriteToThrow(IChunk chunk) =>
			throw new IOException($"Did not write all bytes: {chunk.GetType().FullName}");

		/// <summary>
		/// Writes a data directory
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="chunk">The data</param>
		internal static void WriteDataDirectory(this DataWriter writer, IChunk chunk) {
			if (chunk is null || chunk.GetVirtualSize() == 0)
				writer.WriteUInt64(0);
			else {
				writer.WriteUInt32((uint)chunk.RVA);
				writer.WriteUInt32(chunk.GetVirtualSize());
			}
		}

		internal static void WriteDebugDirectory(this DataWriter writer, DebugDirectory chunk) {
			if (chunk is null || chunk.GetVirtualSize() == 0)
				writer.WriteUInt64(0);
			else {
				writer.WriteUInt32((uint)chunk.RVA);
				writer.WriteUInt32((uint)(chunk.Count * DebugDirectory.HEADER_SIZE));
			}
		}
	}
}




namespace dnlib.DotNet.Writer {
	/// <summary>
	/// .NET Heap interface
	/// </summary>
	public interface IHeap : IChunk {
		/// <summary>
		/// Gets the name of the heap
		/// </summary>
		string Name { get; }

		/// <summary>
		/// Checks whether the heap is empty
		/// </summary>
		bool IsEmpty { get; }

		/// <summary>
		/// Called when the heap should be set to read-only mode
		/// </summary>
		void SetReadOnly();
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Options to <see cref="ImageCor20Header"/>
	/// </summary>
	public sealed class Cor20HeaderOptions {
		/// <summary>
		/// Default major runtime version
		/// </summary>
		public const ushort DEFAULT_MAJOR_RT_VER = 2;

		/// <summary>
		/// Default minor runtime version
		/// </summary>
		public const ushort DEFAULT_MINOR_RT_VER = 5;

		/// <summary>
		/// Major runtime version
		/// </summary>
		public ushort? MajorRuntimeVersion;

		/// <summary>
		/// Minor runtime version
		/// </summary>
		public ushort? MinorRuntimeVersion;

		/// <summary>
		/// Flags
		/// </summary>
		public ComImageFlags? Flags;

		/// <summary>
		/// Entry point or <c>null</c>. Either a Method/File token or an RVA.
		/// </summary>
		public uint? EntryPoint;

		/// <summary>
		/// Default constructor
		/// </summary>
		public Cor20HeaderOptions() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Flags</param>
		public Cor20HeaderOptions(ComImageFlags flags) => Flags = flags;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="major">Major runtime version (default is <see cref="DEFAULT_MAJOR_RT_VER"/>)</param>
		/// <param name="minor">Minor runtime version (default is <see cref="DEFAULT_MINOR_RT_VER"/>)</param>
		/// <param name="flags">Flags</param>
		public Cor20HeaderOptions(ushort major, ushort minor, ComImageFlags flags) {
			MajorRuntimeVersion = major;
			MinorRuntimeVersion = minor;
			Flags = flags;
		}
	}

	/// <summary>
	/// .NET header
	/// </summary>
	public sealed class ImageCor20Header : IChunk {
		FileOffset offset;
		RVA rva;
		Cor20HeaderOptions options;

		/// <summary>
		/// Gets/sets the <see cref="Metadata"/>
		/// </summary>
		public Metadata Metadata { get; set; }

		/// <summary>
		/// Gets/sets the .NET resources
		/// </summary>
		public NetResources NetResources { get; set; }

		/// <summary>
		/// Gets/sets the strong name signature
		/// </summary>
		public StrongNameSignature StrongNameSignature { get; set; }

		internal IChunk VtableFixups { get; set; }

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Options</param>
		public ImageCor20Header(Cor20HeaderOptions options) => this.options = options;

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() => 0x48;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			writer.WriteInt32(0x48);	// cb
			writer.WriteUInt16(options.MajorRuntimeVersion ?? Cor20HeaderOptions.DEFAULT_MAJOR_RT_VER);
			writer.WriteUInt16(options.MinorRuntimeVersion ?? Cor20HeaderOptions.DEFAULT_MINOR_RT_VER);
			writer.WriteDataDirectory(Metadata);
			writer.WriteUInt32((uint)(options.Flags ?? ComImageFlags.ILOnly));
			writer.WriteUInt32(options.EntryPoint ?? 0);
			writer.WriteDataDirectory(NetResources);
			writer.WriteDataDirectory(StrongNameSignature);
			writer.WriteDataDirectory(null);	// Code manager table
			writer.WriteDataDirectory(VtableFixups);
			writer.WriteDataDirectory(null);	// Export address table jumps
			writer.WriteDataDirectory(null);	// Managed native header
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Import address table chunk
	/// </summary>
	public sealed class ImportAddressTable : IChunk {
		readonly bool is64bit;
		FileOffset offset;
		RVA rva;

		/// <summary>
		/// Gets/sets the <see cref="ImportDirectory"/>
		/// </summary>
		public ImportDirectory ImportDirectory { get; set; }

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		internal bool Enable { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="is64bit">true if it's a 64-bit PE file, false if it's a 32-bit PE file</param>
		public ImportAddressTable(bool is64bit) => this.is64bit = is64bit;

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			if (!Enable)
				return 0;
			return is64bit ? 16U : 8;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			if (!Enable)
				return;
			if (is64bit) {
				writer.WriteUInt64((ulong)(uint)ImportDirectory.CorXxxMainRVA);
				writer.WriteUInt64(0);
			}
			else {
				writer.WriteUInt32((uint)ImportDirectory.CorXxxMainRVA);
				writer.WriteInt32(0);
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Import directory chunk
	/// </summary>
	public sealed class ImportDirectory : IChunk {
		readonly bool is64bit;
		FileOffset offset;
		RVA rva;
		bool isExeFile;
		uint length;
		RVA importLookupTableRVA;
		RVA corXxxMainRVA;
		RVA dllToImportRVA;
		int stringsPadding;
		string dllToImport;
		string entryPointName;

		/// <summary>
		/// Gets/sets the <see cref="ImportAddressTable"/>
		/// </summary>
		public ImportAddressTable ImportAddressTable { get; set; }

		/// <summary>
		/// Gets the RVA of _CorDllMain/_CorExeMain in the import lookup table
		/// </summary>
		public RVA CorXxxMainRVA => corXxxMainRVA;

		/// <summary>
		/// Gets RVA of _CorExeMain/_CorDllMain in the IAT
		/// </summary>
		public RVA IatCorXxxMainRVA => ImportAddressTable.RVA;

		/// <summary>
		/// Gets/sets a value indicating whether this is a EXE or a DLL file
		/// </summary>
		public bool IsExeFile {
			get => isExeFile;
			set => isExeFile = value;
		}

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		internal bool Enable { get; set; }

		/// <summary>
		/// Gets/sets the name of the dll which should be imported.
		/// </summary>
		public string DllToImport {
			get => dllToImport ?? "mscoree.dll";
			set => dllToImport = value;
		}

		/// <summary>
		/// Gets/sets the name of the entry point of the imported dll.
		/// </summary>
		public string EntryPointName {
			get => entryPointName ?? (IsExeFile ? "_CorExeMain" : "_CorDllMain");
			set => entryPointName = value;
		}

		const uint STRINGS_ALIGNMENT = 16;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="is64bit">true if it's a 64-bit PE file, false if it's a 32-bit PE file</param>
		public ImportDirectory(bool is64bit) => this.is64bit = is64bit;

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			length = 0x28;
			importLookupTableRVA = rva + length;
			length += is64bit ? 16U : 8;

			stringsPadding = (int)(rva.AlignUp(STRINGS_ALIGNMENT) - rva);
			length += (uint)stringsPadding;
			corXxxMainRVA = rva + length;
			length += 2 + (uint)EntryPointName.Length + 1;
			dllToImportRVA = rva + length;
			length += (uint)DllToImport.Length + 1;
			length++;
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			if (!Enable)
				return 0;
			return length;
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			if (!Enable)
				return;
			writer.WriteUInt32((uint)importLookupTableRVA);
			writer.WriteInt32(0);	// DateTimeStamp
			writer.WriteInt32(0);	// ForwarderChain
			writer.WriteUInt32((uint)dllToImportRVA);	// Name
			writer.WriteUInt32((uint)ImportAddressTable.RVA);
			writer.WriteUInt64(0);
			writer.WriteUInt64(0);
			writer.WriteInt32(0);

			// ImportLookupTable
			if (is64bit) {
				writer.WriteUInt64((ulong)(uint)corXxxMainRVA);
				writer.WriteUInt64(0);
			}
			else {
				writer.WriteUInt32((uint)corXxxMainRVA);
				writer.WriteInt32(0);
			}

			writer.WriteZeroes(stringsPadding);
			writer.WriteUInt16(0);
			writer.WriteBytes(Encoding.UTF8.GetBytes(EntryPointName + "\0"));
			writer.WriteBytes(Encoding.UTF8.GetBytes(DllToImport + "\0"));

			writer.WriteByte(0);
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Interface to get and set raw heap data. Implemented by the offset heaps: #Strings,
	/// #GUID, #Blob, and #US.
	/// </summary>
	/// <typeparam name="TValue">Type of cooked data</typeparam>
	public interface IOffsetHeap<TValue> {
		/// <summary>
		/// Gets the size of the data as raw data when written to the heap
		/// </summary>
		/// <param name="data">The data</param>
		/// <returns>Size of the data as raw data when written to the heap</returns>
		int GetRawDataSize(TValue data);

		/// <summary>
		/// Overrides what value should be written to the heap.
		/// </summary>
		/// <param name="offset">Offset of value. Must match an offset returned by
		/// <see cref="GetAllRawData()"/></param>
		/// <param name="rawData">The new raw data. The size must match the raw size exactly.</param>
		void SetRawData(uint offset, byte[] rawData);

		/// <summary>
		/// Gets all inserted raw data and their offsets. The returned <see cref="byte"/> array
		/// is owned by the caller.
		/// </summary>
		/// <returns>An enumerable of all raw data and their offsets</returns>
		IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData();
	}
}




namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Gets notified of errors. The default handler should normally throw since the written data
	/// will probably be invalid. Any error can be ignored.
	/// </summary>
	public interface IWriterError {
		/// <summary>
		/// Called when an error is detected (eg. a null pointer or other invalid value). The error
		/// can be ignored but the written data won't be valid.
		/// </summary>
		/// <param name="message">Error message</param>
		void Error(string message);
	}

	/// <summary>
	/// Gets notified of errors. The default handler should normally throw since the written data
	/// will probably be invalid. Any error can be ignored.
	/// </summary>
	public interface IWriterError2 : IWriterError {
		/// <summary>
		/// Called when an error is detected (eg. a null pointer or other invalid value). The error
		/// can be ignored but the written data won't be valid.
		/// </summary>
		/// <param name="message">Error message</param>
		/// <param name="args">Optional message arguments</param>
		void Error(string message, params object[] args);
	}
}





namespace dnlib.DotNet.Writer {
	sealed class ManagedExportsWriter {
		const uint DEFAULT_VTBL_FIXUPS_ALIGNMENT = 4;
		const uint DEFAULT_SDATA_ALIGNMENT = 8;
		const StubType stubType = StubType.Export;
		readonly string moduleName;
		readonly Machine machine;
		readonly RelocDirectory relocDirectory;
		readonly Metadata metadata;
		readonly PEHeaders peHeaders;
		readonly Action<string, object[]> logError;
		readonly VtableFixupsChunk vtableFixups;
		readonly StubsChunk stubsChunk;
		readonly SdataChunk sdataChunk;
		readonly ExportDir exportDir;
		readonly List<VTableInfo> vtables;
		readonly List<MethodInfo> allMethodInfos;
		readonly List<MethodInfo> sortedOrdinalMethodInfos;
		readonly List<MethodInfo> sortedNameMethodInfos;
		readonly CpuArch cpuArch;
		uint exportDirOffset;

		bool Is64Bit => machine.Is64Bit();
		FileOffset ExportDirOffset => sdataChunk.FileOffset + exportDirOffset;
		RVA ExportDirRVA => sdataChunk.RVA + exportDirOffset;
		uint ExportDirSize => 0x28;
		internal bool HasExports => vtables.Count != 0;

		sealed class ExportDir : IChunk {
			readonly ManagedExportsWriter owner;
			public FileOffset FileOffset => owner.ExportDirOffset;
			public RVA RVA => owner.ExportDirRVA;
			public ExportDir(ManagedExportsWriter owner) => this.owner = owner;
			void IChunk.SetOffset(FileOffset offset, RVA rva) => throw new NotSupportedException();
			public uint GetFileLength() => owner.ExportDirSize;
			public uint GetVirtualSize() => GetFileLength();
			void IChunk.WriteTo(DataWriter writer) => throw new NotSupportedException();
		}

		sealed class VtableFixupsChunk : IChunk {
			readonly ManagedExportsWriter owner;
			FileOffset offset;
			RVA rva;
			internal uint length;
			public FileOffset FileOffset => offset;
			public RVA RVA => rva;
			public VtableFixupsChunk(ManagedExportsWriter owner) => this.owner = owner;
			public void SetOffset(FileOffset offset, RVA rva) {
				this.offset = offset;
				this.rva = rva;
			}
			public uint GetFileLength() => length;
			public uint GetVirtualSize() => GetFileLength();
			public void WriteTo(DataWriter writer) => owner.WriteVtableFixups(writer);
		}

		sealed class StubsChunk : IChunk {
			readonly ManagedExportsWriter owner;
			FileOffset offset;
			RVA rva;
			internal uint length;
			public FileOffset FileOffset => offset;
			public RVA RVA => rva;
			public StubsChunk(ManagedExportsWriter owner) => this.owner = owner;
			public void SetOffset(FileOffset offset, RVA rva) {
				this.offset = offset;
				this.rva = rva;
			}
			public uint GetFileLength() => length;
			public uint GetVirtualSize() => GetFileLength();
			public void WriteTo(DataWriter writer) => owner.WriteStubs(writer);
		}

		sealed class SdataChunk : IChunk {
			readonly ManagedExportsWriter owner;
			FileOffset offset;
			RVA rva;
			internal uint length;
			public FileOffset FileOffset => offset;
			public RVA RVA => rva;
			public SdataChunk(ManagedExportsWriter owner) => this.owner = owner;
			public void SetOffset(FileOffset offset, RVA rva) {
				this.offset = offset;
				this.rva = rva;
			}
			public uint GetFileLength() => length;
			public uint GetVirtualSize() => GetFileLength();
			public void WriteTo(DataWriter writer) => owner.WriteSdata(writer);
		}

		public ManagedExportsWriter(string moduleName, Machine machine, RelocDirectory relocDirectory, Metadata metadata, PEHeaders peHeaders, Action<string, object[]> logError) {
			this.moduleName = moduleName;
			this.machine = machine;
			this.relocDirectory = relocDirectory;
			this.metadata = metadata;
			this.peHeaders = peHeaders;
			this.logError = logError;
			vtableFixups = new VtableFixupsChunk(this);
			stubsChunk = new StubsChunk(this);
			sdataChunk = new SdataChunk(this);
			exportDir = new ExportDir(this);
			vtables = new List<VTableInfo>();
			allMethodInfos = new List<MethodInfo>();
			sortedOrdinalMethodInfos = new List<MethodInfo>();
			sortedNameMethodInfos = new List<MethodInfo>();
			// The error is reported later when we know that there's at least one exported method
			CpuArch.TryGetCpuArch(machine, out cpuArch);
		}

		internal void AddTextChunks(PESection textSection) {
			textSection.Add(vtableFixups, DEFAULT_VTBL_FIXUPS_ALIGNMENT);
			if (cpuArch is not null)
				textSection.Add(stubsChunk, cpuArch.GetStubAlignment(stubType));
		}

		internal void AddSdataChunks(PESection sdataSection) => sdataSection.Add(sdataChunk, DEFAULT_SDATA_ALIGNMENT);

		internal void InitializeChunkProperties() {
			if (allMethodInfos.Count == 0)
				return;
			peHeaders.ExportDirectory = exportDir;
			peHeaders.ImageCor20Header.VtableFixups = vtableFixups;
		}

		internal void AddExportedMethods(List<MethodDef> methods, uint timestamp) {
			if (methods.Count == 0)
				return;

			// Only check for an unsupported machine when we know there's at least one exported method
			if (cpuArch is null) {
				logError("The module has exported methods but the CPU architecture isn't supported: {0} (0x{1:X4})", new object[] { machine, (ushort)machine });
				return;
			}
			if (methods.Count > 0x10000) {
				logError("Too many methods have been exported. No more than 2^16 methods can be exported. Number of exported methods: {0}", new object[] { methods.Count });
				return;
			}

			Initialize(methods, timestamp);
		}

		sealed class MethodInfo {
			public readonly MethodDef Method;
			public readonly uint StubChunkOffset;
			public int FunctionIndex;
			public uint ManagedVtblOffset;
			public uint NameOffset;
			public int NameIndex;
			public byte[] NameBytes;
			public MethodInfo(MethodDef method, uint stubChunkOffset) {
				Method = method;
				StubChunkOffset = stubChunkOffset;
			}
		}

		sealed class VTableInfo {
			public uint SdataChunkOffset { get; set; }
			public readonly VTableFlags Flags;
			public readonly List<MethodInfo> Methods;
			public VTableInfo(VTableFlags flags) {
				Flags = flags;
				Methods = new List<MethodInfo>();
			}
		}

		void Initialize(List<MethodDef> methods, uint timestamp) {
			var dict = new Dictionary<int, List<VTableInfo>>();
			var baseFlags = Is64Bit ? VTableFlags.Bit64 : VTableFlags.Bit32;
			uint stubOffset = 0;
			uint stubAlignment = cpuArch.GetStubAlignment(stubType);
			uint stubCodeOffset = cpuArch.GetStubCodeOffset(stubType);
			uint stubSize = cpuArch.GetStubSize(stubType);
			foreach (var method in methods) {
				var exportInfo = method.ExportInfo;
				Debug.Assert(exportInfo is not null);
				if (exportInfo is null)
					continue;

				var flags = baseFlags;
				if ((exportInfo.Options & MethodExportInfoOptions.FromUnmanaged) != 0)
					flags |= VTableFlags.FromUnmanaged;
				if ((exportInfo.Options & MethodExportInfoOptions.FromUnmanagedRetainAppDomain) != 0)
					flags |= VTableFlags.FromUnmanagedRetainAppDomain;
				if ((exportInfo.Options & MethodExportInfoOptions.CallMostDerived) != 0)
					flags |= VTableFlags.CallMostDerived;

				if (!dict.TryGetValue((int)flags, out var list))
					dict.Add((int)flags, list = new List<VTableInfo>());
				if (list.Count == 0 || list[list.Count - 1].Methods.Count >= ushort.MaxValue)
					list.Add(new VTableInfo(flags));
				var info = new MethodInfo(method, stubOffset + stubCodeOffset);
				allMethodInfos.Add(info);
				list[list.Count - 1].Methods.Add(info);
				stubOffset = (stubOffset + stubSize + stubAlignment - 1) & ~(stubAlignment - 1);
			}

			foreach (var kv in dict)
				vtables.AddRange(kv.Value);

			WriteSdataBlob(timestamp);

			vtableFixups.length = (uint)vtables.Count * 8;
			stubsChunk.length = stubOffset;
			sdataChunk.length = (uint)sdataBytesInfo.Data.Length;

			uint expectedOffset = 0;
			foreach (var info in allMethodInfos) {
				uint currentOffset = info.StubChunkOffset - stubCodeOffset;
				if (expectedOffset != currentOffset)
					throw new InvalidOperationException();
				cpuArch.WriteStubRelocs(stubType, relocDirectory, stubsChunk, currentOffset);
				expectedOffset = (currentOffset + stubSize + stubAlignment - 1) & ~(stubAlignment - 1);
			}
			if (expectedOffset != stubOffset)
				throw new InvalidOperationException();
		}

		struct NamesBlob {
			readonly Dictionary<string, NameInfo> nameOffsets;
			readonly List<byte[]> names;
			readonly List<uint> methodNameOffsets;
			uint currentOffset;
			int methodNamesCount;
			bool methodNamesIsFrozen;

			public int MethodNamesCount => methodNamesCount;

			readonly struct NameInfo {
				public readonly uint Offset;
				public readonly byte[] Bytes;
				public NameInfo(uint offset, byte[] bytes) {
					Offset = offset;
					Bytes = bytes;
				}
			}

			public NamesBlob(bool dummy) {
				nameOffsets = new Dictionary<string, NameInfo>(StringComparer.Ordinal);
				names = new List<byte[]>();
				methodNameOffsets = new List<uint>();
				currentOffset = 0;
				methodNamesCount = 0;
				methodNamesIsFrozen = false;
			}

			public uint GetMethodNameOffset(string name, out byte[] bytes) {
				if (methodNamesIsFrozen)
					throw new InvalidOperationException();
				methodNamesCount++;
				uint offset = GetOffset(name, out bytes);
				methodNameOffsets.Add(offset);
				return offset;
			}

			public uint GetOtherNameOffset(string name) {
				methodNamesIsFrozen = true;
				return GetOffset(name, out var bytes);
			}

			uint GetOffset(string name, out byte[] bytes) {
				if (nameOffsets.TryGetValue(name, out var nameInfo)) {
					bytes = nameInfo.Bytes;
					return nameInfo.Offset;
				}
				bytes = GetNameASCIIZ(name);
				names.Add(bytes);
				uint offset = currentOffset;
				nameOffsets.Add(name, new NameInfo(offset, bytes));
				currentOffset += (uint)bytes.Length;
				return offset;
			}

			// If this method gets updated, also update the reader (MethodExportInfoProvider)
			static byte[] GetNameASCIIZ(string name) {
				Debug.Assert(name is not null);
				int size = Encoding.UTF8.GetByteCount(name);
				var bytes = new byte[size + 1];
				Encoding.UTF8.GetBytes(name, 0, name.Length, bytes, 0);
				if (bytes[bytes.Length - 1] != 0)
					throw new ModuleWriterException();
				return bytes;
			}

			public void Write(DataWriter writer) {
				foreach (var name in names)
					writer.WriteBytes(name);
			}

			public uint[] GetMethodNameOffsets() => methodNameOffsets.ToArray();
		}

		struct SdataBytesInfo {
			public byte[] Data;
			public uint namesBlobStreamOffset;
			public uint moduleNameOffset;
			public uint exportDirModuleNameStreamOffset;
			public uint exportDirAddressOfFunctionsStreamOffset;
			public uint addressOfFunctionsStreamOffset;
			public uint addressOfNamesStreamOffset;
			public uint addressOfNameOrdinalsStreamOffset;
			public uint[] MethodNameOffsets;
		}
		SdataBytesInfo sdataBytesInfo;

		/// <summary>
		/// Writes the .sdata blob. We could write the data in any order, but we write the data in the same order as ILASM
		/// </summary>
		/// <param name="timestamp">PE timestamp</param>
		void WriteSdataBlob(uint timestamp) {
			var stream = new MemoryStream();
			var writer = new DataWriter(stream);

			// Write all vtables (referenced from the .text section)
			Debug.Assert((writer.Position & 7) == 0);
			foreach (var vtbl in vtables) {
				vtbl.SdataChunkOffset = (uint)writer.Position;
				foreach (var info in vtbl.Methods) {
					info.ManagedVtblOffset = (uint)writer.Position;
					writer.WriteUInt32(0x06000000 + metadata.GetRid(info.Method));
					if ((vtbl.Flags & VTableFlags.Bit64) != 0)
						writer.WriteUInt32(0);
				}
			}

			var namesBlob = new NamesBlob(1 == 2);
			int nameIndex = 0;
			bool error = false;
			foreach (var info in allMethodInfos) {
				var exportInfo = info.Method.ExportInfo;
				var name = exportInfo.Name;
				if (name is null) {
					if (exportInfo.Ordinal is not null) {
						sortedOrdinalMethodInfos.Add(info);
						continue;
					}
					name = info.Method.Name;
				}
				if (string.IsNullOrEmpty(name)) {
					error = true;
					logError("Exported method name is null or empty, method: {0} (0x{1:X8})", new object[] { info.Method, info.Method.MDToken.Raw });
					continue;
				}
				info.NameOffset = namesBlob.GetMethodNameOffset(name, out info.NameBytes);
				info.NameIndex = nameIndex++;
				sortedNameMethodInfos.Add(info);
			}
			Debug.Assert(error || sortedOrdinalMethodInfos.Count + sortedNameMethodInfos.Count == allMethodInfos.Count);
			sdataBytesInfo.MethodNameOffsets = namesBlob.GetMethodNameOffsets();
			Debug.Assert(sortedNameMethodInfos.Count == sdataBytesInfo.MethodNameOffsets.Length);
			sdataBytesInfo.moduleNameOffset = namesBlob.GetOtherNameOffset(moduleName);

			sortedOrdinalMethodInfos.Sort((a, b) => a.Method.ExportInfo.Ordinal.Value.CompareTo(b.Method.ExportInfo.Ordinal.Value));
			sortedNameMethodInfos.Sort((a, b) => CompareTo(a.NameBytes, b.NameBytes));

			int ordinalBase, nextFreeOrdinal;
			if (sortedOrdinalMethodInfos.Count == 0) {
				ordinalBase = 0;
				nextFreeOrdinal = 0;
			}
			else {
				ordinalBase = sortedOrdinalMethodInfos[0].Method.ExportInfo.Ordinal.Value;
				nextFreeOrdinal = sortedOrdinalMethodInfos[sortedOrdinalMethodInfos.Count - 1].Method.ExportInfo.Ordinal.Value + 1;
			}
			int nameFuncBaseIndex = nextFreeOrdinal - ordinalBase;
			int lastFuncIndex = 0;
			for (int i = 0; i < sortedOrdinalMethodInfos.Count; i++) {
				int index = sortedOrdinalMethodInfos[i].Method.ExportInfo.Ordinal.Value - ordinalBase;
				sortedOrdinalMethodInfos[i].FunctionIndex = index;
				lastFuncIndex = index;
			}
			for (int i = 0; i < sortedNameMethodInfos.Count; i++) {
				lastFuncIndex = nameFuncBaseIndex + i;
				sortedNameMethodInfos[i].FunctionIndex = lastFuncIndex;
			}
			int funcSize = lastFuncIndex + 1;
			if (funcSize > 0x10000) {
				logError("Exported function array is too big", Array2.Empty<object>());
				return;
			}

			// Write IMAGE_EXPORT_DIRECTORY
			Debug.Assert((writer.Position & 3) == 0);
			exportDirOffset = (uint)writer.Position;
			writer.WriteUInt32(0); // Characteristics
			writer.WriteUInt32(timestamp);
			writer.WriteUInt32(0); // MajorVersion, MinorVersion
			sdataBytesInfo.exportDirModuleNameStreamOffset = (uint)writer.Position;
			writer.WriteUInt32(0); // Name
			writer.WriteInt32(ordinalBase); // Base
			writer.WriteUInt32((uint)funcSize); // NumberOfFunctions
			writer.WriteInt32(sdataBytesInfo.MethodNameOffsets.Length); // NumberOfNames
			sdataBytesInfo.exportDirAddressOfFunctionsStreamOffset = (uint)writer.Position;
			writer.WriteUInt32(0); // AddressOfFunctions
			writer.WriteUInt32(0); // AddressOfNames
			writer.WriteUInt32(0); // AddressOfNameOrdinals

			sdataBytesInfo.addressOfFunctionsStreamOffset = (uint)writer.Position;
			writer.WriteZeroes(funcSize * 4);
			sdataBytesInfo.addressOfNamesStreamOffset = (uint)writer.Position;
			writer.WriteZeroes(sdataBytesInfo.MethodNameOffsets.Length * 4);
			sdataBytesInfo.addressOfNameOrdinalsStreamOffset = (uint)writer.Position;
			writer.WriteZeroes(sdataBytesInfo.MethodNameOffsets.Length * 2);
			sdataBytesInfo.namesBlobStreamOffset = (uint)writer.Position;
			namesBlob.Write(writer);

			sdataBytesInfo.Data = stream.ToArray();
		}

		void WriteSdata(DataWriter writer) {
			if (sdataBytesInfo.Data is null)
				return;
			PatchSdataBytesBlob();
			writer.WriteBytes(sdataBytesInfo.Data);
		}

		void PatchSdataBytesBlob() {
			uint rva = (uint)sdataChunk.RVA;
			uint namesBaseOffset = rva + sdataBytesInfo.namesBlobStreamOffset;

			var writer = new DataWriter(new MemoryStream(sdataBytesInfo.Data));

			writer.Position = sdataBytesInfo.exportDirModuleNameStreamOffset;
			writer.WriteUInt32(namesBaseOffset + sdataBytesInfo.moduleNameOffset);

			writer.Position = sdataBytesInfo.exportDirAddressOfFunctionsStreamOffset;
			writer.WriteUInt32(rva + sdataBytesInfo.addressOfFunctionsStreamOffset); // AddressOfFunctions
			if (sdataBytesInfo.MethodNameOffsets.Length != 0) {
				writer.WriteUInt32(rva + sdataBytesInfo.addressOfNamesStreamOffset); // AddressOfNames
				writer.WriteUInt32(rva + sdataBytesInfo.addressOfNameOrdinalsStreamOffset); // AddressOfNameOrdinals
			}

			uint funcBaseRva = (uint)stubsChunk.RVA;
			writer.Position = sdataBytesInfo.addressOfFunctionsStreamOffset;
			int currentFuncIndex = 0;
			foreach (var info in sortedOrdinalMethodInfos) {
				int zeroes = info.FunctionIndex - currentFuncIndex;
				if (zeroes < 0)
					throw new InvalidOperationException();
				while (zeroes-- > 0)
					writer.WriteInt32(0);
				writer.WriteUInt32(funcBaseRva + info.StubChunkOffset);
				currentFuncIndex = info.FunctionIndex + 1;
			}
			foreach (var info in sortedNameMethodInfos) {
				if (info.FunctionIndex != currentFuncIndex++)
					throw new InvalidOperationException();
				writer.WriteUInt32(funcBaseRva + info.StubChunkOffset);
			}

			var nameOffsets = sdataBytesInfo.MethodNameOffsets;
			if (nameOffsets.Length != 0) {
				writer.Position = sdataBytesInfo.addressOfNamesStreamOffset;
				foreach (var info in sortedNameMethodInfos)
					writer.WriteUInt32(namesBaseOffset + nameOffsets[info.NameIndex]);

				writer.Position = sdataBytesInfo.addressOfNameOrdinalsStreamOffset;
				foreach (var info in sortedNameMethodInfos)
					writer.WriteUInt16((ushort)info.FunctionIndex);
			}
		}

		void WriteVtableFixups(DataWriter writer) {
			if (vtables.Count == 0)
				return;

			foreach (var vtbl in vtables) {
				Debug.Assert(vtbl.Methods.Count <= ushort.MaxValue);
				writer.WriteUInt32((uint)sdataChunk.RVA + vtbl.SdataChunkOffset);
				writer.WriteUInt16((ushort)vtbl.Methods.Count);
				writer.WriteUInt16((ushort)vtbl.Flags);
			}
		}

		void WriteStubs(DataWriter writer) {
			if (vtables.Count == 0)
				return;
			if (cpuArch is null)
				return;

			ulong imageBase = peHeaders.ImageBase;
			uint stubsBaseRva = (uint)stubsChunk.RVA;
			uint vtblBaseRva = (uint)sdataChunk.RVA;
			uint expectedOffset = 0;
			uint stubCodeOffset = cpuArch.GetStubCodeOffset(stubType);
			uint stubSize = cpuArch.GetStubSize(stubType);
			uint stubAlignment = cpuArch.GetStubAlignment(stubType);
			int zeroes = (int)((stubSize + stubAlignment - 1 & ~(stubAlignment - 1)) - stubSize);
			foreach (var info in allMethodInfos) {
				uint currentOffset = info.StubChunkOffset - stubCodeOffset;
				if (expectedOffset != currentOffset)
					throw new InvalidOperationException();
				var pos = writer.Position;
				cpuArch.WriteStub(stubType, writer, imageBase, stubsBaseRva + currentOffset, vtblBaseRva + info.ManagedVtblOffset);
				Debug.Assert(pos + stubSize == writer.Position, "The full stub wasn't written");
				if (pos + stubSize != writer.Position)
					throw new InvalidOperationException();
				if (zeroes != 0)
					writer.WriteZeroes(zeroes);
				expectedOffset = (currentOffset + stubSize + stubAlignment - 1) & ~(stubAlignment - 1);
			}
			if (expectedOffset != stubsChunk.length)
				throw new InvalidOperationException();
		}

		static int CompareTo(byte[] a, byte[] b) {
			if (a == b)
				return 0;
			int max = Math.Min(a.Length, b.Length);
			for (int i = 0; i < max; i++) {
				int c = a[i] - b[i];
				if (c != 0)
					return c;
			}
			return a.Length - b.Length;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes field marshal blobs
	/// </summary>
	public readonly struct MarshalBlobWriter : IDisposable, IFullNameFactoryHelper {
		readonly ModuleDef module;
		readonly MemoryStream outStream;
		readonly DataWriter writer;
		readonly IWriterError helper;
		readonly bool optimizeCustomAttributeSerializedTypeNames;

		/// <summary>
		/// Creates a field marshal blob from <paramref name="marshalType"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="marshalType">Marshal type</param>
		/// <param name="helper">Helps this class</param>
		/// <returns>A field marshal blob or <c>null</c> if <paramref name="marshalType"/> is
		/// <c>null</c></returns>
		public static byte[] Write(ModuleDef module, MarshalType marshalType, IWriterError helper) =>
			Write(module, marshalType, helper, false);

		/// <summary>
		/// Creates a field marshal blob from <paramref name="marshalType"/>
		/// </summary>
		/// <param name="module">Owner module</param>
		/// <param name="marshalType">Marshal type</param>
		/// <param name="helper">Helps this class</param>
		/// <param name="optimizeCustomAttributeSerializedTypeNames">Optimize serialized type strings in custom attributes.
		/// For more info, see <see cref="MetadataFlags.OptimizeCustomAttributeSerializedTypeNames"/></param>
		/// <returns>A field marshal blob or <c>null</c> if <paramref name="marshalType"/> is
		/// <c>null</c></returns>
		public static byte[] Write(ModuleDef module, MarshalType marshalType, IWriterError helper, bool optimizeCustomAttributeSerializedTypeNames) {
			using (var writer = new MarshalBlobWriter(module, helper, optimizeCustomAttributeSerializedTypeNames))
				return writer.Write(marshalType);
		}

		MarshalBlobWriter(ModuleDef module, IWriterError helper, bool optimizeCustomAttributeSerializedTypeNames) {
			this.module = module;
			outStream = new MemoryStream();
			writer = new DataWriter(outStream);
			this.helper = helper;
			this.optimizeCustomAttributeSerializedTypeNames = optimizeCustomAttributeSerializedTypeNames;
		}

		byte[] Write(MarshalType marshalType) {
			if (marshalType is null)
				return null;

			var type = marshalType.NativeType;
			if (type != NativeType.RawBlob) {
				if ((uint)type > byte.MaxValue)
					helper.Error("Invalid MarshalType.NativeType");
				writer.WriteByte((byte)type);
			}
			bool canWrite = true;
			switch (type) {
			case NativeType.FixedSysString:
				var fixedSysString = (FixedSysStringMarshalType)marshalType;
				if (fixedSysString.IsSizeValid)
					WriteCompressedUInt32((uint)fixedSysString.Size);
				break;

			case NativeType.SafeArray:
				var safeArray = (SafeArrayMarshalType)marshalType;
				if (UpdateCanWrite(safeArray.IsVariantTypeValid, "VariantType", ref canWrite))
					WriteCompressedUInt32((uint)safeArray.VariantType);
				if (UpdateCanWrite(safeArray.IsUserDefinedSubTypeValid, "UserDefinedSubType", ref canWrite))
					Write(safeArray.UserDefinedSubType.AssemblyQualifiedName);
				break;

			case NativeType.FixedArray:
				var fixedArray = (FixedArrayMarshalType)marshalType;
				if (UpdateCanWrite(fixedArray.IsSizeValid, "Size", ref canWrite))
					WriteCompressedUInt32((uint)fixedArray.Size);
				if (UpdateCanWrite(fixedArray.IsElementTypeValid, "ElementType", ref canWrite))
					WriteCompressedUInt32((uint)fixedArray.ElementType);
				break;

			case NativeType.Array:
				var array = (ArrayMarshalType)marshalType;
				if (UpdateCanWrite(array.IsElementTypeValid, "ElementType", ref canWrite))
					WriteCompressedUInt32((uint)array.ElementType);
				if (UpdateCanWrite(array.IsParamNumberValid, "ParamNumber", ref canWrite))
					WriteCompressedUInt32((uint)array.ParamNumber);
				if (UpdateCanWrite(array.IsSizeValid, "Size", ref canWrite))
					WriteCompressedUInt32((uint)array.Size);
				if (UpdateCanWrite(array.IsFlagsValid, "Flags", ref canWrite))
					WriteCompressedUInt32((uint)array.Flags);
				break;

			case NativeType.CustomMarshaler:
				var custMarshaler = (CustomMarshalType)marshalType;
				Write(custMarshaler.Guid);
				Write(custMarshaler.NativeTypeName);
				var cm = custMarshaler.CustomMarshaler;
				var cmName = cm is null ? string.Empty : FullNameFactory.AssemblyQualifiedName(cm, this);
				Write(cmName);
				Write(custMarshaler.Cookie);
				break;

			case NativeType.IUnknown:
			case NativeType.IDispatch:
			case NativeType.IntF:
				var iface = (InterfaceMarshalType)marshalType;
				if (iface.IsIidParamIndexValid)
					WriteCompressedUInt32((uint)iface.IidParamIndex);
				break;

			case NativeType.RawBlob:
				var data = ((RawMarshalType)marshalType).Data;
				if (data is not null)
					writer.WriteBytes(data);
				break;

			default:
				break;
			}

			return outStream.ToArray();
		}

		bool UpdateCanWrite(bool isValid, string field, ref bool canWriteMore) {
			if (!canWriteMore) {
				if (isValid)
					helper.Error($"MarshalType field {field} is valid even though a previous field was invalid");
				return canWriteMore;
			}

			if (!isValid)
				canWriteMore = false;

			return canWriteMore;
		}

		uint WriteCompressedUInt32(uint value) => writer.WriteCompressedUInt32(helper, value);

		void Write(UTF8String s) => writer.Write(helper, s);

		/// <inheritdoc/>
		public void Dispose() => outStream?.Dispose();

		bool IFullNameFactoryHelper.MustUseAssemblyName(IType type) =>
			FullNameFactory.MustUseAssemblyName(module, type, optimizeCustomAttributeSerializedTypeNames);
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Calculates max stack usage by using a simple pass over all instructions. This value
	/// can be placed in the fat method header's MaxStack field.
	/// </summary>
	public struct MaxStackCalculator {
		IList<Instruction> instructions;
		IList<Emit.ExceptionHandler> exceptionHandlers;
		readonly Dictionary<Instruction, int> stackHeights;
		bool hasError;
		int currentMaxStack;

		/// <summary>
		/// Gets max stack value
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <param name="exceptionHandlers">All exception handlers</param>
		/// <returns>Max stack value</returns>
		public static uint GetMaxStack(IList<Instruction> instructions, IList<Emit.ExceptionHandler> exceptionHandlers) {
			new MaxStackCalculator(instructions, exceptionHandlers).Calculate(out uint maxStack);
			return maxStack;
		}

		/// <summary>
		/// Gets max stack value
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <param name="exceptionHandlers">All exception handlers</param>
		/// <param name="maxStack">Updated with max stack value</param>
		/// <returns><c>true</c> if no errors were detected, <c>false</c> otherwise</returns>
		public static bool GetMaxStack(IList<Instruction> instructions, IList<Emit.ExceptionHandler> exceptionHandlers, out uint maxStack) =>
			new MaxStackCalculator(instructions, exceptionHandlers).Calculate(out maxStack);

		internal static MaxStackCalculator Create() => new MaxStackCalculator(true);

		MaxStackCalculator(bool dummy) {
			instructions = null;
			exceptionHandlers = null;
			stackHeights = new Dictionary<Instruction, int>();
			hasError = false;
			currentMaxStack = 0;
		}

		MaxStackCalculator(IList<Instruction> instructions, IList<Emit.ExceptionHandler> exceptionHandlers) {
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
			stackHeights = new Dictionary<Instruction, int>();
			hasError = false;
			currentMaxStack = 0;
		}

		internal void Reset(IList<Instruction> instructions, IList<Emit.ExceptionHandler> exceptionHandlers) {
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
			stackHeights.Clear();
			hasError = false;
			currentMaxStack = 0;
		}

		internal bool Calculate(out uint maxStack) {
			var exceptionHandlers = this.exceptionHandlers;
			var stackHeights = this.stackHeights;
			for (int i = 0; i < exceptionHandlers.Count; i++) {
				var eh = exceptionHandlers[i];
				if (eh is null)
					continue;
				Instruction instr;
				if ((instr = eh.TryStart) is not null)
					stackHeights[instr] = 0;
				if ((instr = eh.FilterStart) is not null) {
					stackHeights[instr] = 1;
					currentMaxStack = 1;
				}
				if ((instr = eh.HandlerStart) is not null) {
					bool pushed = eh.IsCatch || eh.IsFilter;
					if (pushed) {
						stackHeights[instr] = 1;
						currentMaxStack = 1;
					}
					else
						stackHeights[instr] = 0;
				}
			}

			int stack = 0;
			bool resetStack = false;
			var instructions = this.instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i];
				if (instr is null)
					continue;

				if (resetStack) {
					stackHeights.TryGetValue(instr, out stack);
					resetStack = false;
				}
				stack = WriteStack(instr, stack);
				var opCode = instr.OpCode;
				var code = opCode.Code;
				if (code == Code.Jmp) {
					if (stack != 0)
						hasError = true;
				}
				else {
					instr.CalculateStackUsage(out int pushes, out int pops);
					if (pops == -1)
						stack = 0;
					else {
						stack -= pops;
						if (stack < 0) {
							hasError = true;
							stack = 0;
						}
						stack += pushes;
					}
				}
				if (stack < 0) {
					hasError = true;
					stack = 0;
				}

				switch (opCode.FlowControl) {
				case Emit.FlowControl.Branch:
					WriteStack(instr.Operand as Instruction, stack);
					resetStack = true;
					break;

				case Emit.FlowControl.Call:
					if (code == Code.Jmp)
						resetStack = true;
					break;

				case Emit.FlowControl.Cond_Branch:
					if (code == Code.Switch) {
						if (instr.Operand is IList<Instruction> targets) {
							for (int j = 0; j < targets.Count; j++)
								WriteStack(targets[j], stack);
						}
					}
					else
						WriteStack(instr.Operand as Instruction, stack);
					break;

				case Emit.FlowControl.Return:
				case Emit.FlowControl.Throw:
					resetStack = true;
					break;
				}
			}

			maxStack = (uint)currentMaxStack;
			return !hasError;
		}

		int WriteStack(Instruction instr, int stack) {
			if (instr is null) {
				hasError = true;
				return stack;
			}
			var stackHeights = this.stackHeights;
			if (stackHeights.TryGetValue(instr, out int stack2)) {
				if (stack != stack2)
					hasError = true;
				return stack2;
			}
			stackHeights[instr] = stack;
			if (stack > currentMaxStack)
				currentMaxStack = stack;
			return stack;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// MD table interface
	/// </summary>
	public interface IMDTable {
		/// <summary>
		/// Gets the table type
		/// </summary>
		Table Table { get; }

		/// <summary>
		/// <c>true</c> if the table is empty
		/// </summary>
		bool IsEmpty { get; }

		/// <summary>
		/// Gets the number of rows in this table
		/// </summary>
		int Rows { get; }

		/// <summary>
		/// Gets/sets a value indicating whether it's sorted
		/// </summary>
		bool IsSorted { get; set; }

		/// <summary>
		/// <c>true</c> if <see cref="SetReadOnly()"/> has been called
		/// </summary>
		bool IsReadOnly { get; }

		/// <summary>
		/// Gets/sets the <see cref="TableInfo"/>
		/// </summary>
		TableInfo TableInfo { get; set; }

		/// <summary>
		/// Called when the table can't be modified any more
		/// </summary>
		void SetReadOnly();
	}

	/// <summary>
	/// Creates rows in a table. Rows can optionally be shared to create a compact table.
	/// </summary>
	/// <typeparam name="TRow">The raw row type</typeparam>
	public sealed class MDTable<TRow> : IMDTable where TRow : struct {
		readonly Table table;
		readonly Dictionary<TRow, uint> cachedDict;
		readonly List<TRow> cached;
		TableInfo tableInfo;
		bool isSorted;
		bool isReadOnly;

		/// <inheritdoc/>
		public Table Table => table;

		/// <inheritdoc/>
		public bool IsEmpty => cached.Count == 0;

		/// <inheritdoc/>
		public int Rows => cached.Count;

		/// <inheritdoc/>
		public bool IsSorted {
			get => isSorted;
			set => isSorted = value;
		}

		/// <inheritdoc/>
		public bool IsReadOnly => isReadOnly;

		/// <inheritdoc/>
		public TableInfo TableInfo {
			get => tableInfo;
			set => tableInfo = value;
		}

		/// <summary>
		/// Gets the value with rid <paramref name="rid"/>
		/// </summary>
		/// <param name="rid">The row ID</param>
		public TRow this[uint rid] {
			get => cached[(int)rid - 1];
			set => cached[(int)rid - 1] = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="table">The table type</param>
		/// <param name="equalityComparer">Equality comparer</param>
		public MDTable(Table table, IEqualityComparer<TRow> equalityComparer) {
			this.table = table;
			cachedDict = new Dictionary<TRow, uint>(equalityComparer);
			cached = new List<TRow>();
		}

		/// <inheritdoc/>
		public void SetReadOnly() => isReadOnly = true;

		/// <summary>
		/// Adds a row. If the row already exists, returns a rid to the existing one, else
		/// it's created and a new rid is returned.
		/// </summary>
		/// <param name="row">The row. It's now owned by us and must NOT be modified by the caller.</param>
		/// <returns>The RID (row ID) of the row</returns>
		public uint Add(TRow row) {
			if (isReadOnly)
				throw new ModuleWriterException($"Trying to modify table {table} after it's been set to read-only");
			if (cachedDict.TryGetValue(row, out uint rid))
				return rid;
			return Create(row);
		}

		/// <summary>
		/// Creates a new row even if this row already exists.
		/// </summary>
		/// <param name="row">The row. It's now owned by us and must NOT be modified by the caller.</param>
		/// <returns>The RID (row ID) of the row</returns>
		public uint Create(TRow row) {
			if (isReadOnly)
				throw new ModuleWriterException($"Trying to modify table {table} after it's been set to read-only");
			uint rid = (uint)cached.Count + 1;
			if (!cachedDict.ContainsKey(row))
				cachedDict[row] = rid;
			cached.Add(row);
			return rid;
		}

		/// <summary>
		/// Re-adds all added rows. Should be called if rows have been modified after being
		/// inserted.
		/// </summary>
		public void ReAddRows() {
			if (isReadOnly)
				throw new ModuleWriterException($"Trying to modify table {table} after it's been set to read-only");
			cachedDict.Clear();
			for (int i = 0; i < cached.Count; i++) {
				uint rid = (uint)i + 1;
				var row = cached[i];
				if (!cachedDict.ContainsKey(row))
					cachedDict[row] = rid;
			}
		}

		/// <summary>
		/// Reset the table.
		/// </summary>
		public void Reset() {
			if (isReadOnly)
				throw new ModuleWriterException($"Trying to modify table {table} after it's been set to read-only");
			cachedDict.Clear();
			cached.Clear();
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes <see cref="MDTable{T}"/>s
	/// </summary>
	public static class MDTableWriter {
		/// <summary>
		/// Writes a <c>Module</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawModuleRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			var columns2 = columns[2];
			var columns3 = columns[3];
			var columns4 = columns[4];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.Generation);
				columns1.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns2.Write24(writer, row.Mvid);
				columns3.Write24(writer, row.EncId);
				columns4.Write24(writer, row.EncBaseId);
			}
		}

		/// <summary>
		/// Writes a <c>TypeRef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawTypeRefRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			var columns2 = columns[2];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.ResolutionScope);
				columns1.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns2.Write24(writer, stringsHeap.GetOffset(row.Namespace));
			}
		}

		/// <summary>
		/// Writes a <c>TypeDef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawTypeDefRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			var columns2 = columns[2];
			var columns3 = columns[3];
			var columns4 = columns[4];
			var columns5 = columns[5];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.Flags);
				columns1.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns2.Write24(writer, stringsHeap.GetOffset(row.Namespace));
				columns3.Write24(writer, row.Extends);
				columns4.Write24(writer, row.FieldList);
				columns5.Write24(writer, row.MethodList);
			}
		}

		/// <summary>
		/// Writes a <c>FieldPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawFieldPtrRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Field);
			}
		}

		/// <summary>
		/// Writes a <c>Field</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawFieldRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			var columns2 = columns[2];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.Flags);
				columns1.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns2.Write24(writer, row.Signature);
			}
		}

		/// <summary>
		/// Writes a <c>MethodPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawMethodPtrRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Method);
			}
		}

		/// <summary>
		/// Writes a <c>Method</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawMethodRow> table) {
			var columns = table.TableInfo.Columns;
			var columns3 = columns[3];
			var columns4 = columns[4];
			var columns5 = columns[5];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.RVA);
				writer.WriteUInt16(row.ImplFlags);
				writer.WriteUInt16(row.Flags);
				columns3.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns4.Write24(writer, row.Signature);
				columns5.Write24(writer, row.ParamList);
			}
		}

		/// <summary>
		/// Writes a <c>ParamPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawParamPtrRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Param);
			}
		}

		/// <summary>
		/// Writes a <c>Param</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawParamRow> table) {
			var columns = table.TableInfo.Columns;
			var columns2 = columns[2];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.Flags);
				writer.WriteUInt16(row.Sequence);
				columns2.Write24(writer, stringsHeap.GetOffset(row.Name));
			}
		}

		/// <summary>
		/// Writes a <c>InterfaceImpl</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawInterfaceImplRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Class);
				columns1.Write24(writer, row.Interface);
			}
		}

		/// <summary>
		/// Writes a <c>MemberRef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawMemberRefRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			var columns2 = columns[2];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Class);
				columns1.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns2.Write24(writer, row.Signature);
			}
		}

		/// <summary>
		/// Writes a <c>Constant</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawConstantRow> table) {
			var columns = table.TableInfo.Columns;
			var columns2 = columns[2];
			var columns3 = columns[3];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteByte(row.Type);
				writer.WriteByte(row.Padding);
				columns2.Write24(writer, row.Parent);
				columns3.Write24(writer, row.Value);
			}
		}

		/// <summary>
		/// Writes a <c>CustomAttribute</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawCustomAttributeRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			var columns2 = columns[2];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Parent);
				columns1.Write24(writer, row.Type);
				columns2.Write24(writer, row.Value);
			}
		}

		/// <summary>
		/// Writes a <c>FieldMarshal</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawFieldMarshalRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Parent);
				columns1.Write24(writer, row.NativeType);
			}
		}

		/// <summary>
		/// Writes a <c>DeclSecurity</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawDeclSecurityRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			var columns2 = columns[2];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteInt16(row.Action);
				columns1.Write24(writer, row.Parent);
				columns2.Write24(writer, row.PermissionSet);
			}
		}

		/// <summary>
		/// Writes a <c>ClassLayout</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawClassLayoutRow> table) {
			var columns = table.TableInfo.Columns;
			var columns2 = columns[2];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.PackingSize);
				writer.WriteUInt32(row.ClassSize);
				columns2.Write24(writer, row.Parent);
			}
		}

		/// <summary>
		/// Writes a <c>FieldLayout</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawFieldLayoutRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.OffSet);
				columns1.Write24(writer, row.Field);
			}
		}

		/// <summary>
		/// Writes a <c>StandAloneSig</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawStandAloneSigRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Signature);
			}
		}

		/// <summary>
		/// Writes a <c>EventMap</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawEventMapRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Parent);
				columns1.Write24(writer, row.EventList);
			}
		}

		/// <summary>
		/// Writes a <c>EventPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawEventPtrRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Event);
			}
		}

		/// <summary>
		/// Writes a <c>Event</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawEventRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			var columns2 = columns[2];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.EventFlags);
				columns1.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns2.Write24(writer, row.EventType);
			}
		}

		/// <summary>
		/// Writes a <c>PropertyMap</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawPropertyMapRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Parent);
				columns1.Write24(writer, row.PropertyList);
			}
		}

		/// <summary>
		/// Writes a <c>PropertyPtr</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawPropertyPtrRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Property);
			}
		}

		/// <summary>
		/// Writes a <c>Property</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawPropertyRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			var columns2 = columns[2];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.PropFlags);
				columns1.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns2.Write24(writer, row.Type);
			}
		}

		/// <summary>
		/// Writes a <c>MethodSemantics</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawMethodSemanticsRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			var columns2 = columns[2];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.Semantic);
				columns1.Write24(writer, row.Method);
				columns2.Write24(writer, row.Association);
			}
		}

		/// <summary>
		/// Writes a <c>MethodImpl</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawMethodImplRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			var columns2 = columns[2];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Class);
				columns1.Write24(writer, row.MethodBody);
				columns2.Write24(writer, row.MethodDeclaration);
			}
		}

		/// <summary>
		/// Writes a <c>ModuleRef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawModuleRefRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, stringsHeap.GetOffset(row.Name));
			}
		}

		/// <summary>
		/// Writes a <c>TypeSpec</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawTypeSpecRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Signature);
			}
		}

		/// <summary>
		/// Writes a <c>ImplMap</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawImplMapRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			var columns2 = columns[2];
			var columns3 = columns[3];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.MappingFlags);
				columns1.Write24(writer, row.MemberForwarded);
				columns2.Write24(writer, stringsHeap.GetOffset(row.ImportName));
				columns3.Write24(writer, row.ImportScope);
			}
		}

		/// <summary>
		/// Writes a <c>FieldRVA</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawFieldRVARow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.RVA);
				columns1.Write24(writer, row.Field);
			}
		}

		/// <summary>
		/// Writes a <c>ENCLog</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawENCLogRow> table) {
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.Token);
				writer.WriteUInt32(row.FuncCode);
			}
		}

		/// <summary>
		/// Writes a <c>ENCMap</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawENCMapRow> table) {
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.Token);
			}
		}

		/// <summary>
		/// Writes a <c>Assembly</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawAssemblyRow> table) {
			var columns = table.TableInfo.Columns;
			var columns6 = columns[6];
			var columns7 = columns[7];
			var columns8 = columns[8];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.HashAlgId);
				writer.WriteUInt16(row.MajorVersion);
				writer.WriteUInt16(row.MinorVersion);
				writer.WriteUInt16(row.BuildNumber);
				writer.WriteUInt16(row.RevisionNumber);
				writer.WriteUInt32(row.Flags);
				columns6.Write24(writer, row.PublicKey);
				columns7.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns8.Write24(writer, stringsHeap.GetOffset(row.Locale));
			}
		}

		/// <summary>
		/// Writes a <c>AssemblyProcessor</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawAssemblyProcessorRow> table) {
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.Processor);
			}
		}

		/// <summary>
		/// Writes a <c>AssemblyOS</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawAssemblyOSRow> table) {
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.OSPlatformId);
				writer.WriteUInt32(row.OSMajorVersion);
				writer.WriteUInt32(row.OSMinorVersion);
			}
		}

		/// <summary>
		/// Writes a <c>AssemblyRef</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawAssemblyRefRow> table) {
			var columns = table.TableInfo.Columns;
			var columns5 = columns[5];
			var columns6 = columns[6];
			var columns7 = columns[7];
			var columns8 = columns[8];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.MajorVersion);
				writer.WriteUInt16(row.MinorVersion);
				writer.WriteUInt16(row.BuildNumber);
				writer.WriteUInt16(row.RevisionNumber);
				writer.WriteUInt32(row.Flags);
				columns5.Write24(writer, row.PublicKeyOrToken);
				columns6.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns7.Write24(writer, stringsHeap.GetOffset(row.Locale));
				columns8.Write24(writer, row.HashValue);
			}
		}

		/// <summary>
		/// Writes a <c>AssemblyRefProcessor</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawAssemblyRefProcessorRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.Processor);
				columns1.Write24(writer, row.AssemblyRef);
			}
		}

		/// <summary>
		/// Writes a <c>AssemblyRefOS</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawAssemblyRefOSRow> table) {
			var columns = table.TableInfo.Columns;
			var columns3 = columns[3];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.OSPlatformId);
				writer.WriteUInt32(row.OSMajorVersion);
				writer.WriteUInt32(row.OSMinorVersion);
				columns3.Write24(writer, row.AssemblyRef);
			}
		}

		/// <summary>
		/// Writes a <c>File</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawFileRow> table) {
			var columns = table.TableInfo.Columns;
			var columns1 = columns[1];
			var columns2 = columns[2];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.Flags);
				columns1.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns2.Write24(writer, row.HashValue);
			}
		}

		/// <summary>
		/// Writes a <c>ExportedType</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawExportedTypeRow> table) {
			var columns = table.TableInfo.Columns;
			var columns2 = columns[2];
			var columns3 = columns[3];
			var columns4 = columns[4];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.Flags);
				writer.WriteUInt32(row.TypeDefId);
				columns2.Write24(writer, stringsHeap.GetOffset(row.TypeName));
				columns3.Write24(writer, stringsHeap.GetOffset(row.TypeNamespace));
				columns4.Write24(writer, row.Implementation);
			}
		}

		/// <summary>
		/// Writes a <c>ManifestResource</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawManifestResourceRow> table) {
			var columns = table.TableInfo.Columns;
			var columns2 = columns[2];
			var columns3 = columns[3];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt32(row.Offset);
				writer.WriteUInt32(row.Flags);
				columns2.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns3.Write24(writer, row.Implementation);
			}
		}

		/// <summary>
		/// Writes a <c>NestedClass</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawNestedClassRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.NestedClass);
				columns1.Write24(writer, row.EnclosingClass);
			}
		}

		/// <summary>
		/// Writes a <c>GenericParam</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawGenericParamRow> table) {
			var columns = table.TableInfo.Columns;
			var columns2 = columns[2];
			var columns3 = columns[3];
			var stringsHeap = metadata.StringsHeap;
			if (columns.Length >= 5) {
				var columns4 = columns[4];
				for (int i = 0; i < table.Rows; i++) {
					var row = table[(uint)i + 1];
					writer.WriteUInt16(row.Number);
					writer.WriteUInt16(row.Flags);
					columns2.Write24(writer, row.Owner);
					columns3.Write24(writer, stringsHeap.GetOffset(row.Name));
					columns4.Write24(writer, row.Kind);
				}
			}
			else {
				for (int i = 0; i < table.Rows; i++) {
					var row = table[(uint)i + 1];
					writer.WriteUInt16(row.Number);
					writer.WriteUInt16(row.Flags);
					columns2.Write24(writer, row.Owner);
					columns3.Write24(writer, stringsHeap.GetOffset(row.Name));
				}
			}
		}

		/// <summary>
		/// Writes a <c>MethodSpec</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawMethodSpecRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Method);
				columns1.Write24(writer, row.Instantiation);
			}
		}

		/// <summary>
		/// Writes a <c>GenericParamConstraint</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawGenericParamConstraintRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Owner);
				columns1.Write24(writer, row.Constraint);
			}
		}

		/// <summary>
		/// Writes a <c>Document</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawDocumentRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			var columns2 = columns[2];
			var columns3 = columns[3];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Name);
				columns1.Write24(writer, row.HashAlgorithm);
				columns2.Write24(writer, row.Hash);
				columns3.Write24(writer, row.Language);
			}
		}

		/// <summary>
		/// Writes a <c>MethodDebugInformation</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawMethodDebugInformationRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Document);
				columns1.Write24(writer, row.SequencePoints);
			}
		}

		/// <summary>
		/// Writes a <c>LocalScope</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawLocalScopeRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			var columns2 = columns[2];
			var columns3 = columns[3];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Method);
				columns1.Write24(writer, row.ImportScope);
				columns2.Write24(writer, row.VariableList);
				columns3.Write24(writer, row.ConstantList);
				writer.WriteUInt32(row.StartOffset);
				writer.WriteUInt32(row.Length);
			}
		}

		/// <summary>
		/// Writes a <c>LocalVariable</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawLocalVariableRow> table) {
			var columns = table.TableInfo.Columns;
			var columns2 = columns[2];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				writer.WriteUInt16(row.Attributes);
				writer.WriteUInt16(row.Index);
				columns2.Write24(writer, stringsHeap.GetOffset(row.Name));
			}
		}

		/// <summary>
		/// Writes a <c>LocalConstant</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawLocalConstantRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			var stringsHeap = metadata.StringsHeap;
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, stringsHeap.GetOffset(row.Name));
				columns1.Write24(writer, row.Signature);
			}
		}

		/// <summary>
		/// Writes a <c>ImportScope</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawImportScopeRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Parent);
				columns1.Write24(writer, row.Imports);
			}
		}

		/// <summary>
		/// Writes a <c>StateMachineMethod</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawStateMachineMethodRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.MoveNextMethod);
				columns1.Write24(writer, row.KickoffMethod);
			}
		}

		/// <summary>
		/// Writes a <c>CustomDebugInformation</c> table
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="metadata">Metadata</param>
		/// <param name="table">Table</param>
		public static void Write(this DataWriter writer, Metadata metadata, MDTable<RawCustomDebugInformationRow> table) {
			var columns = table.TableInfo.Columns;
			var columns0 = columns[0];
			var columns1 = columns[1];
			var columns2 = columns[2];
			for (int i = 0; i < table.Rows; i++) {
				var row = table[(uint)i + 1];
				columns0.Write24(writer, row.Parent);
				columns1.Write24(writer, row.Kind);
				columns2.Write24(writer, row.Value);
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="Metadata"/> flags
	/// </summary>
	[Flags]
	public enum MetadataFlags : uint {
		/// <summary>
		/// Preserves all rids in the <c>TypeRef</c> table
		/// </summary>
		PreserveTypeRefRids = 1,

		/// <summary>
		/// Preserves all rids in the <c>TypeDef</c> table
		/// </summary>
		PreserveTypeDefRids = 2,

		/// <summary>
		/// Preserves all rids in the <c>Field</c> table
		/// </summary>
		PreserveFieldRids = 4,

		/// <summary>
		/// Preserves all rids in the <c>Method</c> table
		/// </summary>
		PreserveMethodRids = 8,

		/// <summary>
		/// Preserves all rids in the <c>Param</c> table
		/// </summary>
		PreserveParamRids = 0x10,

		/// <summary>
		/// Preserves all rids in the <c>MemberRef</c> table
		/// </summary>
		PreserveMemberRefRids = 0x20,

		/// <summary>
		/// Preserves all rids in the <c>StandAloneSig</c> table
		/// </summary>
		PreserveStandAloneSigRids = 0x40,

		/// <summary>
		/// Preserves all rids in the <c>Event</c> table
		/// </summary>
		PreserveEventRids = 0x80,

		/// <summary>
		/// Preserves all rids in the <c>Property</c> table
		/// </summary>
		PreservePropertyRids = 0x100,

		/// <summary>
		/// Preserves all rids in the <c>TypeSpec</c> table
		/// </summary>
		PreserveTypeSpecRids = 0x200,

		/// <summary>
		/// Preserves all rids in the <c>MethodSpec</c> table
		/// </summary>
		PreserveMethodSpecRids = 0x400,

		/// <summary>
		/// Preserves all method rids, i.e., <c>Method</c>, <c>MemberRef</c> and
		/// <c>MethodSpec</c> rids.
		/// </summary>
		PreserveAllMethodRids = PreserveMethodRids | PreserveMemberRefRids | PreserveMethodSpecRids,

		/// <summary>
		/// Preserves all rids in the following tables: <c>TypeRef</c>, <c>TypeDef</c>,
		/// <c>Field</c>, <c>Method</c>, <c>Param</c>, <c>MemberRef</c>, <c>StandAloneSig</c>,
		/// <c>Event</c>, <c>Property</c>, <c>TypeSpec</c>, <c>MethodSpec</c>
		/// </summary>
		PreserveRids =	PreserveTypeRefRids |
						PreserveTypeDefRids |
						PreserveFieldRids |
						PreserveMethodRids |
						PreserveParamRids |
						PreserveMemberRefRids |
						PreserveStandAloneSigRids |
						PreserveEventRids |
						PreservePropertyRids |
						PreserveTypeSpecRids |
						PreserveMethodSpecRids,

		/// <summary>
		/// Preserves all offsets in the #Strings heap (the original #Strings heap will be saved
		/// in the new file). Type names, field names, and other non-user strings are stored
		/// in the #Strings heap.
		/// </summary>
		PreserveStringsOffsets = 0x800,

		/// <summary>
		/// Preserves all offsets in the #US heap (the original #US heap will be saved
		/// in the new file). User strings (referenced by the ldstr instruction) are stored in
		/// the #US heap.
		/// </summary>
		PreserveUSOffsets = 0x1000,

		/// <summary>
		/// Preserves all offsets in the #Blob heap (the original #Blob heap will be saved
		/// in the new file). Custom attributes, signatures and other blobs are stored in the
		/// #Blob heap.
		/// </summary>
		PreserveBlobOffsets = 0x2000,

		/// <summary>
		/// Preserves the extra data that is present after the original signature in the #Blob
		/// heap. This extra data shouldn't be present but might be present if an obfuscator
		/// has added this extra data and is eg. using it to decrypt stuff.
		/// </summary>
		PreserveExtraSignatureData = 0x4000,

		/// <summary>
		/// Preserves as much as possible
		/// </summary>
		PreserveAll = PreserveRids | PreserveStringsOffsets | PreserveUSOffsets |
					PreserveBlobOffsets | PreserveExtraSignatureData,

		/// <summary>
		/// The original method body's max stack field should be used and a new one should not
		/// be calculated.
		/// </summary>
		KeepOldMaxStack = 0x8000,

		/// <summary>
		/// Always create the #GUID heap even if it's empty
		/// </summary>
		AlwaysCreateGuidHeap = 0x10000,

		/// <summary>
		/// Always create the #Strings heap even if it's empty
		/// </summary>
		AlwaysCreateStringsHeap = 0x20000,

		/// <summary>
		/// Always create the #US heap even if it's empty
		/// </summary>
		AlwaysCreateUSHeap = 0x40000,

		/// <summary>
		/// Always create the #Blob heap even if it's empty
		/// </summary>
		AlwaysCreateBlobHeap = 0x80000,

		/// <summary>
		/// DEPRECATED:
		/// Sort the InterfaceImpl table the same way Roslyn sorts it. Roslyn doesn't sort it
		/// according to the ECMA spec, see https://github.com/dotnet/roslyn/issues/3905
		/// </summary>
		RoslynSortInterfaceImpl = 0x100000,

		/// <summary>
		/// Don't write method bodies
		/// </summary>
		NoMethodBodies = 0x200000,

		/// <summary>
		/// Don't write .NET resources
		/// </summary>
		NoDotNetResources = 0x400000,

		/// <summary>
		/// Don't write field data
		/// </summary>
		NoFieldData = 0x800000,

		/// <summary>
		/// Serialized type names stored in custom attributes are optimized if the types
		/// exist in the core library (eg. mscorlib/System.Private.CoreLib).
		/// Instead of storing type-name + assembly-name, only type-name is stored. This results in
		/// slightly smaller assemblies.
		/// <br/>
		/// <br/>
		/// If it's a type in the current module, the type name is optimized and no assembly name is stored in the custom attribute.
		/// <br/>
		/// <br/>
		/// This is disabled by default. It's safe to enable if the reference core assembly
		/// is the same as the runtime core assembly (eg. it's mscorlib.dll and .NET Framework,
		/// but not .NET Core / .NET Standard).
		/// </summary>
		OptimizeCustomAttributeSerializedTypeNames = 0x1000000,
	}

	/// <summary>
	/// Metadata heaps event args
	/// </summary>
	public readonly struct MetadataHeapsAddedEventArgs {
		/// <summary>
		/// Gets the metadata writer
		/// </summary>
		public Metadata Metadata { get; }

		/// <summary>
		/// Gets all heaps
		/// </summary>
		public List<IHeap> Heaps { get; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Metadata writer</param>
		/// <param name="heaps">All heaps</param>
		public MetadataHeapsAddedEventArgs(Metadata metadata, List<IHeap> heaps) {
			Metadata = metadata ?? throw new ArgumentNullException(nameof(metadata));
			Heaps = heaps ?? throw new ArgumentNullException(nameof(heaps));
		}
	}

	/// <summary>
	/// <see cref="Metadata"/> options
	/// </summary>
	public sealed class MetadataOptions {
		MetadataHeaderOptions metadataHeaderOptions;
		MetadataHeaderOptions debugMetadataHeaderOptions;
		TablesHeapOptions tablesHeapOptions;
		List<IHeap> customHeaps;

		/// <summary>
		/// Gets/sets the <see cref="MetadataHeader"/> options. This is never <c>null</c>.
		/// </summary>
		public MetadataHeaderOptions MetadataHeaderOptions {
			get => metadataHeaderOptions ??= new MetadataHeaderOptions();
			set => metadataHeaderOptions = value;
		}

		/// <summary>
		/// Gets/sets the debug (portable PDB) <see cref="MetadataHeader"/> options. This is never <c>null</c>.
		/// </summary>
		public MetadataHeaderOptions DebugMetadataHeaderOptions {
			get => debugMetadataHeaderOptions ??= MetadataHeaderOptions.CreatePortablePdbV1_0();
			set => debugMetadataHeaderOptions = value;
		}

		/// <summary>
		/// Gets/sets the <see cref="TablesHeap"/> options. This is never <c>null</c>.
		/// </summary>
		public TablesHeapOptions TablesHeapOptions {
			get => tablesHeapOptions ??= new TablesHeapOptions();
			set => tablesHeapOptions = value;
		}

		/// <summary>
		/// Gets/sets the debug (portable PDB) <see cref="TablesHeap"/> options. This is never <c>null</c>.
		/// </summary>
		public TablesHeapOptions DebugTablesHeapOptions {
			get => tablesHeapOptions ??= TablesHeapOptions.CreatePortablePdbV1_0();
			set => tablesHeapOptions = value;
		}

		/// <summary>
		/// Various options
		/// </summary>
		public MetadataFlags Flags;

		/// <summary>
		/// Extra heaps to add to the metadata. Also see <see cref="MetadataHeapsAdded"/> and <see cref="PreserveHeapOrder(ModuleDef, bool)"/>
		/// </summary>
		public List<IHeap> CustomHeaps => customHeaps ??= new List<IHeap>();

		/// <summary>
		/// Raised after all heaps have been added. The caller can sort the list if needed
		/// </summary>
		public event EventHandler2<MetadataHeapsAddedEventArgs> MetadataHeapsAdded;
		internal void RaiseMetadataHeapsAdded(MetadataHeapsAddedEventArgs e) => MetadataHeapsAdded?.Invoke(e.Metadata, e);

		/// <summary>
		/// Preserves the original order of heaps, and optionally adds all custom heaps to <see cref="CustomHeaps"/>.
		/// </summary>
		/// <param name="module">Original module with the heaps</param>
		/// <param name="addCustomHeaps">If true, all custom streams are added to <see cref="CustomHeaps"/></param>
		public void PreserveHeapOrder(ModuleDef module, bool addCustomHeaps) {
			if (module is null)
				throw new ArgumentNullException(nameof(module));
			if (module is ModuleDefMD mod) {
				if (addCustomHeaps) {
					var otherStreams = mod.Metadata.AllStreams.Where(a => a.GetType() == typeof(CustomDotNetStream)).Select(a => new DataReaderHeap(a));
					CustomHeaps.AddRange(otherStreams.OfType<IHeap>());
				}
				var streamToOrder = new Dictionary<DotNetStream, int>(mod.Metadata.AllStreams.Count);
				for (int i = 0, order = 0; i < mod.Metadata.AllStreams.Count; i++) {
					var stream = mod.Metadata.AllStreams[i];
					if (stream.StartOffset == 0)
						continue;
					streamToOrder.Add(stream, order++);
				}
				var nameToOrder = new Dictionary<string, int>(mod.Metadata.AllStreams.Count, StringComparer.Ordinal);
				for (int i = 0, order = 0; i < mod.Metadata.AllStreams.Count; i++) {
					var stream = mod.Metadata.AllStreams[i];
					if (stream.StartOffset == 0)
						continue;
					bool isKnownStream = stream is BlobStream || stream is GuidStream ||
						stream is PdbStream || stream is StringsStream || stream is TablesStream || stream is USStream;
					if (!nameToOrder.ContainsKey(stream.Name) || isKnownStream)
						nameToOrder[stream.Name] = order;
					order++;
				}
				MetadataHeapsAdded += (s, e) => {
					e.Heaps.Sort((a, b) => {
						int oa = GetOrder(streamToOrder, nameToOrder, a);
						int ob = GetOrder(streamToOrder, nameToOrder, b);
						int c = oa - ob;
						if (c != 0)
							return c;
						return StringComparer.Ordinal.Compare(a.Name, b.Name);
					});
				};
			}
		}

		static int GetOrder(Dictionary<DotNetStream, int> streamToOrder, Dictionary<string, int> nameToOrder, IHeap heap) {
			if (heap is DataReaderHeap drHeap && drHeap.OptionalOriginalStream is DotNetStream dnHeap && streamToOrder.TryGetValue(dnHeap, out int order))
				return order;
			if (nameToOrder.TryGetValue(heap.Name, out order))
				return order;

			return int.MaxValue;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public MetadataOptions() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="flags">Flags</param>
		public MetadataOptions(MetadataFlags flags) => Flags = flags;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="mdhOptions">Meta data header options</param>
		public MetadataOptions(MetadataHeaderOptions mdhOptions) => metadataHeaderOptions = mdhOptions;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="mdhOptions">Meta data header options</param>
		/// <param name="flags">Flags</param>
		public MetadataOptions(MetadataHeaderOptions mdhOptions, MetadataFlags flags) {
			Flags = flags;
			metadataHeaderOptions = mdhOptions;
		}
	}

	sealed class DataWriterContext {
		public readonly MemoryStream OutStream;
		public readonly DataWriter Writer;
		public DataWriterContext() {
			OutStream = new MemoryStream();
			Writer = new DataWriter(OutStream);
		}
	}

	/// <summary>
	/// Portable PDB metadata kind
	/// </summary>
	public enum DebugMetadataKind {
		/// <summary>
		/// No debugging metadata
		/// </summary>
		None,

		/// <summary>
		/// Standalone / embedded portable PDB metadata
		/// </summary>
		Standalone,
	}

	/// <summary>
	/// Metadata writer event args
	/// </summary>
	public readonly struct MetadataWriterEventArgs {
		/// <summary>
		/// Gets the metadata writer
		/// </summary>
		public Metadata Metadata { get; }

		/// <summary>
		/// Gets the event
		/// </summary>
		public MetadataEvent Event { get; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Writer</param>
		/// <param name="event">Event</param>
		public MetadataWriterEventArgs(Metadata metadata, MetadataEvent @event) {
			Metadata = metadata ?? throw new ArgumentNullException(nameof(metadata));
			Event = @event;
		}
	}

	/// <summary>
	/// Metadata writer progress event args
	/// </summary>
	public readonly struct MetadataProgressEventArgs {
		/// <summary>
		/// Gets the metadata writer
		/// </summary>
		public Metadata Metadata { get; }

		/// <summary>
		/// Gets the progress, 0.0 - 1.0
		/// </summary>
		public double Progress { get; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Writer</param>
		/// <param name="progress">Progress, 0.0 - 1.0</param>
		public MetadataProgressEventArgs(Metadata metadata, double progress) {
			if (progress < 0 || progress > 1)
				throw new ArgumentOutOfRangeException(nameof(progress));
			Metadata = metadata ?? throw new ArgumentNullException(nameof(metadata));
			Progress = progress;
		}
	}

	/// <summary>
	/// .NET meta data
	/// </summary>
	public abstract class Metadata : IReuseChunk, ISignatureWriterHelper, ITokenProvider, ICustomAttributeWriterHelper, IPortablePdbCustomDebugInfoWriterHelper, IWriterError2 {
		uint length;
		FileOffset offset;
		RVA rva;
		readonly MetadataOptions options;
		ILogger logger;
		readonly NormalMetadata debugMetadata;
		readonly bool isStandaloneDebugMetadata;
		internal readonly ModuleDef module;
		internal readonly UniqueChunkList<ByteArrayChunk> constants;
		internal readonly MethodBodyChunks methodBodies;
		internal readonly NetResources netResources;
		internal readonly MetadataHeader metadataHeader;
		internal readonly PdbHeap pdbHeap;
		internal readonly TablesHeap tablesHeap;
		internal readonly StringsHeap stringsHeap;
		internal readonly USHeap usHeap;
		internal readonly GuidHeap guidHeap;
		internal readonly BlobHeap blobHeap;
		internal TypeDef[] allTypeDefs;
		internal readonly Rows<ModuleDef> moduleDefInfos = new Rows<ModuleDef>();
		internal readonly SortedRows<InterfaceImpl, RawInterfaceImplRow> interfaceImplInfos = new SortedRows<InterfaceImpl, RawInterfaceImplRow>();
		internal readonly SortedRows<IHasConstant, RawConstantRow> hasConstantInfos = new SortedRows<IHasConstant, RawConstantRow>();
		internal readonly SortedRows<CustomAttribute, RawCustomAttributeRow> customAttributeInfos = new SortedRows<CustomAttribute, RawCustomAttributeRow>();
		internal readonly SortedRows<IHasFieldMarshal, RawFieldMarshalRow> fieldMarshalInfos = new SortedRows<IHasFieldMarshal, RawFieldMarshalRow>();
		internal readonly SortedRows<DeclSecurity, RawDeclSecurityRow> declSecurityInfos = new SortedRows<DeclSecurity, RawDeclSecurityRow>();
		internal readonly SortedRows<TypeDef, RawClassLayoutRow> classLayoutInfos = new SortedRows<TypeDef, RawClassLayoutRow>();
		internal readonly SortedRows<FieldDef, RawFieldLayoutRow> fieldLayoutInfos = new SortedRows<FieldDef, RawFieldLayoutRow>();
		internal readonly Rows<TypeDef> eventMapInfos = new Rows<TypeDef>();
		internal readonly Rows<TypeDef> propertyMapInfos = new Rows<TypeDef>();
		internal readonly SortedRows<MethodDef, RawMethodSemanticsRow> methodSemanticsInfos = new SortedRows<MethodDef, RawMethodSemanticsRow>();
		internal readonly SortedRows<MethodDef, RawMethodImplRow> methodImplInfos = new SortedRows<MethodDef, RawMethodImplRow>();
		internal readonly Rows<ModuleRef> moduleRefInfos = new Rows<ModuleRef>();
		internal readonly SortedRows<IMemberForwarded, RawImplMapRow> implMapInfos = new SortedRows<IMemberForwarded, RawImplMapRow>();
		internal readonly SortedRows<FieldDef, RawFieldRVARow> fieldRVAInfos = new SortedRows<FieldDef, RawFieldRVARow>();
		internal readonly Rows<AssemblyDef> assemblyInfos = new Rows<AssemblyDef>();
		internal readonly Rows<AssemblyRef> assemblyRefInfos = new Rows<AssemblyRef>();
		internal readonly Rows<FileDef> fileDefInfos = new Rows<FileDef>();
		internal readonly Rows<ExportedType> exportedTypeInfos = new Rows<ExportedType>();
		internal readonly Rows<Resource> manifestResourceInfos = new Rows<Resource>();
		internal readonly SortedRows<TypeDef, RawNestedClassRow> nestedClassInfos = new SortedRows<TypeDef, RawNestedClassRow>();
		internal readonly SortedRows<GenericParam, RawGenericParamRow> genericParamInfos = new SortedRows<GenericParam, RawGenericParamRow>();
		internal readonly SortedRows<GenericParamConstraint, RawGenericParamConstraintRow> genericParamConstraintInfos = new SortedRows<GenericParamConstraint, RawGenericParamConstraintRow>();
		internal readonly Dictionary<MethodDef, MethodBody> methodToBody = new Dictionary<MethodDef, MethodBody>();
		internal readonly Dictionary<MethodDef, NativeMethodBody> methodToNativeBody = new Dictionary<MethodDef, NativeMethodBody>();
		internal readonly Dictionary<EmbeddedResource, DataReaderChunk> embeddedResourceToByteArray = new Dictionary<EmbeddedResource, DataReaderChunk>();
		readonly Dictionary<FieldDef, ByteArrayChunk> fieldToInitialValue = new Dictionary<FieldDef, ByteArrayChunk>();
		readonly Rows<PdbDocument> pdbDocumentInfos = new Rows<PdbDocument>();
		bool methodDebugInformationInfosUsed;
		readonly SortedRows<PdbScope, RawLocalScopeRow> localScopeInfos = new SortedRows<PdbScope, RawLocalScopeRow>();
		readonly Rows<PdbLocal> localVariableInfos = new Rows<PdbLocal>();
		readonly Rows<PdbConstant> localConstantInfos = new Rows<PdbConstant>();
		readonly Rows<PdbImportScope> importScopeInfos = new Rows<PdbImportScope>();
		readonly SortedRows<PdbCustomDebugInfo, RawStateMachineMethodRow> stateMachineMethodInfos = new SortedRows<PdbCustomDebugInfo, RawStateMachineMethodRow>();
		readonly SortedRows<PdbCustomDebugInfo, RawCustomDebugInformationRow> customDebugInfos = new SortedRows<PdbCustomDebugInfo, RawCustomDebugInformationRow>();
		readonly List<DataWriterContext> binaryWriterContexts = new List<DataWriterContext>();
		readonly List<SerializerMethodContext> serializerMethodContexts = new List<SerializerMethodContext>();
		readonly List<MethodDef> exportedMethods = new List<MethodDef>();

		/// <summary>
		/// Raised at various times when writing the metadata
		/// </summary>
		public event EventHandler2<MetadataWriterEventArgs> MetadataEvent;

		/// <summary>
		/// Raised when the progress is updated
		/// </summary>
		public event EventHandler2<MetadataProgressEventArgs> ProgressUpdated;

		/// <summary>
		/// Gets/sets the logger
		/// </summary>
		public ILogger Logger {
			get => logger;
			set => logger = value;
		}

		/// <summary>
		/// Gets the module
		/// </summary>
		public ModuleDef Module => module;

		/// <summary>
		/// Gets the constants
		/// </summary>
		public UniqueChunkList<ByteArrayChunk> Constants => constants;

		/// <summary>
		/// Gets the method body chunks
		/// </summary>
		public MethodBodyChunks MethodBodyChunks => methodBodies;

		/// <summary>
		/// Gets the .NET resources
		/// </summary>
		public NetResources NetResources => netResources;

		/// <summary>
		/// Gets the MD header
		/// </summary>
		public MetadataHeader MetadataHeader => metadataHeader;

		/// <summary>
		/// Gets the tables heap. Access to this heap is not recommended, but is useful if you
		/// want to add random table entries.
		/// </summary>
		public TablesHeap TablesHeap => tablesHeap;

		/// <summary>
		/// Gets the #Strings heap. Access to this heap is not recommended, but is useful if you
		/// want to add random strings.
		/// </summary>
		public StringsHeap StringsHeap => stringsHeap;

		/// <summary>
		/// Gets the #US heap. Access to this heap is not recommended, but is useful if
		/// you want to add random user strings.
		/// </summary>
		public USHeap USHeap => usHeap;

		/// <summary>
		/// Gets the #GUID heap. Access to this heap is not recommended, but is useful if you
		/// want to add random GUIDs.
		/// </summary>
		public GuidHeap GuidHeap => guidHeap;

		/// <summary>
		/// Gets the #Blob heap. Access to this heap is not recommended, but is useful if you
		/// want to add random blobs.
		/// </summary>
		public BlobHeap BlobHeap => blobHeap;

		/// <summary>
		/// Gets the #Pdb heap. It's only used if it's portable PDB metadata
		/// </summary>
		public PdbHeap PdbHeap => pdbHeap;

		/// <summary>
		/// Gets all exported methods
		/// </summary>
		public List<MethodDef> ExportedMethods => exportedMethods;

		/// <summary>
		/// The public key that should be used instead of the one in <see cref="AssemblyDef"/>.
		/// </summary>
		internal byte[] AssemblyPublicKey { get; set; }

		internal sealed class SortedRows<T, TRow> where T : class where TRow : struct {
			public List<Info> infos = new List<Info>();
			Dictionary<T, uint> toRid = new Dictionary<T, uint>();
			bool isSorted;

			public struct Info {
				public readonly T data;
				public /*readonly*/ TRow row;
				public Info(T data, ref TRow row) {
					this.data = data;
					this.row = row;
				}
			}

			public void Add(T data, TRow row) {
				if (isSorted)
					throw new ModuleWriterException($"Adding a row after it's been sorted. Table: {row.GetType()}");
				infos.Add(new Info(data, ref row));
				toRid[data] = (uint)toRid.Count + 1;
			}

			public void Sort(Comparison<Info> comparison) {
				infos.Sort(CreateComparison(comparison));
				toRid.Clear();
				for (int i = 0; i < infos.Count; i++)
					toRid[infos[i].data] = (uint)i + 1;
				isSorted = true;
			}

			Comparison<Info> CreateComparison(Comparison<Info> comparison) =>
				(a, b) => {
					int c = comparison(a, b);
					if (c != 0)
						return c;
					// Make sure it's a stable sort
					return toRid[a.data].CompareTo(toRid[b.data]);
				};

			public uint Rid(T data) => toRid[data];

			public bool TryGetRid(T data, out uint rid) {
				if (data is null) {
					rid = 0;
					return false;
				}
				return toRid.TryGetValue(data, out rid);
			}
		}

		internal sealed class Rows<T> where T : class {
			Dictionary<T, uint> dict = new Dictionary<T, uint>();

			public int Count => dict.Count;

			public bool TryGetRid(T value, out uint rid) {
				if (value is null) {
					rid = 0;
					return false;
				}
				return dict.TryGetValue(value, out rid);
			}

			public bool Exists(T value) => dict.ContainsKey(value);
			public void Add(T value, uint rid) => dict.Add(value, rid);
			public uint Rid(T value) => dict[value];
			public void SetRid(T value, uint rid) => dict[value] = rid;
		}

		/// <summary>
		/// Creates a <see cref="Metadata"/> instance
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="constants">Constants list</param>
		/// <param name="methodBodies">Method bodies list</param>
		/// <param name="netResources">.NET resources list</param>
		/// <param name="options">Options</param>
		/// <param name="debugKind">Debug metadata kind</param>
		/// <returns>A new <see cref="Metadata"/> instance</returns>
		public static Metadata Create(ModuleDef module, UniqueChunkList<ByteArrayChunk> constants, MethodBodyChunks methodBodies, NetResources netResources, MetadataOptions options = null, DebugMetadataKind debugKind = DebugMetadataKind.None) {
			if (options is null)
				options = new MetadataOptions();
			if ((options.Flags & MetadataFlags.PreserveRids) != 0 && module is ModuleDefMD)
				return new PreserveTokensMetadata(module, constants, methodBodies, netResources, options, debugKind, false);
			return new NormalMetadata(module, constants, methodBodies, netResources, options, debugKind, false);
		}

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveTypeRefRids"/> bit
		/// </summary>
		public bool PreserveTypeRefRids => (options.Flags & MetadataFlags.PreserveTypeRefRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveTypeDefRids"/> bit
		/// </summary>
		public bool PreserveTypeDefRids => (options.Flags & MetadataFlags.PreserveTypeDefRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveFieldRids"/> bit
		/// </summary>
		public bool PreserveFieldRids => (options.Flags & MetadataFlags.PreserveFieldRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveMethodRids"/> bit
		/// </summary>
		public bool PreserveMethodRids => (options.Flags & MetadataFlags.PreserveMethodRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveParamRids"/> bit
		/// </summary>
		public bool PreserveParamRids => (options.Flags & MetadataFlags.PreserveParamRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveMemberRefRids"/> bit
		/// </summary>
		public bool PreserveMemberRefRids => (options.Flags & MetadataFlags.PreserveMemberRefRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveStandAloneSigRids"/> bit
		/// </summary>
		public bool PreserveStandAloneSigRids => (options.Flags & MetadataFlags.PreserveStandAloneSigRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveEventRids"/> bit
		/// </summary>
		public bool PreserveEventRids => (options.Flags & MetadataFlags.PreserveEventRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreservePropertyRids"/> bit
		/// </summary>
		public bool PreservePropertyRids => (options.Flags & MetadataFlags.PreservePropertyRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveTypeSpecRids"/> bit
		/// </summary>
		public bool PreserveTypeSpecRids => (options.Flags & MetadataFlags.PreserveTypeSpecRids) != 0;

		/// <summary>
		/// Gets the <see cref="MetadataFlags.PreserveMethodSpecRids"/> bit
		/// </summary>
		public bool PreserveMethodSpecRids => (options.Flags & MetadataFlags.PreserveMethodSpecRids) != 0;

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.PreserveStringsOffsets"/> bit
		/// </summary>
		public bool PreserveStringsOffsets {
			get => (options.Flags & MetadataFlags.PreserveStringsOffsets) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.PreserveStringsOffsets;
				else
					options.Flags &= ~MetadataFlags.PreserveStringsOffsets;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.PreserveUSOffsets"/> bit
		/// </summary>
		public bool PreserveUSOffsets {
			get => (options.Flags & MetadataFlags.PreserveUSOffsets) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.PreserveUSOffsets;
				else
					options.Flags &= ~MetadataFlags.PreserveUSOffsets;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.PreserveBlobOffsets"/> bit
		/// </summary>
		public bool PreserveBlobOffsets {
			get => (options.Flags & MetadataFlags.PreserveBlobOffsets) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.PreserveBlobOffsets;
				else
					options.Flags &= ~MetadataFlags.PreserveBlobOffsets;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.PreserveExtraSignatureData"/> bit
		/// </summary>
		public bool PreserveExtraSignatureData {
			get => (options.Flags & MetadataFlags.PreserveExtraSignatureData) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.PreserveExtraSignatureData;
				else
					options.Flags &= ~MetadataFlags.PreserveExtraSignatureData;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.KeepOldMaxStack"/> bit
		/// </summary>
		public bool KeepOldMaxStack {
			get => (options.Flags & MetadataFlags.KeepOldMaxStack) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.KeepOldMaxStack;
				else
					options.Flags &= ~MetadataFlags.KeepOldMaxStack;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.AlwaysCreateGuidHeap"/> bit
		/// </summary>
		public bool AlwaysCreateGuidHeap {
			get => (options.Flags & MetadataFlags.AlwaysCreateGuidHeap) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.AlwaysCreateGuidHeap;
				else
					options.Flags &= ~MetadataFlags.AlwaysCreateGuidHeap;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.AlwaysCreateStringsHeap"/> bit
		/// </summary>
		public bool AlwaysCreateStringsHeap {
			get => (options.Flags & MetadataFlags.AlwaysCreateStringsHeap) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.AlwaysCreateStringsHeap;
				else
					options.Flags &= ~MetadataFlags.AlwaysCreateStringsHeap;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.AlwaysCreateUSHeap"/> bit
		/// </summary>
		public bool AlwaysCreateUSHeap {
			get => (options.Flags & MetadataFlags.AlwaysCreateUSHeap) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.AlwaysCreateUSHeap;
				else
					options.Flags &= ~MetadataFlags.AlwaysCreateUSHeap;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.AlwaysCreateBlobHeap"/> bit
		/// </summary>
		public bool AlwaysCreateBlobHeap {
			get => (options.Flags & MetadataFlags.AlwaysCreateBlobHeap) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.AlwaysCreateBlobHeap;
				else
					options.Flags &= ~MetadataFlags.AlwaysCreateBlobHeap;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.RoslynSortInterfaceImpl"/> bit
		/// </summary>
		public bool RoslynSortInterfaceImpl {
			get => (options.Flags & MetadataFlags.RoslynSortInterfaceImpl) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.RoslynSortInterfaceImpl;
				else
					options.Flags &= ~MetadataFlags.RoslynSortInterfaceImpl;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.NoMethodBodies"/> bit
		/// </summary>
		public bool NoMethodBodies {
			get => (options.Flags & MetadataFlags.NoMethodBodies) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.NoMethodBodies;
				else
					options.Flags &= ~MetadataFlags.NoMethodBodies;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.NoDotNetResources"/> bit
		/// </summary>
		public bool NoDotNetResources {
			get => (options.Flags & MetadataFlags.NoDotNetResources) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.NoDotNetResources;
				else
					options.Flags &= ~MetadataFlags.NoDotNetResources;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.NoFieldData"/> bit
		/// </summary>
		public bool NoFieldData {
			get => (options.Flags & MetadataFlags.NoFieldData) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.NoFieldData;
				else
					options.Flags &= ~MetadataFlags.NoFieldData;
			}
		}

		/// <summary>
		/// Gets/sets the <see cref="MetadataFlags.OptimizeCustomAttributeSerializedTypeNames"/> bit
		/// </summary>
		public bool OptimizeCustomAttributeSerializedTypeNames {
			get => (options.Flags & MetadataFlags.OptimizeCustomAttributeSerializedTypeNames) != 0;
			set {
				if (value)
					options.Flags |= MetadataFlags.OptimizeCustomAttributeSerializedTypeNames;
				else
					options.Flags &= ~MetadataFlags.OptimizeCustomAttributeSerializedTypeNames;
			}
		}

		/// <summary>
		/// If <c>true</c>, use the original Field RVAs. If it has no RVA, assume it's a new
		/// field value and create a new Field RVA.
		/// </summary>
		internal bool KeepFieldRVA { get; set; }

		/// <summary>
		/// Gets the number of methods that will be written.
		/// </summary>
		protected abstract int NumberOfMethods { get; }

		internal Metadata(ModuleDef module, UniqueChunkList<ByteArrayChunk> constants, MethodBodyChunks methodBodies, NetResources netResources, MetadataOptions options, DebugMetadataKind debugKind, bool isStandaloneDebugMetadata) {
			this.module = module;
			this.constants = constants;
			this.methodBodies = methodBodies;
			this.netResources = netResources;
			this.options = options ?? new MetadataOptions();
			metadataHeader = new MetadataHeader(isStandaloneDebugMetadata ? this.options.DebugMetadataHeaderOptions : this.options.MetadataHeaderOptions);
			tablesHeap = new TablesHeap(this, isStandaloneDebugMetadata ? this.options.DebugTablesHeapOptions : this.options.TablesHeapOptions);
			stringsHeap = new StringsHeap();
			usHeap = new USHeap();
			guidHeap = new GuidHeap();
			blobHeap = new BlobHeap();
			pdbHeap = new PdbHeap();

			this.isStandaloneDebugMetadata = isStandaloneDebugMetadata;
			switch (debugKind) {
			case DebugMetadataKind.None:
				break;

			case DebugMetadataKind.Standalone:
				Debug.Assert(!isStandaloneDebugMetadata);
				//TODO: Refactor this into a smaller class
				debugMetadata = new NormalMetadata(module, constants, methodBodies, netResources, options, DebugMetadataKind.None, true);
				break;

			default:
				throw new ArgumentOutOfRangeException(nameof(debugKind));
			}
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="module">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(ModuleDef module) {
			moduleDefInfos.TryGetRid(module, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="tr">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(TypeRef tr);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(TypeDef td);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="fd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(FieldDef fd);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="md">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(MethodDef md);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="pd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(ParamDef pd);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ii">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(InterfaceImpl ii) {
			interfaceImplInfos.TryGetRid(ii, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="mr">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(MemberRef mr);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="hc">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetConstantRid(IHasConstant hc) {
			hasConstantInfos.TryGetRid(hc, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ca">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetCustomAttributeRid(CustomAttribute ca) {
			customAttributeInfos.TryGetRid(ca, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="hfm">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetFieldMarshalRid(IHasFieldMarshal hfm) {
			fieldMarshalInfos.TryGetRid(hfm, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ds">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(DeclSecurity ds) {
			declSecurityInfos.TryGetRid(ds, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetClassLayoutRid(TypeDef td) {
			classLayoutInfos.TryGetRid(td, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="fd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetFieldLayoutRid(FieldDef fd) {
			fieldLayoutInfos.TryGetRid(fd, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="sas">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(StandAloneSig sas);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetEventMapRid(TypeDef td) {
			eventMapInfos.TryGetRid(td, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ed">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(EventDef ed);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetPropertyMapRid(TypeDef td) {
			propertyMapInfos.TryGetRid(td, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="pd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(PropertyDef pd);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="md">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetMethodSemanticsRid(MethodDef md) {
			methodSemanticsInfos.TryGetRid(md, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="mr">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(ModuleRef mr) {
			moduleRefInfos.TryGetRid(mr, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ts">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(TypeSpec ts);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="mf">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetImplMapRid(IMemberForwarded mf) {
			implMapInfos.TryGetRid(mf, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="fd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetFieldRVARid(FieldDef fd) {
			fieldRVAInfos.TryGetRid(fd, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="asm">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(AssemblyDef asm) {
			assemblyInfos.TryGetRid(asm, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="asmRef">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(AssemblyRef asmRef) {
			assemblyRefInfos.TryGetRid(asmRef, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="fd">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(FileDef fd) {
			fileDefInfos.TryGetRid(fd, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="et">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(ExportedType et) {
			exportedTypeInfos.TryGetRid(et, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="resource">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetManifestResourceRid(Resource resource) {
			manifestResourceInfos.TryGetRid(resource, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="td">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetNestedClassRid(TypeDef td) {
			nestedClassInfos.TryGetRid(td, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="gp">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(GenericParam gp) {
			genericParamInfos.TryGetRid(gp, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="ms">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public abstract uint GetRid(MethodSpec ms);

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="gpc">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(GenericParamConstraint gpc) {
			genericParamConstraintInfos.TryGetRid(gpc, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="doc">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbDocument doc) {
			if (debugMetadata is null)
				return 0;
			debugMetadata.pdbDocumentInfos.TryGetRid(doc, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="scope">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbScope scope) {
			if (debugMetadata is null)
				return 0;
			debugMetadata.localScopeInfos.TryGetRid(scope, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="local">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbLocal local) {
			if (debugMetadata is null)
				return 0;
			debugMetadata.localVariableInfos.TryGetRid(local, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="constant">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbConstant constant) {
			if (debugMetadata is null)
				return 0;

			debugMetadata.localConstantInfos.TryGetRid(constant, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="importScope">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetRid(PdbImportScope importScope) {
			if (debugMetadata is null)
				return 0;
			debugMetadata.importScopeInfos.TryGetRid(importScope, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="asyncMethod">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetStateMachineMethodRid(PdbAsyncMethodCustomDebugInfo asyncMethod) {
			if (debugMetadata is null)
				return 0;
			debugMetadata.stateMachineMethodInfos.TryGetRid(asyncMethod, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="iteratorMethod">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetStateMachineMethodRid(PdbIteratorMethodCustomDebugInfo iteratorMethod) {
			if (debugMetadata is null)
				return 0;
			debugMetadata.stateMachineMethodInfos.TryGetRid(iteratorMethod, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the new rid
		/// </summary>
		/// <param name="cdi">Value</param>
		/// <returns>Its new rid or <c>0</c></returns>
		public uint GetCustomDebugInfoRid(PdbCustomDebugInfo cdi) {
			if (debugMetadata is null)
				return 0;
			debugMetadata.customDebugInfos.TryGetRid(cdi, out uint rid);
			return rid;
		}

		/// <summary>
		/// Gets the <see cref="MethodBody"/>
		/// </summary>
		/// <param name="md">Method</param>
		/// <returns>The <see cref="MethodBody"/> or <c>null</c> if <paramref name="md"/> is
		/// <c>null</c> or not a method defined in this module.</returns>
		public MethodBody GetMethodBody(MethodDef md) {
			if (md is null)
				return null;
			methodToBody.TryGetValue(md, out var mb);
			return mb;
		}

		/// <summary>
		/// Gets a method's local variable signature token
		/// </summary>
		/// <param name="md">Method</param>
		/// <returns>Locals sig token or <c>0</c></returns>
		public uint GetLocalVarSigToken(MethodDef md) => GetMethodBody(md)?.LocalVarSigTok ?? 0;

		/// <summary>
		/// Gets the <see cref="DataReaderChunk"/> where the resource data will be stored
		/// </summary>
		/// <param name="er">Embedded resource</param>
		/// <returns>A <see cref="DataReaderChunk"/> instance or <c>null</c> if <paramref name="er"/>
		/// is invalid</returns>
		public DataReaderChunk GetChunk(EmbeddedResource er) {
			if (er is null)
				return null;
			embeddedResourceToByteArray.TryGetValue(er, out var chunk);
			return chunk;
		}

		/// <summary>
		/// Gets the <see cref="ByteArrayChunk"/> where the initial value is stored
		/// </summary>
		/// <param name="fd">Field</param>
		/// <returns>A <see cref="ByteArrayChunk"/> instance or <c>null</c> if <paramref name="fd"/>
		/// is invalid</returns>
		public ByteArrayChunk GetInitialValueChunk(FieldDef fd) {
			if (fd is null)
				return null;
			fieldToInitialValue.TryGetValue(fd, out var chunk);
			return chunk;
		}

		ILogger GetLogger() => logger ?? DummyLogger.ThrowModuleWriterExceptionOnErrorInstance;

		/// <summary>
		/// Called when an error is detected
		/// </summary>
		/// <param name="message">Error message</param>
		/// <param name="args">Optional message arguments</param>
		protected void Error(string message, params object[] args) => GetLogger().Log(this, LoggerEvent.Error, message, args);

		/// <summary>
		/// Called to warn of something
		/// </summary>
		/// <param name="message">Warning message</param>
		/// <param name="args">Optional message arguments</param>
		protected void Warning(string message, params object[] args) => GetLogger().Log(this, LoggerEvent.Warning, message, args);

		/// <summary>
		/// Raises <see cref="MetadataEvent"/>
		/// </summary>
		/// <param name="evt">Event</param>
		protected void OnMetadataEvent(MetadataEvent evt) {
			RaiseProgress(evt, 0);
			MetadataEvent?.Invoke(this, new MetadataWriterEventArgs(this, evt));
		}

		static readonly double[] eventToProgress = new double[(int)Writer.MetadataEvent.EndCreateTables - (int)Writer.MetadataEvent.BeginCreateTables + 1 + 1] {
			0,					// BeginCreateTables
			0.00134240009466231,// AllocateTypeDefRids
			0.00257484711254305,// AllocateMemberDefRids
			0.0762721800615359,	// MemberDefRidsAllocated
			0.196633787905108,	// MemberDefsInitialized
			0.207788892253819,	// BeforeSortTables
			0.270543867900699,	// MostTablesSorted
			0.451478814851716,	// MemberDefCustomAttributesWritten
			0.451478949929206,	// BeginAddResources
			0.454664752528583,	// EndAddResources
			0.454664887606073,	// BeginWriteMethodBodies
			0.992591810143725,	// EndWriteMethodBodies
			0.999984331011171,	// OnAllTablesSorted
			1,					// EndCreateTables
			1,// An extra one so we can get the next base progress without checking the index
		};

		/// <summary>
		/// Raises the progress event
		/// </summary>
		/// <param name="evt">Base event</param>
		/// <param name="subProgress">Sub progress</param>
		protected void RaiseProgress(MetadataEvent evt, double subProgress) {
			subProgress = Math.Min(1, Math.Max(0, subProgress));
			var baseProgress = eventToProgress[(int)evt];
			var nextProgress = eventToProgress[(int)evt + 1];
			var progress = baseProgress + (nextProgress - baseProgress) * subProgress;
			progress = Math.Min(1, Math.Max(0, progress));
			ProgressUpdated?.Invoke(this, new MetadataProgressEventArgs(this, progress));
		}

		/// <summary>
		/// Creates the .NET metadata tables
		/// </summary>
		public void CreateTables() {
			OnMetadataEvent(Writer.MetadataEvent.BeginCreateTables);

			if (module.Types.Count == 0 || module.Types[0] is null)
				throw new ModuleWriterException("Missing global <Module> type");

			if (module is ModuleDefMD moduleDefMD) {
				if (PreserveStringsOffsets)
					stringsHeap.Populate(moduleDefMD.StringsStream);
				if (PreserveUSOffsets)
					usHeap.Populate(moduleDefMD.USStream);
				if (PreserveBlobOffsets)
					blobHeap.Populate(moduleDefMD.BlobStream);
			}

			Create();
		}

		/// <summary>
		/// Updates each <c>Method</c> row's <c>RVA</c> column if it has any code
		/// </summary>
		void UpdateMethodRvas() {
			foreach (var kv in methodToBody) {
				var method = kv.Key;
				var body = kv.Value;
				uint rid = GetRid(method);
				var row = tablesHeap.MethodTable[rid];
				row = new RawMethodRow((uint)body.RVA, row.ImplFlags, row.Flags, row.Name, row.Signature, row.ParamList);
				tablesHeap.MethodTable[rid] = row;
			}
			foreach (var kv in methodToNativeBody) {
				var method = kv.Key;
				var body = kv.Value;
				uint rid = GetRid(method);
				var row = tablesHeap.MethodTable[rid];
				row = new RawMethodRow((uint)body.RVA, row.ImplFlags, row.Flags, row.Name, row.Signature, row.ParamList);
				tablesHeap.MethodTable[rid] = row;
			}
		}

		/// <summary>
		/// Updates the <c>FieldRVA</c> rows
		/// </summary>
		void UpdateFieldRvas() {
			foreach (var kv in fieldToInitialValue) {
				var field = kv.Key;
				var iv = kv.Value;
				uint rid = fieldRVAInfos.Rid(field);
				var row = tablesHeap.FieldRVATable[rid];
				row = new RawFieldRVARow((uint)iv.RVA, row.Field);
				tablesHeap.FieldRVATable[rid] = row;
			}
		}

		void Create() {
			Debug.Assert(!isStandaloneDebugMetadata);
			Initialize();
			allTypeDefs = GetAllTypeDefs();
			OnMetadataEvent(Writer.MetadataEvent.AllocateTypeDefRids);
			AllocateTypeDefRids();
			OnMetadataEvent(Writer.MetadataEvent.AllocateMemberDefRids);
			AllocateMemberDefRids();
			OnMetadataEvent(Writer.MetadataEvent.MemberDefRidsAllocated);

			AddModule(module);
			AddPdbDocuments();
			InitializeMethodDebugInformation();
			InitializeTypeDefsAndMemberDefs();
			OnMetadataEvent(Writer.MetadataEvent.MemberDefsInitialized);

			InitializeVTableFixups();

			AddExportedTypes();
			InitializeEntryPoint();
			if (module.Assembly is not null)
				AddAssembly(module.Assembly, AssemblyPublicKey);

			OnMetadataEvent(Writer.MetadataEvent.BeforeSortTables);
			SortTables();
			InitializeGenericParamConstraintTable();
			OnMetadataEvent(Writer.MetadataEvent.MostTablesSorted);

			WriteTypeDefAndMemberDefCustomAttributesAndCustomDebugInfos();
			OnMetadataEvent(Writer.MetadataEvent.MemberDefCustomAttributesWritten);

			OnMetadataEvent(Writer.MetadataEvent.BeginAddResources);
			AddResources(module.Resources);
			OnMetadataEvent(Writer.MetadataEvent.EndAddResources);

			OnMetadataEvent(Writer.MetadataEvent.BeginWriteMethodBodies);
			WriteMethodBodies();
			OnMetadataEvent(Writer.MetadataEvent.EndWriteMethodBodies);

			BeforeSortingCustomAttributes();
			InitializeCustomAttributeAndCustomDebugInfoTables();
			OnMetadataEvent(Writer.MetadataEvent.OnAllTablesSorted);

			EverythingInitialized();
			OnMetadataEvent(Writer.MetadataEvent.EndCreateTables);
		}

		/// <summary>
		/// Initializes all <c>TypeDef</c>, <c>Field</c>, <c>Method</c>, <c>Event</c>,
		/// <c>Property</c> and <c>Param</c> rows. Other tables that are related to these six
		/// tables are also updated. No custom attributes are written yet, though. Method bodies
		/// aren't written either.
		/// </summary>
		void InitializeTypeDefsAndMemberDefs() {
			int count;
			int numTypes = allTypeDefs.Length;
			int typeNum = 0;
			int notifyNum = 0;
			const int numNotifyEvents = 5;
			int notifyAfter = numTypes / numNotifyEvents;

			foreach (var type in allTypeDefs) {
				if (typeNum++ == notifyAfter && notifyNum < numNotifyEvents) {
					RaiseProgress(Writer.MetadataEvent.MemberDefRidsAllocated, (double)typeNum / numTypes);
					notifyNum++;
					notifyAfter = (int)((double)numTypes / numNotifyEvents * (notifyNum + 1));
				}

				if (type is null) {
					Error("TypeDef is null");
					continue;
				}
				uint typeRid = GetRid(type);
				var typeRow = tablesHeap.TypeDefTable[typeRid];
				typeRow = new RawTypeDefRow((uint)type.Attributes, stringsHeap.Add(type.Name), stringsHeap.Add(type.Namespace), type.BaseType is null ? 0 : AddTypeDefOrRef(type.BaseType), typeRow.FieldList, typeRow.MethodList);
				tablesHeap.TypeDefTable[typeRid] = typeRow;
				AddGenericParams(new MDToken(Table.TypeDef, typeRid), type.GenericParameters);
				AddDeclSecurities(new MDToken(Table.TypeDef, typeRid), type.DeclSecurities);
				AddInterfaceImpls(typeRid, type.Interfaces);
				AddClassLayout(type);
				AddNestedType(type, type.DeclaringType);

				var fields = type.Fields;
				count = fields.Count;
				for (int i = 0; i < count; i++) {
					var field = fields[i];
					if (field is null) {
						Error("Field is null. TypeDef {0} ({1:X8})", type, type.MDToken.Raw);
						continue;
					}
					uint rid = GetRid(field);
					var row = new RawFieldRow((ushort)field.Attributes, stringsHeap.Add(field.Name), GetSignature(field.Signature));
					tablesHeap.FieldTable[rid] = row;
					AddFieldLayout(field);
					AddFieldMarshal(new MDToken(Table.Field, rid), field);
					AddFieldRVA(field);
					AddImplMap(new MDToken(Table.Field, rid), field);
					AddConstant(new MDToken(Table.Field, rid), field);
				}

				var methods = type.Methods;
				count = methods.Count;
				for (int i = 0; i < count; i++) {
					var method = methods[i];
					if (method is null) {
						Error("Method is null. TypeDef {0} ({1:X8})", type, type.MDToken.Raw);
						continue;
					}
					if (method.ExportInfo is not null)
						ExportedMethods.Add(method);
					uint rid = GetRid(method);
					var row = tablesHeap.MethodTable[rid];
					row = new RawMethodRow(row.RVA, (ushort)method.ImplAttributes, (ushort)method.Attributes, stringsHeap.Add(method.Name), GetSignature(method.Signature), row.ParamList);
					tablesHeap.MethodTable[rid] = row;
					AddGenericParams(new MDToken(Table.Method, rid), method.GenericParameters);
					AddDeclSecurities(new MDToken(Table.Method, rid), method.DeclSecurities);
					AddImplMap(new MDToken(Table.Method, rid), method);
					AddMethodImpls(method, method.Overrides);
					var paramDefs = method.ParamDefs;
					int count2 = paramDefs.Count;
					for (int j = 0; j < count2; j++) {
						var pd = paramDefs[j];
						if (pd is null) {
							Error("Param is null. Method {0} ({1:X8})", method, method.MDToken.Raw);
							continue;
						}
						uint pdRid = GetRid(pd);
						var pdRow = new RawParamRow((ushort)pd.Attributes, pd.Sequence, stringsHeap.Add(pd.Name));
						tablesHeap.ParamTable[pdRid] = pdRow;
						AddConstant(new MDToken(Table.Param, pdRid), pd);
						AddFieldMarshal(new MDToken(Table.Param, pdRid), pd);
					}
				}

				var events = type.Events;
				count = events.Count;
				for (int i = 0; i < count; i++) {
					var evt = events[i];
					if (evt is null) {
						Error("Event is null. TypeDef {0} ({1:X8})", type, type.MDToken.Raw);
						continue;
					}
					uint rid = GetRid(evt);
					var row = new RawEventRow((ushort)evt.Attributes, stringsHeap.Add(evt.Name), AddTypeDefOrRef(evt.EventType));
					tablesHeap.EventTable[rid] = row;
					AddMethodSemantics(evt);
				}

				var properties = type.Properties;
				count = properties.Count;
				for (int i = 0; i < count; i++) {
					var prop = properties[i];
					if (prop is null) {
						Error("Property is null. TypeDef {0} ({1:X8})", type, type.MDToken.Raw);
						continue;
					}
					uint rid = GetRid(prop);
					var row = new RawPropertyRow((ushort)prop.Attributes, stringsHeap.Add(prop.Name), GetSignature(prop.Type));
					tablesHeap.PropertyTable[rid] = row;
					AddConstant(new MDToken(Table.Property, rid), prop);
					AddMethodSemantics(prop);
				}
			}
		}

		/// <summary>
		/// Writes <c>TypeDef</c>, <c>Field</c>, <c>Method</c>, <c>Event</c>,
		/// <c>Property</c> and <c>Param</c> custom attributes and custom debug infos.
		/// </summary>
		void WriteTypeDefAndMemberDefCustomAttributesAndCustomDebugInfos() {
			int count;
			int numTypes = allTypeDefs.Length;
			int typeNum = 0;
			int notifyNum = 0;
			const int numNotifyEvents = 5;
			int notifyAfter = numTypes / numNotifyEvents;

			uint rid;
			foreach (var type in allTypeDefs) {
				if (typeNum++ == notifyAfter && notifyNum < numNotifyEvents) {
					RaiseProgress(Writer.MetadataEvent.MostTablesSorted, (double)typeNum / numTypes);
					notifyNum++;
					notifyAfter = (int)((double)numTypes / numNotifyEvents * (notifyNum + 1));
				}

				if (type is null)
					continue;
				if (type.HasCustomAttributes || type.HasCustomDebugInfos) {
					rid = GetRid(type);
					AddCustomAttributes(Table.TypeDef, rid, type);
					AddCustomDebugInformationList(Table.TypeDef, rid, type);
				}

				var fields = type.Fields;
				count = fields.Count;
				for (int i = 0; i < count; i++) {
					var field = fields[i];
					if (field is null)
						continue;
					if (field.HasCustomAttributes || field.HasCustomDebugInfos) {
						rid = GetRid(field);
						AddCustomAttributes(Table.Field, rid, field);
						AddCustomDebugInformationList(Table.Field, rid, field);
					}
				}

				var methods = type.Methods;
				count = methods.Count;
				for (int i = 0; i < count; i++) {
					var method = methods[i];
					if (method is null)
						continue;
					if (method.HasCustomAttributes) {
						rid = GetRid(method);
						AddCustomAttributes(Table.Method, rid, method);
						// Method custom debug info is added later when writing method bodies
					}
					var paramDefs = method.ParamDefs;
					int count2 = paramDefs.Count;
					for (int j = 0; j < count2; j++) {
						var pd = paramDefs[j];
						if (pd is null)
							continue;
						if (pd.HasCustomAttributes || pd.HasCustomDebugInfos) {
							rid = GetRid(pd);
							AddCustomAttributes(Table.Param, rid, pd);
							AddCustomDebugInformationList(Table.Param, rid, pd);
						}
					}
				}
				var events = type.Events;
				count = events.Count;
				for (int i = 0; i < count; i++) {
					var evt = events[i];
					if (evt is null)
						continue;
					if (evt.HasCustomAttributes || evt.HasCustomDebugInfos) {
						rid = GetRid(evt);
						AddCustomAttributes(Table.Event, rid, evt);
						AddCustomDebugInformationList(Table.Event, rid, evt);
					}
				}
				var properties = type.Properties;
				count = properties.Count;
				for (int i = 0; i < count; i++) {
					var prop = properties[i];
					if (prop is null)
						continue;
					if (prop.HasCustomAttributes || prop.HasCustomDebugInfos) {
						rid = GetRid(prop);
						AddCustomAttributes(Table.Property, rid, prop);
						AddCustomDebugInformationList(Table.Property, rid, prop);
					}
				}
			}
		}

		/// <summary>
		/// Adds the tokens of all methods in all vtables, if any
		/// </summary>
		void InitializeVTableFixups() {
			var fixups = module.VTableFixups;
			if (fixups is null || fixups.VTables.Count == 0)
				return;

			foreach (var vtable in fixups) {
				if (vtable is null) {
					Error("VTable is null");
					continue;
				}
				foreach (var method in vtable) {
					if (method is null)
						continue;
					AddMDTokenProvider(method);
				}
			}
		}

		void AddExportedTypes() {
			var exportedTypes = module.ExportedTypes;
			int count = exportedTypes.Count;
			for (int i = 0; i < count; i++)
				AddExportedType(exportedTypes[i]);
		}

		/// <summary>
		/// Adds the entry point. It's only needed if it's a <see cref="FileDef"/> since if it's
		/// a <see cref="MethodDef"/>, it will have already been added.
		/// </summary>
		void InitializeEntryPoint() {
			if (module.ManagedEntryPoint is FileDef epFile)
				AddFile(epFile);
		}

		/// <summary>
		/// Sorts all unsorted tables except <c>GenericParamConstraint</c> and <c>CustomAttribute</c>
		/// </summary>
		void SortTables() {
			classLayoutInfos.Sort((a, b)	=> a.row.Parent.CompareTo(b.row.Parent));
			hasConstantInfos.Sort((a, b)	=> a.row.Parent.CompareTo(b.row.Parent));
			declSecurityInfos.Sort((a, b)	=> a.row.Parent.CompareTo(b.row.Parent));
			fieldLayoutInfos.Sort((a, b)	=> a.row.Field.CompareTo(b.row.Field));
			fieldMarshalInfos.Sort((a, b)	=> a.row.Parent.CompareTo(b.row.Parent));
			fieldRVAInfos.Sort((a, b)		=> a.row.Field.CompareTo(b.row.Field));
			implMapInfos.Sort((a, b)		=> a.row.MemberForwarded.CompareTo(b.row.MemberForwarded));
			methodImplInfos.Sort((a, b)		=> a.row.Class.CompareTo(b.row.Class));
			methodSemanticsInfos.Sort((a, b)=> a.row.Association.CompareTo(b.row.Association));
			nestedClassInfos.Sort((a, b)	=> a.row.NestedClass.CompareTo(b.row.NestedClass));
			genericParamInfos.Sort((a, b) => {
				if (a.row.Owner != b.row.Owner)
					return a.row.Owner.CompareTo(b.row.Owner);
				return a.row.Number.CompareTo(b.row.Number);
			});
			interfaceImplInfos.Sort((a, b) => a.row.Class.CompareTo(b.row.Class));

			tablesHeap.ClassLayoutTable.IsSorted = true;
			tablesHeap.ConstantTable.IsSorted = true;
			tablesHeap.DeclSecurityTable.IsSorted = true;
			tablesHeap.FieldLayoutTable.IsSorted = true;
			tablesHeap.FieldMarshalTable.IsSorted = true;
			tablesHeap.FieldRVATable.IsSorted = true;
			tablesHeap.GenericParamTable.IsSorted = true;
			tablesHeap.ImplMapTable.IsSorted = true;
			tablesHeap.InterfaceImplTable.IsSorted = true;
			tablesHeap.MethodImplTable.IsSorted = true;
			tablesHeap.MethodSemanticsTable.IsSorted = true;
			tablesHeap.NestedClassTable.IsSorted = true;

			// These two are also sorted
			tablesHeap.EventMapTable.IsSorted = true;
			tablesHeap.PropertyMapTable.IsSorted = true;

			foreach (var info in classLayoutInfos.infos) tablesHeap.ClassLayoutTable.Create(info.row);
			foreach (var info in hasConstantInfos.infos) tablesHeap.ConstantTable.Create(info.row);
			foreach (var info in declSecurityInfos.infos) tablesHeap.DeclSecurityTable.Create(info.row);
			foreach (var info in fieldLayoutInfos.infos) tablesHeap.FieldLayoutTable.Create(info.row);
			foreach (var info in fieldMarshalInfos.infos) tablesHeap.FieldMarshalTable.Create(info.row);
			foreach (var info in fieldRVAInfos.infos) tablesHeap.FieldRVATable.Create(info.row);
			foreach (var info in genericParamInfos.infos) tablesHeap.GenericParamTable.Create(info.row);
			foreach (var info in implMapInfos.infos) tablesHeap.ImplMapTable.Create(info.row);
			foreach (var info in interfaceImplInfos.infos) tablesHeap.InterfaceImplTable.Create(info.row);
			foreach (var info in methodImplInfos.infos) tablesHeap.MethodImplTable.Create(info.row);
			foreach (var info in methodSemanticsInfos.infos) tablesHeap.MethodSemanticsTable.Create(info.row);
			foreach (var info in nestedClassInfos.infos) tablesHeap.NestedClassTable.Create(info.row);

			foreach (var info in interfaceImplInfos.infos) {
				if (info.data.HasCustomAttributes || info.data.HasCustomDebugInfos) {
					uint rid = interfaceImplInfos.Rid(info.data);
					AddCustomAttributes(Table.InterfaceImpl, rid, info.data);
					AddCustomDebugInformationList(Table.InterfaceImpl, rid, info.data);
				}
			}
			foreach (var info in declSecurityInfos.infos) {
				if (info.data.HasCustomAttributes || info.data.HasCustomDebugInfos) {
					uint rid = declSecurityInfos.Rid(info.data);
					AddCustomAttributes(Table.DeclSecurity, rid, info.data);
					AddCustomDebugInformationList(Table.DeclSecurity, rid, info.data);
				}
			}
			foreach (var info in genericParamInfos.infos) {
				if (info.data.HasCustomAttributes || info.data.HasCustomDebugInfos) {
					uint rid = genericParamInfos.Rid(info.data);
					AddCustomAttributes(Table.GenericParam, rid, info.data);
					AddCustomDebugInformationList(Table.GenericParam, rid, info.data);
				}
			}
		}

		/// <summary>
		/// Initializes the <c>GenericParamConstraint</c> table
		/// </summary>
		void InitializeGenericParamConstraintTable() {
			foreach (var type in allTypeDefs) {
				if (type is null)
					continue;
				AddGenericParamConstraints(type.GenericParameters);
				var methods = type.Methods;
				int count = methods.Count;
				for (int i = 0; i < count; i++) {
					var method = methods[i];
					if (method is null)
						continue;
					AddGenericParamConstraints(method.GenericParameters);
				}
			}
			genericParamConstraintInfos.Sort((a, b) => a.row.Owner.CompareTo(b.row.Owner));
			tablesHeap.GenericParamConstraintTable.IsSorted = true;
			foreach (var info in genericParamConstraintInfos.infos)
				tablesHeap.GenericParamConstraintTable.Create(info.row);
			foreach (var info in genericParamConstraintInfos.infos) {
				if (info.data.HasCustomAttributes || info.data.HasCustomDebugInfos) {
					uint rid = genericParamConstraintInfos.Rid(info.data);
					AddCustomAttributes(Table.GenericParamConstraint, rid, info.data);
					AddCustomDebugInformationList(Table.GenericParamConstraint, rid, info.data);
				}
			}
		}

		/// <summary>
		/// Inserts all custom attribute / custom debug info rows in the tables and sort them
		/// </summary>
		void InitializeCustomAttributeAndCustomDebugInfoTables() {
			customAttributeInfos.Sort((a, b) => a.row.Parent.CompareTo(b.row.Parent));
			tablesHeap.CustomAttributeTable.IsSorted = true;
			foreach (var info in customAttributeInfos.infos)
				tablesHeap.CustomAttributeTable.Create(info.row);

			if (debugMetadata is not null) {
				debugMetadata.stateMachineMethodInfos.Sort((a, b) => a.row.MoveNextMethod.CompareTo(b.row.MoveNextMethod));
				debugMetadata.tablesHeap.StateMachineMethodTable.IsSorted = true;
				foreach (var info in debugMetadata.stateMachineMethodInfos.infos)
					debugMetadata.tablesHeap.StateMachineMethodTable.Create(info.row);

				debugMetadata.customDebugInfos.Sort((a, b) => a.row.Parent.CompareTo(b.row.Parent));
				debugMetadata.tablesHeap.CustomDebugInformationTable.IsSorted = true;
				foreach (var info in debugMetadata.customDebugInfos.infos)
					debugMetadata.tablesHeap.CustomDebugInformationTable.Create(info.row);
			}
		}

		struct MethodScopeDebugInfo {
			public uint MethodRid;
			public PdbScope Scope;
			public uint ScopeStart;
			public uint ScopeLength;
		}

		/// <summary>
		/// Writes all method bodies
		/// </summary>
		void WriteMethodBodies() {
			Debug.Assert(!isStandaloneDebugMetadata);
			if (NoMethodBodies)
				return;
			int numMethods = NumberOfMethods;
			int methodNum = 0;
			int notifyNum = 0;
			// Writing method bodies is the most expensive part and takes the longest
			const int numNotifyEvents = 40;
			int notifyAfter = numMethods / numNotifyEvents;

			var debugMetadata = this.debugMetadata;
			var methodBodies = this.methodBodies;
			var methodToBody = this.methodToBody;

			List<MethodScopeDebugInfo> methodScopeDebugInfos;
			List<PdbScope> scopeStack;
			SerializerMethodContext serializerMethodContext;
			if (debugMetadata is null) {
				methodScopeDebugInfos = null;
				scopeStack = null;
				serializerMethodContext = null;
			}
			else {
				methodScopeDebugInfos = new List<MethodScopeDebugInfo>();
				scopeStack = new List<PdbScope>();
				serializerMethodContext = AllocSerializerMethodContext();
			}

			bool keepMaxStack = KeepOldMaxStack;
			var writer = new MethodBodyWriter(this);
			foreach (var type in allTypeDefs) {
				if (type is null)
					continue;

				var methods = type.Methods;
				for (int i = 0; i < methods.Count; i++) {
					var method = methods[i];
					if (method is null)
						continue;

					if (methodNum++ == notifyAfter && notifyNum < numNotifyEvents) {
						RaiseProgress(Writer.MetadataEvent.BeginWriteMethodBodies, (double)methodNum / numMethods);
						notifyNum++;
						notifyAfter = (int)((double)numMethods / numNotifyEvents * (notifyNum + 1));
					}

					uint localVarSigTok = 0;

					var cilBody = method.Body;
					if (cilBody is not null) {
						if (!(cilBody.Instructions.Count == 0 && cilBody.Variables.Count == 0)) {
							writer.Reset(method, keepMaxStack || cilBody.KeepOldMaxStack);
							writer.Write();
							var origRva = method.RVA;
							uint origSize = cilBody.MetadataBodySize;
							var mb = methodBodies.Add(new MethodBody(writer.Code, writer.ExtraSections, writer.LocalVarSigTok), origRva, origSize);
							methodToBody[method] = mb;
							localVarSigTok = writer.LocalVarSigTok;
						}
					}
					else {
						var nativeBody = method.NativeBody;
						if (nativeBody is not null)
							methodToNativeBody[method] = nativeBody;
						else if (method.MethodBody is not null)
							Error("Unsupported method body");
					}

					if (debugMetadata is not null) {
						uint rid = GetRid(method);

						if (cilBody is not null) {
							var pdbMethod = cilBody.PdbMethod;
							if (pdbMethod is not null) {
								// We don't need to write empty scopes
								if (!IsEmptyRootScope(cilBody, pdbMethod.Scope)) {
									serializerMethodContext.SetBody(method);
									scopeStack.Add(pdbMethod.Scope);
									while (scopeStack.Count > 0) {
										var scope = scopeStack[scopeStack.Count - 1];
										scopeStack.RemoveAt(scopeStack.Count - 1);
										scopeStack.AddRange(scope.Scopes);
										uint scopeStart = serializerMethodContext.GetOffset(scope.Start);
										uint scopeEnd = serializerMethodContext.GetOffset(scope.End);
										methodScopeDebugInfos.Add(new MethodScopeDebugInfo() {
											MethodRid = rid,
											Scope = scope,
											ScopeStart = scopeStart,
											ScopeLength = scopeEnd - scopeStart,
										});
									}
								}
							}
						}

						// Always add CDIs even if it has no managed method body
						AddCustomDebugInformationList(method, rid, localVarSigTok);
					}
				}
			}
			if (debugMetadata is not null) {
				methodScopeDebugInfos.Sort((a, b) => {
					int c = a.MethodRid.CompareTo(b.MethodRid);
					if (c != 0)
						return c;
					c = a.ScopeStart.CompareTo(b.ScopeStart);
					if (c != 0)
						return c;
					return b.ScopeLength.CompareTo(a.ScopeLength);
				});
				foreach (var info in methodScopeDebugInfos) {
					uint localScopeRid = (uint)debugMetadata.localScopeInfos.infos.Count + 1;
					var row = new RawLocalScopeRow(info.MethodRid, AddImportScope(info.Scope.ImportScope),
						(uint)debugMetadata.tablesHeap.LocalVariableTable.Rows + 1,
						(uint)debugMetadata.tablesHeap.LocalConstantTable.Rows + 1,
						info.ScopeStart, info.ScopeLength);
					debugMetadata.localScopeInfos.Add(info.Scope, row);
					var variables = info.Scope.Variables;
					int count = variables.Count;
					for (int i = 0; i < count; i++) {
						var local = variables[i];
						AddLocalVariable(local);
					}
					var constants = info.Scope.Constants;
					count = constants.Count;
					for (int i = 0; i < count; i++) {
						var constant = constants[i];
						AddLocalConstant(constant);
					}
					AddCustomDebugInformationList(Table.LocalScope, localScopeRid, info.Scope.CustomDebugInfos);
				}

				debugMetadata.tablesHeap.LocalScopeTable.IsSorted = true;
				foreach (var info in debugMetadata.localScopeInfos.infos)
					debugMetadata.tablesHeap.LocalScopeTable.Create(info.row);
			}
			if (serializerMethodContext is not null)
				Free(ref serializerMethodContext);
		}

		static bool IsEmptyRootScope(CilBody cilBody, PdbScope scope) {
			if (scope.Variables.Count != 0)
				return false;
			if (scope.Constants.Count != 0)
				return false;
			if (scope.Namespaces.Count != 0)
				return false;
			if (scope.ImportScope is not null)
				return false;
			if (scope.Scopes.Count != 0)
				return false;
			if (scope.CustomDebugInfos.Count != 0)
				return false;
			if (scope.End is not null)
				return false;
			if (cilBody.Instructions.Count != 0 && cilBody.Instructions[0] != scope.Start)
				return false;

			return true;
		}

		/// <summary>
		/// Checks whether a list is empty or whether it contains only <c>null</c>s
		/// </summary>
		/// <typeparam name="T">Any type</typeparam>
		/// <param name="list">The list</param>
		/// <returns><c>true</c> if the list is empty or if it contains only <c>null</c>s, <c>false</c> otherwise</returns>
		protected static bool IsEmpty<T>(IList<T> list) where T : class {
			if (list is null)
				return true;
			int count = list.Count;
			for (int i = 0; i < count; i++) {
				if (list[i] is not null)
					return false;
			}
			return true;
		}

		/// <inheritdoc/>
		public MDToken GetToken(object o) {
			if (o is IMDTokenProvider tp)
				return new MDToken(tp.MDToken.Table, AddMDTokenProvider(tp));

			if (o is string s)
				return new MDToken((Table)0x70, usHeap.Add(s));

			if (o is MethodSig methodSig)
				return new MDToken(Table.StandAloneSig, AddStandAloneSig(methodSig, methodSig.OriginalToken));

			if (o is FieldSig fieldSig)
				return new MDToken(Table.StandAloneSig, AddStandAloneSig(fieldSig, 0));

			if (o is null)
				Error("Instruction operand is null");
			else
				Error("Invalid instruction operand");
			return new MDToken((Table)0xFF, 0x00FFFFFF);
		}

		/// <inheritdoc/>
		public virtual MDToken GetToken(IList<TypeSig> locals, uint origToken) {
			if (locals is null || locals.Count == 0)
				return new MDToken((Table)0, 0);

			var row = new RawStandAloneSigRow(GetSignature(new LocalSig(locals, false)));
			uint rid = tablesHeap.StandAloneSigTable.Add(row);
			//TODO: Add custom attributes
			//TODO: Add custom debug infos
			return new MDToken(Table.StandAloneSig, rid);
		}

		/// <summary>
		/// Adds a <see cref="StandAloneSig"/>
		/// </summary>
		/// <param name="methodSig">Method signature</param>
		/// <param name="origToken">Original <c>StandAloneSig</c> token or 0 if none</param>
		/// <returns>Its new rid</returns>
		protected virtual uint AddStandAloneSig(MethodSig methodSig, uint origToken) {
			if (methodSig is null) {
				Error("StandAloneSig: MethodSig is null");
				return 0;
			}

			var row = new RawStandAloneSigRow(GetSignature(methodSig));
			uint rid = tablesHeap.StandAloneSigTable.Add(row);
			//TODO: Add custom attributes
			//TODO: Add custom debug infos
			return rid;
		}

		/// <summary>
		/// Adds a <see cref="StandAloneSig"/>
		/// </summary>
		/// <param name="fieldSig">FIeld signature</param>
		/// <param name="origToken">Original <c>StandAloneSig</c> token or 0 if none</param>
		/// <returns>Its new rid</returns>
		protected virtual uint AddStandAloneSig(FieldSig fieldSig, uint origToken) {
			if (fieldSig is null) {
				Error("StandAloneSig: FieldSig is null");
				return 0;
			}

			var row = new RawStandAloneSigRow(GetSignature(fieldSig));
			uint rid = tablesHeap.StandAloneSigTable.Add(row);
			//TODO: Add custom attributes
			//TODO: Add custom debug infos
			return rid;
		}

		uint AddMDTokenProvider(IMDTokenProvider tp) {
			if (tp is not null) {
				switch (tp.MDToken.Table) {
				case Table.Module:
					return AddModule((ModuleDef)tp);

				case Table.TypeRef:
					return AddTypeRef((TypeRef)tp);

				case Table.TypeDef:
					return GetRid((TypeDef)tp);

				case Table.Field:
					return GetRid((FieldDef)tp);

				case Table.Method:
					return GetRid((MethodDef)tp);

				case Table.Param:
					return GetRid((ParamDef)tp);

				case Table.MemberRef:
					return AddMemberRef((MemberRef)tp);

				case Table.StandAloneSig:
					return AddStandAloneSig((StandAloneSig)tp);

				case Table.Event:
					return GetRid((EventDef)tp);

				case Table.Property:
					return GetRid((PropertyDef)tp);

				case Table.ModuleRef:
					return AddModuleRef((ModuleRef)tp);

				case Table.TypeSpec:
					return AddTypeSpec((TypeSpec)tp);

				case Table.Assembly:
					return AddAssembly((AssemblyDef)tp, null);

				case Table.AssemblyRef:
					return AddAssemblyRef((AssemblyRef)tp);

				case Table.File:
					return AddFile((FileDef)tp);

				case Table.ExportedType:
					return AddExportedType((ExportedType)tp);

				case Table.MethodSpec:
					return AddMethodSpec((MethodSpec)tp);

				case Table.FieldPtr:
				case Table.MethodPtr:
				case Table.ParamPtr:
				case Table.InterfaceImpl:
				case Table.Constant:
				case Table.CustomAttribute:
				case Table.FieldMarshal:
				case Table.DeclSecurity:
				case Table.ClassLayout:
				case Table.FieldLayout:
				case Table.EventMap:
				case Table.EventPtr:
				case Table.PropertyMap:
				case Table.PropertyPtr:
				case Table.MethodSemantics:
				case Table.MethodImpl:
				case Table.ImplMap:
				case Table.FieldRVA:
				case Table.ENCLog:
				case Table.ENCMap:
				case Table.AssemblyProcessor:
				case Table.AssemblyOS:
				case Table.AssemblyRefProcessor:
				case Table.AssemblyRefOS:
				case Table.ManifestResource:
				case Table.NestedClass:
				case Table.GenericParam:
				case Table.GenericParamConstraint:
				case Table.Document:
				case Table.MethodDebugInformation:
				case Table.LocalScope:
				case Table.LocalVariable:
				case Table.LocalConstant:
				case Table.ImportScope:
				case Table.StateMachineMethod:
				case Table.CustomDebugInformation:
				default:
					break;
				}
			}

			if (tp is null)
				Error("IMDTokenProvider is null");
			else
				Error("Invalid IMDTokenProvider");
			return 0;
		}

		/// <summary>
		/// Adds a <see cref="ITypeDefOrRef"/>
		/// </summary>
		/// <param name="tdr">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddTypeDefOrRef(ITypeDefOrRef tdr) {
			if (tdr is null) {
				Error("TypeDefOrRef is null");
				return 0;
			}

			var token = new MDToken(tdr.MDToken.Table, AddMDTokenProvider(tdr));
			if (!CodedToken.TypeDefOrRef.Encode(token, out uint encodedToken)) {
				Error("Can't encode TypeDefOrRef token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="IResolutionScope"/>
		/// </summary>
		/// <param name="rs">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddResolutionScope(IResolutionScope rs) {
			if (rs is null) {
				return 0;
			}

			var token = new MDToken(rs.MDToken.Table, AddMDTokenProvider(rs));
			if (!CodedToken.ResolutionScope.Encode(token, out uint encodedToken)) {
				Error("Can't encode ResolutionScope token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="IMethodDefOrRef"/>
		/// </summary>
		/// <param name="mdr">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddMethodDefOrRef(IMethodDefOrRef mdr) {
			if (mdr is null) {
				Error("MethodDefOrRef is null");
				return 0;
			}

			var token = new MDToken(mdr.MDToken.Table, AddMDTokenProvider(mdr));
			if (!CodedToken.MethodDefOrRef.Encode(token, out uint encodedToken)) {
				Error("Can't encode MethodDefOrRef token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="IMemberRefParent"/>
		/// </summary>
		/// <param name="parent">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddMemberRefParent(IMemberRefParent parent) {
			if (parent is null) {
				Error("MemberRefParent is null");
				return 0;
			}

			var token = new MDToken(parent.MDToken.Table, AddMDTokenProvider(parent));
			if (!CodedToken.MemberRefParent.Encode(token, out uint encodedToken)) {
				Error("Can't encode MemberRefParent token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="IImplementation"/>
		/// </summary>
		/// <param name="impl">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddImplementation(IImplementation impl) {
			if (impl is null) {
				Error("Implementation is null");
				return 0;
			}

			var token = new MDToken(impl.MDToken.Table, AddMDTokenProvider(impl));
			if (!CodedToken.Implementation.Encode(token, out uint encodedToken)) {
				Error("Can't encode Implementation token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <see cref="ICustomAttributeType"/>
		/// </summary>
		/// <param name="cat">Value</param>
		/// <returns>Its encoded token</returns>
		protected uint AddCustomAttributeType(ICustomAttributeType cat) {
			if (cat is null) {
				Error("CustomAttributeType is null");
				return 0;
			}

			var token = new MDToken(cat.MDToken.Table, AddMDTokenProvider(cat));
			if (!CodedToken.CustomAttributeType.Encode(token, out uint encodedToken)) {
				Error("Can't encode CustomAttributeType token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			return encodedToken;
		}

		/// <summary>
		/// Adds a <c>NestedType</c> row
		/// </summary>
		/// <param name="nestedType">Nested type</param>
		/// <param name="declaringType">Declaring type</param>
		protected void AddNestedType(TypeDef nestedType, TypeDef declaringType) {
			if (nestedType is null || declaringType is null)
				return;
			uint nestedRid = GetRid(nestedType);
			uint dtRid = GetRid(declaringType);
			if (nestedRid == 0 || dtRid == 0)
				return;
			var row = new RawNestedClassRow(nestedRid, dtRid);
			nestedClassInfos.Add(declaringType, row);
		}

		/// <summary>
		/// Adds a <c>Module</c> row
		/// </summary>
		/// <param name="module">Module</param>
		/// <returns>Its new rid</returns>
		protected uint AddModule(ModuleDef module) {
			if (module is null) {
				Error("Module is null");
				return 0;
			}
			if (this.module != module)
				Error("Module {0} must be referenced with a ModuleRef, not a ModuleDef", module);
			if (moduleDefInfos.TryGetRid(module, out uint rid))
				return rid;
			var row = new RawModuleRow(module.Generation,
								stringsHeap.Add(module.Name),
								guidHeap.Add(module.Mvid),
								guidHeap.Add(module.EncId),
								guidHeap.Add(module.EncBaseId));
			rid = tablesHeap.ModuleTable.Add(row);
			moduleDefInfos.Add(module, rid);
			AddCustomAttributes(Table.Module, rid, module);
			AddCustomDebugInformationList(Table.Module, rid, module);
			return rid;
		}

		/// <summary>
		/// Adds a <c>ModuleRef</c> row
		/// </summary>
		/// <param name="modRef">Module ref</param>
		/// <returns>Its new rid</returns>
		protected uint AddModuleRef(ModuleRef modRef) {
			if (modRef is null) {
				Error("ModuleRef is null");
				return 0;
			}
			if (moduleRefInfos.TryGetRid(modRef, out uint rid))
				return rid;
			var row = new RawModuleRefRow(stringsHeap.Add(modRef.Name));
			rid = tablesHeap.ModuleRefTable.Add(row);
			moduleRefInfos.Add(modRef, rid);
			AddCustomAttributes(Table.ModuleRef, rid, modRef);
			AddCustomDebugInformationList(Table.ModuleRef, rid, modRef);
			return rid;
		}

		/// <summary>
		/// Adds an <c>AssemblyRef</c> row
		/// </summary>
		/// <param name="asmRef">Assembly ref</param>
		/// <returns>Its new rid</returns>
		protected uint AddAssemblyRef(AssemblyRef asmRef) {
			if (asmRef is null) {
				Error("AssemblyRef is null");
				return 0;
			}
			if (assemblyRefInfos.TryGetRid(asmRef, out uint rid))
				return rid;
			var version = Utils.CreateVersionWithNoUndefinedValues(asmRef.Version);
			var row = new RawAssemblyRefRow((ushort)version.Major,
							(ushort)version.Minor,
							(ushort)version.Build,
							(ushort)version.Revision,
							(uint)asmRef.Attributes,
							blobHeap.Add(PublicKeyBase.GetRawData(asmRef.PublicKeyOrToken)),
							stringsHeap.Add(asmRef.Name),
							stringsHeap.Add(asmRef.Culture),
							blobHeap.Add(asmRef.Hash));
			rid = tablesHeap.AssemblyRefTable.Add(row);
			assemblyRefInfos.Add(asmRef, rid);
			AddCustomAttributes(Table.AssemblyRef, rid, asmRef);
			AddCustomDebugInformationList(Table.AssemblyRef, rid, asmRef);
			return rid;
		}

		/// <summary>
		/// Adds an <c>Assembly</c> row
		/// </summary>
		/// <param name="asm">Assembly</param>
		/// <param name="publicKey">The public key that should be used</param>
		/// <returns>Its new rid</returns>
		protected uint AddAssembly(AssemblyDef asm, byte[] publicKey) {
			if (asm is null) {
				Error("Assembly is null");
				return 0;
			}
			if (assemblyInfos.TryGetRid(asm, out uint rid))
				return rid;

			var asmAttrs = asm.Attributes;
			if (publicKey is not null)
				asmAttrs |= AssemblyAttributes.PublicKey;
			else
				publicKey = PublicKeyBase.GetRawData(asm.PublicKeyOrToken);

			var version = Utils.CreateVersionWithNoUndefinedValues(asm.Version);
			var row = new RawAssemblyRow((uint)asm.HashAlgorithm,
							(ushort)version.Major,
							(ushort)version.Minor,
							(ushort)version.Build,
							(ushort)version.Revision,
							(uint)asmAttrs,
							blobHeap.Add(publicKey),
							stringsHeap.Add(asm.Name),
							stringsHeap.Add(asm.Culture));
			rid = tablesHeap.AssemblyTable.Add(row);
			assemblyInfos.Add(asm, rid);
			AddDeclSecurities(new MDToken(Table.Assembly, rid), asm.DeclSecurities);
			AddCustomAttributes(Table.Assembly, rid, asm);
			AddCustomDebugInformationList(Table.Assembly, rid, asm);
			return rid;
		}

		/// <summary>
		/// Adds generic parameters
		/// </summary>
		/// <param name="token">New token of owner</param>
		/// <param name="gps">All generic params</param>
		protected void AddGenericParams(MDToken token, IList<GenericParam> gps) {
			if (gps is null)
				return;
			int count = gps.Count;
			for (int i = 0; i < count; i++)
				AddGenericParam(token, gps[i]);
		}

		/// <summary>
		/// Adds a generic param
		/// </summary>
		/// <param name="owner">New token of owner</param>
		/// <param name="gp">Generic paramater</param>
		protected void AddGenericParam(MDToken owner, GenericParam gp) {
			if (gp is null) {
				Error("GenericParam is null");
				return;
			}
			if (!CodedToken.TypeOrMethodDef.Encode(owner, out uint encodedOwner)) {
				Error("Can't encode TypeOrMethodDef token {0:X8}", owner.Raw);
				encodedOwner = 0;
			}
			var row = new RawGenericParamRow(gp.Number,
							(ushort)gp.Flags,
							encodedOwner,
							stringsHeap.Add(gp.Name),
							gp.Kind is null ? 0 : AddTypeDefOrRef(gp.Kind));
			genericParamInfos.Add(gp, row);
		}

		void AddGenericParamConstraints(IList<GenericParam> gps) {
			if (gps is null)
				return;
			int count = gps.Count;
			for (int i = 0; i < count; i++) {
				var gp = gps[i];
				if (gp is null)
					continue;
				uint rid = genericParamInfos.Rid(gp);
				AddGenericParamConstraints(rid, gp.GenericParamConstraints);
			}
		}

		/// <summary>
		/// Adds generic parameter constraints
		/// </summary>
		/// <param name="gpRid">New rid of owner generic param</param>
		/// <param name="constraints">Its constraints</param>
		protected void AddGenericParamConstraints(uint gpRid, IList<GenericParamConstraint> constraints) {
			if (constraints is null)
				return;
			int count = constraints.Count;
			for (int i = 0; i < count; i++)
				AddGenericParamConstraint(gpRid, constraints[i]);
		}

		/// <summary>
		/// Adds a generic parameter constraint
		/// </summary>
		/// <param name="gpRid">New rid of owner generic param</param>
		/// <param name="gpc">Generic parameter constraint</param>
		protected void AddGenericParamConstraint(uint gpRid, GenericParamConstraint gpc) {
			if (gpc is null) {
				Error("GenericParamConstraint is null");
				return;
			}
			var row = new RawGenericParamConstraintRow(gpRid, AddTypeDefOrRef(gpc.Constraint));
			genericParamConstraintInfos.Add(gpc, row);
		}

		/// <summary>
		/// Adds a <c>InterfaceImpl</c> row
		/// </summary>
		/// <param name="typeDefRid">New rid of owner</param>
		/// <param name="ifaces">All interfaces</param>
		protected void AddInterfaceImpls(uint typeDefRid, IList<InterfaceImpl> ifaces) {
			int count = ifaces.Count;
			for (int i = 0; i < count; i++) {
				var iface = ifaces[i];
				if (iface is null)
					continue;
				var row = new RawInterfaceImplRow(typeDefRid,
							AddTypeDefOrRef(iface.Interface));
				interfaceImplInfos.Add(iface, row);
			}
		}

		/// <summary>
		/// Adds a <c>FieldLayout</c> row
		/// </summary>
		/// <param name="field">Owner field</param>
		protected void AddFieldLayout(FieldDef field) {
			if (field is null || field.FieldOffset is null)
				return;
			var rid = GetRid(field);
			var row = new RawFieldLayoutRow(field.FieldOffset.Value, rid);
			fieldLayoutInfos.Add(field, row);
		}

		/// <summary>
		/// Adds a <c>FieldMarshal</c> row
		/// </summary>
		/// <param name="parent">New owner token</param>
		/// <param name="hfm">Owner</param>
		protected void AddFieldMarshal(MDToken parent, IHasFieldMarshal hfm) {
			if (hfm is null || hfm.MarshalType is null)
				return;
			var fieldMarshal = hfm.MarshalType;
			if (!CodedToken.HasFieldMarshal.Encode(parent, out uint encodedParent)) {
				Error("Can't encode HasFieldMarshal token {0:X8}", parent.Raw);
				encodedParent = 0;
			}
			var row = new RawFieldMarshalRow(encodedParent,
						blobHeap.Add(MarshalBlobWriter.Write(module, fieldMarshal, this, OptimizeCustomAttributeSerializedTypeNames)));
			fieldMarshalInfos.Add(hfm, row);
		}

		/// <summary>
		/// Adds a <c>FieldRVA</c> row
		/// </summary>
		/// <param name="field">The field</param>
		protected void AddFieldRVA(FieldDef field) {
			Debug.Assert(!isStandaloneDebugMetadata);
			if (NoFieldData)
				return;
			if (field.RVA != 0 && KeepFieldRVA) {
				uint rid = GetRid(field);
				var row = new RawFieldRVARow((uint)field.RVA, rid);
				fieldRVAInfos.Add(field, row);
			}
			else {
				if (field is null || field.InitialValue is null)
					return;
				var ivBytes = field.InitialValue;
				if (!VerifyFieldSize(field, ivBytes.Length))
					Error("Field {0} ({1:X8}) initial value size != size of field type", field, field.MDToken.Raw);
				uint rid = GetRid(field);
				var iv = constants.Add(new ByteArrayChunk(ivBytes), ModuleWriterBase.DEFAULT_CONSTANTS_ALIGNMENT);
				fieldToInitialValue[field] = iv;
				var row = new RawFieldRVARow(0, rid);
				fieldRVAInfos.Add(field, row);
			}
		}

		static bool VerifyFieldSize(FieldDef field, int size) {
			if (field is null)
				return false;
			var sig = field.FieldSig;
			if (sig is null)
				return false;
			return field.GetFieldSize() == size;
		}

		/// <summary>
		/// Adds a <c>ImplMap</c> row
		/// </summary>
		/// <param name="parent">New owner token</param>
		/// <param name="mf">Owner</param>
		protected void AddImplMap(MDToken parent, IMemberForwarded mf) {
			if (mf is null || mf.ImplMap is null)
				return;
			var implMap = mf.ImplMap;
			if (!CodedToken.MemberForwarded.Encode(parent, out uint encodedParent)) {
				Error("Can't encode MemberForwarded token {0:X8}", parent.Raw);
				encodedParent = 0;
			}
			var row = new RawImplMapRow((ushort)implMap.Attributes,
						encodedParent,
						stringsHeap.Add(implMap.Name),
						AddModuleRef(implMap.Module));
			implMapInfos.Add(mf, row);
		}

		/// <summary>
		/// Adds a <c>Constant</c> row
		/// </summary>
		/// <param name="parent">New owner token</param>
		/// <param name="hc">Owner</param>
		protected void AddConstant(MDToken parent, IHasConstant hc) {
			if (hc is null || hc.Constant is null)
				return;
			var constant = hc.Constant;
			if (!CodedToken.HasConstant.Encode(parent, out uint encodedParent)) {
				Error("Can't encode HasConstant token {0:X8}", parent.Raw);
				encodedParent = 0;
			}
			var row = new RawConstantRow((byte)constant.Type, 0,
						encodedParent,
						blobHeap.Add(GetConstantValueAsByteArray(constant.Type, constant.Value)));
			hasConstantInfos.Add(hc, row);
		}

		static readonly byte[] constantClassByteArray = new byte[4];
		static readonly byte[] constantDefaultByteArray = new byte[8];
		byte[] GetConstantValueAsByteArray(ElementType etype, object o) {
			if (o is null) {
				if (etype == ElementType.Class)
					return constantClassByteArray;
				Error("Constant is null");
				return constantDefaultByteArray;
			}

			var typeCode = Type.GetTypeCode(o.GetType());
			switch (typeCode) {
			case TypeCode.Boolean:
				VerifyConstantType(etype, ElementType.Boolean);
				return BitConverter.GetBytes((bool)o);

			case TypeCode.Char:
				VerifyConstantType(etype, ElementType.Char);
				return BitConverter.GetBytes((char)o);

			case TypeCode.SByte:
				VerifyConstantType(etype, ElementType.I1);
				return new byte[1] { (byte)(sbyte)o };

			case TypeCode.Byte:
				VerifyConstantType(etype, ElementType.U1);
				return new byte[1] { (byte)o };

			case TypeCode.Int16:
				VerifyConstantType(etype, ElementType.I2);
				return BitConverter.GetBytes((short)o);

			case TypeCode.UInt16:
				VerifyConstantType(etype, ElementType.U2);
				return BitConverter.GetBytes((ushort)o);

			case TypeCode.Int32:
				VerifyConstantType(etype, ElementType.I4);
				return BitConverter.GetBytes((int)o);

			case TypeCode.UInt32:
				VerifyConstantType(etype, ElementType.U4);
				return BitConverter.GetBytes((uint)o);

			case TypeCode.Int64:
				VerifyConstantType(etype, ElementType.I8);
				return BitConverter.GetBytes((long)o);

			case TypeCode.UInt64:
				VerifyConstantType(etype, ElementType.U8);
				return BitConverter.GetBytes((ulong)o);

			case TypeCode.Single:
				VerifyConstantType(etype, ElementType.R4);
				return BitConverter.GetBytes((float)o);

			case TypeCode.Double:
				VerifyConstantType(etype, ElementType.R8);
				return BitConverter.GetBytes((double)o);

			case TypeCode.String:
				VerifyConstantType(etype, ElementType.String);
				return Encoding.Unicode.GetBytes((string)o);

			default:
				Error("Invalid constant type: {0}", typeCode);
				return constantDefaultByteArray;
			}
		}

		void VerifyConstantType(ElementType realType, ElementType expectedType) {
			if (realType != expectedType)
				Error("Constant value's type is the wrong type: {0} != {1}", realType, expectedType);
		}

		/// <summary>
		/// Adds a <c>DeclSecurity</c> row
		/// </summary>
		/// <param name="parent">New owner token</param>
		/// <param name="declSecurities">All <c>DeclSecurity</c> rows</param>
		protected void AddDeclSecurities(MDToken parent, IList<DeclSecurity> declSecurities) {
			if (declSecurities is null)
				return;
			if (!CodedToken.HasDeclSecurity.Encode(parent, out uint encodedParent)) {
				Error("Can't encode HasDeclSecurity token {0:X8}", parent.Raw);
				encodedParent = 0;
			}
			var bwctx = AllocBinaryWriterContext();
			int count = declSecurities.Count;
			for (int i = 0; i < count; i++) {
				var decl = declSecurities[i];
				if (decl is null)
					continue;
				var row = new RawDeclSecurityRow((short)decl.Action,
							encodedParent,
							blobHeap.Add(DeclSecurityWriter.Write(module, decl.SecurityAttributes, this, OptimizeCustomAttributeSerializedTypeNames, bwctx)));
				declSecurityInfos.Add(decl, row);
			}
			Free(ref bwctx);
		}

		/// <summary>
		/// Adds <c>MethodSemantics</c> rows
		/// </summary>
		/// <param name="evt">Event</param>
		protected void AddMethodSemantics(EventDef evt) {
			if (evt is null) {
				Error("Event is null");
				return;
			}
			uint rid = GetRid(evt);
			if (rid == 0)
				return;
			var token = new MDToken(Table.Event, rid);
			AddMethodSemantics(token, evt.AddMethod, MethodSemanticsAttributes.AddOn);
			AddMethodSemantics(token, evt.RemoveMethod, MethodSemanticsAttributes.RemoveOn);
			AddMethodSemantics(token, evt.InvokeMethod, MethodSemanticsAttributes.Fire);
			AddMethodSemantics(token, evt.OtherMethods, MethodSemanticsAttributes.Other);
		}

		/// <summary>
		/// Adds <c>MethodSemantics</c> rows
		/// </summary>
		/// <param name="prop">Property</param>
		protected void AddMethodSemantics(PropertyDef prop) {
			if (prop is null) {
				Error("Property is null");
				return;
			}
			uint rid = GetRid(prop);
			if (rid == 0)
				return;
			var token = new MDToken(Table.Property, rid);
			AddMethodSemantics(token, prop.GetMethods, MethodSemanticsAttributes.Getter);
			AddMethodSemantics(token, prop.SetMethods, MethodSemanticsAttributes.Setter);
			AddMethodSemantics(token, prop.OtherMethods, MethodSemanticsAttributes.Other);
		}

		void AddMethodSemantics(MDToken owner, IList<MethodDef> methods, MethodSemanticsAttributes attrs) {
			if (methods is null)
				return;
			int count = methods.Count;
			for (int i = 0; i < count; i++)
				AddMethodSemantics(owner, methods[i], attrs);
		}

		void AddMethodSemantics(MDToken owner, MethodDef method, MethodSemanticsAttributes flags) {
			if (method is null)
				return;
			uint methodRid = GetRid(method);
			if (methodRid == 0)
				return;
			if (!CodedToken.HasSemantic.Encode(owner, out uint encodedOwner)) {
				Error("Can't encode HasSemantic token {0:X8}", owner.Raw);
				encodedOwner = 0;
			}
			var row = new RawMethodSemanticsRow((ushort)flags, methodRid, encodedOwner);
			methodSemanticsInfos.Add(method, row);
		}

		void AddMethodImpls(MethodDef method, IList<MethodOverride> overrides) {
			if (overrides is null)
				return;
			if (method.DeclaringType is null) {
				Error("Method declaring type is null. Method {0} ({1:X8})", method, method.MDToken.Raw);
				return;
			}
			if (overrides.Count != 0) {
				uint rid = GetRid(method.DeclaringType);
				int count = overrides.Count;
				for (int i = 0; i < count; i++) {
					var ovr = overrides[i];
					var row = new RawMethodImplRow(rid,
								AddMethodDefOrRef(ovr.MethodBody),
								AddMethodDefOrRef(ovr.MethodDeclaration));
					methodImplInfos.Add(method, row);
				}
			}
		}

		/// <summary>
		/// Adds a <c>ClassLayout</c> row
		/// </summary>
		/// <param name="type">Type</param>
		protected void AddClassLayout(TypeDef type) {
			if (type is null || type.ClassLayout is null)
				return;
			var rid = GetRid(type);
			var classLayout = type.ClassLayout;
			var row = new RawClassLayoutRow(classLayout.PackingSize, classLayout.ClassSize, rid);
			classLayoutInfos.Add(type, row);
		}

		void AddResources(IList<Resource> resources) {
			if (NoDotNetResources)
				return;
			if (resources is null)
				return;
			int count = resources.Count;
			for (int i = 0; i < count; i++)
				AddResource(resources[i]);
		}

		void AddResource(Resource resource) {
			Debug.Assert(!NoDotNetResources);
			if (resource is EmbeddedResource er) {
				AddEmbeddedResource(er);
				return;
			}

			if (resource is AssemblyLinkedResource alr) {
				AddAssemblyLinkedResource(alr);
				return;
			}

			if (resource is LinkedResource lr) {
				AddLinkedResource(lr);
				return;
			}

			if (resource is null)
				Error("Resource is null");
			else
				Error("Invalid resource type: {0}", resource.GetType());
		}

		uint AddEmbeddedResource(EmbeddedResource er) {
			Debug.Assert(!isStandaloneDebugMetadata);
			Debug.Assert(!NoDotNetResources);
			if (er is null) {
				Error("EmbeddedResource is null");
				return 0;
			}
			if (manifestResourceInfos.TryGetRid(er, out uint rid))
				return rid;
			var row = new RawManifestResourceRow(netResources.NextOffset,
						(uint)er.Attributes,
						stringsHeap.Add(er.Name),
						0);
			rid = tablesHeap.ManifestResourceTable.Add(row);
			manifestResourceInfos.Add(er, rid);
			embeddedResourceToByteArray[er] = netResources.Add(er.CreateReader());
			AddCustomAttributes(Table.ManifestResource, rid, er);
			AddCustomDebugInformationList(Table.ManifestResource, rid, er);
			return rid;
		}

		uint AddAssemblyLinkedResource(AssemblyLinkedResource alr) {
			Debug.Assert(!NoDotNetResources);
			if (alr is null) {
				Error("AssemblyLinkedResource is null");
				return 0;
			}
			if (manifestResourceInfos.TryGetRid(alr, out uint rid))
				return rid;
			var row = new RawManifestResourceRow(0,
						(uint)alr.Attributes,
						stringsHeap.Add(alr.Name),
						AddImplementation(alr.Assembly));
			rid = tablesHeap.ManifestResourceTable.Add(row);
			manifestResourceInfos.Add(alr, rid);
			AddCustomAttributes(Table.ManifestResource, rid, alr);
			AddCustomDebugInformationList(Table.ManifestResource, rid, alr);
			return rid;
		}

		uint AddLinkedResource(LinkedResource lr) {
			Debug.Assert(!NoDotNetResources);
			if (lr is null) {
				Error("LinkedResource is null");
				return 0;
			}
			if (manifestResourceInfos.TryGetRid(lr, out uint rid))
				return rid;
			var row = new RawManifestResourceRow(0,
						(uint)lr.Attributes,
						stringsHeap.Add(lr.Name),
						AddImplementation(lr.File));
			rid = tablesHeap.ManifestResourceTable.Add(row);
			manifestResourceInfos.Add(lr, rid);
			AddCustomAttributes(Table.ManifestResource, rid, lr);
			AddCustomDebugInformationList(Table.ManifestResource, rid, lr);
			return rid;
		}

		/// <summary>
		/// Adds a <c>File</c> row
		/// </summary>
		/// <param name="file">File</param>
		/// <returns>Its new rid</returns>
		protected uint AddFile(FileDef file) {
			if (file is null) {
				Error("FileDef is null");
				return 0;
			}
			if (fileDefInfos.TryGetRid(file, out uint rid))
				return rid;
			var row = new RawFileRow((uint)file.Flags,
						stringsHeap.Add(file.Name),
						blobHeap.Add(file.HashValue));	//TODO: Re-calculate the hash value if possible
			rid = tablesHeap.FileTable.Add(row);
			fileDefInfos.Add(file, rid);
			AddCustomAttributes(Table.File, rid, file);
			AddCustomDebugInformationList(Table.File, rid, file);
			return rid;
		}

		/// <summary>
		/// Adds a <c>ExportedType</c> row
		/// </summary>
		/// <param name="et">Exported type</param>
		/// <returns>Its new rid</returns>
		protected uint AddExportedType(ExportedType et) {
			if (et is null) {
				Error("ExportedType is null");
				return 0;
			}
			if (exportedTypeInfos.TryGetRid(et, out uint rid))
				return rid;
			exportedTypeInfos.Add(et, 0);	// Prevent inf recursion
			var row = new RawExportedTypeRow((uint)et.Attributes,
						et.TypeDefId,	//TODO: Should be updated with the new rid
						stringsHeap.Add(et.TypeName),
						stringsHeap.Add(et.TypeNamespace),
						AddImplementation(et.Implementation));
			rid = tablesHeap.ExportedTypeTable.Add(row);
			exportedTypeInfos.SetRid(et, rid);
			AddCustomAttributes(Table.ExportedType, rid, et);
			AddCustomDebugInformationList(Table.ExportedType, rid, et);
			return rid;
		}

		/// <summary>
		/// Gets a #Blob offset of a type signature
		/// </summary>
		/// <param name="ts">Type sig</param>
		/// <param name="extraData">Extra data to append the signature if
		/// <see cref="PreserveExtraSignatureData"/> is <c>true</c>.</param>
		/// <returns>#Blob offset</returns>
		protected uint GetSignature(TypeSig ts, byte[] extraData) {
			byte[] blob;
			if (ts is null) {
				Error("TypeSig is null");
				blob = null;
			}
			else {
				var bwctx = AllocBinaryWriterContext();
				blob = SignatureWriter.Write(this, ts, bwctx);
				Free(ref bwctx);
			}
			AppendExtraData(ref blob, extraData);
			return blobHeap.Add(blob);
		}

		/// <summary>
		/// Gets a #Blob offset of a calling convention signature
		/// </summary>
		/// <param name="sig">Signature</param>
		/// <returns>#Blob offset</returns>
		protected uint GetSignature(CallingConventionSig sig) {
			if (sig is null) {
				Error("CallingConventionSig is null");
				return 0;
			}

			var bwctx = AllocBinaryWriterContext();
			var blob = SignatureWriter.Write(this, sig, bwctx);
			Free(ref bwctx);
			AppendExtraData(ref blob, sig.ExtraData);
			return blobHeap.Add(blob);
		}

		void AppendExtraData(ref byte[] blob, byte[] extraData) {
			if (PreserveExtraSignatureData && extraData is not null && extraData.Length > 0) {
				int blen = blob is null ? 0 : blob.Length;
				Array.Resize(ref blob, blen + extraData.Length);
				Array.Copy(extraData, 0, blob, blen, extraData.Length);
			}
		}

		/// <summary>
		/// Adds a <c>CustomAttribute</c> row
		/// </summary>
		/// <param name="table">Owner table</param>
		/// <param name="rid">New owner rid</param>
		/// <param name="hca">Onwer</param>
		protected void AddCustomAttributes(Table table, uint rid, IHasCustomAttribute hca) => AddCustomAttributes(table, rid, hca.CustomAttributes);

		void AddCustomAttributes(Table table, uint rid, CustomAttributeCollection caList) {
			var token = new MDToken(table, rid);
			int count = caList.Count;
			for (int i = 0; i < count; i++)
				AddCustomAttribute(token, caList[i]);
		}

		void AddCustomAttribute(MDToken token, CustomAttribute ca) {
			if (ca is null) {
				Error("Custom attribute is null");
				return;
			}
			if (!CodedToken.HasCustomAttribute.Encode(token, out uint encodedToken)) {
				Error("Can't encode HasCustomAttribute token {0:X8}", token.Raw);
				encodedToken = 0;
			}
			var bwctx = AllocBinaryWriterContext();
			var caBlob = CustomAttributeWriter.Write(this, ca, bwctx);
			Free(ref bwctx);
			var row = new RawCustomAttributeRow(encodedToken,
						AddCustomAttributeType(ca.Constructor),
						blobHeap.Add(caBlob));
			customAttributeInfos.Add(ca, row);
		}

		void AddCustomDebugInformationList(MethodDef method, uint rid, uint localVarSigToken) {
			Debug.Assert(debugMetadata is not null);
			if (debugMetadata is null)
				return;
			var serializerMethodContext = AllocSerializerMethodContext();
			serializerMethodContext.SetBody(method);
			if (method.CustomDebugInfos.Count != 0)
				AddCustomDebugInformationCore(serializerMethodContext, Table.Method, rid, method.CustomDebugInfos);
			AddMethodDebugInformation(method, rid, localVarSigToken);
			Free(ref serializerMethodContext);
		}

		void AddMethodDebugInformation(MethodDef method, uint rid, uint localVarSigToken) {
			Debug.Assert(debugMetadata is not null);
			var body = method.Body;
			if (body is null)
				return;

			GetSingleDocument(body, out var singleDoc, out var firstDoc, out bool hasNoSeqPoints);
			if (hasNoSeqPoints)
				return;

			var bwctx = AllocBinaryWriterContext();
			var outStream = bwctx.OutStream;
			var writer = bwctx.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;

			writer.WriteCompressedUInt32(localVarSigToken);
			if (singleDoc is null)
				writer.WriteCompressedUInt32(VerifyGetRid(firstDoc));

			var instrs = body.Instructions;
			var currentDoc = firstDoc;
			uint ilOffset = uint.MaxValue;
			int line = -1, column = 0;
			uint instrOffset = 0;
			Instruction instr = null;
			for (int i = 0; i < instrs.Count; i++, instrOffset += (uint)instr.GetSize()) {
				instr = instrs[i];
				var seqPoint = instr.SequencePoint;
				if (seqPoint is null)
					continue;
				if (seqPoint.Document is null) {
					Error("PDB document is null");
					return;
				}
				if (currentDoc != seqPoint.Document) {
					// document-record

					currentDoc = seqPoint.Document;
					writer.WriteCompressedUInt32(0);
					writer.WriteCompressedUInt32(VerifyGetRid(currentDoc));
				}

				// SequencePointRecord

				if (ilOffset == uint.MaxValue)
					writer.WriteCompressedUInt32(instrOffset);
				else
					writer.WriteCompressedUInt32(instrOffset - ilOffset);
				ilOffset = instrOffset;

				if (seqPoint.StartLine == SequencePointConstants.HIDDEN_LINE && seqPoint.EndLine == SequencePointConstants.HIDDEN_LINE) {
					// hidden-sequence-point-record

					writer.WriteCompressedUInt32(0);
					writer.WriteCompressedUInt32(0);
				}
				else {
					// sequence-point-record

					uint dlines = (uint)(seqPoint.EndLine - seqPoint.StartLine);
					int dcolumns = seqPoint.EndColumn - seqPoint.StartColumn;
					writer.WriteCompressedUInt32(dlines);
					if (dlines == 0)
						writer.WriteCompressedUInt32((uint)dcolumns);
					else
						writer.WriteCompressedInt32(dcolumns);

					if (line < 0) {
						writer.WriteCompressedUInt32((uint)seqPoint.StartLine);
						writer.WriteCompressedUInt32((uint)seqPoint.StartColumn);
					}
					else {
						writer.WriteCompressedInt32(seqPoint.StartLine - line);
						writer.WriteCompressedInt32(seqPoint.StartColumn - column);
					}
					line = seqPoint.StartLine;
					column = seqPoint.StartColumn;
				}
			}

			var seqPointsBlob = outStream.ToArray();
			var row = new RawMethodDebugInformationRow(singleDoc is null ? 0 : AddPdbDocument(singleDoc), debugMetadata.blobHeap.Add(seqPointsBlob));
			debugMetadata.tablesHeap.MethodDebugInformationTable[rid] = row;
			debugMetadata.methodDebugInformationInfosUsed = true;
			Free(ref bwctx);
		}

		uint VerifyGetRid(PdbDocument doc) {
			Debug.Assert(debugMetadata is not null);
			if (!debugMetadata.pdbDocumentInfos.TryGetRid(doc, out uint rid)) {
				Error("PDB document has been removed");
				return 0;
			}
			return rid;
		}

		static void GetSingleDocument(CilBody body, out PdbDocument singleDoc, out PdbDocument firstDoc, out bool hasNoSeqPoints) {
			var instrs = body.Instructions;
			int docCount = 0;
			singleDoc = null;
			firstDoc = null;
			for (int i = 0; i < instrs.Count; i++) {
				var seqPt = instrs[i].SequencePoint;
				if (seqPt is null)
					continue;
				var doc = seqPt.Document;
				if (doc is null)
					continue;
				if (firstDoc is null)
					firstDoc = doc;
				if (singleDoc != doc) {
					singleDoc = doc;
					docCount++;
					if (docCount > 1)
						break;
				}
			}
			hasNoSeqPoints = docCount == 0;
			if (docCount != 1)
				singleDoc = null;
		}

		/// <summary>
		/// Adds a <c>CustomDebugInformation</c> row
		/// </summary>
		/// <param name="table">Owner table</param>
		/// <param name="rid">New owner rid</param>
		/// <param name="hcdi">Onwer</param>
		protected void AddCustomDebugInformationList(Table table, uint rid, IHasCustomDebugInformation hcdi) {
			Debug.Assert(table != Table.Method);
			if (debugMetadata is null)
				return;
			if (hcdi.CustomDebugInfos.Count == 0)
				return;
			var serializerMethodContext = AllocSerializerMethodContext();
			serializerMethodContext.SetBody(null);
			AddCustomDebugInformationCore(serializerMethodContext, table, rid, hcdi.CustomDebugInfos);
			Free(ref serializerMethodContext);
		}

		void AddCustomDebugInformationList(Table table, uint rid, IList<PdbCustomDebugInfo> cdis) {
			Debug.Assert(table != Table.Method);
			if (debugMetadata is null)
				return;
			if (cdis.Count == 0)
				return;
			var serializerMethodContext = AllocSerializerMethodContext();
			serializerMethodContext.SetBody(null);
			AddCustomDebugInformationCore(serializerMethodContext, table, rid, cdis);
			Free(ref serializerMethodContext);
		}

		void AddCustomDebugInformationCore(SerializerMethodContext serializerMethodContext, Table table, uint rid, IList<PdbCustomDebugInfo> cdis) {
			Debug.Assert(debugMetadata is not null);
			Debug.Assert(cdis.Count != 0);

			var token = new MDToken(table, rid);
			if (!CodedToken.HasCustomDebugInformation.Encode(token, out uint encodedToken)) {
				Error("Couldn't encode HasCustomDebugInformation token {0:X8}", token.Raw);
				return;
			}

			for (int i = 0; i < cdis.Count; i++) {
				var cdi = cdis[i];
				if (cdi is null) {
					Error("Custom debug info is null");
					continue;
				}

				AddCustomDebugInformation(serializerMethodContext, token.Raw, encodedToken, cdi);
			}
		}

		void AddCustomDebugInformation(SerializerMethodContext serializerMethodContext, uint token, uint encodedToken, PdbCustomDebugInfo cdi) {
			Debug.Assert(debugMetadata is not null);

			switch (cdi.Kind) {
			case PdbCustomDebugInfoKind.UsingGroups:
			case PdbCustomDebugInfoKind.ForwardMethodInfo:
			case PdbCustomDebugInfoKind.ForwardModuleInfo:
			case PdbCustomDebugInfoKind.StateMachineTypeName:
			case PdbCustomDebugInfoKind.DynamicLocals:
			case PdbCustomDebugInfoKind.TupleElementNames:
			case PdbCustomDebugInfoKind.SourceServer:
				// These are Windows PDB CDIs
				Error("Unsupported custom debug info {0}", cdi.Kind);
				break;

			case PdbCustomDebugInfoKind.StateMachineHoistedLocalScopes:
			case PdbCustomDebugInfoKind.EditAndContinueLocalSlotMap:
			case PdbCustomDebugInfoKind.EditAndContinueLambdaMap:
			case PdbCustomDebugInfoKind.Unknown:
			case PdbCustomDebugInfoKind.TupleElementNames_PortablePdb:
			case PdbCustomDebugInfoKind.DefaultNamespace:
			case PdbCustomDebugInfoKind.DynamicLocalVariables:
			case PdbCustomDebugInfoKind.EmbeddedSource:
			case PdbCustomDebugInfoKind.SourceLink:
			case PdbCustomDebugInfoKind.CompilationMetadataReferences:
			case PdbCustomDebugInfoKind.CompilationOptions:
				AddCustomDebugInformationCore(serializerMethodContext, encodedToken, cdi, cdi.Guid);
				break;

			case PdbCustomDebugInfoKind.AsyncMethod:
				// This is a portable PDB pseudo CDI
				AddCustomDebugInformationCore(serializerMethodContext, encodedToken, cdi, CustomDebugInfoGuids.AsyncMethodSteppingInformationBlob);
				AddStateMachineMethod(cdi, token, ((PdbAsyncMethodCustomDebugInfo)cdi).KickoffMethod);
				break;

			case PdbCustomDebugInfoKind.IteratorMethod:
				// This is a portable PDB pseudo CDI
				AddStateMachineMethod(cdi, token, ((PdbIteratorMethodCustomDebugInfo)cdi).KickoffMethod);
				break;

			default:
				Error("Unknown custom debug info {0}", cdi.Kind.ToString());
				break;
			}
		}

		void AddStateMachineMethod(PdbCustomDebugInfo cdi, uint moveNextMethodToken, MethodDef kickoffMethod) {
			Debug.Assert(new MDToken(moveNextMethodToken).Table == Table.Method);
			Debug.Assert(debugMetadata is not null);
			if (kickoffMethod is null) {
				Error("KickoffMethod is null");
				return;
			}
			var row = new RawStateMachineMethodRow(new MDToken(moveNextMethodToken).Rid, GetRid(kickoffMethod));
			debugMetadata.stateMachineMethodInfos.Add(cdi, row);
		}

		void AddCustomDebugInformationCore(SerializerMethodContext serializerMethodContext, uint encodedToken, PdbCustomDebugInfo cdi, Guid cdiGuid) {
			Debug.Assert(debugMetadata is not null);

			var bwctx = AllocBinaryWriterContext();
			var cdiBlob = PortablePdbCustomDebugInfoWriter.Write(this, serializerMethodContext, this, cdi, bwctx);
			Debug.Assert(cdiGuid != Guid.Empty);
			Free(ref bwctx);
			var row = new RawCustomDebugInformationRow(encodedToken,
						debugMetadata.guidHeap.Add(cdiGuid),
						debugMetadata.blobHeap.Add(cdiBlob));
			debugMetadata.customDebugInfos.Add(cdi, row);
		}

		void InitializeMethodDebugInformation() {
			if (debugMetadata is null)
				return;
			int numMethods = NumberOfMethods;
			for (int i = 0; i < numMethods; i++)
				debugMetadata.tablesHeap.MethodDebugInformationTable.Create(new RawMethodDebugInformationRow());
		}

		void AddPdbDocuments() {
			if (debugMetadata is null)
				return;
			foreach (var doc in module.PdbState.Documents)
				AddPdbDocument(doc);
		}

		uint AddPdbDocument(PdbDocument doc) {
			Debug.Assert(debugMetadata is not null);
			if (doc is null) {
				Error("PdbDocument is null");
				return 0;
			}
			if (debugMetadata.pdbDocumentInfos.TryGetRid(doc, out uint rid))
				return rid;
			var row = new RawDocumentRow(GetDocumentNameBlobOffset(doc.Url),
							debugMetadata.guidHeap.Add(doc.CheckSumAlgorithmId),
							debugMetadata.blobHeap.Add(doc.CheckSum),
							debugMetadata.guidHeap.Add(doc.Language));
			rid = debugMetadata.tablesHeap.DocumentTable.Add(row);
			debugMetadata.pdbDocumentInfos.Add(doc, rid);
			AddCustomDebugInformationList(Table.Document, rid, doc.CustomDebugInfos);
			return rid;
		}

		uint GetDocumentNameBlobOffset(string name) {
			Debug.Assert(debugMetadata is not null);
			if (name is null) {
				Error("Document name is null");
				name = string.Empty;
			}

			var bwctx = AllocBinaryWriterContext();
			var outStream = bwctx.OutStream;
			var writer = bwctx.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;
			var parts = name.Split(directorySeparatorCharArray);
			if (parts.Length == 1)
				writer.WriteByte(0);
			else
				writer.WriteBytes(directorySeparatorCharUtf8);
			for (int i = 0; i < parts.Length; i++) {
				var part = parts[i];
				uint partOffset = debugMetadata.blobHeap.Add(Encoding.UTF8.GetBytes(part));
				writer.WriteCompressedUInt32(partOffset);
			}

			var res = debugMetadata.blobHeap.Add(outStream.ToArray());
			Free(ref bwctx);
			return res;
		}
		static readonly byte[] directorySeparatorCharUtf8 = Encoding.UTF8.GetBytes(Path.DirectorySeparatorChar.ToString());
		static readonly char[] directorySeparatorCharArray = new char[] { Path.DirectorySeparatorChar };

		uint AddImportScope(PdbImportScope scope) {
			Debug.Assert(debugMetadata is not null);
			if (scope is null)
				return 0;
			if (debugMetadata.importScopeInfos.TryGetRid(scope, out uint rid)) {
				if (rid == 0)
					Error("PdbImportScope has an infinite Parent loop");
				return rid;
			}
			debugMetadata.importScopeInfos.Add(scope, 0);   // Prevent inf recursion

			var bwctx = AllocBinaryWriterContext();
			var outStream = bwctx.OutStream;
			var writer = bwctx.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;
			ImportScopeBlobWriter.Write(this, this, writer, debugMetadata.blobHeap, scope.Imports);
			var importsData = outStream.ToArray();
			Free(ref bwctx);

			var row = new RawImportScopeRow(AddImportScope(scope.Parent), debugMetadata.blobHeap.Add(importsData));
			rid = debugMetadata.tablesHeap.ImportScopeTable.Add(row);
			debugMetadata.importScopeInfos.SetRid(scope, rid);

			AddCustomDebugInformationList(Table.ImportScope, rid, scope.CustomDebugInfos);
			return rid;
		}

		void AddLocalVariable(PdbLocal local) {
			Debug.Assert(debugMetadata is not null);
			if (local is null) {
				Error("PDB local is null");
				return;
			}
			var row = new RawLocalVariableRow((ushort)local.Attributes, (ushort)local.Index, debugMetadata.stringsHeap.Add(local.Name));
			uint rid = debugMetadata.tablesHeap.LocalVariableTable.Create(row);
			debugMetadata.localVariableInfos.Add(local, rid);
			AddCustomDebugInformationList(Table.LocalVariable, rid, local.CustomDebugInfos);
		}

		void AddLocalConstant(PdbConstant constant) {
			Debug.Assert(debugMetadata is not null);
			if (constant is null) {
				Error("PDB constant is null");
				return;
			}

			var bwctx = AllocBinaryWriterContext();
			var outStream = bwctx.OutStream;
			var writer = bwctx.Writer;
			outStream.SetLength(0);
			outStream.Position = 0;
			LocalConstantSigBlobWriter.Write(this, this, writer, constant.Type, constant.Value);
			var signature = outStream.ToArray();
			Free(ref bwctx);

			var row = new RawLocalConstantRow(debugMetadata.stringsHeap.Add(constant.Name), debugMetadata.blobHeap.Add(signature));
			uint rid = debugMetadata.tablesHeap.LocalConstantTable.Create(row);
			debugMetadata.localConstantInfos.Add(constant, rid);
			AddCustomDebugInformationList(Table.LocalConstant, rid, constant.CustomDebugInfos);
		}

		/// <summary>
		/// Writes the portable PDB to <paramref name="output"/>.
		/// </summary>
		/// <param name="output">Output stream</param>
		/// <param name="entryPointToken">Entry point token</param>
		/// <param name="pdbIdOffset">Updated with the offset of the 20-byte PDB ID. The caller is responsible for initializing it with the PDB ID</param>
		internal void WritePortablePdb(Stream output, uint entryPointToken, out long pdbIdOffset) {
			if (debugMetadata is null)
				throw new InvalidOperationException();
			var pdbHeap = debugMetadata.PdbHeap;
			pdbHeap.EntryPoint = entryPointToken;

			tablesHeap.GetSystemTableRows(out ulong systemTablesMask, pdbHeap.TypeSystemTableRows);
			debugMetadata.tablesHeap.SetSystemTableRows(pdbHeap.TypeSystemTableRows);
			if (!debugMetadata.methodDebugInformationInfosUsed)
				debugMetadata.tablesHeap.MethodDebugInformationTable.Reset();
			pdbHeap.ReferencedTypeSystemTables = systemTablesMask;
			var writer = new DataWriter(output);
			debugMetadata.OnBeforeSetOffset();
			debugMetadata.SetOffset(0, 0);
			debugMetadata.GetFileLength();
			debugMetadata.VerifyWriteTo(writer);
			pdbIdOffset = (long)pdbHeap.PdbIdOffset;
		}

		/// <inheritdoc/>
		uint ISignatureWriterHelper.ToEncodedToken(ITypeDefOrRef typeDefOrRef) => AddTypeDefOrRef(typeDefOrRef);

		/// <inheritdoc/>
		void IWriterError.Error(string message) => Error(message);

		/// <inheritdoc/>
		void IWriterError2.Error(string message, params object[] args) => Error(message, args);

		/// <inheritdoc/>
		bool IFullNameFactoryHelper.MustUseAssemblyName(IType type) =>
			FullNameFactory.MustUseAssemblyName(module, type, OptimizeCustomAttributeSerializedTypeNames);

		/// <summary>
		/// Called before any other methods
		/// </summary>
		protected virtual void Initialize() {
		}

		/// <summary>
		/// Gets all <see cref="TypeDef"/>s that should be saved in the meta data
		/// </summary>
		protected abstract TypeDef[] GetAllTypeDefs();

		/// <summary>
		/// Initializes <c>TypeDef</c> rids and creates raw rows, but does not initialize
		/// any columns.
		/// </summary>
		protected abstract void AllocateTypeDefRids();

		/// <summary>
		/// Allocates <c>Field</c>, <c>Method</c>, <c>Property</c>, <c>Event</c>, <c>Param</c>:
		/// rid and raw row, but doesn't initialize the raw row.
		/// Initializes <c>TypeDef</c> columns: <c>FieldList</c>, <c>MethodList</c>.
		/// Initializes <c>Method</c> column: <c>ParamList</c>.
		/// Initializes <see cref="Metadata.eventMapInfos"/> and <see cref="Metadata.propertyMapInfos"/>.
		/// </summary>
		protected abstract void AllocateMemberDefRids();

		/// <summary>
		/// Adds a <see cref="TypeRef"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="tr">Type reference</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddTypeRef(TypeRef tr);

		/// <summary>
		/// Adds a <see cref="TypeSpec"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="ts">Type spec</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddTypeSpec(TypeSpec ts);

		/// <summary>
		/// Adds a <see cref="MemberRef"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="mr">Member ref</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddMemberRef(MemberRef mr);

		/// <summary>
		/// Adds a <see cref="StandAloneSig"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="sas">Stand alone sig</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddStandAloneSig(StandAloneSig sas);

		/// <summary>
		/// Adds a <see cref="MethodSpec"/>. Its custom attributes are also added.
		/// </summary>
		/// <param name="ms">Method spec</param>
		/// <returns>Its new rid</returns>
		protected abstract uint AddMethodSpec(MethodSpec ms);

		/// <summary>
		/// Called before sorting the <c>CustomAttribute</c> table. This is the last time anything
		/// can be inserted into this table.
		/// </summary>
		protected virtual void BeforeSortingCustomAttributes() {
		}

		/// <summary>
		/// Called after everything has been initialized. The sub class can initialize more
		/// rows if necessary or do nothing. After this method has been called, nothing else
		/// can be added.
		/// </summary>
		protected virtual void EverythingInitialized() {
		}

		const uint HEAP_ALIGNMENT = 4;

		bool IReuseChunk.CanReuse(RVA origRva, uint origSize) {
			// The caller should've called SetOffset() so we know our final size
			Debug.Assert(length != 0);
			if (length == 0)
				throw new InvalidOperationException();
			return length <= origSize;
		}

		/// <summary>
		/// Should be called before all chunks get an RVA
		/// </summary>
		internal void OnBeforeSetOffset() =>
			stringsHeap.AddOptimizedStringsAndSetReadOnly();

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			// This method can be called twice by NativeModuleWriter. It needs to know the size
			// of the final metadata. If it fits in the old location, the new MD will be written
			// there (smaller file size). If the new MD doesn't fit in the old location, this
			// method gets called a second time with the updated offset + rva.
			bool initAll = this.offset == 0;
			this.offset = offset;
			this.rva = rva;

			if (initAll) {
				// #Strings heap is initialized in OnBeforeSetOffset()
				blobHeap.SetReadOnly();
				guidHeap.SetReadOnly();
				tablesHeap.SetReadOnly();
				pdbHeap.SetReadOnly();
				tablesHeap.BigStrings = stringsHeap.IsBig;
				tablesHeap.BigBlob = blobHeap.IsBig;
				tablesHeap.BigGuid = guidHeap.IsBig;
				metadataHeader.Heaps = GetHeaps();
			}

			metadataHeader.SetOffset(offset, rva);
			uint len = metadataHeader.GetFileLength();
			offset += len;
			rva += len;

			foreach (var heap in metadataHeader.Heaps) {
				offset = offset.AlignUp(HEAP_ALIGNMENT);
				rva = rva.AlignUp(HEAP_ALIGNMENT);
				heap.SetOffset(offset, rva);
				len = heap.GetFileLength();
				offset += len;
				rva += len;
			}
			Debug.Assert(initAll || length == rva - this.rva);
			if (!(initAll || length == rva - this.rva))
				throw new InvalidOperationException();
			length = rva - this.rva;

			if (!isStandaloneDebugMetadata && initAll)
				UpdateMethodAndFieldRvas();
		}

		internal void UpdateMethodAndFieldRvas() {
			UpdateMethodRvas();
			UpdateFieldRvas();
		}

		IList<IHeap> GetHeaps() {
			var heaps = new List<IHeap>();

			if (isStandaloneDebugMetadata) {
				heaps.Add(pdbHeap);
				heaps.Add(tablesHeap);
				if (!stringsHeap.IsEmpty)
					heaps.Add(stringsHeap);
				if (!usHeap.IsEmpty)
					heaps.Add(usHeap);
				if (!guidHeap.IsEmpty)
					heaps.Add(guidHeap);
				if (!blobHeap.IsEmpty)
					heaps.Add(blobHeap);
			}
			else {
				heaps.Add(tablesHeap);
				if (!stringsHeap.IsEmpty || AlwaysCreateStringsHeap)
					heaps.Add(stringsHeap);
				if (!usHeap.IsEmpty || AlwaysCreateUSHeap)
					heaps.Add(usHeap);
				if (!guidHeap.IsEmpty || AlwaysCreateGuidHeap)
					heaps.Add(guidHeap);
				if (!blobHeap.IsEmpty || AlwaysCreateBlobHeap)
					heaps.Add(blobHeap);

				heaps.AddRange(options.CustomHeaps);
				options.RaiseMetadataHeapsAdded(new MetadataHeapsAddedEventArgs(this, heaps));
			}

			return heaps;
		}

		/// <inheritdoc/>
		public uint GetFileLength() => length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			var rva2 = rva;
			metadataHeader.VerifyWriteTo(writer);
			rva2 += metadataHeader.GetFileLength();

			foreach (var heap in metadataHeader.Heaps) {
				writer.WriteZeroes((int)(rva2.AlignUp(HEAP_ALIGNMENT) - rva2));
				rva2 = rva2.AlignUp(HEAP_ALIGNMENT);
				heap.VerifyWriteTo(writer);
				rva2 += heap.GetFileLength();
			}
		}

		/// <summary>
		/// Sorts the <see cref="ParamDef"/>s
		/// </summary>
		/// <param name="pds">All <see cref="ParamDef"/>s</param>
		/// <returns>A sorted <see cref="ParamDef"/> list</returns>
		protected static List<ParamDef> Sort(IEnumerable<ParamDef> pds) {
			var sorted = new List<ParamDef>(pds);
			sorted.Sort((a, b) => {
				if (a is null)
					return -1;
				if (b is null)
					return 1;
				return a.Sequence.CompareTo(b.Sequence);
			});
			return sorted;
		}

		DataWriterContext AllocBinaryWriterContext() {
			if (binaryWriterContexts.Count == 0)
				return new DataWriterContext();
			var res = binaryWriterContexts[binaryWriterContexts.Count - 1];
			binaryWriterContexts.RemoveAt(binaryWriterContexts.Count - 1);
			return res;
		}

		void Free(ref DataWriterContext ctx) {
			binaryWriterContexts.Add(ctx);
			ctx = null;
		}

		SerializerMethodContext AllocSerializerMethodContext() {
			if (serializerMethodContexts.Count == 0)
				return new SerializerMethodContext(this);
			var res = serializerMethodContexts[serializerMethodContexts.Count - 1];
			serializerMethodContexts.RemoveAt(serializerMethodContexts.Count - 1);
			return res;
		}

		void Free(ref SerializerMethodContext ctx) {
			serializerMethodContexts.Add(ctx);
			ctx = null;
		}
	}
}




namespace dnlib.DotNet.Writer {
	/// <summary>
	/// All <see cref="Metadata"/> events
	/// </summary>
	public enum MetadataEvent {
		/// <summary>
		/// Creating the tables has just begun
		/// </summary>
		BeginCreateTables,

		/// <summary>
		/// Before allocating all TypeDef RIDs
		/// </summary>
		AllocateTypeDefRids,

		/// <summary>
		/// Before allocating all MemberDef RIDs
		/// </summary>
		AllocateMemberDefRids,

		/// <summary>
		/// The <c>rid</c>s of types, fields, methods, events, properties and parameters are
		/// now known.
		/// </summary>
		MemberDefRidsAllocated,

		/// <summary>
		/// The tables and rows of all types, fields, methods, events, properties and parameters
		/// have been initialized. Method body RVAs are still not known, and no method has been
		/// written yet.
		/// </summary>
		MemberDefsInitialized,

		/// <summary>
		/// Before sorting most tables
		/// </summary>
		BeforeSortTables,

		/// <summary>
		/// Most of the tables that should be sorted have been sorted. The <c>CustomAttribute</c>
		/// table is still unsorted since it hasn't been created yet.
		/// </summary>
		MostTablesSorted,

		/// <summary>
		/// Custom attributes of all types, fields, methods, events, properties and parameters
		/// have now been written.
		/// </summary>
		MemberDefCustomAttributesWritten,

		/// <summary>
		/// All resources are about to be added to the .NET resources table
		/// </summary>
		BeginAddResources,

		/// <summary>
		/// All resources have been added to the .NET resources table
		/// </summary>
		EndAddResources,

		/// <summary>
		/// All method bodies are about to be written
		/// </summary>
		BeginWriteMethodBodies,

		/// <summary>
		/// All method bodies have been written. Their RVAs are still not known.
		/// </summary>
		EndWriteMethodBodies,

		/// <summary>
		/// All tables are now sorted, including the <c>CustomAttribute</c> table.
		/// </summary>
		OnAllTablesSorted,

		/// <summary>
		/// All tables have been created and all rows populated. The only columns that haven't
		/// been initialized yet are the ones that are RVAs.
		/// </summary>
		EndCreateTables,
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="MetadataHeader"/> options
	/// </summary>
	public sealed class MetadataHeaderOptions {
		/// <summary>
		/// Default version string
		/// </summary>
		public const string DEFAULT_VERSION_STRING = MDHeaderRuntimeVersion.MS_CLR_20;

		/// <summary>
		/// Default header signature
		/// </summary>
		public const uint DEFAULT_SIGNATURE = 0x424A5342;

		/// <summary>
		/// MD header signature. Default value is <see cref="DEFAULT_SIGNATURE"/>
		/// </summary>
		public uint? Signature;

		/// <summary>
		/// Major version. Default is 1. MS' CLR supports v0.x (x >= 19) and v1.1, nothing else.
		/// </summary>
		public ushort? MajorVersion;

		/// <summary>
		/// Minor version. Default is 1.
		/// </summary>
		public ushort? MinorVersion;

		/// <summary>
		/// Reserved and should be 0.
		/// </summary>
		public uint? Reserved1;

		/// <summary>
		/// Version string. Default is <see cref="DEFAULT_VERSION_STRING"/>. It's stored as a
		/// zero-terminated UTF-8 string. Length should be &lt;= 255 bytes.
		/// </summary>
		public string VersionString;

		/// <summary>
		/// Storage flags should be 0
		/// </summary>
		public StorageFlags? StorageFlags;

		/// <summary>
		/// Reserved and should be 0
		/// </summary>
		public byte? Reserved2;

		/// <summary>
		/// Creates portable PDB v1.0 options
		/// </summary>
		/// <returns></returns>
		public static MetadataHeaderOptions CreatePortablePdbV1_0() =>
			new MetadataHeaderOptions() {
				Signature = DEFAULT_SIGNATURE,
				MajorVersion = 1,
				MinorVersion = 1,
				Reserved1 = 0,
				VersionString = MDHeaderRuntimeVersion.PORTABLE_PDB_V1_0,
				StorageFlags = 0,
				Reserved2 = 0,
			};
	}

	/// <summary>
	/// Meta data header. IMAGE_COR20_HEADER.Metadata points to this header.
	/// </summary>
	public sealed class MetadataHeader : IChunk {
		IList<IHeap> heaps;
		readonly MetadataHeaderOptions options;
		uint length;
		FileOffset offset;
		RVA rva;

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Gets/sets the heaps
		/// </summary>
		public IList<IHeap> Heaps {
			get => heaps;
			set => heaps = value;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public MetadataHeader()
			: this(null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Options</param>
		public MetadataHeader(MetadataHeaderOptions options) => this.options = options ?? new MetadataHeaderOptions();

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			length = 16;
			length += (uint)GetVersionString().Length;
			length = Utils.AlignUp(length, 4);
			length += 4;
			var heaps = this.heaps;
			int count = heaps.Count;
			for (int i = 0; i < count; i++) {
				var heap = heaps[i];
				length += 8;
				length += (uint)GetAsciizName(heap.Name).Length;
				length = Utils.AlignUp(length, 4);
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() => length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			writer.WriteUInt32(options.Signature ?? MetadataHeaderOptions.DEFAULT_SIGNATURE);
			writer.WriteUInt16(options.MajorVersion ?? 1);
			writer.WriteUInt16(options.MinorVersion ?? 1);
			writer.WriteUInt32(options.Reserved1 ?? 0);
			var s = GetVersionString();
			writer.WriteInt32(Utils.AlignUp(s.Length, 4));
			writer.WriteBytes(s);
			writer.WriteZeroes(Utils.AlignUp(s.Length, 4) - s.Length);
			writer.WriteByte((byte)(options.StorageFlags ?? 0));
			writer.WriteByte(options.Reserved2 ?? 0);
			var heaps = this.heaps;
			writer.WriteUInt16((ushort)heaps.Count);
			int count = heaps.Count;
			for (int i = 0; i < count; i++) {
				var heap = heaps[i];
				writer.WriteUInt32((uint)(heap.FileOffset - offset));
				writer.WriteUInt32(heap.GetFileLength());
				writer.WriteBytes(s = GetAsciizName(heap.Name));
				if (s.Length > 32)
					throw new ModuleWriterException($"Heap name '{heap.Name}' is > 32 bytes");
				writer.WriteZeroes(Utils.AlignUp(s.Length, 4) - s.Length);
			}
		}

		byte[] GetVersionString() => Encoding.UTF8.GetBytes((options.VersionString ?? MetadataHeaderOptions.DEFAULT_VERSION_STRING) + "\0");
		byte[] GetAsciizName(string s) => Encoding.ASCII.GetBytes(s + "\0");
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Method body chunk
	/// </summary>
	public sealed class MethodBody : IChunk {
		const uint EXTRA_SECTIONS_ALIGNMENT = 4;

		readonly bool isTiny;
		readonly byte[] code;
		readonly byte[] extraSections;
		uint length;
		FileOffset offset;
		RVA rva;
		readonly uint localVarSigTok;

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Gets the code
		/// </summary>
		public byte[] Code => code;

		/// <summary>
		/// Gets the extra sections (exception handlers) or <c>null</c>
		/// </summary>
		public byte[] ExtraSections => extraSections;

		/// <summary>
		/// Gets the token of the locals
		/// </summary>
		public uint LocalVarSigTok => localVarSigTok;

		/// <summary>
		/// <c>true</c> if it's a fat body
		/// </summary>
		public bool IsFat => !isTiny;

		/// <summary>
		/// <c>true</c> if it's a tiny body
		/// </summary>
		public bool IsTiny => isTiny;

		/// <summary>
		/// <c>true</c> if there's an extra section
		/// </summary>
		public bool HasExtraSections => extraSections is not null && extraSections.Length > 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="code">Code</param>
		public MethodBody(byte[] code)
			: this(code, null, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="code">Code</param>
		/// <param name="extraSections">Extra sections or <c>null</c></param>
		public MethodBody(byte[] code, byte[] extraSections)
			: this(code, extraSections, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="code">Code</param>
		/// <param name="extraSections">Extra sections or <c>null</c></param>
		/// <param name="localVarSigTok">Token of locals</param>
		public MethodBody(byte[] code, byte[] extraSections, uint localVarSigTok) {
			isTiny = (code[0] & 3) == 2;
			this.code = code;
			this.extraSections = extraSections;
			this.localVarSigTok = localVarSigTok;
		}

		/// <summary>
		/// Gets the approximate size of the method body (code + exception handlers)
		/// </summary>
		public int GetApproximateSizeOfMethodBody() {
			int len = code.Length;
			if (extraSections is not null) {
				len = Utils.AlignUp(len, EXTRA_SECTIONS_ALIGNMENT);
				len += extraSections.Length;
				len = Utils.AlignUp(len, EXTRA_SECTIONS_ALIGNMENT);
			}
			return len;
		}

		internal bool CanReuse(RVA origRva, uint origSize) {
			uint length;
			if (HasExtraSections) {
				var rva2 = origRva + (uint)code.Length;
				rva2 = rva2.AlignUp(EXTRA_SECTIONS_ALIGNMENT);
				rva2 += (uint)extraSections.Length;
				length = (uint)rva2 - (uint)origRva;
			}
			else
				length = (uint)code.Length;
			return length <= origSize;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			Debug.Assert(this.rva == 0);
			this.offset = offset;
			this.rva = rva;
			if (HasExtraSections) {
				var rva2 = rva + (uint)code.Length;
				rva2 = rva2.AlignUp(EXTRA_SECTIONS_ALIGNMENT);
				rva2 += (uint)extraSections.Length;
				length = (uint)rva2 - (uint)rva;
			}
			else
				length = (uint)code.Length;
		}

		/// <inheritdoc/>
		public uint GetFileLength() => length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			writer.WriteBytes(code);
			if (HasExtraSections) {
				var rva2 = rva + (uint)code.Length;
				writer.WriteZeroes((int)rva2.AlignUp(EXTRA_SECTIONS_ALIGNMENT) - (int)rva2);
				writer.WriteBytes(extraSections);
			}
		}

		/// <inheritdoc/>
		public override int GetHashCode() => Utils.GetHashCode(code) + Utils.GetHashCode(extraSections);

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			var other = obj as MethodBody;
			if (other is null)
				return false;
			return Utils.Equals(code, other.code) &&
				Utils.Equals(extraSections, other.extraSections);
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Stores all method body chunks
	/// </summary>
	public sealed class MethodBodyChunks : IChunk {
		const uint FAT_BODY_ALIGNMENT = 4;
		Dictionary<MethodBody, MethodBody> tinyMethodsDict;
		Dictionary<MethodBody, MethodBody> fatMethodsDict;
		readonly List<MethodBody> tinyMethods;
		readonly List<MethodBody> fatMethods;
		readonly List<ReusedMethodInfo> reusedMethods;
		readonly Dictionary<uint, MethodBody> rvaToReusedMethod;
		readonly bool shareBodies;
		FileOffset offset;
		RVA rva;
		uint length;
		bool setOffsetCalled;
		readonly bool alignFatBodies;
		uint savedBytes;

		readonly struct ReusedMethodInfo {
			public readonly MethodBody MethodBody;
			public readonly RVA RVA;
			public ReusedMethodInfo(MethodBody methodBody, RVA rva) {
				MethodBody = methodBody;
				RVA = rva;
			}
		}

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Gets the number of bytes saved by re-using method bodies
		/// </summary>
		public uint SavedBytes => savedBytes;

		internal bool CanReuseOldBodyLocation { get; set; }
		internal bool ReusedAllMethodBodyLocations => tinyMethods.Count == 0 && fatMethods.Count == 0;
		internal bool HasReusedMethods => reusedMethods.Count > 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="shareBodies"><c>true</c> if bodies can be shared</param>
		public MethodBodyChunks(bool shareBodies) {
			this.shareBodies = shareBodies;
			alignFatBodies = true;
			if (shareBodies) {
				tinyMethodsDict = new Dictionary<MethodBody, MethodBody>();
				fatMethodsDict = new Dictionary<MethodBody, MethodBody>();
			}
			tinyMethods = new List<MethodBody>();
			fatMethods = new List<MethodBody>();
			reusedMethods = new List<ReusedMethodInfo>();
			rvaToReusedMethod = new Dictionary<uint, MethodBody>();
		}

		/// <summary>
		/// Adds a <see cref="MethodBody"/> and returns the one that has been cached
		/// </summary>
		/// <param name="methodBody">The method body</param>
		/// <returns>The cached method body</returns>
		public MethodBody Add(MethodBody methodBody) => Add(methodBody, 0, 0);

		internal MethodBody Add(MethodBody methodBody, RVA origRva, uint origSize) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			if (CanReuseOldBodyLocation && origRva != 0 && origSize != 0 && methodBody.CanReuse(origRva, origSize)) {
				if (rvaToReusedMethod.TryGetValue((uint)origRva, out var reusedMethod)) {
					if (methodBody.Equals(reusedMethod))
						return reusedMethod;
				}
				else {
					rvaToReusedMethod.Add((uint)origRva, methodBody);
					reusedMethods.Add(new ReusedMethodInfo(methodBody, origRva));
					return methodBody;
				}
			}
			if (shareBodies) {
				var dict = methodBody.IsFat ? fatMethodsDict : tinyMethodsDict;
				if (dict.TryGetValue(methodBody, out var cached)) {
					savedBytes += (uint)methodBody.GetApproximateSizeOfMethodBody();
					return cached;
				}
				dict[methodBody] = methodBody;
			}
			var list = methodBody.IsFat ? fatMethods : tinyMethods;
			list.Add(methodBody);
			return methodBody;
		}

		/// <summary>Removes the specified method body from this chunk</summary>
		/// <param name="methodBody">The method body</param>
		/// <returns><see langword="true" /> if the method body is removed</returns>
		public bool Remove(MethodBody methodBody) {
			if (methodBody is null)
				throw new ArgumentNullException(nameof(methodBody));
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			if (CanReuseOldBodyLocation)
				throw new InvalidOperationException("Reusing old body locations is enabled. Can't remove bodies.");

			var list = methodBody.IsFat ? fatMethods : tinyMethods;
			return list.Remove(methodBody);
		}

		internal void InitializeReusedMethodBodies(Func<RVA, FileOffset> getNewFileOffset) {
			foreach (var info in reusedMethods) {
				var offset = getNewFileOffset(info.RVA);
				info.MethodBody.SetOffset(offset, info.RVA);
			}
		}

		internal void WriteReusedMethodBodies(DataWriter writer, long destStreamBaseOffset) {
			foreach (var info in reusedMethods) {
				Debug.Assert(info.MethodBody.RVA == info.RVA);
				if (info.MethodBody.RVA != info.RVA)
					throw new InvalidOperationException();
				writer.Position = destStreamBaseOffset + (uint)info.MethodBody.FileOffset;
				info.MethodBody.VerifyWriteTo(writer);
			}
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			setOffsetCalled = true;
			this.offset = offset;
			this.rva = rva;

			tinyMethodsDict = null;
			fatMethodsDict = null;

			var rva2 = rva;
			foreach (var mb in tinyMethods) {
				mb.SetOffset(offset, rva2);
				uint len = mb.GetFileLength();
				rva2 += len;
				offset += len;
			}

			foreach (var mb in fatMethods) {
				if (alignFatBodies) {
					uint padding = (uint)rva2.AlignUp(FAT_BODY_ALIGNMENT) - (uint)rva2;
					rva2 += padding;
					offset += padding;
				}
				mb.SetOffset(offset, rva2);
				uint len = mb.GetFileLength();
				rva2 += len;
				offset += len;
			}

			length = (uint)rva2 - (uint)rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() => length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			var rva2 = rva;
			foreach (var mb in tinyMethods) {
				mb.VerifyWriteTo(writer);
				rva2 += mb.GetFileLength();
			}

			foreach (var mb in fatMethods) {
				if (alignFatBodies) {
					int padding = (int)rva2.AlignUp(FAT_BODY_ALIGNMENT) - (int)rva2;
					writer.WriteZeroes(padding);
					rva2 += (uint)padding;
				}
				mb.VerifyWriteTo(writer);
				rva2 += mb.GetFileLength();
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Returns tokens of token types, strings and signatures
	/// </summary>
	public interface ITokenProvider : IWriterError {
		/// <summary>
		/// Gets the token of <paramref name="o"/>
		/// </summary>
		/// <param name="o">A token type or a string or a signature</param>
		/// <returns>The token</returns>
		MDToken GetToken(object o);

		/// <summary>
		/// Gets a <c>StandAloneSig</c> token
		/// </summary>
		/// <param name="locals">All locals</param>
		/// <param name="origToken">The original token or <c>0</c> if none</param>
		/// <returns>A <c>StandAloneSig</c> token or <c>0</c> if <paramref name="locals"/> is
		/// empty.</returns>
		MDToken GetToken(IList<TypeSig> locals, uint origToken);
	}

	/// <summary>
	/// Writes CIL method bodies
	/// </summary>
	public sealed class MethodBodyWriter : MethodBodyWriterBase {
		readonly ITokenProvider helper;
		MethodDef method;
		CilBody cilBody;
		bool keepMaxStack;
		uint codeSize;
		uint maxStack;
		byte[] code;
		byte[] extraSections;
		uint localVarSigTok;

		/// <summary>
		/// Gets the code as a byte array. This is valid only after calling <see cref="Write()"/>.
		/// The size of this array is not necessarily a multiple of 4, even if there are exception
		/// handlers present. See also <see cref="GetFullMethodBody()"/>
		/// </summary>
		public byte[] Code => code;

		/// <summary>
		/// Gets the extra sections (exception handlers) as a byte array or <c>null</c> if there
		/// are no exception handlers. This is valid only after calling <see cref="Write()"/>
		/// </summary>
		public byte[] ExtraSections => extraSections;

		/// <summary>
		/// Gets the token of the locals
		/// </summary>
		public uint LocalVarSigTok => localVarSigTok;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="helper">Helps this instance</param>
		/// <param name="method">The method</param>
		public MethodBodyWriter(ITokenProvider helper, MethodDef method)
			: this(helper, method, false) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="helper">Helps this instance</param>
		/// <param name="method">The method</param>
		/// <param name="keepMaxStack">Keep the original max stack value that has been initialized
		/// in <paramref name="method"/></param>
		public MethodBodyWriter(ITokenProvider helper, MethodDef method, bool keepMaxStack)
			: base(method.Body.Instructions, method.Body.ExceptionHandlers) {
			this.helper = helper;
			this.method = method;
			this.keepMaxStack = keepMaxStack;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="helper">Helps this instance</param>
		/// <param name="cilBody">The CIL method body</param>
		public MethodBodyWriter(ITokenProvider helper, CilBody cilBody)
			: this(helper, cilBody, false) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="helper">Helps this instance</param>
		/// <param name="cilBody">The CIL method body</param>
		/// <param name="keepMaxStack">Keep the original max stack value that has been initialized
		/// in <paramref name="cilBody"/></param>
		public MethodBodyWriter(ITokenProvider helper, CilBody cilBody, bool keepMaxStack)
			: base(cilBody.Instructions, cilBody.ExceptionHandlers) {
			this.helper = helper;
			this.cilBody = cilBody;
			this.keepMaxStack = keepMaxStack;
		}

		internal MethodBodyWriter(ITokenProvider helper) {
			this.helper = helper;
		}

		internal void Reset(MethodDef method, bool keepMaxStack) {
			this.method = method;
			this.keepMaxStack = keepMaxStack;
			cilBody = method.Body;
			codeSize = 0;
			maxStack = 0;
			code = null;
			extraSections = null;
			localVarSigTok = 0;
			Reset(cilBody.Instructions, cilBody.ExceptionHandlers);
		}

		/// <summary>
		/// Writes the method body
		/// </summary>
		public void Write() {
			codeSize = InitializeInstructionOffsets();
			maxStack = keepMaxStack ? cilBody.MaxStack : GetMaxStack();
			if (NeedFatHeader())
				WriteFatHeader();
			else
				WriteTinyHeader();
			if (exceptionHandlers.Count > 0)
				WriteExceptionHandlers();
		}

		/// <summary>
		/// Gets the code and (possible) exception handlers in one array. The exception handlers
		/// are 4-byte aligned.
		/// </summary>
		/// <returns>The code and any exception handlers</returns>
		public byte[] GetFullMethodBody() {
			int padding = Utils.AlignUp(code.Length, 4) - code.Length;
			var bytes = new byte[code.Length + (extraSections is null ? 0 : padding + extraSections.Length)];
			Array.Copy(code, 0, bytes, 0, code.Length);
			if (extraSections is not null)
				Array.Copy(extraSections, 0, bytes, code.Length + padding, extraSections.Length);
			return bytes;
		}

		bool NeedFatHeader() {
			//TODO: If locals has cust attrs or custom debug infos, we also need a fat header
			return codeSize > 0x3F ||
					exceptionHandlers.Count > 0 ||
					cilBody.HasVariables ||
					maxStack > 8;
		}

		void WriteFatHeader() {
			if (maxStack > ushort.MaxValue) {
				Error("MaxStack is too big");
				maxStack = ushort.MaxValue;
			}

			ushort flags = 0x3003;
			if (exceptionHandlers.Count > 0)
				flags |= 8;
			if (cilBody.InitLocals)
				flags |= 0x10;

			code = new byte[12 + codeSize];
			var writer = new ArrayWriter(code);
			writer.WriteUInt16(flags);
			writer.WriteUInt16((ushort)maxStack);
			writer.WriteUInt32(codeSize);
			writer.WriteUInt32(localVarSigTok = helper.GetToken(GetLocals(), cilBody.LocalVarSigTok).Raw);
			if (WriteInstructions(ref writer) != codeSize)
				Error("Didn't write all code bytes");
		}

		IList<TypeSig> GetLocals() {
			var localsSig = new TypeSig[cilBody.Variables.Count];
			for (int i = 0; i < cilBody.Variables.Count; i++)
				localsSig[i] = cilBody.Variables[i].Type;
			return localsSig;
		}

		void WriteTinyHeader() {
			localVarSigTok = 0;
			code = new byte[1 + codeSize];
			var writer = new ArrayWriter(code);
			writer.WriteByte((byte)((codeSize << 2) | 2));
			if (WriteInstructions(ref writer) != codeSize)
				Error("Didn't write all code bytes");
		}

		void WriteExceptionHandlers() {
			if (NeedFatExceptionClauses())
				extraSections = WriteFatExceptionClauses();
			else
				extraSections = WriteSmallExceptionClauses();
		}

		bool NeedFatExceptionClauses() {
			// Size must fit in a byte, and since one small exception record is 12 bytes
			// and header is 4 bytes: x*12+4 <= 255 ==> x <= 20
			var exceptionHandlers = this.exceptionHandlers;
			if (exceptionHandlers.Count > 20)
				return true;

			for (int i = 0; i < exceptionHandlers.Count; i++) {
				var eh = exceptionHandlers[i];
				if (!FitsInSmallExceptionClause(eh.TryStart, eh.TryEnd))
					return true;
				if (!FitsInSmallExceptionClause(eh.HandlerStart, eh.HandlerEnd))
					return true;
			}

			return false;
		}

		bool FitsInSmallExceptionClause(Instruction start, Instruction end) {
			uint offs1 = GetOffset2(start);
			uint offs2 = GetOffset2(end);
			if (offs2 < offs1)
				return false;
			return offs1 <= ushort.MaxValue && offs2 - offs1 <= byte.MaxValue;
		}

		uint GetOffset2(Instruction instr) {
			if (instr is null)
				return codeSize;
			return GetOffset(instr);
		}

		byte[] WriteFatExceptionClauses() {
			const int maxExceptionHandlers = (0x00FFFFFF - 4) / 24;
			var exceptionHandlers = this.exceptionHandlers;
			int numExceptionHandlers = exceptionHandlers.Count;
			if (numExceptionHandlers > maxExceptionHandlers) {
				Error("Too many exception handlers");
				numExceptionHandlers = maxExceptionHandlers;
			}

			var data = new byte[numExceptionHandlers * 24 + 4];
			var writer = new ArrayWriter(data);
			writer.WriteUInt32((((uint)numExceptionHandlers * 24 + 4) << 8) | 0x41);
			for (int i = 0; i < numExceptionHandlers; i++) {
				var eh = exceptionHandlers[i];
				uint offs1, offs2;

				writer.WriteUInt32((uint)eh.HandlerType);

				offs1 = GetOffset2(eh.TryStart);
				offs2 = GetOffset2(eh.TryEnd);
				if (offs2 <= offs1)
					Error("Exception handler: TryEnd <= TryStart");
				writer.WriteUInt32(offs1);
				writer.WriteUInt32(offs2 - offs1);

				offs1 = GetOffset2(eh.HandlerStart);
				offs2 = GetOffset2(eh.HandlerEnd);
				if (offs2 <= offs1)
					Error("Exception handler: HandlerEnd <= HandlerStart");
				writer.WriteUInt32(offs1);
				writer.WriteUInt32(offs2 - offs1);

				if (eh.IsCatch)
					writer.WriteUInt32(helper.GetToken(eh.CatchType).Raw);
				else if (eh.IsFilter)
					writer.WriteUInt32(GetOffset2(eh.FilterStart));
				else
					writer.WriteInt32(0);
			}

			if (writer.Position != data.Length)
				throw new InvalidOperationException();
			return data;
		}

		byte[] WriteSmallExceptionClauses() {
			const int maxExceptionHandlers = (0xFF - 4) / 12;
			var exceptionHandlers = this.exceptionHandlers;
			int numExceptionHandlers = exceptionHandlers.Count;
			if (numExceptionHandlers > maxExceptionHandlers) {
				Error("Too many exception handlers");
				numExceptionHandlers = maxExceptionHandlers;
			}

			var data = new byte[numExceptionHandlers * 12 + 4];
			var writer = new ArrayWriter(data);
			writer.WriteUInt32((((uint)numExceptionHandlers * 12 + 4) << 8) | 1);
			for (int i = 0; i < numExceptionHandlers; i++) {
				var eh = exceptionHandlers[i];
				uint offs1, offs2;

				writer.WriteUInt16((ushort)eh.HandlerType);

				offs1 = GetOffset2(eh.TryStart);
				offs2 = GetOffset2(eh.TryEnd);
				if (offs2 <= offs1)
					Error("Exception handler: TryEnd <= TryStart");
				writer.WriteUInt16((ushort)offs1);
				writer.WriteByte((byte)(offs2 - offs1));

				offs1 = GetOffset2(eh.HandlerStart);
				offs2 = GetOffset2(eh.HandlerEnd);
				if (offs2 <= offs1)
					Error("Exception handler: HandlerEnd <= HandlerStart");
				writer.WriteUInt16((ushort)offs1);
				writer.WriteByte((byte)(offs2 - offs1));

				if (eh.IsCatch)
					writer.WriteUInt32(helper.GetToken(eh.CatchType).Raw);
				else if (eh.IsFilter)
					writer.WriteUInt32(GetOffset2(eh.FilterStart));
				else
					writer.WriteInt32(0);
			}

			if (writer.Position != data.Length)
				throw new InvalidOperationException();
			return data;
		}

		/// <inheritdoc/>
		protected override void ErrorImpl(string message) {
			if (method is not null && helper is IWriterError2 writerError2)
				writerError2.Error(message + " At method {0} ({1:X8}).", method, method.MDToken.Raw);
			else
				helper.Error(message);
		}

		/// <inheritdoc/>
		protected override void WriteInlineField(ref ArrayWriter writer, Instruction instr) => writer.WriteUInt32(helper.GetToken(instr.Operand).Raw);

		/// <inheritdoc/>
		protected override void WriteInlineMethod(ref ArrayWriter writer, Instruction instr) => writer.WriteUInt32(helper.GetToken(instr.Operand).Raw);

		/// <inheritdoc/>
		protected override void WriteInlineSig(ref ArrayWriter writer, Instruction instr) => writer.WriteUInt32(helper.GetToken(instr.Operand).Raw);

		/// <inheritdoc/>
		protected override void WriteInlineString(ref ArrayWriter writer, Instruction instr) => writer.WriteUInt32(helper.GetToken(instr.Operand).Raw);

		/// <inheritdoc/>
		protected override void WriteInlineTok(ref ArrayWriter writer, Instruction instr) => writer.WriteUInt32(helper.GetToken(instr.Operand).Raw);

		/// <inheritdoc/>
		protected override void WriteInlineType(ref ArrayWriter writer, Instruction instr) => writer.WriteUInt32(helper.GetToken(instr.Operand).Raw);
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Base class of all CIL method body writers
	/// </summary>
	public abstract class MethodBodyWriterBase {
		/// <summary/>
		protected IList<Instruction> instructions;
		/// <summary/>
		protected IList<Emit.ExceptionHandler> exceptionHandlers;
		readonly Dictionary<Instruction, uint> offsets = new Dictionary<Instruction, uint>();
		uint firstInstructionOffset;
		int errors;
		MaxStackCalculator maxStackCalculator = MaxStackCalculator.Create();

		/// <summary>
		/// <c>true</c> if there was at least one error
		/// </summary>
		public bool ErrorDetected => errors > 0;

		internal MethodBodyWriterBase() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="instructions">All instructions</param>
		/// <param name="exceptionHandlers">All exception handlers</param>
		protected MethodBodyWriterBase(IList<Instruction> instructions, IList<Emit.ExceptionHandler> exceptionHandlers) {
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
		}

		internal void Reset(IList<Instruction> instructions, IList<Emit.ExceptionHandler> exceptionHandlers) {
			this.instructions = instructions;
			this.exceptionHandlers = exceptionHandlers;
			offsets.Clear();
			firstInstructionOffset = 0;
			errors = 0;
		}

		/// <summary>
		/// Called when an error is detected (eg. a null pointer). The error can be
		/// ignored but the method won't be valid.
		/// </summary>
		/// <param name="message">Error message</param>
		protected void Error(string message) {
			errors++;
			ErrorImpl(message);
		}

		/// <summary>
		/// Called when an error is detected (eg. a null pointer). The error can be
		/// ignored but the method won't be valid.
		/// </summary>
		/// <param name="message">Error message</param>
		protected virtual void ErrorImpl(string message) {
		}

		/// <summary>
		/// Gets max stack value
		/// </summary>
		protected uint GetMaxStack() {
			if (instructions.Count == 0)
				return 0;
			maxStackCalculator.Reset(instructions, exceptionHandlers);
			if (!maxStackCalculator.Calculate(out uint maxStack)) {
				Error("Error calculating max stack value. If the method's obfuscated, set CilBody.KeepOldMaxStack or MetadataOptions.Flags (KeepOldMaxStack, global option) to ignore this error. Otherwise fix your generated CIL code so it conforms to the ECMA standard.");
				maxStack += 8;
			}
			return maxStack;
		}

		/// <summary>
		/// Gets the offset of an instruction
		/// </summary>
		/// <param name="instr">The instruction</param>
		/// <returns>The offset or <c>0</c> if <paramref name="instr"/> is <c>null</c> or not
		/// present in the list of all instructions.</returns>
		protected uint GetOffset(Instruction instr) {
			if (instr is null) {
				Error("Instruction is null");
				return 0;
			}
			if (offsets.TryGetValue(instr, out uint offset))
				return offset;
			Error("Found some other method's instruction or a removed instruction. You probably removed an instruction that is the target of a branch instruction or an instruction that's the first/last instruction in an exception handler.");
			return 0;
		}

		/// <summary>
		/// Initializes instruction offsets and returns the total code size
		/// </summary>
		/// <returns>Size of code</returns>
		protected uint InitializeInstructionOffsets() {
			uint offset = 0;
			var instructions = this.instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i];
				if (instr is null)
					continue;
				offsets[instr] = offset;
				offset += GetSizeOfInstruction(instr);
			}
			return offset;
		}

		/// <summary>
		/// Gets the size of an instruction
		/// </summary>
		/// <param name="instr">The instruction</param>
		/// <returns>Size of the instruction in bytes</returns>
		protected virtual uint GetSizeOfInstruction(Instruction instr) => (uint)instr.GetSize();

		/// <summary>
		/// Writes all instructions to <paramref name="writer"/> at its current offset
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <returns>Number of bytes written</returns>
		protected uint WriteInstructions(ref ArrayWriter writer) {
			firstInstructionOffset = (uint)writer.Position;
			var instructions = this.instructions;
			for (int i = 0; i < instructions.Count; i++) {
				var instr = instructions[i];
				if (instr is null)
					continue;
				WriteInstruction(ref writer, instr);
			}
			return ToInstructionOffset(ref writer);
		}

		/// <summary>
		/// Gets the current offset in the instruction stream. This offset is relative to
		/// the first written instruction.
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <returns>Current offset, relative to the first written instruction</returns>
		protected uint ToInstructionOffset(ref ArrayWriter writer) => (uint)writer.Position - firstInstructionOffset;

		/// <summary>
		/// Writes an instruction
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <param name="instr">The instruction</param>
		protected virtual void WriteInstruction(ref ArrayWriter writer, Instruction instr) {
			WriteOpCode(ref writer, instr);
			WriteOperand(ref writer, instr);
		}

		/// <summary>
		/// Writes an instruction's opcode
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <param name="instr">The instruction</param>
		protected void WriteOpCode(ref ArrayWriter writer, Instruction instr) {
			var code = instr.OpCode.Code;
			var hi = (ushort)code >> 8;
			if ((ushort)code <= 0xFF)
				writer.WriteByte((byte)code);
			else if (hi == 0xFE || (hi >= 0xF0 && hi <= 0xFB)) {
				writer.WriteByte((byte)((ushort)code >> 8));
				writer.WriteByte((byte)code);
			}
			else if (code == Code.UNKNOWN1)
				writer.WriteByte((byte)Code.Nop);
			else if (code == Code.UNKNOWN2)
				writer.WriteUInt16((ushort)(((ushort)Code.Nop << 8) | Code.Nop));
			else {
				Error("Unknown instruction");
				writer.WriteByte((byte)Code.Nop);
			}
		}

		/// <summary>
		/// Writes an instruction's operand
		/// </summary>
		/// <param name="writer">The instruction writer</param>
		/// <param name="instr">The instruction</param>
		protected void WriteOperand(ref ArrayWriter writer, Instruction instr) {
			switch (instr.OpCode.OperandType) {
			case Emit.OperandType.InlineBrTarget:	WriteInlineBrTarget(ref writer, instr); break;
			case Emit.OperandType.InlineField:		WriteInlineField(ref writer, instr); break;
			case Emit.OperandType.InlineI:			WriteInlineI(ref writer, instr); break;
			case Emit.OperandType.InlineI8:			WriteInlineI8(ref writer, instr); break;
			case Emit.OperandType.InlineMethod:		WriteInlineMethod(ref writer, instr); break;
			case Emit.OperandType.InlineNone:		WriteInlineNone(ref writer, instr); break;
			case Emit.OperandType.InlinePhi:			WriteInlinePhi(ref writer, instr); break;
			case Emit.OperandType.InlineR:			WriteInlineR(ref writer, instr); break;
			case Emit.OperandType.InlineSig:			WriteInlineSig(ref writer, instr); break;
			case Emit.OperandType.InlineString:		WriteInlineString(ref writer, instr); break;
			case Emit.OperandType.InlineSwitch:		WriteInlineSwitch(ref writer, instr); break;
			case Emit.OperandType.InlineTok:			WriteInlineTok(ref writer, instr); break;
			case Emit.OperandType.InlineType:		WriteInlineType(ref writer, instr); break;
			case Emit.OperandType.InlineVar:			WriteInlineVar(ref writer, instr); break;
			case Emit.OperandType.ShortInlineBrTarget: WriteShortInlineBrTarget(ref writer, instr); break;
			case Emit.OperandType.ShortInlineI:		WriteShortInlineI(ref writer, instr); break;
			case Emit.OperandType.ShortInlineR:		WriteShortInlineR(ref writer, instr); break;
			case Emit.OperandType.ShortInlineVar:	WriteShortInlineVar(ref writer, instr); break;

			default:
				Error("Unknown operand type");
				break;
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineBrTarget"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineBrTarget(ref ArrayWriter writer, Instruction instr) {
			uint displ = GetOffset(instr.Operand as Instruction) - (ToInstructionOffset(ref writer) + 4);
			writer.WriteUInt32(displ);
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineField"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineField(ref ArrayWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineI"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineI(ref ArrayWriter writer, Instruction instr) {
			if (instr.Operand is int)
				writer.WriteInt32((int)instr.Operand);
			else {
				Error("Operand is not an Int32");
				writer.WriteInt32(0);
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineI8"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineI8(ref ArrayWriter writer, Instruction instr) {
			if (instr.Operand is long)
				writer.WriteInt64((long)instr.Operand);
			else {
				Error("Operand is not an Int64");
				writer.WriteInt64(0);
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineMethod"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineMethod(ref ArrayWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineNone"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineNone(ref ArrayWriter writer, Instruction instr) {
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlinePhi"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlinePhi(ref ArrayWriter writer, Instruction instr) {
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineR"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineR(ref ArrayWriter writer, Instruction instr) {
			if (instr.Operand is double)
				writer.WriteDouble((double)instr.Operand);
			else {
				Error("Operand is not a Double");
				writer.WriteDouble(0);
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineSig"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineSig(ref ArrayWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineString"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineString(ref ArrayWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineSwitch"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineSwitch(ref ArrayWriter writer, Instruction instr) {
			var targets = instr.Operand as IList<Instruction>;
			if (targets is null) {
				Error("switch operand is not a list of instructions");
				writer.WriteInt32(0);
			}
			else {
				uint offsetAfter = (uint)(ToInstructionOffset(ref writer) + 4 + targets.Count * 4);
				writer.WriteInt32(targets.Count);
				for (int i = 0; i < targets.Count; i++) {
					var target = targets[i];
					writer.WriteUInt32(GetOffset(target) - offsetAfter);
				}
			}
		}

		/// <summary>
		/// Writes an <see cref="OperandType.InlineTok"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineTok(ref ArrayWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineType"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected abstract void WriteInlineType(ref ArrayWriter writer, Instruction instr);

		/// <summary>
		/// Writes an <see cref="OperandType.InlineVar"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteInlineVar(ref ArrayWriter writer, Instruction instr) {
			var variable = instr.Operand as IVariable;
			if (variable is null) {
				Error("Operand is not a local/arg");
				writer.WriteUInt16(0);
			}
			else {
				int index = variable.Index;
				if (ushort.MinValue <= index && index <= ushort.MaxValue)
					writer.WriteUInt16((ushort)index);
				else {
					Error("Local/arg index doesn't fit in a UInt16");
					writer.WriteUInt16(0);
				}
			}
		}

		/// <summary>
		/// Writes a <see cref="OperandType.ShortInlineBrTarget"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteShortInlineBrTarget(ref ArrayWriter writer, Instruction instr) {
			int displ = (int)(GetOffset(instr.Operand as Instruction) - (ToInstructionOffset(ref writer) + 1));
			if (sbyte.MinValue <= displ && displ <= sbyte.MaxValue)
				writer.WriteSByte((sbyte)displ);
			else {
				Error("Target instruction is too far away for a short branch. Use the long branch or call CilBody.SimplifyBranches() and CilBody.OptimizeBranches()");
				writer.WriteByte(0);
			}
		}

		/// <summary>
		/// Writes a <see cref="OperandType.ShortInlineI"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteShortInlineI(ref ArrayWriter writer, Instruction instr) {
			if (instr.Operand is sbyte)
				writer.WriteSByte((sbyte)instr.Operand);
			else if (instr.Operand is byte)
				writer.WriteByte((byte)instr.Operand);
			else {
				Error("Operand is not a Byte or a SByte");
				writer.WriteByte(0);
			}
		}

		/// <summary>
		/// Writes a <see cref="OperandType.ShortInlineR"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteShortInlineR(ref ArrayWriter writer, Instruction instr) {
			if (instr.Operand is float)
				writer.WriteSingle((float)instr.Operand);
			else {
				Error("Operand is not a Single");
				writer.WriteSingle(0);
			}
		}

		/// <summary>
		/// Writes a <see cref="OperandType.ShortInlineVar"/> operand
		/// </summary>
		/// <param name="writer">Instruction writer</param>
		/// <param name="instr">Instruction</param>
		protected virtual void WriteShortInlineVar(ref ArrayWriter writer, Instruction instr) {
			var variable = instr.Operand as IVariable;
			if (variable is null) {
				Error("Operand is not a local/arg");
				writer.WriteByte(0);
			}
			else {
				int index = variable.Index;
				if (byte.MinValue <= index && index <= byte.MaxValue)
					writer.WriteByte((byte)index);
				else {
					Error("Local/arg index doesn't fit in a Byte. Use the longer ldloc/ldarg/stloc/starg instruction.");
					writer.WriteByte(0);
				}
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="ModuleWriter"/> options
	/// </summary>
	public sealed class ModuleWriterOptions : ModuleWriterOptionsBase {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		public ModuleWriterOptions(ModuleDef module) : base(module) { }
	}

	/// <summary>
	/// Writes a .NET PE file. See also <see cref="NativeModuleWriter"/>
	/// </summary>
	public sealed class ModuleWriter : ModuleWriterBase {
		const uint DEFAULT_RELOC_ALIGNMENT = 4;
		const uint MVID_ALIGNMENT = 1;

		readonly ModuleDef module;
		ModuleWriterOptions options;

		List<PESection> sections;
		PESection mvidSection;
		PESection textSection;
		PESection sdataSection;
		PESection rsrcSection;
		PESection relocSection;

		PEHeaders peHeaders;
		ImportAddressTable importAddressTable;
		ImageCor20Header imageCor20Header;
		ImportDirectory importDirectory;
		StartupStub startupStub;
		RelocDirectory relocDirectory;
		ManagedExportsWriter managedExportsWriter;
		bool needStartupStub;

		/// <inheritdoc/>
		public override ModuleDef Module => module;

		/// <inheritdoc/>
		public override ModuleWriterOptionsBase TheOptions => Options;

		/// <summary>
		/// Gets/sets the writer options. This is never <c>null</c>
		/// </summary>
		public ModuleWriterOptions Options {
			get => options ??= new ModuleWriterOptions(module);
			set => options = value;
		}

		/// <summary>
		/// Gets all <see cref="PESection"/>s. The reloc section must be the last section, so use <see cref="AddSection(PESection)"/> if you need to append a section
		/// </summary>
		public override List<PESection> Sections => sections;

		/// <summary>
		/// Adds <paramref name="section"/> to the sections list, but before the reloc section which must be last
		/// </summary>
		/// <param name="section">New section to add to the list</param>
		public override void AddSection(PESection section) {
			if (sections.Count > 0 && sections[sections.Count - 1] == relocSection)
				sections.Insert(sections.Count - 1, section);
			else
				sections.Add(section);
		}

		/// <summary>
		/// Gets the <c>.text</c> section
		/// </summary>
		public override PESection TextSection => textSection;

		/// <summary>
		/// Gets the <c>.sdata</c> section
		/// </summary>
		internal PESection SdataSection => sdataSection;

		/// <summary>
		/// Gets the <c>.rsrc</c> section or null if none
		/// </summary>
		public override PESection RsrcSection => rsrcSection;

		/// <summary>
		/// Gets the <c>.reloc</c> section
		/// </summary>
		public PESection RelocSection => relocSection;

		/// <summary>
		/// Gets the PE headers
		/// </summary>
		public PEHeaders PEHeaders => peHeaders;

		/// <summary>
		/// Gets the IAT or <c>null</c> if there's none
		/// </summary>
		public ImportAddressTable ImportAddressTable => importAddressTable;

		/// <summary>
		/// Gets the .NET header
		/// </summary>
		public ImageCor20Header ImageCor20Header => imageCor20Header;

		/// <summary>
		/// Gets the import directory or <c>null</c> if there's none
		/// </summary>
		public ImportDirectory ImportDirectory => importDirectory;

		/// <summary>
		/// Gets the startup stub or <c>null</c> if there's none
		/// </summary>
		public StartupStub StartupStub => startupStub;

		/// <summary>
		/// Gets the reloc directory or <c>null</c> if there's none
		/// </summary>
		public RelocDirectory RelocDirectory => relocDirectory;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		public ModuleWriter(ModuleDef module)
			: this(module, null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		/// <param name="options">Options or <c>null</c></param>
		public ModuleWriter(ModuleDef module, ModuleWriterOptions options) {
			this.module = module;
			this.options = options;
		}

		/// <inheritdoc/>
		protected override long WriteImpl() {
			Initialize();
			metadata.CreateTables();
			return WriteFile();
		}

		void Initialize() {
			CreateSections();
			OnWriterEvent(ModuleWriterEvent.PESectionsCreated);

			CreateChunks();
			OnWriterEvent(ModuleWriterEvent.ChunksCreated);

			AddChunksToSections();
			OnWriterEvent(ModuleWriterEvent.ChunksAddedToSections);
		}

		/// <inheritdoc/>
		protected override Win32Resources GetWin32Resources() {
			if (Options.NoWin32Resources)
				return null;
			return Options.Win32Resources ?? module.Win32Resources;
		}

		void CreateSections() {
			sections = new List<PESection>();
			if (TheOptions.AddMvidSection)
				sections.Add(mvidSection = new PESection(".mvid", 0x42000040));
			sections.Add(textSection = new PESection(".text", 0x60000020));
			sections.Add(sdataSection = new PESection(".sdata", 0xC0000040));
			if (GetWin32Resources() is not null)
				sections.Add(rsrcSection = new PESection(".rsrc", 0x40000040));
			// Should be last so any data in a previous section can add relocations
			sections.Add(relocSection = new PESection(".reloc", 0x42000040));
		}

		void CreateChunks() {
			peHeaders = new PEHeaders(Options.PEHeadersOptions);

			var machine = Options.PEHeadersOptions.Machine ?? Machine.I386;
			bool is64bit = machine.Is64Bit();
			relocDirectory = new RelocDirectory(machine);
			if (machine.IsI386())
				needStartupStub = true;

			importAddressTable = new ImportAddressTable(is64bit);
			importDirectory = new ImportDirectory(is64bit);
			startupStub = new StartupStub(relocDirectory, machine, (format, args) => Error(format, args));

			CreateStrongNameSignature();

			imageCor20Header = new ImageCor20Header(Options.Cor20HeaderOptions);
			CreateMetadataChunks(module);
			managedExportsWriter = new ManagedExportsWriter(UTF8String.ToSystemStringOrEmpty(module.Name), machine, relocDirectory, metadata, peHeaders, (format, args) => Error(format, args));

			CreateDebugDirectory();

			importDirectory.IsExeFile = Options.IsExeFile;
			peHeaders.IsExeFile = Options.IsExeFile;
		}

		void AddChunksToSections() {
			var machine = Options.PEHeadersOptions.Machine ?? Machine.I386;
			bool is64bit = machine.Is64Bit();
			uint pointerAlignment = is64bit ? 8U : 4;

			if (mvidSection is not null)
				mvidSection.Add(new ByteArrayChunk((module.Mvid ?? Guid.Empty).ToByteArray()), MVID_ALIGNMENT);
			textSection.Add(importAddressTable, pointerAlignment);
			textSection.Add(imageCor20Header, DEFAULT_COR20HEADER_ALIGNMENT);
			textSection.Add(strongNameSignature, DEFAULT_STRONGNAMESIG_ALIGNMENT);
			managedExportsWriter.AddTextChunks(textSection);
			textSection.Add(constants, DEFAULT_CONSTANTS_ALIGNMENT);
			textSection.Add(methodBodies, DEFAULT_METHODBODIES_ALIGNMENT);
			textSection.Add(netResources, DEFAULT_NETRESOURCES_ALIGNMENT);
			textSection.Add(metadata, DEFAULT_METADATA_ALIGNMENT);
			textSection.Add(debugDirectory, DebugDirectory.DEFAULT_DEBUGDIRECTORY_ALIGNMENT);
			textSection.Add(importDirectory, pointerAlignment);
			textSection.Add(startupStub, startupStub.Alignment);
			managedExportsWriter.AddSdataChunks(sdataSection);
			if (GetWin32Resources() is not null)
				rsrcSection.Add(win32Resources, DEFAULT_WIN32_RESOURCES_ALIGNMENT);
			relocSection.Add(relocDirectory, DEFAULT_RELOC_ALIGNMENT);
		}

		long WriteFile() {
			managedExportsWriter.AddExportedMethods(metadata.ExportedMethods, GetTimeDateStamp());
			if (managedExportsWriter.HasExports)
				needStartupStub = true;

			OnWriterEvent(ModuleWriterEvent.BeginWritePdb);
			WritePdbFile();
			OnWriterEvent(ModuleWriterEvent.EndWritePdb);

			metadata.OnBeforeSetOffset();
			OnWriterEvent(ModuleWriterEvent.BeginCalculateRvasAndFileOffsets);
			var chunks = new List<IChunk>();
			chunks.Add(peHeaders);
			if (!managedExportsWriter.HasExports)
				sections.Remove(sdataSection);
			if (!(relocDirectory.NeedsRelocSection || managedExportsWriter.HasExports || needStartupStub))
				sections.Remove(relocSection);

			importAddressTable.Enable = needStartupStub;
			importDirectory.Enable = needStartupStub;
			startupStub.Enable = needStartupStub;

			foreach (var section in sections)
				chunks.Add(section);
			peHeaders.PESections = sections;
			int relocIndex = sections.IndexOf(relocSection);
			if (relocIndex >= 0 && relocIndex != sections.Count - 1)
				throw new InvalidOperationException("Reloc section must be the last section, use AddSection() to add a section");
			CalculateRvasAndFileOffsets(chunks, 0, 0, peHeaders.FileAlignment, peHeaders.SectionAlignment);
			OnWriterEvent(ModuleWriterEvent.EndCalculateRvasAndFileOffsets);

			InitializeChunkProperties();

			OnWriterEvent(ModuleWriterEvent.BeginWriteChunks);
			var writer = new DataWriter(destStream);
			WriteChunks(writer, chunks, 0, peHeaders.FileAlignment);
			long imageLength = writer.Position - destStreamBaseOffset;
			OnWriterEvent(ModuleWriterEvent.EndWriteChunks);

			OnWriterEvent(ModuleWriterEvent.BeginStrongNameSign);
			if (Options.StrongNameKey is not null)
				StrongNameSign((long)strongNameSignature.FileOffset);
			OnWriterEvent(ModuleWriterEvent.EndStrongNameSign);

			OnWriterEvent(ModuleWriterEvent.BeginWritePEChecksum);
			if (Options.AddCheckSum)
				peHeaders.WriteCheckSum(writer, imageLength);
			OnWriterEvent(ModuleWriterEvent.EndWritePEChecksum);

			return imageLength;
		}

		void InitializeChunkProperties() {
			Options.Cor20HeaderOptions.EntryPoint = GetEntryPoint();

			importAddressTable.ImportDirectory = importDirectory;
			importDirectory.ImportAddressTable = importAddressTable;
			startupStub.ImportDirectory = importDirectory;
			startupStub.PEHeaders = peHeaders;
			peHeaders.StartupStub = startupStub;
			peHeaders.ImageCor20Header = imageCor20Header;
			peHeaders.ImportAddressTable = importAddressTable;
			peHeaders.ImportDirectory = importDirectory;
			peHeaders.Win32Resources = win32Resources;
			peHeaders.RelocDirectory = relocDirectory;
			peHeaders.DebugDirectory = debugDirectory;
			imageCor20Header.Metadata = metadata;
			imageCor20Header.NetResources = netResources;
			imageCor20Header.StrongNameSignature = strongNameSignature;
			managedExportsWriter.InitializeChunkProperties();
		}

		uint GetEntryPoint() {
			if (module.ManagedEntryPoint is MethodDef methodEntryPoint)
				return new MDToken(Table.Method, metadata.GetRid(methodEntryPoint)).Raw;

			if (module.ManagedEntryPoint is FileDef fileEntryPoint)
				return new MDToken(Table.File, metadata.GetRid(fileEntryPoint)).Raw;

			uint nativeEntryPoint = (uint)module.NativeEntryPoint;
			if (nativeEntryPoint != 0)
				return nativeEntryPoint;

			return 0;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Module writer event args
	/// </summary>
	public readonly struct ModuleWriterEventArgs {
		/// <summary>
		/// Gets the writer (<see cref="ModuleWriter"/> or <see cref="NativeModuleWriter"/>)
		/// </summary>
		public ModuleWriterBase Writer { get; }

		/// <summary>
		/// Gets the event
		/// </summary>
		public ModuleWriterEvent Event { get; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="event">Event</param>
		public ModuleWriterEventArgs(ModuleWriterBase writer, ModuleWriterEvent @event) {
			Writer = writer ?? throw new ArgumentNullException(nameof(writer));
			Event = @event;
		}
	}

	/// <summary>
	/// Module writer progress event args
	/// </summary>
	public readonly struct ModuleWriterProgressEventArgs {
		/// <summary>
		/// Gets the writer (<see cref="ModuleWriter"/> or <see cref="NativeModuleWriter"/>)
		/// </summary>
		public ModuleWriterBase Writer { get; }

		/// <summary>
		/// Gets the progress, 0.0 - 1.0
		/// </summary>
		public double Progress { get; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="progress">Progress, 0.0 - 1.0</param>
		public ModuleWriterProgressEventArgs(ModuleWriterBase writer, double progress) {
			if (progress < 0 || progress > 1)
				throw new ArgumentOutOfRangeException(nameof(progress));
			Writer = writer ?? throw new ArgumentNullException(nameof(writer));
			Progress = progress;
		}
	}

	/// <summary>
	/// Content ID
	/// </summary>
	public readonly struct ContentId {
		/// <summary>
		/// Gets the GUID
		/// </summary>
		public readonly Guid Guid;

		/// <summary>
		/// Gets the timestamp
		/// </summary>
		public readonly uint Timestamp;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="guid">Guid</param>
		/// <param name="timestamp">Timestamp</param>
		public ContentId(Guid guid, uint timestamp) {
			Guid = guid;
			Timestamp = timestamp;
		}
	}

	/// <summary>
	/// Event handler
	/// </summary>
	/// <typeparam name="TEventArgs">Event args type</typeparam>
	/// <param name="sender">Sender</param>
	/// <param name="e">Event args</param>
	public delegate void EventHandler2<TEventArgs>(object sender, TEventArgs e);

	/// <summary>
	/// PDB writer options
	/// </summary>
	[Flags]
	public enum PdbWriterOptions {
		/// <summary>
		/// No bit is set
		/// </summary>
		None						= 0,

		/// <summary>
		/// Don't use Microsoft.DiaSymReader.Native. This is a NuGet package with an updated Windows PDB reader/writer implementation,
		/// and if it's available at runtime, dnlib will try to use it. If this option is set, dnlib won't use it.
		/// You have to add a reference to the NuGet package if you want to use it, dnlib has no reference to the NuGet package.
		///
		/// This is only used if it's a Windows PDB file.
		/// </summary>
		NoDiaSymReader			= 0x00000001,

		/// <summary>
		/// Don't use diasymreader.dll's PDB writer that is shipped with .NET Framework.
		///
		/// This is only used if it's a Windows PDB file.
		/// </summary>
		NoOldDiaSymReader		= 0x00000002,

		/// <summary>
		/// Create a deterministic PDB file and add a <see cref="ImageDebugType.Reproducible"/> debug directory entry to the PE file.
		///
		/// It's ignored if the PDB writer doesn't support it.
		/// </summary>
		Deterministic			= 0x00000004,

		/// <summary>
		/// Hash the PDB file and add a PDB checksum debug directory entry to the PE file.
		///
		/// It's ignored if the PDB writer doesn't support it.
		/// </summary>
		PdbChecksum				= 0x00000008,
	}

	/// <summary>
	/// Common module writer options base class
	/// </summary>
	public class ModuleWriterOptionsBase {
		PEHeadersOptions peHeadersOptions;
		Cor20HeaderOptions cor20HeaderOptions;
		MetadataOptions metadataOptions;
		ILogger logger;
		ILogger metadataLogger;
		bool noWin32Resources;
		Win32Resources win32Resources;
		StrongNameKey strongNameKey;
		StrongNamePublicKey strongNamePublicKey;
		bool delaySign;

		/// <summary>
		/// Raised at various times when writing the file. The listener has a chance to modify
		/// the file, eg. add extra metadata, encrypt methods, etc.
		/// </summary>
		public event EventHandler2<ModuleWriterEventArgs> WriterEvent;
		internal void RaiseEvent(object sender, ModuleWriterEventArgs e) => WriterEvent?.Invoke(sender, e);

		/// <summary>
		/// Raised when the progress is updated
		/// </summary>
		public event EventHandler2<ModuleWriterProgressEventArgs> ProgressUpdated;
		internal void RaiseEvent(object sender, ModuleWriterProgressEventArgs e) => ProgressUpdated?.Invoke(sender, e);

		/// <summary>
		/// Gets/sets the logger. If this is <c>null</c>, any errors result in a
		/// <see cref="ModuleWriterException"/> being thrown. To disable this behavior, either
		/// create your own logger or use <see cref="DummyLogger.NoThrowInstance"/>.
		/// </summary>
		public ILogger Logger {
			get => logger;
			set => logger = value;
		}

		/// <summary>
		/// Gets/sets the <see cref="Metadata"/> writer logger. If this is <c>null</c>, use
		/// <see cref="Logger"/>.
		/// </summary>
		public ILogger MetadataLogger {
			get => metadataLogger;
			set => metadataLogger = value;
		}

		/// <summary>
		/// Gets/sets the <see cref="PEHeaders"/> options. This is never <c>null</c>.
		/// </summary>
		public PEHeadersOptions PEHeadersOptions {
			get => peHeadersOptions ??= new PEHeadersOptions();
			set => peHeadersOptions = value;
		}

		/// <summary>
		/// Gets/sets the <see cref="ImageCor20Header"/> options. This is never <c>null</c>.
		/// </summary>
		public Cor20HeaderOptions Cor20HeaderOptions {
			get => cor20HeaderOptions ??= new Cor20HeaderOptions();
			set => cor20HeaderOptions = value;
		}

		/// <summary>
		/// Gets/sets the <see cref="Metadata"/> options. This is never <c>null</c>.
		/// </summary>
		public MetadataOptions MetadataOptions {
			get => metadataOptions ??= new MetadataOptions();
			set => metadataOptions = value;
		}

		/// <summary>
		/// If <c>true</c>, Win32 resources aren't written to the output
		/// </summary>
		public bool NoWin32Resources {
			get => noWin32Resources;
			set => noWin32Resources = value;
		}

		/// <summary>
		/// Gets/sets the Win32 resources. If this is <c>null</c>, use the module's
		/// Win32 resources if any.
		/// </summary>
		public Win32Resources Win32Resources {
			get => win32Resources;
			set => win32Resources = value;
		}

		/// <summary>
		/// true to delay sign the assembly. Initialize <see cref="StrongNamePublicKey"/> to the
		/// public key to use, and don't initialize <see cref="StrongNameKey"/>. To generate the
		/// public key from your strong name key file, execute <c>sn -p mykey.snk mypublickey.snk</c>
		/// </summary>
		public bool DelaySign {
			get => delaySign;
			set => delaySign = value;
		}

		/// <summary>
		/// Gets/sets the strong name key. When you enhance strong name sign an assembly,
		/// this instance's HashAlgorithm must be initialized to its public key's HashAlgorithm.
		/// You should call <see cref="InitializeStrongNameSigning(ModuleDef,StrongNameKey)"/>
		/// to initialize this property if you use normal strong name signing.
		/// You should call <see cref="InitializeEnhancedStrongNameSigning(ModuleDef,StrongNameKey,StrongNamePublicKey)"/>
		/// or <see cref="InitializeEnhancedStrongNameSigning(ModuleDef,StrongNameKey,StrongNamePublicKey,StrongNameKey,StrongNamePublicKey)"/>
		/// to initialize this property if you use enhanced strong name signing.
		/// </summary>
		public StrongNameKey StrongNameKey {
			get => strongNameKey;
			set => strongNameKey = value;
		}

		/// <summary>
		/// Gets/sets the new public key that should be used. If this is <c>null</c>, use
		/// the public key generated from <see cref="StrongNameKey"/>. If it is also <c>null</c>,
		/// use the module's Assembly's public key.
		/// You should call <see cref="InitializeEnhancedStrongNameSigning(ModuleDef,StrongNameKey,StrongNamePublicKey)"/>
		/// or <see cref="InitializeEnhancedStrongNameSigning(ModuleDef,StrongNameKey,StrongNamePublicKey,StrongNameKey,StrongNamePublicKey)"/>
		/// to initialize this property if you use enhanced strong name signing.
		/// </summary>
		public StrongNamePublicKey StrongNamePublicKey {
			get => strongNamePublicKey;
			set => strongNamePublicKey = value;
		}

		/// <summary>
		/// <c>true</c> if method bodies can be shared (two or more method bodies can share the
		/// same RVA), <c>false</c> if method bodies can't be shared. Don't enable it if there
		/// must be a 1:1 relationship with method bodies and their RVAs.
		/// This is enabled by default and results in smaller files.
		/// </summary>
		public bool ShareMethodBodies { get; set; }

		/// <summary>
		/// <c>true</c> if the PE header CheckSum field should be updated, <c>false</c> if the
		/// CheckSum field isn't updated.
		/// </summary>
		public bool AddCheckSum { get; set; }

		/// <summary>
		/// <c>true</c> if it's a 64-bit module, <c>false</c> if it's a 32-bit or AnyCPU module.
		/// </summary>
		public bool Is64Bit {
			get {
				if (!PEHeadersOptions.Machine.HasValue)
					return false;
				return PEHeadersOptions.Machine.Value.Is64Bit();
			}
		}

		/// <summary>
		/// Gets/sets the module kind
		/// </summary>
		public ModuleKind ModuleKind { get; set; }

		/// <summary>
		/// <c>true</c> if it should be written as an EXE file, <c>false</c> if it should be
		/// written as a DLL file.
		/// </summary>
		public bool IsExeFile => ModuleKind != ModuleKind.Dll && ModuleKind != ModuleKind.NetModule;

		/// <summary>
		/// Set it to <c>true</c> to enable writing a PDB file. Default is <c>false</c> (a PDB file
		/// won't be written to disk).
		/// </summary>
		public bool WritePdb { get; set; }

		/// <summary>
		/// PDB writer options. This property is ignored if <see cref="WritePdb"/> is false.
		/// </summary>
		public PdbWriterOptions PdbOptions { get; set; }

		/// <summary>
		/// PDB file name. If it's <c>null</c> a PDB file with the same name as the output assembly
		/// will be created but with a PDB extension. <see cref="WritePdb"/> must be <c>true</c> or
		/// this property is ignored.
		/// </summary>
		public string PdbFileName { get; set; }

		/// <summary>
		/// PDB file name stored in the debug directory, or null to use <see cref="PdbFileName"/>
		/// </summary>
		public string PdbFileNameInDebugDirectory { get; set; }

		/// <summary>
		/// PDB stream. If this is initialized, then you should also set <see cref="PdbFileName"/>
		/// to the name of the PDB file since the file name must be written to the PE debug directory.
		/// <see cref="WritePdb"/> must be <c>true</c> or this property is ignored.
		/// </summary>
		public Stream PdbStream { get; set; }

		/// <summary>
		/// Gets the PDB content id (portable PDBs). The <see cref="Stream"/> argument is the PDB stream with the PDB ID zeroed out,
		/// and the 2nd <see cref="uint"/> argument is the default timestamp.
		/// This property is ignored if a deterministic PDB file is created or if the PDB checksum is calculated.
		/// </summary>
		public Func<Stream, uint, ContentId> GetPdbContentId { get; set; }

		const ChecksumAlgorithm DefaultPdbChecksumAlgorithm = ChecksumAlgorithm.SHA256;

		/// <summary>
		/// PDB checksum algorithm
		/// </summary>
		public ChecksumAlgorithm PdbChecksumAlgorithm { get; set; } = DefaultPdbChecksumAlgorithm;

		/// <summary>
		/// true if an <c>.mvid</c> section should be added to the assembly. Not used by native module writer.
		/// </summary>
		public bool AddMvidSection { get; set; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		protected ModuleWriterOptionsBase(ModuleDef module) {
			ShareMethodBodies = true;
			MetadataOptions.MetadataHeaderOptions.VersionString = module.RuntimeVersion;
			ModuleKind = module.Kind;
			PEHeadersOptions.Machine = module.Machine;
			PEHeadersOptions.Characteristics = module.Characteristics;
			PEHeadersOptions.DllCharacteristics = module.DllCharacteristics;
			if (module.Kind == ModuleKind.Windows)
				PEHeadersOptions.Subsystem = Subsystem.WindowsGui;
			else
				PEHeadersOptions.Subsystem = Subsystem.WindowsCui;
			PEHeadersOptions.NumberOfRvaAndSizes = 0x10;
			Cor20HeaderOptions.Flags = module.Cor20HeaderFlags;

			if (module.Assembly is not null && !PublicKeyBase.IsNullOrEmpty2(module.Assembly.PublicKey))
				Cor20HeaderOptions.Flags |= ComImageFlags.StrongNameSigned;

			if (module.Cor20HeaderRuntimeVersion is not null) {
				Cor20HeaderOptions.MajorRuntimeVersion = (ushort)(module.Cor20HeaderRuntimeVersion.Value >> 16);
				Cor20HeaderOptions.MinorRuntimeVersion = (ushort)module.Cor20HeaderRuntimeVersion.Value;
			}
			else if (module.IsClr1x) {
				Cor20HeaderOptions.MajorRuntimeVersion = 2;
				Cor20HeaderOptions.MinorRuntimeVersion = 0;
			}
			else {
				Cor20HeaderOptions.MajorRuntimeVersion = 2;
				Cor20HeaderOptions.MinorRuntimeVersion = 5;
			}

			if (module.TablesHeaderVersion is not null) {
				MetadataOptions.TablesHeapOptions.MajorVersion = (byte)(module.TablesHeaderVersion.Value >> 8);
				MetadataOptions.TablesHeapOptions.MinorVersion = (byte)module.TablesHeaderVersion.Value;
			}
			else if (module.IsClr1x) {
				// Generics aren't supported
				MetadataOptions.TablesHeapOptions.MajorVersion = 1;
				MetadataOptions.TablesHeapOptions.MinorVersion = 0;
			}
			else {
				// Generics are supported
				MetadataOptions.TablesHeapOptions.MajorVersion = 2;
				MetadataOptions.TablesHeapOptions.MinorVersion = 0;
			}

			// Some tools crash if #GUID is missing so always create it by default
			MetadataOptions.Flags |= MetadataFlags.AlwaysCreateGuidHeap;

			var modDefMD = module as ModuleDefMD;
			if (modDefMD is not null) {
				var ntHeaders = modDefMD.Metadata.PEImage.ImageNTHeaders;
				PEHeadersOptions.TimeDateStamp = ntHeaders.FileHeader.TimeDateStamp;
				PEHeadersOptions.MajorLinkerVersion = ntHeaders.OptionalHeader.MajorLinkerVersion;
				PEHeadersOptions.MinorLinkerVersion = ntHeaders.OptionalHeader.MinorLinkerVersion;
				PEHeadersOptions.ImageBase = ntHeaders.OptionalHeader.ImageBase;
				PEHeadersOptions.MajorOperatingSystemVersion = ntHeaders.OptionalHeader.MajorOperatingSystemVersion;
				PEHeadersOptions.MinorOperatingSystemVersion = ntHeaders.OptionalHeader.MinorOperatingSystemVersion;
				PEHeadersOptions.MajorImageVersion = ntHeaders.OptionalHeader.MajorImageVersion;
				PEHeadersOptions.MinorImageVersion = ntHeaders.OptionalHeader.MinorImageVersion;
				PEHeadersOptions.MajorSubsystemVersion = ntHeaders.OptionalHeader.MajorSubsystemVersion;
				PEHeadersOptions.MinorSubsystemVersion = ntHeaders.OptionalHeader.MinorSubsystemVersion;
				PEHeadersOptions.Win32VersionValue = ntHeaders.OptionalHeader.Win32VersionValue;
				AddCheckSum = ntHeaders.OptionalHeader.CheckSum != 0;
				AddMvidSection = HasMvidSection(modDefMD.Metadata.PEImage.ImageSectionHeaders);
				if (HasDebugDirectoryEntry(modDefMD.Metadata.PEImage.ImageDebugDirectories, ImageDebugType.Reproducible))
					PdbOptions |= PdbWriterOptions.Deterministic;
				if (HasDebugDirectoryEntry(modDefMD.Metadata.PEImage.ImageDebugDirectories, ImageDebugType.PdbChecksum))
					PdbOptions |= PdbWriterOptions.PdbChecksum;
				if (TryGetPdbChecksumAlgorithm(modDefMD.Metadata.PEImage, modDefMD.Metadata.PEImage.ImageDebugDirectories, out var pdbChecksumAlgorithm))
					PdbChecksumAlgorithm = pdbChecksumAlgorithm;
				MetadataOptions.TablesHeapOptions.Log2Rid = modDefMD.TablesStream.Log2Rid;
			}

			if (Is64Bit) {
				PEHeadersOptions.Characteristics &= ~Characteristics.Bit32Machine;
				PEHeadersOptions.Characteristics |= Characteristics.LargeAddressAware;
			}
			else if (modDefMD is null)
				PEHeadersOptions.Characteristics |= Characteristics.Bit32Machine;
		}

		static bool HasMvidSection(IList<ImageSectionHeader> sections) {
			int count = sections.Count;
			for (int i = 0; i < count; i++) {
				var section = sections[i];
				if (section.VirtualSize != 16)
					continue;
				var name = section.Name;
				// Roslyn ignores the last 2 bytes
				if (name[0] == '.' && name[1] == 'm' && name[2] == 'v' && name[3] == 'i' && name[4] == 'd' && name[5] == 0)
					return true;
			}
			return false;
		}

		static bool HasDebugDirectoryEntry(IList<ImageDebugDirectory> debugDirs, ImageDebugType type) {
			int count = debugDirs.Count;
			for (int i = 0; i < count; i++) {
				if (debugDirs[i].Type == type)
					return true;
			}
			return false;
		}

		static bool TryGetPdbChecksumAlgorithm(IPEImage peImage, IList<ImageDebugDirectory> debugDirs, out ChecksumAlgorithm pdbChecksumAlgorithm) {
			int count = debugDirs.Count;
			for (int i = 0; i < count; i++) {
				var dir = debugDirs[i];
				if (dir.Type == ImageDebugType.PdbChecksum) {
					var reader = peImage.CreateReader(dir.AddressOfRawData, dir.SizeOfData);
					if (TryGetPdbChecksumAlgorithm(ref reader, out pdbChecksumAlgorithm))
						return true;
				}
			}

			pdbChecksumAlgorithm = DefaultPdbChecksumAlgorithm;
			return false;
		}

		static bool TryGetPdbChecksumAlgorithm(ref DataReader reader, out ChecksumAlgorithm pdbChecksumAlgorithm) {
			try {
				var checksumName = reader.TryReadZeroTerminatedUtf8String();
				if (Hasher.TryGetChecksumAlgorithm(checksumName, out pdbChecksumAlgorithm, out int checksumSize) && (uint)checksumSize == reader.BytesLeft)
					return true;
			}
			catch (IOException) {
			}
			catch (ArgumentException) {
			}

			pdbChecksumAlgorithm = DefaultPdbChecksumAlgorithm;
			return false;
		}

		/// <summary>
		/// Initializes <see cref="StrongNameKey"/> and <see cref="StrongNamePublicKey"/>
		/// for normal strong name signing.
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="signatureKey">Signature strong name key pair</param>
		public void InitializeStrongNameSigning(ModuleDef module, StrongNameKey signatureKey) {
			StrongNameKey = signatureKey;
			StrongNamePublicKey = null;
			if (module.Assembly is not null)
				module.Assembly.CustomAttributes.RemoveAll("System.Reflection.AssemblySignatureKeyAttribute");
		}

		/// <summary>
		/// Initializes <see cref="StrongNameKey"/> and <see cref="StrongNamePublicKey"/>
		/// for enhanced strong name signing (without key migration). See
		/// http://msdn.microsoft.com/en-us/library/hh415055.aspx
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="signatureKey">Signature strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		public void InitializeEnhancedStrongNameSigning(ModuleDef module, StrongNameKey signatureKey, StrongNamePublicKey signaturePubKey) {
			InitializeStrongNameSigning(module, signatureKey);
			StrongNameKey = StrongNameKey.WithHashAlgorithm(signaturePubKey.HashAlgorithm);
		}

		/// <summary>
		/// Initializes <see cref="StrongNameKey"/> and <see cref="StrongNamePublicKey"/>
		/// for enhanced strong name signing (with key migration). See
		/// http://msdn.microsoft.com/en-us/library/hh415055.aspx
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="signatureKey">Signature strong name key pair</param>
		/// <param name="signaturePubKey">Signature public key</param>
		/// <param name="identityKey">Identity strong name key pair</param>
		/// <param name="identityPubKey">Identity public key</param>
		public void InitializeEnhancedStrongNameSigning(ModuleDef module, StrongNameKey signatureKey, StrongNamePublicKey signaturePubKey, StrongNameKey identityKey, StrongNamePublicKey identityPubKey) {
			StrongNameKey = signatureKey.WithHashAlgorithm(signaturePubKey.HashAlgorithm);
			StrongNamePublicKey = identityPubKey;
			if (module.Assembly is not null)
				module.Assembly.UpdateOrCreateAssemblySignatureKeyAttribute(identityPubKey, identityKey, signaturePubKey);
		}
	}

	/// <summary>
	/// Module writer base class
	/// </summary>
	public abstract class ModuleWriterBase : ILogger {
		/// <summary>Default alignment of all constants</summary>
		protected internal const uint DEFAULT_CONSTANTS_ALIGNMENT = 8;
		/// <summary>Default alignment of all method bodies</summary>
		protected const uint DEFAULT_METHODBODIES_ALIGNMENT = 4;
		/// <summary>Default alignment of all .NET resources</summary>
		protected const uint DEFAULT_NETRESOURCES_ALIGNMENT = 4;
		/// <summary>Default alignment of the .NET metadata</summary>
		protected const uint DEFAULT_METADATA_ALIGNMENT = 4;
		/// <summary>Default Win32 resources alignment</summary>
		protected internal const uint DEFAULT_WIN32_RESOURCES_ALIGNMENT = 8;
		/// <summary>Default strong name signature alignment</summary>
		protected const uint DEFAULT_STRONGNAMESIG_ALIGNMENT = 4;
		/// <summary>Default COR20 header alignment</summary>
		protected const uint DEFAULT_COR20HEADER_ALIGNMENT = 4;

		/// <summary>See <see cref="DestinationStream"/></summary>
		protected Stream destStream;
		/// <summary>See <see cref="Constants"/></summary>
		protected UniqueChunkList<ByteArrayChunk> constants;
		/// <summary>See <see cref="MethodBodies"/></summary>
		protected MethodBodyChunks methodBodies;
		/// <summary>See <see cref="NetResources"/></summary>
		protected NetResources netResources;
		/// <summary>See <see cref="Metadata"/></summary>
		protected Writer.Metadata metadata;
		/// <summary>See <see cref="Win32Resources"/></summary>
		protected Win32ResourcesChunk win32Resources;
		/// <summary>Offset where the module is written. Usually 0.</summary>
		protected long destStreamBaseOffset;
		/// <summary>Debug directory</summary>
		protected DebugDirectory debugDirectory;

		string createdPdbFileName;

		/// <summary>
		/// Strong name signature
		/// </summary>
		protected StrongNameSignature strongNameSignature;

		/// <summary>
		/// Returns the module writer options
		/// </summary>
		public abstract ModuleWriterOptionsBase TheOptions { get; }

		/// <summary>
		/// Gets the destination stream
		/// </summary>
		public Stream DestinationStream => destStream;

		/// <summary>
		/// Gets the constants
		/// </summary>
		public UniqueChunkList<ByteArrayChunk> Constants => constants;

		/// <summary>
		/// Gets the method bodies
		/// </summary>
		public MethodBodyChunks MethodBodies => methodBodies;

		/// <summary>
		/// Gets the .NET resources
		/// </summary>
		public NetResources NetResources => netResources;

		/// <summary>
		/// Gets the .NET metadata
		/// </summary>
		public Writer.Metadata Metadata => metadata;

		/// <summary>
		/// Gets the Win32 resources or <c>null</c> if there's none
		/// </summary>
		public Win32ResourcesChunk Win32Resources => win32Resources;

		/// <summary>
		/// Gets the strong name signature or <c>null</c> if there's none
		/// </summary>
		public StrongNameSignature StrongNameSignature => strongNameSignature;

		/// <summary>
		/// Gets all <see cref="PESection"/>s. The reloc section must be the last section, so use <see cref="AddSection(PESection)"/> if you need to append a section
		/// </summary>
		public abstract List<PESection> Sections { get; }

		/// <summary>
		/// Adds <paramref name="section"/> to the sections list, but before the reloc section which must be last
		/// </summary>
		/// <param name="section">New section to add to the list</param>
		public virtual void AddSection(PESection section) => Sections.Add(section);

		/// <summary>
		/// Gets the <c>.text</c> section
		/// </summary>
		public abstract PESection TextSection { get; }

		/// <summary>
		/// Gets the <c>.rsrc</c> section or <c>null</c> if there's none
		/// </summary>
		public abstract PESection RsrcSection { get; }

		/// <summary>
		/// Gets the debug directory or <c>null</c> if there's none
		/// </summary>
		public DebugDirectory DebugDirectory => debugDirectory;

		/// <summary>
		/// <c>true</c> if <c>this</c> is a <see cref="NativeModuleWriter"/>, <c>false</c> if
		/// <c>this</c> is a <see cref="ModuleWriter"/>.
		/// </summary>
		public bool IsNativeWriter => this is NativeModuleWriter;

		/// <summary>
		/// null if we're not writing a PDB
		/// </summary>
		PdbState pdbState;

		/// <summary>
		/// Writes the module to a file
		/// </summary>
		/// <param name="fileName">File name. The file will be truncated if it exists.</param>
		public void Write(string fileName) {
			using (var dest = new FileStream(fileName, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite)) {
				dest.SetLength(0);
				try {
					Write(dest);
				}
				catch {
					// Writing failed. Delete the file since it's useless.
					dest.Close();
					DeleteFileNoThrow(fileName);
					throw;
				}
			}
		}

		static void DeleteFileNoThrow(string fileName) {
			if (string.IsNullOrEmpty(fileName))
				return;
			try {
				File.Delete(fileName);
			}
			catch {
			}
		}

		/// <summary>
		/// Writes the module to a <see cref="Stream"/>
		/// </summary>
		/// <param name="dest">Destination stream</param>
		public void Write(Stream dest) {
			pdbState = TheOptions.WritePdb && Module.PdbState is not null ? Module.PdbState : null;
			if (TheOptions.DelaySign) {
				Debug.Assert(TheOptions.StrongNamePublicKey is not null, "Options.StrongNamePublicKey must be initialized when delay signing the assembly");
				Debug.Assert(TheOptions.StrongNameKey is null, "Options.StrongNameKey must be null when delay signing the assembly");
				TheOptions.Cor20HeaderOptions.Flags &= ~ComImageFlags.StrongNameSigned;
			}
			else if (TheOptions.StrongNameKey is not null || TheOptions.StrongNamePublicKey is not null)
				TheOptions.Cor20HeaderOptions.Flags |= ComImageFlags.StrongNameSigned;

			destStream = dest;
			destStreamBaseOffset = destStream.Position;
			OnWriterEvent(ModuleWriterEvent.Begin);
			var imageLength = WriteImpl();
			destStream.Position = destStreamBaseOffset + imageLength;
			OnWriterEvent(ModuleWriterEvent.End);
		}

		/// <summary>
		/// Returns the module that is written
		/// </summary>
		public abstract ModuleDef Module { get; }

		/// <summary>
		/// Writes the module to <see cref="destStream"/>. Event listeners and
		/// <see cref="destStream"/> have been initialized when this method is called.
		/// </summary>
		/// <returns>Number of bytes written</returns>
		protected abstract long WriteImpl();

		/// <summary>
		/// Creates the strong name signature if the module has one of the strong name flags
		/// set or wants to sign the assembly.
		/// </summary>
		protected void CreateStrongNameSignature() {
			if (TheOptions.DelaySign && TheOptions.StrongNamePublicKey is not null) {
				int len = TheOptions.StrongNamePublicKey.CreatePublicKey().Length - 0x20;
				strongNameSignature = new StrongNameSignature(len > 0 ? len : 0x80);
			}
			else if (TheOptions.StrongNameKey is not null)
				strongNameSignature = new StrongNameSignature(TheOptions.StrongNameKey.SignatureSize);
			else if (Module.Assembly is not null && !PublicKeyBase.IsNullOrEmpty2(Module.Assembly.PublicKey)) {
				int len = Module.Assembly.PublicKey.Data.Length - 0x20;
				strongNameSignature = new StrongNameSignature(len > 0 ? len : 0x80);
			}
			else if (((TheOptions.Cor20HeaderOptions.Flags ?? Module.Cor20HeaderFlags) & ComImageFlags.StrongNameSigned) != 0)
				strongNameSignature = new StrongNameSignature(0x80);
		}

		/// <summary>
		/// Creates the .NET metadata chunks (constants, method bodies, .NET resources,
		/// the metadata, and Win32 resources)
		/// </summary>
		/// <param name="module"></param>
		protected void CreateMetadataChunks(ModuleDef module) {
			constants = new UniqueChunkList<ByteArrayChunk>();
			methodBodies = new MethodBodyChunks(TheOptions.ShareMethodBodies);
			netResources = new NetResources(DEFAULT_NETRESOURCES_ALIGNMENT);

			DebugMetadataKind debugKind;
			if (pdbState is not null && (pdbState.PdbFileKind == PdbFileKind.PortablePDB || pdbState.PdbFileKind == PdbFileKind.EmbeddedPortablePDB))
				debugKind = DebugMetadataKind.Standalone;
			else
				debugKind = DebugMetadataKind.None;
			metadata = Metadata.Create(module, constants, methodBodies, netResources, TheOptions.MetadataOptions, debugKind);
			metadata.Logger = TheOptions.MetadataLogger ?? this;
			metadata.MetadataEvent += Metadata_MetadataEvent;
			metadata.ProgressUpdated += Metadata_ProgressUpdated;

			// StrongNamePublicKey is used if the user wants to override the assembly's
			// public key or when enhanced strong naming the assembly.
			var pk = TheOptions.StrongNamePublicKey;
			if (pk is not null)
				metadata.AssemblyPublicKey = pk.CreatePublicKey();
			else if (TheOptions.StrongNameKey is not null)
				metadata.AssemblyPublicKey = TheOptions.StrongNameKey.PublicKey;

			var w32Resources = GetWin32Resources();
			if (w32Resources is not null)
				win32Resources = new Win32ResourcesChunk(w32Resources);
		}

		/// <summary>
		/// Gets the Win32 resources that should be written to the new image or <c>null</c> if none
		/// </summary>
		protected abstract Win32Resources GetWin32Resources();

		/// <summary>
		/// Calculates <see cref="RVA"/> and <see cref="FileOffset"/> of all <see cref="IChunk"/>s
		/// </summary>
		/// <param name="chunks">All chunks</param>
		/// <param name="offset">Starting file offset</param>
		/// <param name="rva">Starting RVA</param>
		/// <param name="fileAlignment">File alignment</param>
		/// <param name="sectionAlignment">Section alignment</param>
		protected void CalculateRvasAndFileOffsets(List<IChunk> chunks, FileOffset offset, RVA rva, uint fileAlignment, uint sectionAlignment) {
			int count = chunks.Count;
			for (int i = 0; i < count; i++) {
				var chunk = chunks[i];
				chunk.SetOffset(offset, rva);
				// If it has zero size, it's not present in the file (eg. a section that wasn't needed)
				if (chunk.GetVirtualSize() != 0) {
					offset += chunk.GetFileLength();
					rva += chunk.GetVirtualSize();
					offset = offset.AlignUp(fileAlignment);
					rva = rva.AlignUp(sectionAlignment);
				}
			}
		}

		/// <summary>
		/// Writes all chunks to <paramref name="writer"/>
		/// </summary>
		/// <param name="writer">The writer</param>
		/// <param name="chunks">All chunks</param>
		/// <param name="offset">File offset of first chunk</param>
		/// <param name="fileAlignment">File alignment</param>
		protected void WriteChunks(DataWriter writer, List<IChunk> chunks, FileOffset offset, uint fileAlignment) {
			int count = chunks.Count;
			for (int i = 0; i < count; i++) {
				var chunk = chunks[i];
				chunk.VerifyWriteTo(writer);
				// If it has zero size, it's not present in the file (eg. a section that wasn't needed)
				if (chunk.GetVirtualSize() != 0) {
					offset += chunk.GetFileLength();
					var newOffset = offset.AlignUp(fileAlignment);
					writer.WriteZeroes((int)(newOffset - offset));
					offset = newOffset;
				}
			}
		}

		/// <summary>
		/// Strong name sign the assembly
		/// </summary>
		/// <param name="snSigOffset">Strong name signature offset</param>
		protected void StrongNameSign(long snSigOffset) {
			var snSigner = new StrongNameSigner(destStream, destStreamBaseOffset);
			snSigner.WriteSignature(TheOptions.StrongNameKey, snSigOffset);
		}

		bool CanWritePdb() => pdbState is not null;

		/// <summary>
		/// Creates the debug directory if a PDB file should be written
		/// </summary>
		protected void CreateDebugDirectory() {
			if (CanWritePdb())
				debugDirectory = new DebugDirectory();
		}

		/// <summary>
		/// Write the PDB file. The caller should send the PDB events before and after calling this
		/// method.
		/// </summary>
		protected void WritePdbFile() {
			if (!CanWritePdb())
				return;
			if (debugDirectory is null)
				throw new InvalidOperationException("debugDirectory is null but WritePdb is true");

			if (pdbState is null) {
				Error("TheOptions.WritePdb is true but module has no PdbState");
				return;
			}

			try {
				switch (pdbState.PdbFileKind) {
				case PdbFileKind.WindowsPDB:
					WriteWindowsPdb(pdbState);
					break;

				case PdbFileKind.PortablePDB:
					WritePortablePdb(pdbState, false);
					break;

				case PdbFileKind.EmbeddedPortablePDB:
					WritePortablePdb(pdbState, true);
					break;

				default:
					Error("Invalid PDB file kind {0}", pdbState.PdbFileKind);
					break;
				}
			}
			catch {
				DeleteFileNoThrow(createdPdbFileName);
				throw;
			}
		}

		void AddReproduciblePdbDebugDirectoryEntry() =>
			debugDirectory.Add(Array2.Empty<byte>(), type: ImageDebugType.Reproducible, majorVersion: 0, minorVersion: 0, timeDateStamp: 0);

		void AddPdbChecksumDebugDirectoryEntry(byte[] checksumBytes, ChecksumAlgorithm checksumAlgorithm) {
			var stream = new MemoryStream();
			var writer = new DataWriter(stream);
			var checksumName = Hasher.GetChecksumName(checksumAlgorithm);
			writer.WriteBytes(Encoding.UTF8.GetBytes(checksumName));
			writer.WriteByte(0);
			writer.WriteBytes(checksumBytes);
			var blob = stream.ToArray();
			debugDirectory.Add(blob, ImageDebugType.PdbChecksum, majorVersion: 1, minorVersion: 0, timeDateStamp: 0);
		}

		const uint PdbAge = 1;
		void WriteWindowsPdb(PdbState pdbState) {
			bool addPdbChecksumDebugDirectoryEntry = (TheOptions.PdbOptions & PdbWriterOptions.PdbChecksum) != 0;
			addPdbChecksumDebugDirectoryEntry = false;//TODO: If this is true, get the checksum from the PDB writer
			var symWriter = GetWindowsPdbSymbolWriter(TheOptions.PdbOptions, out var pdbFilename);
			if (symWriter is null) {
				Error("Could not create a PDB symbol writer. A Windows OS might be required.");
				return;
			}

			using (var pdbWriter = new WindowsPdbWriter(symWriter, pdbState, metadata)) {
				pdbWriter.Logger = TheOptions.Logger;
				pdbWriter.Write();

				var pdbAge = PdbAge;
				bool hasContentId = pdbWriter.GetDebugInfo(TheOptions.PdbChecksumAlgorithm, ref pdbAge, out var pdbGuid, out uint stamp, out var idd, out var codeViewData);
				if (hasContentId) {
					debugDirectory.Add(GetCodeViewData(pdbGuid, pdbAge, TheOptions.PdbFileNameInDebugDirectory ?? pdbFilename),
						type: ImageDebugType.CodeView,
						majorVersion: 0,
						minorVersion: 0,
						timeDateStamp: stamp);
				}
				else {
					Debug.Fail("Failed to get the PDB content ID");
					if (codeViewData is null)
						throw new InvalidOperationException();
					var entry = debugDirectory.Add(codeViewData);
					entry.DebugDirectory = idd;
					entry.DebugDirectory.TimeDateStamp = GetTimeDateStamp();
				}

				//TODO: Only do this if symWriter supports PDB checksums
				if (addPdbChecksumDebugDirectoryEntry)
					{}//TODO: AddPdbChecksumDebugDirectoryEntry(checksumBytes, TheOptions.PdbChecksumAlgorithm);, and verify that the order of the debug dir entries is the same as Roslyn created binaries
				if (symWriter.IsDeterministic)
					AddReproduciblePdbDebugDirectoryEntry();
			}
		}

		/// <summary>
		/// Gets the timestamp stored in the PE header
		/// </summary>
		/// <returns></returns>
		protected uint GetTimeDateStamp() {
			var td = TheOptions.PEHeadersOptions.TimeDateStamp;
			if (td.HasValue)
				return (uint)td;
			TheOptions.PEHeadersOptions.TimeDateStamp = PEHeadersOptions.CreateNewTimeDateStamp();
			return (uint)TheOptions.PEHeadersOptions.TimeDateStamp;
		}

		SymbolWriter GetWindowsPdbSymbolWriter(PdbWriterOptions options, out string pdbFilename) {
			if (TheOptions.PdbStream is not null) {
				return Pdb.Dss.SymbolReaderWriterFactory.Create(options, TheOptions.PdbStream,
							pdbFilename = TheOptions.PdbFileName ??
							GetStreamName(TheOptions.PdbStream) ??
							GetDefaultPdbFileName());
			}

			if (!string.IsNullOrEmpty(TheOptions.PdbFileName)) {
				createdPdbFileName = pdbFilename = TheOptions.PdbFileName;
				return Pdb.Dss.SymbolReaderWriterFactory.Create(options, createdPdbFileName);
			}

			createdPdbFileName = pdbFilename = GetDefaultPdbFileName();
			if (createdPdbFileName is null)
				return null;
			return Pdb.Dss.SymbolReaderWriterFactory.Create(options, createdPdbFileName);
		}

		static string GetStreamName(Stream stream) => (stream as FileStream)?.Name;

		static string GetModuleName(ModuleDef module) {
			var name = module.Name ?? string.Empty;
			if (string.IsNullOrEmpty(name))
				return null;
			if (name.EndsWith(".dll", StringComparison.OrdinalIgnoreCase) || name.EndsWith(".exe", StringComparison.OrdinalIgnoreCase) || name.EndsWith(".netmodule", StringComparison.OrdinalIgnoreCase))
				return name;
			return name + ".pdb";
		}

		string GetDefaultPdbFileName() {
			var destFileName = GetStreamName(destStream) ?? GetModuleName(Module);
			if (string.IsNullOrEmpty(destFileName)) {
				Error("TheOptions.WritePdb is true but it's not possible to guess the default PDB file name. Set PdbFileName to the name of the PDB file.");
				return null;
			}

			return Path.ChangeExtension(destFileName, "pdb");
		}

		void WritePortablePdb(PdbState pdbState, bool isEmbeddedPortablePdb) {
			bool ownsStream = false;
			Stream pdbStream = null;
			try {
				MemoryStream embeddedMemoryStream = null;
				if (isEmbeddedPortablePdb) {
					pdbStream = embeddedMemoryStream = new MemoryStream();
					ownsStream = true;
				}
				else
					pdbStream = GetStandalonePortablePdbStream(out ownsStream);
				if (pdbStream is null)
					throw new ModuleWriterException("Couldn't create a PDB stream");

				var pdbFilename = TheOptions.PdbFileName ?? GetStreamName(pdbStream) ?? GetDefaultPdbFileName();
				if (isEmbeddedPortablePdb)
					pdbFilename = Path.GetFileName(pdbFilename);

				uint entryPointToken;
				if (pdbState.UserEntryPoint is null)
					entryPointToken = 0;
				else
					entryPointToken = new MDToken(Table.Method, metadata.GetRid(pdbState.UserEntryPoint)).Raw;

				metadata.WritePortablePdb(pdbStream, entryPointToken, out var pdbIdOffset);

				Guid pdbGuid;
				var pdbId = new byte[20];
				var pdbIdWriter = new ArrayWriter(pdbId);
				uint codeViewTimestamp;
				byte[] checksumBytes;
				if ((TheOptions.PdbOptions & PdbWriterOptions.Deterministic) != 0 ||
					(TheOptions.PdbOptions & PdbWriterOptions.PdbChecksum) != 0 ||
					TheOptions.GetPdbContentId is null) {
					pdbStream.Position = 0;
					checksumBytes = Hasher.Hash(TheOptions.PdbChecksumAlgorithm, pdbStream, pdbStream.Length);
					if (checksumBytes.Length < 20)
						throw new ModuleWriterException("Checksum bytes length < 20");
					RoslynContentIdProvider.GetContentId(checksumBytes, out pdbGuid, out codeViewTimestamp);
				}
				else {
					var contentId = TheOptions.GetPdbContentId(pdbStream, GetTimeDateStamp());
					codeViewTimestamp = contentId.Timestamp;
					pdbGuid = contentId.Guid;
					checksumBytes = null;
				}
				pdbIdWriter.WriteBytes(pdbGuid.ToByteArray());
				pdbIdWriter.WriteUInt32(codeViewTimestamp);
				Debug.Assert(pdbIdWriter.Position == pdbId.Length);
				pdbStream.Position = pdbIdOffset;
				pdbStream.Write(pdbId, 0, pdbId.Length);

				// NOTE: We add these directory entries in the same order as Roslyn seems to do:
				//	- CodeView
				//	- PdbChecksum
				//	- Reproducible
				//	- EmbeddedPortablePdb

				debugDirectory.Add(GetCodeViewData(pdbGuid, PdbAge, TheOptions.PdbFileNameInDebugDirectory ?? pdbFilename),
					type: ImageDebugType.CodeView,
					majorVersion: PortablePdbConstants.FormatVersion,
					minorVersion: PortablePdbConstants.PortableCodeViewVersionMagic,
					timeDateStamp: codeViewTimestamp);

				if (checksumBytes is not null)
					AddPdbChecksumDebugDirectoryEntry(checksumBytes, TheOptions.PdbChecksumAlgorithm);

				if ((TheOptions.PdbOptions & PdbWriterOptions.Deterministic) != 0)
					AddReproduciblePdbDebugDirectoryEntry();

				if (isEmbeddedPortablePdb) {
					Debug.Assert(embeddedMemoryStream is not null);
					debugDirectory.Add(CreateEmbeddedPortablePdbBlob(embeddedMemoryStream),
						type: ImageDebugType.EmbeddedPortablePdb,
						majorVersion: PortablePdbConstants.FormatVersion,
						minorVersion: PortablePdbConstants.EmbeddedVersion,
						timeDateStamp: 0);
				}
			}
			finally {
				if (ownsStream && pdbStream is not null)
					pdbStream.Dispose();
			}
		}

		static byte[] CreateEmbeddedPortablePdbBlob(MemoryStream portablePdbStream) {
			var compressedData = Compress(portablePdbStream);
			var data = new byte[4 + 4 + compressedData.Length];
			var stream = new MemoryStream(data);
			var writer = new DataWriter(stream);
			writer.WriteInt32(0x4244504D);//"MPDB"
			writer.WriteUInt32((uint)portablePdbStream.Length);
			writer.WriteBytes(compressedData);
			Debug.Assert(stream.Position == data.Length);
			return data;
		}

		static byte[] Compress(MemoryStream sourceStream) {
			sourceStream.Position = 0;
			var destStream = new MemoryStream();
			using (var deflate = new DeflateStream(destStream, CompressionMode.Compress)) {
				var source = sourceStream.ToArray();
				deflate.Write(source, 0, source.Length);
			}
			return destStream.ToArray();
		}

		static byte[] GetCodeViewData(Guid guid, uint age, string filename) {
			var stream = new MemoryStream();
			var writer = new DataWriter(stream);
			writer.WriteInt32(0x53445352);
			writer.WriteBytes(guid.ToByteArray());
			writer.WriteUInt32(age);
			writer.WriteBytes(Encoding.UTF8.GetBytes(filename));
			writer.WriteByte(0);
			return stream.ToArray();
		}

		Stream GetStandalonePortablePdbStream(out bool ownsStream) {
			if (TheOptions.PdbStream is not null) {
				ownsStream = false;
				return TheOptions.PdbStream;
			}

			if (!string.IsNullOrEmpty(TheOptions.PdbFileName))
				createdPdbFileName = TheOptions.PdbFileName;
			else
				createdPdbFileName = GetDefaultPdbFileName();
			if (createdPdbFileName is null) {
				ownsStream = false;
				return null;
			}
			ownsStream = true;
			return File.Create(createdPdbFileName);
		}

		void Metadata_MetadataEvent(object sender, MetadataWriterEventArgs e) {
			switch (e.Event) {
			case MetadataEvent.BeginCreateTables:
				OnWriterEvent(ModuleWriterEvent.MDBeginCreateTables);
				break;

			case MetadataEvent.AllocateTypeDefRids:
				OnWriterEvent(ModuleWriterEvent.MDAllocateTypeDefRids);
				break;

			case MetadataEvent.AllocateMemberDefRids:
				OnWriterEvent(ModuleWriterEvent.MDAllocateMemberDefRids);
				break;

			case MetadataEvent.MemberDefRidsAllocated:
				OnWriterEvent(ModuleWriterEvent.MDMemberDefRidsAllocated);
				break;

			case MetadataEvent.MemberDefsInitialized:
				OnWriterEvent(ModuleWriterEvent.MDMemberDefsInitialized);
				break;

			case MetadataEvent.BeforeSortTables:
				OnWriterEvent(ModuleWriterEvent.MDBeforeSortTables);
				break;

			case MetadataEvent.MostTablesSorted:
				OnWriterEvent(ModuleWriterEvent.MDMostTablesSorted);
				break;

			case MetadataEvent.MemberDefCustomAttributesWritten:
				OnWriterEvent(ModuleWriterEvent.MDMemberDefCustomAttributesWritten);
				break;

			case MetadataEvent.BeginAddResources:
				OnWriterEvent(ModuleWriterEvent.MDBeginAddResources);
				break;

			case MetadataEvent.EndAddResources:
				OnWriterEvent(ModuleWriterEvent.MDEndAddResources);
				break;

			case MetadataEvent.BeginWriteMethodBodies:
				OnWriterEvent(ModuleWriterEvent.MDBeginWriteMethodBodies);
				break;

			case MetadataEvent.EndWriteMethodBodies:
				OnWriterEvent(ModuleWriterEvent.MDEndWriteMethodBodies);
				break;

			case MetadataEvent.OnAllTablesSorted:
				OnWriterEvent(ModuleWriterEvent.MDOnAllTablesSorted);
				break;

			case MetadataEvent.EndCreateTables:
				OnWriterEvent(ModuleWriterEvent.MDEndCreateTables);
				break;

			default:
				Debug.Fail($"Unknown MD event: {e.Event}");
				break;
			}
		}

		void Metadata_ProgressUpdated(object sender, MetadataProgressEventArgs e) =>
			RaiseProgress(ModuleWriterEvent.MDBeginCreateTables, ModuleWriterEvent.MDEndCreateTables + 1, e.Progress);

		/// <summary>
		/// Raises a writer event
		/// </summary>
		/// <param name="evt">Event</param>
		protected void OnWriterEvent(ModuleWriterEvent evt) {
			RaiseProgress(evt, 0);
			TheOptions.RaiseEvent(this, new ModuleWriterEventArgs(this, evt));
		}

		static readonly double[] eventToProgress = new double[(int)ModuleWriterEvent.End - (int)ModuleWriterEvent.Begin + 1 + 1] {
			0,					// Begin
			0.00128048488389907,// PESectionsCreated
			0.0524625293056615,	// ChunksCreated
			0.0531036610555682,	// ChunksAddedToSections
			0.0535679983835939,	// MDBeginCreateTables
			0.0547784058004697,	// MDAllocateTypeDefRids
			0.0558606342971218,	// MDAllocateMemberDefRids
			0.120553993799033,	// MDMemberDefRidsAllocated
			0.226210300699921,	// MDMemberDefsInitialized
			0.236002648477671,	// MDBeforeSortTables
			0.291089703426468,	// MDMostTablesSorted
			0.449919748849947,	// MDMemberDefCustomAttributesWritten
			0.449919985998736,	// MDBeginAddResources
			0.452716444513587,	// MDEndAddResources
			0.452716681662375,	// MDBeginWriteMethodBodies
			0.924922132195272,	// MDEndWriteMethodBodies
			0.931410404476231,	// MDOnAllTablesSorted
			0.931425463424305,	// MDEndCreateTables
			0.932072998191503,	// BeginWritePdb
			0.932175327893773,	// EndWritePdb
			0.932175446468167,	// BeginCalculateRvasAndFileOffsets
			0.954646479929387,	// EndCalculateRvasAndFileOffsets
			0.95492263969368,	// BeginWriteChunks
			0.980563166714175,	// EndWriteChunks
			0.980563403862964,	// BeginStrongNameSign
			0.980563403862964,	// EndStrongNameSign
			0.980563522437358,	// BeginWritePEChecksum
			0.999975573674777,	// EndWritePEChecksum
			1,					// End
			1,// An extra one so we can get the next base progress without checking the index
		};

		void RaiseProgress(ModuleWriterEvent evt, double subProgress) => RaiseProgress(evt, evt + 1, subProgress);

		void RaiseProgress(ModuleWriterEvent evt, ModuleWriterEvent nextEvt, double subProgress) {
			subProgress = Math.Min(1, Math.Max(0, subProgress));
			var baseProgress = eventToProgress[(int)evt];
			var nextProgress = eventToProgress[(int)nextEvt];
			var progress = baseProgress + (nextProgress - baseProgress) * subProgress;
			progress = Math.Min(1, Math.Max(0, progress));
			TheOptions.RaiseEvent(this, new ModuleWriterProgressEventArgs(this, progress));
		}

		ILogger GetLogger() => TheOptions.Logger ?? DummyLogger.ThrowModuleWriterExceptionOnErrorInstance;

		/// <inheritdoc/>
		void ILogger.Log(object sender, LoggerEvent loggerEvent, string format, params object[] args) =>
			GetLogger().Log(this, loggerEvent, format, args);

		/// <inheritdoc/>
		bool ILogger.IgnoresEvent(LoggerEvent loggerEvent) => GetLogger().IgnoresEvent(loggerEvent);

		/// <summary>
		/// Logs an error message
		/// </summary>
		/// <param name="format">Format</param>
		/// <param name="args">Format args</param>
		protected void Error(string format, params object[] args) =>
			GetLogger().Log(this, LoggerEvent.Error, format, args);

		/// <summary>
		/// Logs a warning message
		/// </summary>
		/// <param name="format">Format</param>
		/// <param name="args">Format args</param>
		protected void Warning(string format, params object[] args) =>
			GetLogger().Log(this, LoggerEvent.Warning, format, args);
	}
}




namespace dnlib.DotNet.Writer {
	/// <summary>
	/// All <see cref="ModuleWriter"/> / <see cref="NativeModuleWriter"/> events
	/// </summary>
	public enum ModuleWriterEvent {
		/// <summary>
		/// Writing has just begun
		/// </summary>
		Begin,

		/// <summary>
		/// All PE sections have been created
		/// </summary>
		PESectionsCreated,

		/// <summary>
		/// All chunks have been created
		/// </summary>
		ChunksCreated,

		/// <summary>
		/// All chunks have been added to their sections
		/// </summary>
		ChunksAddedToSections,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.BeginCreateTables"/>.
		/// Creating the metadata tables has just begun
		/// </summary>
		MDBeginCreateTables,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.AllocateTypeDefRids"/>.
		/// Before allocating all TypeDef RIDs
		/// </summary>
		MDAllocateTypeDefRids,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.AllocateMemberDefRids"/>.
		/// Before allocating all MemberDef RIDs
		/// </summary>
		MDAllocateMemberDefRids,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.MemberDefRidsAllocated"/>.
		/// The <c>rid</c>s of types, fields, methods, events, properties and parameters are
		/// now known.
		/// </summary>
		MDMemberDefRidsAllocated,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.MemberDefsInitialized"/>.
		/// The tables and rows of all types, fields, methods, events, properties and parameters
		/// have been initialized. Method body RVAs are still not known, and no method has been
		/// written yet.
		/// </summary>
		MDMemberDefsInitialized,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.BeforeSortTables"/>.
		/// Before sorting most tables
		/// </summary>
		MDBeforeSortTables,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.MostTablesSorted"/>.
		/// Most of the tables that should be sorted have been sorted. The <c>CustomAttribute</c>
		/// table is still unsorted since it hasn't been created yet.
		/// </summary>
		MDMostTablesSorted,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.MemberDefCustomAttributesWritten"/>.
		/// Custom attributes of all types, fields, methods, events, properties and parameters
		/// have now been written.
		/// </summary>
		MDMemberDefCustomAttributesWritten,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.BeginAddResources"/>.
		/// All resources are about to be added to the .NET resources table
		/// </summary>
		MDBeginAddResources,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.EndAddResources"/>.
		/// All resources have been added to the .NET resources table
		/// </summary>
		MDEndAddResources,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.BeginWriteMethodBodies"/>.
		/// All method bodies are about to be written
		/// </summary>
		MDBeginWriteMethodBodies,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.EndWriteMethodBodies"/>.
		/// All method bodies have been written. Their RVAs are still not known.
		/// </summary>
		MDEndWriteMethodBodies,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.OnAllTablesSorted"/>.
		/// All tables are now sorted, including the <c>CustomAttribute</c> table.
		/// </summary>
		MDOnAllTablesSorted,

		/// <summary>
		/// Original event: <see cref="MetadataEvent.EndCreateTables"/>.
		/// All tables have been created and all rows populated. The only columns that haven't
		/// been initialized yet are the ones that are RVAs.
		/// </summary>
		MDEndCreateTables,

		/// <summary>
		/// This event occurs before the PDB file is written. This event occurs even if no PDB file
		/// will be written.
		/// </summary>
		BeginWritePdb,

		/// <summary>
		/// The PDB file has been written. This event occurs even if no PDB file has been written.
		/// </summary>
		EndWritePdb,

		/// <summary>
		/// This event occurs just before all RVAs and file offsets of the chunks are calculated.
		/// </summary>
		BeginCalculateRvasAndFileOffsets,

		/// <summary>
		/// File offsets and RVAs of all chunks are now known. This includes method body and
		/// field RVAs. Nothing has been written to the destination stream yet.
		/// </summary>
		EndCalculateRvasAndFileOffsets,

		/// <summary>
		/// This event occurs before all chunks are written to the destination stream, and after
		/// all RVAs and file offsets are known.
		/// </summary>
		BeginWriteChunks,

		/// <summary>
		/// All chunks have been written to the destination stream.
		/// </summary>
		EndWriteChunks,

		/// <summary>
		/// This event occurs before the strong name signature is calculated. This event
		/// occurs even if the assembly isn't strong name signed.
		/// </summary>
		BeginStrongNameSign,

		/// <summary>
		/// This event occurs after the strong name signature has been calculated. This event
		/// occurs even if the assembly isn't strong name signed.
		/// </summary>
		EndStrongNameSign,

		/// <summary>
		/// This event occurs before the checksum in the PE header is updated. This event
		/// occurs even if the checksum isn't updated.
		/// </summary>
		BeginWritePEChecksum,

		/// <summary>
		/// This event occurs after the checksum in the PE header has been updated. This event
		/// occurs even if the checksum isn't updated.
		/// </summary>
		EndWritePEChecksum,

		/// <summary>
		/// Writing has ended
		/// </summary>
		End,
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Thrown when the module writer encounters an unrecoverable error
	/// </summary>
	[Serializable]
	public class ModuleWriterException : Exception {
		/// <summary>
		/// Default constructor
		/// </summary>
		public ModuleWriterException() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		public ModuleWriterException(string message)
			: base(message) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="message">Error message</param>
		/// <param name="innerException">Other exception</param>
		public ModuleWriterException(string message, Exception innerException)
			: base(message, innerException) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="info"></param>
		/// <param name="context"></param>
		protected ModuleWriterException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="NativeModuleWriter"/> options
	/// </summary>
	public sealed class NativeModuleWriterOptions : ModuleWriterOptionsBase {
		/// <summary>
		/// If <c>true</c>, any extra data after the PE data in the original file is also saved
		/// at the end of the new file. Enable this option if some protector has written data to
		/// the end of the file and uses it at runtime.
		/// </summary>
		public bool KeepExtraPEData { get; set; }

		/// <summary>
		/// If <c>true</c>, keep the original Win32 resources
		/// </summary>
		public bool KeepWin32Resources { get; set; }

		internal bool OptimizeImageSize { get; }

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">Module</param>
		/// <param name="optimizeImageSize">true to optimize the image size so it's as small as possible.
		/// Since the file can contain native methods and other native data, we re-use the
		/// original file when writing the new file. If <paramref name="optimizeImageSize"/> is true,
		/// we'll try to re-use the old method body locations in the original file and
		/// also try to fit the new metadata in the old metadata location.</param>
		public NativeModuleWriterOptions(ModuleDefMD module, bool optimizeImageSize) : base(module) {
			// C++ .NET mixed mode assemblies sometimes/often call Module.ResolveMethod(),
			// so method metadata tokens must be preserved.
			MetadataOptions.Flags |= MetadataFlags.PreserveAllMethodRids;

			if (optimizeImageSize) {
				OptimizeImageSize = true;

				// Prevent the #Blob heap from getting bigger. Encoded TypeDefOrRef tokens are stored there (in
				// typesigs and callingconvsigs) so we must preserve TypeDefOrRef tokens (or the #Blob heap could
				// grow in size and new MD won't fit in old location)
				MetadataOptions.Flags |= MetadataFlags.PreserveTypeRefRids | MetadataFlags.PreserveTypeDefRids | MetadataFlags.PreserveTypeSpecRids;
			}
		}
	}

	/// <summary>
	/// A module writer that supports saving mixed-mode modules (modules with native code).
	/// The original image will be re-used. See also <see cref="ModuleWriter"/>
	/// </summary>
	public sealed class NativeModuleWriter : ModuleWriterBase {
		/// <summary>The original .NET module</summary>
		readonly ModuleDefMD module;

		/// <summary>All options</summary>
		NativeModuleWriterOptions options;

		/// <summary>
		/// Any extra data found at the end of the original file. This is <c>null</c> if there's
		/// no extra data or if <see cref="NativeModuleWriterOptions.KeepExtraPEData"/> is
		/// <c>false</c>.
		/// </summary>
		DataReaderChunk extraData;

		/// <summary>The original PE sections and their data</summary>
		List<OrigSection> origSections;

		readonly struct ReusedChunkInfo {
			public IReuseChunk Chunk { get; }
			public RVA RVA { get; }
			public ReusedChunkInfo(IReuseChunk chunk, RVA rva) {
				Chunk = chunk;
				RVA = rva;
			}
		}

		List<ReusedChunkInfo> reusedChunks;

		/// <summary>Original PE image</summary>
		readonly IPEImage peImage;

		/// <summary>New sections we've added and their data</summary>
		List<PESection> sections;

		/// <summary>New .text section where we put some stuff, eg. .NET metadata</summary>
		PESection textSection;

		/// <summary>The new COR20 header</summary>
		ByteArrayChunk imageCor20Header;

		/// <summary>
		/// New .rsrc section where we put the new Win32 resources. This is <c>null</c> if there
		/// are no Win32 resources or if <see cref="NativeModuleWriterOptions.KeepWin32Resources"/>
		/// is <c>true</c>
		/// </summary>
		PESection rsrcSection;

		/// <summary>
		/// Offset in <see cref="ModuleWriterBase.destStream"/> of the PE checksum field.
		/// </summary>
		long checkSumOffset;

		/// <summary>
		/// Original PE section
		/// </summary>
		public sealed class OrigSection : IDisposable {
			/// <summary>PE section</summary>
			public ImageSectionHeader PESection;
			/// <summary>PE section data</summary>
			public DataReaderChunk Chunk;

			/// <summary>
			/// Constructor
			/// </summary>
			/// <param name="peSection">PE section</param>
			public OrigSection(ImageSectionHeader peSection) =>
				PESection = peSection;

			/// <inheritdoc/>
			public void Dispose() {
				Chunk = null;
				PESection = null;
			}

			/// <inheritdoc/>
			public override string ToString() {
				uint offs = Chunk.CreateReader().StartOffset;
				return $"{PESection.DisplayName} FO:{offs:X8} L:{Chunk.CreateReader().Length:X8}";
			}
		}

		/// <summary>
		/// Gets the module
		/// </summary>
		public ModuleDefMD ModuleDefMD => module;

		/// <inheritdoc/>
		public override ModuleDef Module => module;

		/// <inheritdoc/>
		public override ModuleWriterOptionsBase TheOptions => Options;

		/// <summary>
		/// Gets/sets the writer options. This is never <c>null</c>
		/// </summary>
		public NativeModuleWriterOptions Options {
			get => options ??= new NativeModuleWriterOptions(module, optimizeImageSize: true);
			set => options = value;
		}

		/// <summary>
		/// Gets all <see cref="PESection"/>s
		/// </summary>
		public override List<PESection> Sections => sections;

		/// <summary>
		/// Gets the original PE sections and their data
		/// </summary>
		public List<OrigSection> OrigSections => origSections;

		/// <summary>
		/// Gets the <c>.text</c> section
		/// </summary>
		public override PESection TextSection => textSection;

		/// <summary>
		/// Gets the <c>.rsrc</c> section or <c>null</c> if there's none
		/// </summary>
		public override PESection RsrcSection => rsrcSection;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="module">The module</param>
		/// <param name="options">Options or <c>null</c></param>
		public NativeModuleWriter(ModuleDefMD module, NativeModuleWriterOptions options) {
			this.module = module;
			this.options = options;
			peImage = module.Metadata.PEImage;
			reusedChunks = new List<ReusedChunkInfo>();
		}

		/// <inheritdoc/>
		protected override long WriteImpl() {
			try {
				return Write();
			}
			finally {
				if (origSections is not null) {
					foreach (var section in origSections)
						section.Dispose();
				}
			}
		}

		long Write() {
			Initialize();

			// It's not safe to create new Field RVAs so re-use them all. The user can override
			// this by setting field.RVA = 0 when creating a new field.InitialValue.
			metadata.KeepFieldRVA = true;

			metadata.CreateTables();
			return WriteFile();
		}

		void Initialize() {
			CreateSections();
			OnWriterEvent(ModuleWriterEvent.PESectionsCreated);

			CreateChunks();
			OnWriterEvent(ModuleWriterEvent.ChunksCreated);

			AddChunksToSections();
			OnWriterEvent(ModuleWriterEvent.ChunksAddedToSections);
		}

		void CreateSections() {
			CreatePESections();
			CreateRawSections();
			CreateExtraData();
		}

		void CreateChunks() {
			CreateMetadataChunks(module);
			methodBodies.CanReuseOldBodyLocation = Options.OptimizeImageSize;

			CreateDebugDirectory();

			imageCor20Header = new ByteArrayChunk(new byte[0x48]);
			CreateStrongNameSignature();
		}

		void AddChunksToSections() {
			textSection.Add(imageCor20Header, DEFAULT_COR20HEADER_ALIGNMENT);
			textSection.Add(strongNameSignature, DEFAULT_STRONGNAMESIG_ALIGNMENT);
			textSection.Add(constants, DEFAULT_CONSTANTS_ALIGNMENT);
			textSection.Add(methodBodies, DEFAULT_METHODBODIES_ALIGNMENT);
			textSection.Add(netResources, DEFAULT_NETRESOURCES_ALIGNMENT);
			textSection.Add(metadata, DEFAULT_METADATA_ALIGNMENT);
			textSection.Add(debugDirectory, DebugDirectory.DEFAULT_DEBUGDIRECTORY_ALIGNMENT);
			if (rsrcSection is not null)
				rsrcSection.Add(win32Resources, DEFAULT_WIN32_RESOURCES_ALIGNMENT);
		}

		/// <inheritdoc/>
		protected override Win32Resources GetWin32Resources() {
			if (Options.KeepWin32Resources)
				return null;
			if (Options.NoWin32Resources)
				return null;
			return Options.Win32Resources ?? module.Win32Resources;
		}

		void CreatePESections() {
			sections = new List<PESection>();
			sections.Add(textSection = new PESection(".text", 0x60000020));
			if (GetWin32Resources() is not null)
				sections.Add(rsrcSection = new PESection(".rsrc", 0x40000040));
		}

		/// <summary>
		/// Gets the raw section data of the image. The sections are saved in
		/// <see cref="origSections"/>.
		/// </summary>
		void CreateRawSections() {
			var fileAlignment = peImage.ImageNTHeaders.OptionalHeader.FileAlignment;
			origSections = new List<OrigSection>(peImage.ImageSectionHeaders.Count);

			foreach (var peSection in peImage.ImageSectionHeaders) {
				var newSection = new OrigSection(peSection);
				origSections.Add(newSection);
				uint sectionSize = Utils.AlignUp(peSection.SizeOfRawData, fileAlignment);
				newSection.Chunk = new DataReaderChunk(peImage.CreateReader(peSection.VirtualAddress, sectionSize), peSection.VirtualSize);
			}
		}

		/// <summary>
		/// Creates the PE header "section"
		/// </summary>
		DataReaderChunk CreateHeaderSection(out IChunk extraHeaderData) {
			uint afterLastSectHeader = GetOffsetAfterLastSectionHeader() + (uint)sections.Count * 0x28;
			uint firstRawOffset = Math.Min(GetFirstRawDataFileOffset(), peImage.ImageNTHeaders.OptionalHeader.SectionAlignment);
			uint headerLen = afterLastSectHeader;
			if (firstRawOffset > headerLen)
				headerLen = firstRawOffset;
			headerLen = Utils.AlignUp(headerLen, peImage.ImageNTHeaders.OptionalHeader.FileAlignment);
			if (headerLen <= peImage.ImageNTHeaders.OptionalHeader.SectionAlignment) {
				uint origSizeOfHeaders = peImage.ImageNTHeaders.OptionalHeader.SizeOfHeaders;
				uint extraLen;
				if (headerLen <= origSizeOfHeaders)
					extraLen = 0;
				else {
					extraLen = headerLen - origSizeOfHeaders;
					headerLen = origSizeOfHeaders;
				}
				if (extraLen > 0)
					extraHeaderData = new ByteArrayChunk(new byte[(int)extraLen]);
				else
					extraHeaderData = null;
				return new DataReaderChunk(peImage.CreateReader((FileOffset)0, headerLen));
			}

			//TODO: Support this too
			throw new ModuleWriterException("Could not create header");
		}

		uint GetOffsetAfterLastSectionHeader() {
			var lastSect = peImage.ImageSectionHeaders[peImage.ImageSectionHeaders.Count - 1];
			return (uint)lastSect.EndOffset;
		}

		uint GetFirstRawDataFileOffset() {
			uint len = uint.MaxValue;
			foreach (var section in peImage.ImageSectionHeaders)
				len = Math.Min(len, section.PointerToRawData);
			return len;
		}

		/// <summary>
		/// Saves any data that is appended to the original PE file
		/// </summary>
		void CreateExtraData() {
			if (!Options.KeepExtraPEData)
				return;
			var lastOffs = GetLastFileSectionOffset();
			extraData = new DataReaderChunk(peImage.CreateReader((FileOffset)lastOffs));
			if (extraData.CreateReader().Length == 0)
				extraData = null;
		}

		uint GetLastFileSectionOffset() {
			uint rva = 0;
			foreach (var sect in origSections)
				rva = Math.Max(rva, (uint)sect.PESection.VirtualAddress + sect.PESection.SizeOfRawData);
			return (uint)peImage.ToFileOffset((RVA)(rva - 1)) + 1;
		}

		void ReuseIfPossible(PESection section, IReuseChunk chunk, RVA origRva, uint origSize, uint requiredAlignment) {
			if (origRva == 0 || origSize == 0)
				return;
			if (chunk is null)
				return;
			if (!chunk.CanReuse(origRva, origSize))
				return;
			if (((uint)origRva & (requiredAlignment - 1)) != 0)
				return;

			if (section.Remove(chunk) is null)
				throw new InvalidOperationException();
			reusedChunks.Add(new ReusedChunkInfo(chunk, origRva));
		}

		FileOffset GetNewFileOffset(RVA rva) {
			foreach (var sect in origSections) {
				var section = sect.PESection;
				if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max(section.VirtualSize, section.SizeOfRawData))
					return sect.Chunk.FileOffset + (rva - section.VirtualAddress);
			}
			return (FileOffset)rva;
		}

		long WriteFile() {
			bool entryPointIsManagedOrNoEntryPoint = GetEntryPoint(out uint entryPointToken);

			OnWriterEvent(ModuleWriterEvent.BeginWritePdb);
			WritePdbFile();
			OnWriterEvent(ModuleWriterEvent.EndWritePdb);

			metadata.OnBeforeSetOffset();
			OnWriterEvent(ModuleWriterEvent.BeginCalculateRvasAndFileOffsets);

			if (Options.OptimizeImageSize) {
				// Check if we can reuse the old MD location for the new MD.
				// If we can't reuse it, it could be due to several reasons:
				//	- TypeDefOrRef tokens weren't preserved resulting in a new #Blob heap that's bigger than the old #Blob heap
				//	- New MD was added or existing MD was modified (eg. types were renamed) by the user so it's
				//	  now bigger and doesn't fit in the old location
				//	- The original location wasn't aligned properly
				//	- The new MD is bigger because the other MD writer was slightly better at optimizing the MD.
				//	  This should be considered a bug.
				var mdDataDir = module.Metadata.ImageCor20Header.Metadata;
				metadata.SetOffset(peImage.ToFileOffset(mdDataDir.VirtualAddress), mdDataDir.VirtualAddress);
				ReuseIfPossible(textSection, metadata, mdDataDir.VirtualAddress, mdDataDir.Size, DEFAULT_METADATA_ALIGNMENT);

				var resourceDataDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[2];
				if (win32Resources is not null && resourceDataDir.VirtualAddress != 0 && resourceDataDir.Size != 0) {
					var win32ResourcesOffset = peImage.ToFileOffset(resourceDataDir.VirtualAddress);
					if (win32Resources.CheckValidOffset(win32ResourcesOffset)) {
						win32Resources.SetOffset(win32ResourcesOffset, resourceDataDir.VirtualAddress);
						ReuseIfPossible(rsrcSection, win32Resources, resourceDataDir.VirtualAddress, resourceDataDir.Size, DEFAULT_WIN32_RESOURCES_ALIGNMENT);
					}
				}

				ReuseIfPossible(textSection, imageCor20Header, module.Metadata.PEImage.ImageNTHeaders.OptionalHeader.DataDirectories[14].VirtualAddress, module.Metadata.PEImage.ImageNTHeaders.OptionalHeader.DataDirectories[14].Size, DEFAULT_COR20HEADER_ALIGNMENT);
				if ((module.Metadata.ImageCor20Header.Flags & ComImageFlags.StrongNameSigned) != 0)
					ReuseIfPossible(textSection, strongNameSignature, module.Metadata.ImageCor20Header.StrongNameSignature.VirtualAddress, module.Metadata.ImageCor20Header.StrongNameSignature.Size, DEFAULT_STRONGNAMESIG_ALIGNMENT);
				ReuseIfPossible(textSection, netResources, module.Metadata.ImageCor20Header.Resources.VirtualAddress, module.Metadata.ImageCor20Header.Resources.Size, DEFAULT_NETRESOURCES_ALIGNMENT);
				if (methodBodies.ReusedAllMethodBodyLocations)
					textSection.Remove(methodBodies);

				var debugDataDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[6];
				if (debugDataDir.VirtualAddress != 0 && debugDataDir.Size != 0 && TryGetRealDebugDirectorySize(peImage, out uint realDebugDirSize))
					ReuseIfPossible(textSection, debugDirectory, debugDataDir.VirtualAddress, realDebugDirSize, DebugDirectory.DEFAULT_DEBUGDIRECTORY_ALIGNMENT);
			}

			if (constants.IsEmpty)
				textSection.Remove(constants);
			if (netResources.IsEmpty)
				textSection.Remove(netResources);
			if (textSection.IsEmpty)
				sections.Remove(textSection);
			if (rsrcSection is not null && rsrcSection.IsEmpty) {
				sections.Remove(rsrcSection);
				rsrcSection = null;
			}

			var headerSection = CreateHeaderSection(out var extraHeaderData);
			var chunks = new List<IChunk>();
			uint headerLen;
			if (extraHeaderData is not null) {
				var list = new ChunkList<IChunk>();
				list.Add(headerSection, 1);
				list.Add(extraHeaderData, 1);
				chunks.Add(list);
				headerLen = headerSection.GetVirtualSize() + extraHeaderData.GetVirtualSize();
			}
			else {
				chunks.Add(headerSection);
				headerLen = headerSection.GetVirtualSize();
			}
			foreach (var origSection in origSections)
				chunks.Add(origSection.Chunk);
			foreach (var section in sections)
				chunks.Add(section);
			if (extraData is not null)
				chunks.Add(extraData);

			CalculateRvasAndFileOffsets(chunks, 0, 0, peImage.ImageNTHeaders.OptionalHeader.FileAlignment, peImage.ImageNTHeaders.OptionalHeader.SectionAlignment);
			if (reusedChunks.Count > 0 || methodBodies.HasReusedMethods) {
				methodBodies.InitializeReusedMethodBodies(GetNewFileOffset);
				foreach (var info in reusedChunks) {
					var offset = GetNewFileOffset(info.RVA);
					info.Chunk.SetOffset(offset, info.RVA);
				}
			}
			metadata.UpdateMethodAndFieldRvas();
			foreach (var section in origSections) {
				if (section.Chunk.RVA != section.PESection.VirtualAddress)
					throw new ModuleWriterException("Invalid section RVA");
			}
			OnWriterEvent(ModuleWriterEvent.EndCalculateRvasAndFileOffsets);

			OnWriterEvent(ModuleWriterEvent.BeginWriteChunks);
			var writer = new DataWriter(destStream);
			WriteChunks(writer, chunks, 0, peImage.ImageNTHeaders.OptionalHeader.FileAlignment);
			long imageLength = writer.Position - destStreamBaseOffset;
			if (reusedChunks.Count > 0 || methodBodies.HasReusedMethods) {
				var pos = writer.Position;
				foreach (var info in reusedChunks) {
					Debug.Assert(info.Chunk.RVA == info.RVA);
					if (info.Chunk.RVA != info.RVA)
						throw new InvalidOperationException();
					writer.Position = destStreamBaseOffset + (uint)info.Chunk.FileOffset;
					info.Chunk.VerifyWriteTo(writer);
				}
				methodBodies.WriteReusedMethodBodies(writer, destStreamBaseOffset);
				writer.Position = pos;
			}
			var sectionSizes = new SectionSizes(peImage.ImageNTHeaders.OptionalHeader.FileAlignment, peImage.ImageNTHeaders.OptionalHeader.SectionAlignment, headerLen, GetSectionSizeInfos);
			UpdateHeaderFields(writer, entryPointIsManagedOrNoEntryPoint, entryPointToken, ref sectionSizes);
			OnWriterEvent(ModuleWriterEvent.EndWriteChunks);

			OnWriterEvent(ModuleWriterEvent.BeginStrongNameSign);
			if (Options.StrongNameKey is not null)
				StrongNameSign((long)strongNameSignature.FileOffset);
			OnWriterEvent(ModuleWriterEvent.EndStrongNameSign);

			OnWriterEvent(ModuleWriterEvent.BeginWritePEChecksum);
			if (Options.AddCheckSum) {
				destStream.Position = destStreamBaseOffset;
				uint newCheckSum = destStream.CalculatePECheckSum(imageLength, checkSumOffset);
				writer.Position = checkSumOffset;
				writer.WriteUInt32(newCheckSum);
			}
			OnWriterEvent(ModuleWriterEvent.EndWritePEChecksum);

			return imageLength;
		}

		static bool TryGetRealDebugDirectorySize(IPEImage peImage, out uint realSize) {
			realSize = 0;
			if (peImage.ImageDebugDirectories.Count == 0)
				return false;
			var dirs = new List<ImageDebugDirectory>(peImage.ImageDebugDirectories);
			dirs.Sort((a, b) => a.AddressOfRawData.CompareTo(b.AddressOfRawData));
			var debugDataDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[6];
			var prevEnd = (uint)debugDataDir.VirtualAddress + debugDataDir.Size;
			for (int i = 0; i < dirs.Count; i++) {
				uint prevEndAligned = (prevEnd + 3) & ~3U;
				var dir = dirs[i];
				if (dir.AddressOfRawData == 0 || dir.SizeOfData == 0)
					continue;
				if (!(prevEnd <= (uint)dir.AddressOfRawData && (uint)dir.AddressOfRawData <= prevEndAligned))
					return false;
				prevEnd = (uint)dir.AddressOfRawData + dir.SizeOfData;
			}

			realSize = prevEnd - (uint)debugDataDir.VirtualAddress;
			return true;
		}

		/// <summary>
		/// <c>true</c> if image is 64-bit
		/// </summary>
		bool Is64Bit() => peImage.ImageNTHeaders.OptionalHeader is ImageOptionalHeader64;

		Characteristics GetCharacteristics() {
			var ch = module.Characteristics;
			if (Is64Bit())
				ch &= ~Characteristics.Bit32Machine;
			else
				ch |= Characteristics.Bit32Machine;
			if (Options.IsExeFile)
				ch &= ~Characteristics.Dll;
			else
				ch |= Characteristics.Dll;
			return ch;
		}

		/// <summary>
		/// Updates the PE header and COR20 header fields that need updating. All sections are
		/// also updated, and the new ones are added.
		/// </summary>
		void UpdateHeaderFields(DataWriter writer, bool entryPointIsManagedOrNoEntryPoint, uint entryPointToken, ref SectionSizes sectionSizes) {
			long fileHeaderOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.FileHeader.StartOffset;
			long optionalHeaderOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.OptionalHeader.StartOffset;
			long sectionsOffset = destStreamBaseOffset + (long)peImage.ImageSectionHeaders[0].StartOffset;
			long dataDirOffset = destStreamBaseOffset + (long)peImage.ImageNTHeaders.OptionalHeader.EndOffset - 16 * 8;
			long cor20Offset = destStreamBaseOffset + (long)imageCor20Header.FileOffset;

			// Update PE file header
			var peOptions = Options.PEHeadersOptions;
			writer.Position = fileHeaderOffset;
			writer.WriteUInt16((ushort)(peOptions.Machine ?? module.Machine));
			writer.WriteUInt16((ushort)(origSections.Count + sections.Count));
			WriteUInt32(writer, peOptions.TimeDateStamp);
			WriteUInt32(writer, peOptions.PointerToSymbolTable);
			WriteUInt32(writer, peOptions.NumberOfSymbols);
			writer.Position += 2;    // sizeof(SizeOfOptionalHeader)
			writer.WriteUInt16((ushort)(peOptions.Characteristics ?? GetCharacteristics()));

			// Update optional header
			writer.Position = optionalHeaderOffset;
			bool is32BitOptionalHeader = peImage.ImageNTHeaders.OptionalHeader is ImageOptionalHeader32;
			if (is32BitOptionalHeader) {
				writer.Position += 2;
				WriteByte(writer, peOptions.MajorLinkerVersion);
				WriteByte(writer, peOptions.MinorLinkerVersion);
				writer.WriteUInt32(sectionSizes.SizeOfCode);
				writer.WriteUInt32(sectionSizes.SizeOfInitdData);
				writer.WriteUInt32(sectionSizes.SizeOfUninitdData);
				writer.Position += 4;	// EntryPoint
				writer.WriteUInt32(sectionSizes.BaseOfCode);
				writer.WriteUInt32(sectionSizes.BaseOfData);
				WriteUInt32(writer, peOptions.ImageBase);
				writer.Position += 8;	// SectionAlignment, FileAlignment
				WriteUInt16(writer, peOptions.MajorOperatingSystemVersion);
				WriteUInt16(writer, peOptions.MinorOperatingSystemVersion);
				WriteUInt16(writer, peOptions.MajorImageVersion);
				WriteUInt16(writer, peOptions.MinorImageVersion);
				WriteUInt16(writer, peOptions.MajorSubsystemVersion);
				WriteUInt16(writer, peOptions.MinorSubsystemVersion);
				WriteUInt32(writer, peOptions.Win32VersionValue);
				writer.WriteUInt32(sectionSizes.SizeOfImage);
				writer.WriteUInt32(sectionSizes.SizeOfHeaders);
				checkSumOffset = writer.Position;
				writer.WriteInt32(0);	// CheckSum
				WriteUInt16(writer, peOptions.Subsystem);
				WriteUInt16(writer, peOptions.DllCharacteristics);
				WriteUInt32(writer, peOptions.SizeOfStackReserve);
				WriteUInt32(writer, peOptions.SizeOfStackCommit);
				WriteUInt32(writer, peOptions.SizeOfHeapReserve);
				WriteUInt32(writer, peOptions.SizeOfHeapCommit);
				WriteUInt32(writer, peOptions.LoaderFlags);
				WriteUInt32(writer, peOptions.NumberOfRvaAndSizes);
			}
			else {
				writer.Position += 2;
				WriteByte(writer, peOptions.MajorLinkerVersion);
				WriteByte(writer, peOptions.MinorLinkerVersion);
				writer.WriteUInt32(sectionSizes.SizeOfCode);
				writer.WriteUInt32(sectionSizes.SizeOfInitdData);
				writer.WriteUInt32(sectionSizes.SizeOfUninitdData);
				writer.Position += 4;	// EntryPoint
				writer.WriteUInt32(sectionSizes.BaseOfCode);
				WriteUInt64(writer, peOptions.ImageBase);
				writer.Position += 8;	// SectionAlignment, FileAlignment
				WriteUInt16(writer, peOptions.MajorOperatingSystemVersion);
				WriteUInt16(writer, peOptions.MinorOperatingSystemVersion);
				WriteUInt16(writer, peOptions.MajorImageVersion);
				WriteUInt16(writer, peOptions.MinorImageVersion);
				WriteUInt16(writer, peOptions.MajorSubsystemVersion);
				WriteUInt16(writer, peOptions.MinorSubsystemVersion);
				WriteUInt32(writer, peOptions.Win32VersionValue);
				writer.WriteUInt32(sectionSizes.SizeOfImage);
				writer.WriteUInt32(sectionSizes.SizeOfHeaders);
				checkSumOffset = writer.Position;
				writer.WriteInt32(0);	// CheckSum
				WriteUInt16(writer, peOptions.Subsystem ?? GetSubsystem());
				WriteUInt16(writer, peOptions.DllCharacteristics ?? module.DllCharacteristics);
				WriteUInt64(writer, peOptions.SizeOfStackReserve);
				WriteUInt64(writer, peOptions.SizeOfStackCommit);
				WriteUInt64(writer, peOptions.SizeOfHeapReserve);
				WriteUInt64(writer, peOptions.SizeOfHeapCommit);
				WriteUInt32(writer, peOptions.LoaderFlags);
				WriteUInt32(writer, peOptions.NumberOfRvaAndSizes);
			}

			// Update Win32 resources data directory, if we wrote a new one
			if (win32Resources is not null) {
				writer.Position = dataDirOffset + 2 * 8;
				writer.WriteDataDirectory(win32Resources);
			}

			// Clear the security descriptor directory
			writer.Position = dataDirOffset + 4 * 8;
			writer.WriteDataDirectory(null);

			// Write a new debug directory
			writer.Position = dataDirOffset + 6 * 8;
			writer.WriteDebugDirectory(debugDirectory);

			// Write a new Metadata data directory
			writer.Position = dataDirOffset + 14 * 8;
			writer.WriteDataDirectory(imageCor20Header);

			// Update old sections, and add new sections
			writer.Position = sectionsOffset;
			foreach (var section in origSections) {
				writer.Position += 0x14;
				writer.WriteUInt32((uint)section.Chunk.FileOffset);	// PointerToRawData
				writer.Position += 0x10;
			}
			foreach (var section in sections)
				section.WriteHeaderTo(writer, peImage.ImageNTHeaders.OptionalHeader.FileAlignment, peImage.ImageNTHeaders.OptionalHeader.SectionAlignment, (uint)section.RVA);

			// Write the .NET header
			writer.Position = cor20Offset;
			writer.WriteInt32(0x48);		// cb
			WriteUInt16(writer, Options.Cor20HeaderOptions.MajorRuntimeVersion);
			WriteUInt16(writer, Options.Cor20HeaderOptions.MinorRuntimeVersion);
			writer.WriteDataDirectory(metadata);
			writer.WriteUInt32((uint)GetComImageFlags(entryPointIsManagedOrNoEntryPoint));
			writer.WriteUInt32(entryPointToken);
			writer.WriteDataDirectory(netResources);
			writer.WriteDataDirectory(strongNameSignature);
			WriteDataDirectory(writer, module.Metadata.ImageCor20Header.CodeManagerTable);
			WriteDataDirectory(writer, module.Metadata.ImageCor20Header.VTableFixups);
			WriteDataDirectory(writer, module.Metadata.ImageCor20Header.ExportAddressTableJumps);
			WriteDataDirectory(writer, module.Metadata.ImageCor20Header.ManagedNativeHeader);

			UpdateVTableFixups(writer);
		}

		static void WriteDataDirectory(DataWriter writer, ImageDataDirectory dataDir) {
			writer.WriteUInt32((uint)dataDir.VirtualAddress);
			writer.WriteUInt32(dataDir.Size);
		}

		static void WriteByte(DataWriter writer, byte? value) {
			if (value is null)
				writer.Position++;
			else
				writer.WriteByte(value.Value);
		}

		static void WriteUInt16(DataWriter writer, ushort? value) {
			if (value is null)
				writer.Position += 2;
			else
				writer.WriteUInt16(value.Value);
		}

		static void WriteUInt16(DataWriter writer, Subsystem? value) {
			if (value is null)
				writer.Position += 2;
			else
				writer.WriteUInt16((ushort)value.Value);
		}

		static void WriteUInt16(DataWriter writer, DllCharacteristics? value) {
			if (value is null)
				writer.Position += 2;
			else
				writer.WriteUInt16((ushort)value.Value);
		}

		static void WriteUInt32(DataWriter writer, uint? value) {
			if (value is null)
				writer.Position += 4;
			else
				writer.WriteUInt32(value.Value);
		}

		static void WriteUInt32(DataWriter writer, ulong? value) {
			if (value is null)
				writer.Position += 4;
			else
				writer.WriteUInt32((uint)value.Value);
		}

		static void WriteUInt64(DataWriter writer, ulong? value) {
			if (value is null)
				writer.Position += 8;
			else
				writer.WriteUInt64(value.Value);
		}

		ComImageFlags GetComImageFlags(bool isManagedEntryPoint) {
			var flags = Options.Cor20HeaderOptions.Flags ?? module.Cor20HeaderFlags;
			if (Options.Cor20HeaderOptions.EntryPoint is not null)
				return flags;
			if (isManagedEntryPoint)
				return flags & ~ComImageFlags.NativeEntryPoint;
			return flags | ComImageFlags.NativeEntryPoint;
		}

		Subsystem GetSubsystem() {
			if (module.Kind == ModuleKind.Windows)
				return Subsystem.WindowsGui;
			return Subsystem.WindowsCui;
		}

		/// <summary>
		/// Converts <paramref name="rva"/> to a file offset in the destination stream
		/// </summary>
		/// <param name="rva">RVA</param>
		long ToWriterOffset(RVA rva) {
			if (rva == 0)
				return 0;
			foreach (var sect in origSections) {
				var section = sect.PESection;
				if (section.VirtualAddress <= rva && rva < section.VirtualAddress + Math.Max(section.VirtualSize, section.SizeOfRawData))
					return destStreamBaseOffset + (long)sect.Chunk.FileOffset + (rva - section.VirtualAddress);
			}
			return 0;
		}

		IEnumerable<SectionSizeInfo> GetSectionSizeInfos() {
			foreach (var section in origSections)
				yield return new SectionSizeInfo(section.Chunk.GetVirtualSize(), section.PESection.Characteristics);
			foreach (var section in sections)
				yield return new SectionSizeInfo(section.GetVirtualSize(), section.Characteristics);
		}

		void UpdateVTableFixups(DataWriter writer) {
			var vtableFixups = module.VTableFixups;
			if (vtableFixups is null || vtableFixups.VTables.Count == 0)
				return;

			writer.Position = ToWriterOffset(vtableFixups.RVA);
			if (writer.Position == 0) {
				Error("Could not convert RVA to file offset");
				return;
			}
			foreach (var vtable in vtableFixups) {
				if (vtable.Methods.Count > ushort.MaxValue)
					throw new ModuleWriterException("Too many methods in vtable");
				writer.WriteUInt32((uint)vtable.RVA);
				writer.WriteUInt16((ushort)vtable.Methods.Count);
				writer.WriteUInt16((ushort)vtable.Flags);

				long pos = writer.Position;
				writer.Position = ToWriterOffset(vtable.RVA);
				if (writer.Position == 0) {
					if (vtable.RVA != 0 || vtable.Methods.Count > 0)
						Error("Could not convert RVA to file offset");
				}
				else {
					var methods = vtable.Methods;
					int count = methods.Count;
					for (int i = 0; i < count; i++) {
						var method = methods[i];
						writer.WriteUInt32(GetMethodToken(method));
						if (vtable.Is64Bit)
							writer.WriteInt32(0);
					}
				}
				writer.Position = pos;
			}
		}

		uint GetMethodToken(IMethod method) {
			if (method is MethodDef md)
				return new MDToken(Table.Method, metadata.GetRid(md)).Raw;

			if (method is MemberRef mr)
				return new MDToken(Table.MemberRef, metadata.GetRid(mr)).Raw;

			if (method is MethodSpec ms)
				return new MDToken(Table.MethodSpec, metadata.GetRid(ms)).Raw;

			if (method is null)
				return 0;

			Error("Invalid VTable method type: {0}", method.GetType());
			return 0;
		}

		/// <summary>
		/// Gets the entry point
		/// </summary>
		/// <param name="ep">Updated with entry point (either a token or RVA of native method)</param>
		/// <returns><c>true</c> if it's a managed entry point or there's no entry point,
		/// <c>false</c> if it's a native entry point</returns>
		bool GetEntryPoint(out uint ep) {
			var tok = Options.Cor20HeaderOptions.EntryPoint;
			if (tok is not null) {
				ep = tok.Value;
				return ep == 0 || ((Options.Cor20HeaderOptions.Flags ?? 0) & ComImageFlags.NativeEntryPoint) == 0;
			}

			if (module.ManagedEntryPoint is MethodDef epMethod) {
				ep = new MDToken(Table.Method, metadata.GetRid(epMethod)).Raw;
				return true;
			}
			if (module.ManagedEntryPoint is FileDef file) {
				ep = new MDToken(Table.File, metadata.GetRid(file)).Raw;
				return true;
			}
			ep = (uint)module.NativeEntryPoint;
			return ep == 0;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// .NET resources
	/// </summary>
	public sealed class NetResources : IReuseChunk {
		readonly List<DataReaderChunk> resources = new List<DataReaderChunk>();
		readonly uint alignment;
		uint length;
		bool setOffsetCalled;
		FileOffset offset;
		RVA rva;

		internal bool IsEmpty => resources.Count == 0;

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Gets offset of next resource. This offset is relative to the start of
		/// the .NET resources and is always aligned.
		/// </summary>
		public uint NextOffset => Utils.AlignUp(length, alignment);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="alignment">Alignment of all resources</param>
		public NetResources(uint alignment) => this.alignment = alignment;

		/// <summary>
		/// Adds a resource
		/// </summary>
		/// <param name="reader">The resource data</param>
		/// <returns>The resource data</returns>
		public DataReaderChunk Add(DataReader reader) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			length = NextOffset + 4 + reader.Length;
			var data = new DataReaderChunk(ref reader);
			resources.Add(data);
			return data;
		}

		bool IReuseChunk.CanReuse(RVA origRva, uint origSize) => length <= origSize;

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			setOffsetCalled = true;
			this.offset = offset;
			this.rva = rva;
			foreach (var resource in resources) {
				offset = offset.AlignUp(alignment);
				rva = rva.AlignUp(alignment);
				resource.SetOffset(offset + 4, rva + 4);
				uint len = 4 + resource.GetFileLength();
				offset += len;
				rva += len;
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() => length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			var rva2 = rva;
			foreach (var resourceData in resources) {
				int padding = (int)rva2.AlignUp(alignment) - (int)rva2;
				writer.WriteZeroes(padding);
				rva2 += (uint)padding;
				writer.WriteUInt32(resourceData.GetFileLength());
				resourceData.VerifyWriteTo(writer);
				rva2 += 4 + resourceData.GetFileLength();
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Does not preserve metadata tokens
	/// </summary>
	sealed class NormalMetadata : Metadata {
		readonly Rows<TypeRef> typeRefInfos = new Rows<TypeRef>();
		readonly Rows<TypeDef> typeDefInfos = new Rows<TypeDef>();
		readonly Rows<FieldDef> fieldDefInfos = new Rows<FieldDef>();
		readonly Rows<MethodDef> methodDefInfos = new Rows<MethodDef>();
		readonly Rows<ParamDef> paramDefInfos = new Rows<ParamDef>();
		readonly Rows<MemberRef> memberRefInfos = new Rows<MemberRef>();
		readonly Rows<StandAloneSig> standAloneSigInfos = new Rows<StandAloneSig>();
		readonly Rows<EventDef> eventDefInfos = new Rows<EventDef>();
		readonly Rows<PropertyDef> propertyDefInfos = new Rows<PropertyDef>();
		readonly Rows<TypeSpec> typeSpecInfos = new Rows<TypeSpec>();
		readonly Rows<MethodSpec> methodSpecInfos = new Rows<MethodSpec>();

		protected override int NumberOfMethods => methodDefInfos.Count;

		public NormalMetadata(ModuleDef module, UniqueChunkList<ByteArrayChunk> constants, MethodBodyChunks methodBodies, NetResources netResources, MetadataOptions options, DebugMetadataKind debugKind, bool isStandaloneDebugMetadata)
			: base(module, constants, methodBodies, netResources, options, debugKind, isStandaloneDebugMetadata) {
		}

		/// <inheritdoc/>
		protected override TypeDef[] GetAllTypeDefs() {
			// All nested types must be after their enclosing type. This is exactly
			// what module.GetTypes() does.
			return module.GetTypes().ToArray();
		}

		/// <inheritdoc/>
		protected override void AllocateTypeDefRids() {
			foreach (var type in allTypeDefs) {
				if (type is null)
					continue;
				uint rid = tablesHeap.TypeDefTable.Create(new RawTypeDefRow());
				typeDefInfos.Add(type, rid);
			}
		}

		/// <inheritdoc/>
		protected override void AllocateMemberDefRids() {
			int numTypes = allTypeDefs.Length;
			int typeNum = 0;
			int notifyNum = 0;
			const int numNotifyEvents = 5;
			int notifyAfter = numTypes / numNotifyEvents;

			uint fieldListRid = 1, methodListRid = 1;
			uint eventListRid = 1, propertyListRid = 1;
			uint paramListRid = 1;
			int count;
			foreach (var type in allTypeDefs) {
				if (typeNum++ == notifyAfter && notifyNum < numNotifyEvents) {
					RaiseProgress(Writer.MetadataEvent.AllocateMemberDefRids, (double)typeNum / numTypes);
					notifyNum++;
					notifyAfter = (int)((double)numTypes / numNotifyEvents * (notifyNum + 1));
				}

				if (type is null)
					continue;
				uint typeRid = GetRid(type);
				var typeRow = tablesHeap.TypeDefTable[typeRid];
				typeRow = new RawTypeDefRow(typeRow.Flags, typeRow.Name, typeRow.Namespace, typeRow.Extends, fieldListRid, methodListRid);
				tablesHeap.TypeDefTable[typeRid] = typeRow;

				var fields = type.Fields;
				count = fields.Count;
				for (int i = 0; i < count; i++) {
					var field = fields[i];
					if (field is null)
						continue;
					uint rid = fieldListRid++;
					if (rid != tablesHeap.FieldTable.Create(new RawFieldRow()))
						throw new ModuleWriterException("Invalid field rid");
					fieldDefInfos.Add(field, rid);
				}

				var methods = type.Methods;
				count = methods.Count;
				for (int i = 0; i < count; i++) {
					var method = methods[i];
					if (method is null)
						continue;
					uint rid = methodListRid++;
					var row = new RawMethodRow(0, 0, 0, 0, 0, paramListRid);
					if (rid != tablesHeap.MethodTable.Create(row))
						throw new ModuleWriterException("Invalid method rid");
					methodDefInfos.Add(method, rid);
					foreach (var pd in Sort(method.ParamDefs)) {
						if (pd is null)
							continue;
						uint pdRid = paramListRid++;
						if (pdRid != tablesHeap.ParamTable.Create(new RawParamRow()))
							throw new ModuleWriterException("Invalid param rid");
						paramDefInfos.Add(pd, pdRid);
					}
				}

				if (!IsEmpty(type.Events)) {
					uint eventMapRid = tablesHeap.EventMapTable.Create(new RawEventMapRow(typeRid, eventListRid));
					eventMapInfos.Add(type, eventMapRid);
					var events = type.Events;
					count = events.Count;
					for (int i = 0; i < count; i++) {
						var evt = events[i];
						if (evt is null)
							continue;
						uint rid = eventListRid++;
						if (rid != tablesHeap.EventTable.Create(new RawEventRow()))
							throw new ModuleWriterException("Invalid event rid");
						eventDefInfos.Add(evt, rid);
					}
				}

				if (!IsEmpty(type.Properties)) {
					uint propertyMapRid = tablesHeap.PropertyMapTable.Create(new RawPropertyMapRow(typeRid, propertyListRid));
					propertyMapInfos.Add(type, propertyMapRid);
					var properties = type.Properties;
					count = properties.Count;
					for (int i = 0; i < count; i++) {
						var prop = properties[i];
						if (prop is null)
							continue;
						uint rid = propertyListRid++;
						if (rid != tablesHeap.PropertyTable.Create(new RawPropertyRow()))
							throw new ModuleWriterException("Invalid property rid");
						propertyDefInfos.Add(prop, rid);
					}
				}
			}
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeRef tr) {
			typeRefInfos.TryGetRid(tr, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeDef td) {
			if (typeDefInfos.TryGetRid(td, out uint rid))
				return rid;
			if (td is null)
				Error("TypeDef is null");
			else
				Error("TypeDef {0} ({1:X8}) is not defined in this module ({2}). A type was removed that is still referenced by this module.", td, td.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(FieldDef fd) {
			if (fieldDefInfos.TryGetRid(fd, out uint rid))
				return rid;
			if (fd is null)
				Error("Field is null");
			else
				Error("Field {0} ({1:X8}) is not defined in this module ({2}). A field was removed that is still referenced by this module.", fd, fd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(MethodDef md) {
			if (methodDefInfos.TryGetRid(md, out uint rid))
				return rid;
			if (md is null)
				Error("Method is null");
			else
				Error("Method {0} ({1:X8}) is not defined in this module ({2}). A method was removed that is still referenced by this module.", md, md.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(ParamDef pd) {
			if (paramDefInfos.TryGetRid(pd, out uint rid))
				return rid;
			if (pd is null)
				Error("Param is null");
			else
				Error("Param {0} ({1:X8}) is not defined in this module ({2}). A parameter was removed that is still referenced by this module.", pd, pd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(MemberRef mr) {
			memberRefInfos.TryGetRid(mr, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(StandAloneSig sas) {
			standAloneSigInfos.TryGetRid(sas, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(EventDef ed) {
			if (eventDefInfos.TryGetRid(ed, out uint rid))
				return rid;
			if (ed is null)
				Error("Event is null");
			else
				Error("Event {0} ({1:X8}) is not defined in this module ({2}). An event was removed that is still referenced by this module.", ed, ed.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(PropertyDef pd) {
			if (propertyDefInfos.TryGetRid(pd, out uint rid))
				return rid;
			if (pd is null)
				Error("Property is null");
			else
				Error("Property {0} ({1:X8}) is not defined in this module ({2}). A property was removed that is still referenced by this module.", pd, pd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeSpec ts) {
			typeSpecInfos.TryGetRid(ts, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(MethodSpec ms) {
			methodSpecInfos.TryGetRid(ms, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddTypeRef(TypeRef tr) {
			if (tr is null) {
				Error("TypeRef is null");
				return 0;
			}
			if (typeRefInfos.TryGetRid(tr, out uint rid)) {
				if (rid == 0)
					Error("TypeRef {0:X8} has an infinite ResolutionScope loop", tr.MDToken.Raw);
				return rid;
			}
			typeRefInfos.Add(tr, 0);	// Prevent inf recursion
			var row = new RawTypeRefRow(AddResolutionScope(tr.ResolutionScope),
						stringsHeap.Add(tr.Name),
						stringsHeap.Add(tr.Namespace));
			rid = tablesHeap.TypeRefTable.Add(row);
			typeRefInfos.SetRid(tr, rid);
			AddCustomAttributes(Table.TypeRef, rid, tr);
			AddCustomDebugInformationList(Table.TypeRef, rid, tr);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddTypeSpec(TypeSpec ts) {
			if (ts is null) {
				Error("TypeSpec is null");
				return 0;
			}
			if (typeSpecInfos.TryGetRid(ts, out uint rid)) {
				if (rid == 0)
					Error("TypeSpec {0:X8} has an infinite TypeSig loop", ts.MDToken.Raw);
				return rid;
			}
			typeSpecInfos.Add(ts, 0);	// Prevent inf recursion
			var row = new RawTypeSpecRow(GetSignature(ts.TypeSig, ts.ExtraData));
			rid = tablesHeap.TypeSpecTable.Add(row);
			typeSpecInfos.SetRid(ts, rid);
			AddCustomAttributes(Table.TypeSpec, rid, ts);
			AddCustomDebugInformationList(Table.TypeSpec, rid, ts);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddMemberRef(MemberRef mr) {
			if (mr is null) {
				Error("MemberRef is null");
				return 0;
			}

			if (memberRefInfos.TryGetRid(mr, out uint rid))
				return rid;
			var row = new RawMemberRefRow(AddMemberRefParent(mr.Class),
							stringsHeap.Add(mr.Name),
							GetSignature(mr.Signature));
			rid = tablesHeap.MemberRefTable.Add(row);
			memberRefInfos.Add(mr, rid);
			AddCustomAttributes(Table.MemberRef, rid, mr);
			AddCustomDebugInformationList(Table.MemberRef, rid, mr);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddStandAloneSig(StandAloneSig sas) {
			if (sas is null) {
				Error("StandAloneSig is null");
				return 0;
			}
			if (standAloneSigInfos.TryGetRid(sas, out uint rid))
				return rid;
			var row = new RawStandAloneSigRow(GetSignature(sas.Signature));
			rid = tablesHeap.StandAloneSigTable.Add(row);
			standAloneSigInfos.Add(sas, rid);
			AddCustomAttributes(Table.StandAloneSig, rid, sas);
			AddCustomDebugInformationList(Table.StandAloneSig, rid, sas);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddMethodSpec(MethodSpec ms) {
			if (ms is null) {
				Error("MethodSpec is null");
				return 0;
			}
			if (methodSpecInfos.TryGetRid(ms, out uint rid))
				return rid;
			var row = new RawMethodSpecRow(AddMethodDefOrRef(ms.Method),
						GetSignature(ms.Instantiation));
			rid = tablesHeap.MethodSpecTable.Add(row);
			methodSpecInfos.Add(ms, rid);
			AddCustomAttributes(Table.MethodSpec, rid, ms);
			AddCustomDebugInformationList(Table.MethodSpec, rid, ms);
			return rid;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #Pdb heap
	/// </summary>
	public sealed class PdbHeap : HeapBase {
		/// <inheritdoc/>
		public override string Name => "#Pdb";

		/// <summary>
		/// Gets the PDB ID. This is always 20 bytes in size.
		/// </summary>
		public byte[] PdbId => pdbId;
		readonly byte[] pdbId;

		/// <summary>
		/// Gets/sets the entry point token
		/// </summary>
		public uint EntryPoint {
			get => entryPoint;
			set => entryPoint = value;
		}
		uint entryPoint;

		/// <summary>
		/// Gets the offset of the 20-byte PDB ID
		/// </summary>
		public FileOffset PdbIdOffset => FileOffset;

		/// <summary>
		/// Gets/sets the referenced type system tables
		/// </summary>
		public ulong ReferencedTypeSystemTables {
			get {
				if (!referencedTypeSystemTablesInitd)
					throw new InvalidOperationException("ReferencedTypeSystemTables hasn't been initialized yet");
				return referencedTypeSystemTables;
			}
			set {
				if (isReadOnly)
					throw new InvalidOperationException("Size has already been calculated, can't write a new value");
				referencedTypeSystemTables = value;
				referencedTypeSystemTablesInitd = true;

				typeSystemTablesCount = 0;
				ulong l = value;
				while (l != 0) {
					if (((int)l & 1) != 0)
						typeSystemTablesCount++;
					l >>= 1;
				}
			}
		}
		ulong referencedTypeSystemTables;
		bool referencedTypeSystemTablesInitd;
		int typeSystemTablesCount;

		/// <summary>
		/// Gets the type system table rows. This table has 64 elements.
		/// </summary>
		public uint[] TypeSystemTableRows => typeSystemTableRows;
		readonly uint[] typeSystemTableRows;

		/// <summary>
		/// Constructor
		/// </summary>
		public PdbHeap() {
			pdbId = new byte[20];
			typeSystemTableRows = new uint[64];
		}

		/// <inheritdoc/>
		public override uint GetRawLength() {
			if (!referencedTypeSystemTablesInitd)
				throw new InvalidOperationException("ReferencedTypeSystemTables hasn't been initialized yet");
			return (uint)(pdbId.Length + 4 + 8 + 4 * typeSystemTablesCount);
		}

		/// <inheritdoc/>
		protected override void WriteToImpl(DataWriter writer) {
			if (!referencedTypeSystemTablesInitd)
				throw new InvalidOperationException("ReferencedTypeSystemTables hasn't been initialized yet");
			writer.WriteBytes(pdbId);
			writer.WriteUInt32(entryPoint);
			writer.WriteUInt64(referencedTypeSystemTables);
			ulong t = referencedTypeSystemTables;
			for (int i = 0; i < typeSystemTableRows.Length; i++, t >>= 1) {
				if (((int)t & 1) != 0)
					writer.WriteUInt32(typeSystemTableRows[i]);
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="PEHeaders"/> options
	/// </summary>
	public sealed class PEHeadersOptions {
		/// <summary>
		/// Default DLL characteristics
		/// </summary>
		public const DllCharacteristics DefaultDllCharacteristics = dnlib.PE.DllCharacteristics.TerminalServerAware | dnlib.PE.DllCharacteristics.NoSeh | dnlib.PE.DllCharacteristics.NxCompat | dnlib.PE.DllCharacteristics.DynamicBase;

		/// <summary>
		/// Default subsystem value
		/// </summary>
		public const Subsystem DEFAULT_SUBSYSTEM = dnlib.PE.Subsystem.WindowsGui;

		/// <summary>
		/// Default major linker version. Roslyn C# defaults to 0x30, and Roslyn VB defaults to 0x50.
		/// </summary>
		public const byte DEFAULT_MAJOR_LINKER_VERSION = 11;

		/// <summary>
		/// Default minor linker version
		/// </summary>
		public const byte DEFAULT_MINOR_LINKER_VERSION = 0;

		/// <summary>
		/// IMAGE_FILE_HEADER.Machine value
		/// </summary>
		public Machine? Machine;

		/// <summary>
		/// IMAGE_FILE_HEADER.TimeDateStamp value
		/// </summary>
		public uint? TimeDateStamp;

		/// <summary>
		/// IMAGE_FILE_HEADER.PointerToSymbolTable value
		/// </summary>
		public uint? PointerToSymbolTable;

		/// <summary>
		/// IMAGE_FILE_HEADER.NumberOfSymbols value
		/// </summary>
		public uint? NumberOfSymbols;

		/// <summary>
		/// IMAGE_FILE_HEADER.Characteristics value. <see cref="dnlib.PE.Characteristics.Dll"/> bit
		/// is ignored and set/cleared depending on whether it's a EXE or a DLL file.
		/// </summary>
		public Characteristics? Characteristics;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MajorLinkerVersion value
		/// </summary>
		public byte? MajorLinkerVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MinorLinkerVersion value
		/// </summary>
		public byte? MinorLinkerVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.ImageBase value
		/// </summary>
		public ulong? ImageBase;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SectionAlignment value
		/// </summary>
		public uint? SectionAlignment;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.FileAlignment value
		/// </summary>
		public uint? FileAlignment;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MajorOperatingSystemVersion value
		/// </summary>
		public ushort? MajorOperatingSystemVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MinorOperatingSystemVersion value
		/// </summary>
		public ushort? MinorOperatingSystemVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MajorImageVersion value
		/// </summary>
		public ushort? MajorImageVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MinorImageVersion value
		/// </summary>
		public ushort? MinorImageVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MajorSubsystemVersion value
		/// </summary>
		public ushort? MajorSubsystemVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.MinorSubsystemVersion value
		/// </summary>
		public ushort? MinorSubsystemVersion;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.Win32VersionValue value
		/// </summary>
		public uint? Win32VersionValue;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.Subsystem value
		/// </summary>
		public Subsystem? Subsystem;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.DllCharacteristics value
		/// </summary>
		public DllCharacteristics? DllCharacteristics;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SizeOfStackReserve value
		/// </summary>
		public ulong? SizeOfStackReserve;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SizeOfStackCommit value
		/// </summary>
		public ulong? SizeOfStackCommit;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SizeOfHeapReserve value
		/// </summary>
		public ulong? SizeOfHeapReserve;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.SizeOfHeapCommit value
		/// </summary>
		public ulong? SizeOfHeapCommit;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.LoaderFlags value
		/// </summary>
		public uint? LoaderFlags;

		/// <summary>
		/// IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes value
		/// </summary>
		public uint? NumberOfRvaAndSizes;

		/// <summary>
		/// Creates a new time date stamp using current time
		/// </summary>
		/// <returns>A new time date stamp</returns>
		public static uint CreateNewTimeDateStamp() => (uint)(DateTime.UtcNow - Epoch).TotalSeconds;
		static readonly DateTime Epoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
	}

	/// <summary>
	/// DOS and PE headers
	/// </summary>
	public sealed class PEHeaders : IChunk {
		IList<PESection> sections;
		readonly PEHeadersOptions options;
		FileOffset offset;
		RVA rva;
		uint length;
		readonly uint sectionAlignment;
		readonly uint fileAlignment;
		ulong imageBase;
		long startOffset;
		long checkSumOffset;
		bool isExeFile;

		// Copied from Partition II.25.2.1
		static readonly byte[] dosHeader = new byte[0x80] {
			0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00,
			0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
			0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
			0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
			0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
			0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72,
			0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
			0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E,
			0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
			0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
			0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		};

		/// <summary>
		/// Gets/sets the native entry point
		/// </summary>
		public StartupStub StartupStub { get; set; }

		/// <summary>
		/// Gets/sets the COR20 header
		/// </summary>
		public ImageCor20Header ImageCor20Header { get; set; }

		/// <summary>
		/// Gets/sets the IAT
		/// </summary>
		public ImportAddressTable ImportAddressTable { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="ImportDirectory"/>
		/// </summary>
		public ImportDirectory ImportDirectory { get; set; }

		/// <summary>
		/// Gets/sets the Win32 resources
		/// </summary>
		public Win32ResourcesChunk Win32Resources { get; set; }

		/// <summary>
		/// Gets/sets the relocation directory
		/// </summary>
		public RelocDirectory RelocDirectory { get; set; }

		/// <summary>
		/// Gets/sets the debug directory
		/// </summary>
		public DebugDirectory DebugDirectory { get; set; }

		internal IChunk ExportDirectory { get; set; }

		/// <summary>
		/// Gets the image base
		/// </summary>
		public ulong ImageBase => imageBase;

		/// <summary>
		/// Gets/sets a value indicating whether this is a EXE or a DLL file
		/// </summary>
		public bool IsExeFile {
			get => isExeFile;
			set => isExeFile = value;
		}

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Gets the section alignment
		/// </summary>
		public uint SectionAlignment => sectionAlignment;

		/// <summary>
		/// Gets the file alignment
		/// </summary>
		public uint FileAlignment => fileAlignment;

		/// <summary>
		/// Gets/sets the <see cref="PESection"/>s
		/// </summary>
		public IList<PESection> PESections {
			get => sections;
			set => sections = value;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public PEHeaders()
			: this(new PEHeadersOptions()) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="options">Options</param>
		public PEHeaders(PEHeadersOptions options) {
			this.options = options ?? new PEHeadersOptions();
			sectionAlignment = this.options.SectionAlignment ?? 0x2000;
			fileAlignment = this.options.FileAlignment ?? 0x200;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			length = (uint)dosHeader.Length;
			length += 4 + 0x14;
			length += Use32BitOptionalHeader() ? 0xE0U : 0xF0;
			length += (uint)sections.Count * 0x28;

			if (Use32BitOptionalHeader())
				imageBase = options.ImageBase ?? (IsExeFile ? 0x00400000UL : 0x10000000);
			else
				imageBase = options.ImageBase ?? (IsExeFile ? 0x0000000140000000UL : 0x0000000180000000);
		}

		int SectionsCount {
			get {
				int count = 0;
				foreach (var section in sections) {
					if (section.GetVirtualSize() != 0)
						count++;
				}
				return count;
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() => length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		IEnumerable<SectionSizeInfo> GetSectionSizeInfos() {
			foreach (var section in sections) {
				uint virtSize = section.GetVirtualSize();
				if (virtSize != 0)
					yield return new SectionSizeInfo(virtSize, section.Characteristics);
			}
		}

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			startOffset = writer.Position;

			// DOS header
			writer.WriteBytes(dosHeader);

			// PE magic
			writer.WriteInt32(0x00004550);

			// Image file header
			writer.WriteUInt16((ushort)GetMachine());
			writer.WriteUInt16((ushort)SectionsCount);
			Debug.Assert(SectionsCount == sections.Count, "One or more sections are empty! The PE file could be bigger than it should be. Empty sections should be removed.");
			writer.WriteUInt32(options.TimeDateStamp ?? PEHeadersOptions.CreateNewTimeDateStamp());
			writer.WriteUInt32(options.PointerToSymbolTable ?? 0);
			writer.WriteUInt32(options.NumberOfSymbols ?? 0);
			writer.WriteUInt16((ushort)(Use32BitOptionalHeader() ? 0xE0U : 0xF0));
			writer.WriteUInt16((ushort)GetCharacteristics());

			var sectionSizes = new SectionSizes(fileAlignment, sectionAlignment, length, () => GetSectionSizeInfos());

			// Image optional header
			uint ep = StartupStub is null || !StartupStub.Enable ? 0 : (uint)StartupStub.EntryPointRVA;
			if (Use32BitOptionalHeader()) {
				writer.WriteUInt16((ushort)0x010B);
				writer.WriteByte(options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);
				writer.WriteByte(options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);
				writer.WriteUInt32(sectionSizes.SizeOfCode);
				writer.WriteUInt32(sectionSizes.SizeOfInitdData);
				writer.WriteUInt32(sectionSizes.SizeOfUninitdData);
				writer.WriteUInt32(ep);
				writer.WriteUInt32(sectionSizes.BaseOfCode);
				writer.WriteUInt32(sectionSizes.BaseOfData);
				writer.WriteUInt32((uint)imageBase);
				writer.WriteUInt32(sectionAlignment);
				writer.WriteUInt32(fileAlignment);
				writer.WriteUInt16(options.MajorOperatingSystemVersion ?? 4);
				writer.WriteUInt16(options.MinorOperatingSystemVersion ?? 0);
				writer.WriteUInt16(options.MajorImageVersion ?? 0);
				writer.WriteUInt16(options.MinorImageVersion ?? 0);
				writer.WriteUInt16(options.MajorSubsystemVersion ?? 4);
				writer.WriteUInt16(options.MinorSubsystemVersion ?? 0);
				writer.WriteUInt32(options.Win32VersionValue ?? 0);
				writer.WriteUInt32(sectionSizes.SizeOfImage);
				writer.WriteUInt32(sectionSizes.SizeOfHeaders);
				checkSumOffset = writer.Position;
				writer.WriteInt32(0);	// CheckSum
				writer.WriteUInt16((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));
				writer.WriteUInt16((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));
				writer.WriteUInt32((uint)(options.SizeOfStackReserve ?? 0x00100000));
				writer.WriteUInt32((uint)(options.SizeOfStackCommit ?? 0x00001000));
				writer.WriteUInt32((uint)(options.SizeOfHeapReserve ?? 0x00100000));
				writer.WriteUInt32((uint)(options.SizeOfHeapCommit ?? 0x00001000));
				writer.WriteUInt32(options.LoaderFlags ?? 0x00000000);
				writer.WriteUInt32(options.NumberOfRvaAndSizes ?? 0x00000010);
			}
			else {
				writer.WriteUInt16((ushort)0x020B);
				writer.WriteByte(options.MajorLinkerVersion ?? PEHeadersOptions.DEFAULT_MAJOR_LINKER_VERSION);
				writer.WriteByte(options.MinorLinkerVersion ?? PEHeadersOptions.DEFAULT_MINOR_LINKER_VERSION);
				writer.WriteUInt32(sectionSizes.SizeOfCode);
				writer.WriteUInt32(sectionSizes.SizeOfInitdData);
				writer.WriteUInt32(sectionSizes.SizeOfUninitdData);
				writer.WriteUInt32(ep);
				writer.WriteUInt32(sectionSizes.BaseOfCode);
				writer.WriteUInt64(imageBase);
				writer.WriteUInt32(sectionAlignment);
				writer.WriteUInt32(fileAlignment);
				writer.WriteUInt16(options.MajorOperatingSystemVersion ?? 4);
				writer.WriteUInt16(options.MinorOperatingSystemVersion ?? 0);
				writer.WriteUInt16(options.MajorImageVersion ?? 0);
				writer.WriteUInt16(options.MinorImageVersion ?? 0);
				writer.WriteUInt16(options.MajorSubsystemVersion ?? 4);
				writer.WriteUInt16(options.MinorSubsystemVersion ?? 0);
				writer.WriteUInt32(options.Win32VersionValue ?? 0);
				writer.WriteUInt32(sectionSizes.SizeOfImage);
				writer.WriteUInt32(sectionSizes.SizeOfHeaders);
				checkSumOffset = writer.Position;
				writer.WriteInt32(0);	// CheckSum
				writer.WriteUInt16((ushort)(options.Subsystem ?? PEHeadersOptions.DEFAULT_SUBSYSTEM));
				writer.WriteUInt16((ushort)(options.DllCharacteristics ?? PEHeadersOptions.DefaultDllCharacteristics));
				writer.WriteUInt64(options.SizeOfStackReserve ?? 0x0000000000400000);
				writer.WriteUInt64(options.SizeOfStackCommit ?? 0x0000000000004000);
				writer.WriteUInt64(options.SizeOfHeapReserve ?? 0x0000000000100000);
				writer.WriteUInt64(options.SizeOfHeapCommit ?? 0x0000000000002000);
				writer.WriteUInt32(options.LoaderFlags ?? 0x00000000);
				writer.WriteUInt32(options.NumberOfRvaAndSizes ?? 0x00000010);
			}

			writer.WriteDataDirectory(ExportDirectory);
			writer.WriteDataDirectory(ImportDirectory);
			writer.WriteDataDirectory(Win32Resources);
			writer.WriteDataDirectory(null);	// Exception table
			writer.WriteDataDirectory(null);	// Certificate table
			writer.WriteDataDirectory(RelocDirectory);
			writer.WriteDebugDirectory(DebugDirectory);
			writer.WriteDataDirectory(null);	// Architecture-specific data
			writer.WriteDataDirectory(null);	// Global pointer register RVA
			writer.WriteDataDirectory(null);	// Thread local storage
			writer.WriteDataDirectory(null);	// Load configuration table
			writer.WriteDataDirectory(null);	// Bound import table
			writer.WriteDataDirectory(ImportAddressTable);
			writer.WriteDataDirectory(null);	// Delay import descriptor
			writer.WriteDataDirectory(ImageCor20Header);
			writer.WriteDataDirectory(null);	// Reserved

			// Sections
			uint rva = Utils.AlignUp(sectionSizes.SizeOfHeaders, sectionAlignment);
			int emptySections = 0;
			foreach (var section in sections) {
				if (section.GetVirtualSize() != 0)
					rva += section.WriteHeaderTo(writer, fileAlignment, sectionAlignment, rva);
				else
					emptySections++;
			}
			if (emptySections != 0)
				writer.Position += emptySections * 0x28;
		}

		/// <summary>
		/// Calculates the PE checksum and writes it to the checksum field
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="length">Length of PE file</param>
		public void WriteCheckSum(DataWriter writer, long length) {
			writer.Position = startOffset;
			uint checkSum = writer.InternalStream.CalculatePECheckSum(length, checkSumOffset);
			writer.Position = checkSumOffset;
			writer.WriteUInt32(checkSum);
		}

		Machine GetMachine() => options.Machine ?? Machine.I386;

		bool Use32BitOptionalHeader() => !GetMachine().Is64Bit();

		Characteristics GetCharacteristics() {
			var chr = options.Characteristics ?? GetDefaultCharacteristics();
			if (IsExeFile)
				chr &= ~Characteristics.Dll;
			else
				chr |= Characteristics.Dll;
			return chr;
		}

		Characteristics GetDefaultCharacteristics() {
			if (Use32BitOptionalHeader())
				return Characteristics.Bit32Machine | Characteristics.ExecutableImage;
			return Characteristics.ExecutableImage | Characteristics.LargeAddressAware;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// A PE section
	/// </summary>
	public sealed class PESection : ChunkList<IChunk> {
		string name;
		uint characteristics;

		/// <summary>
		/// Gets the name
		/// </summary>
		public string Name {
			get => name;
			set => name = value;
		}

		/// <summary>
		/// Gets the Characteristics
		/// </summary>
		public uint Characteristics {
			get => characteristics;
			set => characteristics = value;
		}

		/// <summary>
		/// <c>true</c> if this is a code section
		/// </summary>
		public bool IsCode => (characteristics & 0x20) != 0;

		/// <summary>
		/// <c>true</c> if this is an initialized data section
		/// </summary>
		public bool IsInitializedData => (characteristics & 0x40) != 0;

		/// <summary>
		/// <c>true</c> if this is an uninitialized data section
		/// </summary>
		public bool IsUninitializedData => (characteristics & 0x80) != 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Section name</param>
		/// <param name="characteristics">Section characteristics</param>
		public PESection(string name, uint characteristics) {
			this.name = name;
			this.characteristics = characteristics;
		}

		/// <summary>
		/// Writes the section header to <paramref name="writer"/> at its current position.
		/// Returns aligned virtual size (aligned to <paramref name="sectionAlignment"/>)
		/// </summary>
		/// <param name="writer">Writer</param>
		/// <param name="fileAlignment">File alignment</param>
		/// <param name="sectionAlignment">Section alignment</param>
		/// <param name="rva">Current <see cref="RVA"/></param>
		public uint WriteHeaderTo(DataWriter writer, uint fileAlignment, uint sectionAlignment, uint rva) {
			uint vs = GetVirtualSize();
			uint fileLen = GetFileLength();
			uint alignedVs = Utils.AlignUp(vs, sectionAlignment);
			uint rawSize = Utils.AlignUp(fileLen, fileAlignment);
			uint dataOffset = (uint)FileOffset;

			writer.WriteBytes(Encoding.UTF8.GetBytes(Name + "\0\0\0\0\0\0\0\0"), 0, 8);
			writer.WriteUInt32(vs);			// VirtualSize
			writer.WriteUInt32(rva);		// VirtualAddress
			writer.WriteUInt32(rawSize);	// SizeOfRawData
			writer.WriteUInt32(dataOffset);	// PointerToRawData
			writer.WriteInt32(0);			// PointerToRelocations
			writer.WriteInt32(0);			// PointerToLinenumbers
			writer.WriteUInt16(0);			// NumberOfRelocations
			writer.WriteUInt16(0);			// NumberOfLinenumbers
			writer.WriteUInt32(Characteristics);

			return alignedVs;
		}
	}
}




namespace dnlib.DotNet.Writer {
	static class PortablePdbConstants {
		// See System.Reflection.Metadata.PortablePdbVersions

		// Portable PDB version (v1.0)
		// Format version is stored in DebugDirectory.MajorVersion
		//	SRM: DefaultFormatVersion, MinFormatVersion
		public const ushort FormatVersion = 0x0100;

		// Embedded Portable PDB Blob verison (v1.0)
		// Embedded version is stored in DebugDirectory.MinorVersion
		//	SRM: MinEmbeddedVersion, DefaultEmbeddedVersion, MinUnsupportedEmbeddedVersion
		public const ushort EmbeddedVersion = 0x0100;

		// Stored in DebugDirectory.MinorVersion and indicates that it's a portable PDB file
		// and not a Windows PDB file
		public const ushort PortableCodeViewVersionMagic = 0x504D;
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Preserves metadata tokens
	/// </summary>
	sealed class PreserveTokensMetadata : Metadata {
		readonly ModuleDefMD mod;
		readonly Rows<TypeRef> typeRefInfos = new Rows<TypeRef>();
		readonly Dictionary<TypeDef, uint> typeToRid = new Dictionary<TypeDef, uint>();
		MemberDefDict<FieldDef> fieldDefInfos;
		MemberDefDict<MethodDef> methodDefInfos;
		MemberDefDict<ParamDef> paramDefInfos;
		readonly Rows<MemberRef> memberRefInfos = new Rows<MemberRef>();
		readonly Rows<StandAloneSig> standAloneSigInfos = new Rows<StandAloneSig>();
		MemberDefDict<EventDef> eventDefInfos;
		MemberDefDict<PropertyDef> propertyDefInfos;
		readonly Rows<TypeSpec> typeSpecInfos = new Rows<TypeSpec>();
		readonly Rows<MethodSpec> methodSpecInfos = new Rows<MethodSpec>();
		readonly Dictionary<uint, uint> callConvTokenToSignature = new Dictionary<uint, uint>();

		[DebuggerDisplay("{Rid} -> {NewRid} {Def}")]
		sealed class MemberDefInfo<T> where T : IMDTokenProvider {
			public readonly T Def;

			/// <summary>
			/// Its real rid
			/// </summary>
			public uint Rid;

			/// <summary>
			/// Its logical rid or real rid. If the ptr table exists (eg. MethodPtr), then it's
			/// an index into it, else it's the real rid.
			/// </summary>
			public uint NewRid;

			public MemberDefInfo(T def, uint rid) {
				Def = def;
				Rid = rid;
				NewRid = rid;
			}
		}

		[DebuggerDisplay("Count = {Count}")]
		sealed class MemberDefDict<T> where T : IMDTokenProvider {
			readonly Type defMDType;
			uint userRid = 0x01000000;
			uint newRid = 1;
			int numDefMDs;
			int numDefUsers;
			int tableSize;
			bool wasSorted;
			readonly bool preserveRids;
			readonly bool enableRidToInfo;
			readonly Dictionary<T, MemberDefInfo<T>> defToInfo = new Dictionary<T, MemberDefInfo<T>>();
			Dictionary<uint, MemberDefInfo<T>> ridToInfo;
			readonly List<MemberDefInfo<T>> defs = new List<MemberDefInfo<T>>();
			List<MemberDefInfo<T>> sortedDefs;
			readonly Dictionary<T, int> collectionPositions = new Dictionary<T, int>();

			/// <summary>
			/// Gets total number of defs in the list. It does <c>not</c> necessarily return
			/// the table size. Use <see cref="TableSize"/> for that.
			/// </summary>
			public int Count => defs.Count;

			/// <summary>
			/// Gets the number of rows that need to be created in the table
			/// </summary>
			public int TableSize => tableSize;

			/// <summary>
			/// Returns <c>true</c> if the ptr table (eg. <c>MethodPtr</c>) is needed
			/// </summary>
			public bool NeedPtrTable => preserveRids && !wasSorted;

			public MemberDefDict(Type defMDType, bool preserveRids)
				: this(defMDType, preserveRids, false) {
			}

			public MemberDefDict(Type defMDType, bool preserveRids, bool enableRidToInfo) {
				this.defMDType = defMDType;
				this.preserveRids = preserveRids;
				this.enableRidToInfo = enableRidToInfo;
			}

			public uint Rid(T def) => defToInfo[def].Rid;

			public bool TryGetRid(T def, out uint rid) {
				if (def == null || !defToInfo.TryGetValue(def, out var info)) {
					rid = 0;
					return false;
				}
				rid = info.Rid;
				return true;
			}

			/// <summary>
			/// Sorts the table
			/// </summary>
			/// <param name="comparer">Comparer</param>
			public void Sort(Comparison<MemberDefInfo<T>> comparer) {
				if (!preserveRids) {
					// It's already sorted
					sortedDefs = defs;
					return;
				}

				sortedDefs = new List<MemberDefInfo<T>>(defs);
				sortedDefs.Sort(comparer);
				wasSorted = true;
				for (int i = 0; i < sortedDefs.Count; i++) {
					var def = sortedDefs[i];
					uint newRid = (uint)i + 1;
					def.NewRid = newRid;
					if (def.Rid != newRid)
						wasSorted = false;
				}
			}

			public MemberDefInfo<T> Get(int i) => defs[i];
			public MemberDefInfo<T> GetSorted(int i) => sortedDefs[i];

			public MemberDefInfo<T> GetByRid(uint rid) {
				ridToInfo.TryGetValue(rid, out var info);
				return info;
			}

			/// <summary>
			/// Adds a def. <see cref="SortDefs()"/> must be called after adding the last def.
			/// </summary>
			/// <param name="def">The def</param>
			/// <param name="collPos">Collection position</param>
			public void Add(T def, int collPos) {
				uint rid;
				if (def.GetType() == defMDType) {
					numDefMDs++;
					rid = preserveRids ? def.Rid : newRid++;
				}
				else {
					numDefUsers++;
					rid = preserveRids ? userRid++ : newRid++;
				}

				var info = new MemberDefInfo<T>(def, rid);
				defToInfo[def] = info;
				defs.Add(info);
				collectionPositions.Add(def, collPos);
			}

			/// <summary>
			/// Must be called after <see cref="Add"/>'ing the last def
			/// </summary>
			public void SortDefs() {
				// It's already sorted if we don't preserve rids
				if (preserveRids) {
					// Sort all def MDs before user defs
					defs.Sort((a, b) => a.Rid.CompareTo(b.Rid));

					// Fix user created defs' rids
					uint newRid = numDefMDs == 0 ? 1 : defs[numDefMDs - 1].Rid + 1;
					for (int i = numDefMDs; i < defs.Count; i++)
						defs[i].Rid = newRid++;

					// Now we know total table size
					tableSize = (int)newRid - 1;
				}
				else
					tableSize = defs.Count;

				if (enableRidToInfo) {
					ridToInfo = new Dictionary<uint, MemberDefInfo<T>>(defs.Count);
					foreach (var info in defs)
						ridToInfo.Add(info.Rid, info);
				}

				if ((uint)tableSize > 0x00FFFFFF)
					throw new ModuleWriterException("Table is too big");
			}

			public int GetCollectionPosition(T def) => collectionPositions[def];
		}

		protected override int NumberOfMethods => methodDefInfos.Count;

		public PreserveTokensMetadata(ModuleDef module, UniqueChunkList<ByteArrayChunk> constants, MethodBodyChunks methodBodies, NetResources netResources, MetadataOptions options, DebugMetadataKind debugKind, bool isStandaloneDebugMetadata)
			: base(module, constants, methodBodies, netResources, options, debugKind, isStandaloneDebugMetadata) {
			mod = module as ModuleDefMD;
			if (mod is null)
				throw new ModuleWriterException("Not a ModuleDefMD");
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeRef tr) {
			typeRefInfos.TryGetRid(tr, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeDef td) {
			if (td is null) {
				Error("TypeDef is null");
				return 0;
			}
			if (typeToRid.TryGetValue(td, out uint rid))
				return rid;
			Error("TypeDef {0} ({1:X8}) is not defined in this module ({2}). A type was removed that is still referenced by this module.", td, td.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(FieldDef fd) {
			if (fieldDefInfos.TryGetRid(fd, out uint rid))
				return rid;
			if (fd is null)
				Error("Field is null");
			else
				Error("Field {0} ({1:X8}) is not defined in this module ({2}). A field was removed that is still referenced by this module.", fd, fd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(MethodDef md) {
			if (methodDefInfos.TryGetRid(md, out uint rid))
				return rid;
			if (md is null)
				Error("Method is null");
			else
				Error("Method {0} ({1:X8}) is not defined in this module ({2}). A method was removed that is still referenced by this module.", md, md.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(ParamDef pd) {
			if (paramDefInfos.TryGetRid(pd, out uint rid))
				return rid;
			if (pd is null)
				Error("Param is null");
			else
				Error("Param {0} ({1:X8}) is not defined in this module ({2}). A parameter was removed that is still referenced by this module.", pd, pd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(MemberRef mr) {
			memberRefInfos.TryGetRid(mr, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(StandAloneSig sas) {
			standAloneSigInfos.TryGetRid(sas, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(EventDef ed) {
			if (eventDefInfos.TryGetRid(ed, out uint rid))
				return rid;
			if (ed is null)
				Error("Event is null");
			else
				Error("Event {0} ({1:X8}) is not defined in this module ({2}). An event was removed that is still referenced by this module.", ed, ed.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(PropertyDef pd) {
			if (propertyDefInfos.TryGetRid(pd, out uint rid))
				return rid;
			if (pd is null)
				Error("Property is null");
			else
				Error("Property {0} ({1:X8}) is not defined in this module ({2}). A property was removed that is still referenced by this module.", pd, pd.MDToken.Raw, module);
			return 0;
		}

		/// <inheritdoc/>
		public override uint GetRid(TypeSpec ts) {
			typeSpecInfos.TryGetRid(ts, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		public override uint GetRid(MethodSpec ms) {
			methodSpecInfos.TryGetRid(ms, out uint rid);
			return rid;
		}

		/// <inheritdoc/>
		protected override void Initialize() {
			fieldDefInfos = new MemberDefDict<FieldDef>(typeof(FieldDefMD), PreserveFieldRids);
			methodDefInfos = new MemberDefDict<MethodDef>(typeof(MethodDefMD), PreserveMethodRids, true);
			paramDefInfos = new MemberDefDict<ParamDef>(typeof(ParamDefMD), PreserveParamRids);
			eventDefInfos = new MemberDefDict<EventDef>(typeof(EventDefMD), PreserveEventRids);
			propertyDefInfos = new MemberDefDict<PropertyDef>(typeof(PropertyDefMD), PreservePropertyRids);

			CreateEmptyTableRows();
		}

		/// <inheritdoc/>
		protected override TypeDef[] GetAllTypeDefs() {
			if (!PreserveTypeDefRids) {
				var types2 = module.GetTypes().ToArray();
				InitializeTypeToRid(types2);
				return types2;
			}

			var typeToIndex = new Dictionary<TypeDef, uint>();
			var types = new List<TypeDef>();
			uint index = 0;
			const uint IS_TYPEDEFMD = 0x80000000;
			const uint INDEX_BITS = 0x00FFFFFF;
			foreach (var type in module.GetTypes()) {
				if (type is null)
					continue;
				types.Add(type);
				uint val = (uint)index++;
				if (type.GetType() == typeof(TypeDefMD))
					val |= IS_TYPEDEFMD;
				typeToIndex[type] = val;
			}

			var globalType = types[0];
			types.Sort((a, b) => {
				if (a == b)
					return 0;
				// Make sure the global <Module> type is always sorted first, even if it's
				// a TypeDefUser
				if (a == globalType)
					return -1;
				if (b == globalType)
					return 1;

				// Sort all TypeDefMDs before all TypeDefUsers
				uint ai = typeToIndex[a];
				uint bi = typeToIndex[b];
				bool amd = (ai & IS_TYPEDEFMD) != 0;
				bool bmd = (bi & IS_TYPEDEFMD) != 0;
				if (amd == bmd) {	// Both are TypeDefMDs or both are TypeDefUsers
					// If TypeDefMDs, only compare rids since rids are preserved
					if (amd)
						return a.Rid.CompareTo(b.Rid);

					// If TypeDefUsers, rids aren't preserved so compare by index
					return (ai & INDEX_BITS).CompareTo(bi & INDEX_BITS);
				}
				if (amd)
					return -1;
				return 1;
			});

			// Some of the original types may have been removed. Create dummy types
			// so TypeDef rids can be preserved.
			var newTypes = new List<TypeDef>(types.Count);
			uint prevRid = 1;
			newTypes.Add(globalType);
			for (int i = 1; i < types.Count; i++) {
				var type = types[i];

				// TypeDefUsers were sorted last so when we reach one, we can stop
				if (type.GetType() != typeof(TypeDefMD)) {
					while (i < types.Count)
						newTypes.Add(types[i++]);
					break;
				}

				uint currRid = type.Rid;
				int extraTypes = (int)(currRid - prevRid - 1);
				if (extraTypes != 0) { // always >= 0 since currRid > prevRid
					// At least one type has been removed. Create dummy types.
					for (int j = 0; j < extraTypes; j++)
						newTypes.Add(new TypeDefUser("dummy", Guid.NewGuid().ToString("B"), module.CorLibTypes.Object.TypeDefOrRef));
				}
				newTypes.Add(type);
				prevRid = currRid;
			}

			var newTypesArray = newTypes.ToArray();
			InitializeTypeToRid(newTypesArray);
			return newTypesArray;
		}

		void InitializeTypeToRid(TypeDef[] types) {
			uint rid = 1;
			foreach (var type in types) {
				if (type is null)
					continue;
				if (typeToRid.ContainsKey(type))
					continue;
				typeToRid[type] = rid++;
			}
		}

		/// <inheritdoc/>
		protected override void AllocateTypeDefRids() {
			foreach (var type in allTypeDefs) {
				uint rid = tablesHeap.TypeDefTable.Create(new RawTypeDefRow());
				if (typeToRid[type] != rid)
					throw new ModuleWriterException("Got a different rid than expected");
			}
		}

		/// <summary>
		/// Reserves rows in <c>TypeRef</c>, <c>MemberRef</c>, <c>StandAloneSig</c>,
		/// <c>TypeSpec</c> and <c>MethodSpec</c> where we will store the original rows
		/// to make sure they get the same rid. Any user created rows will be stored at
		/// the end of each table.
		/// </summary>
		void CreateEmptyTableRows() {
			uint rows;

			if (PreserveTypeRefRids) {
				rows = mod.TablesStream.TypeRefTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.TypeRefTable.Create(new RawTypeRefRow());
			}

			if (PreserveMemberRefRids) {
				rows = mod.TablesStream.MemberRefTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.MemberRefTable.Create(new RawMemberRefRow());
			}

			if (PreserveStandAloneSigRids) {
				rows = mod.TablesStream.StandAloneSigTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.StandAloneSigTable.Create(new RawStandAloneSigRow());
			}

			if (PreserveTypeSpecRids) {
				rows = mod.TablesStream.TypeSpecTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.TypeSpecTable.Create(new RawTypeSpecRow());
			}

			if (PreserveMethodSpecRids) {
				rows = mod.TablesStream.MethodSpecTable.Rows;
				for (uint i = 0; i < rows; i++)
					tablesHeap.MethodSpecTable.Create(new RawMethodSpecRow());
			}
		}

		/// <summary>
		/// Adds any non-referenced rows that haven't been added yet but are present in
		/// the original file. If there are any non-referenced rows, it's usually a sign
		/// that an obfuscator has encrypted one or more methods or that it has added
		/// some rows it uses to decrypt something.
		/// </summary>
		void InitializeUninitializedTableRows() {
			InitializeTypeRefTableRows();
			InitializeMemberRefTableRows();
			InitializeStandAloneSigTableRows();
			InitializeTypeSpecTableRows();
			InitializeMethodSpecTableRows();
		}

		bool initdTypeRef = false;
		void InitializeTypeRefTableRows() {
			if (!PreserveTypeRefRids || initdTypeRef)
				return;
			initdTypeRef = true;

			uint rows = mod.TablesStream.TypeRefTable.Rows;
			for (uint rid = 1; rid <= rows; rid++)
				AddTypeRef(mod.ResolveTypeRef(rid));
			tablesHeap.TypeRefTable.ReAddRows();
		}

		bool initdMemberRef = false;
		void InitializeMemberRefTableRows() {
			if (!PreserveMemberRefRids || initdMemberRef)
				return;
			initdMemberRef = true;

			uint rows = mod.TablesStream.MemberRefTable.Rows;
			for (uint rid = 1; rid <= rows; rid++) {
				if (tablesHeap.MemberRefTable[rid].Class != 0)
					continue;
				AddMemberRef(mod.ResolveMemberRef(rid), true);
			}
			tablesHeap.MemberRefTable.ReAddRows();
		}

		bool initdStandAloneSig = false;
		void InitializeStandAloneSigTableRows() {
			if (!PreserveStandAloneSigRids || initdStandAloneSig)
				return;
			initdStandAloneSig = true;

			uint rows = mod.TablesStream.StandAloneSigTable.Rows;
			for (uint rid = 1; rid <= rows; rid++) {
				if (tablesHeap.StandAloneSigTable[rid].Signature != 0)
					continue;
				AddStandAloneSig(mod.ResolveStandAloneSig(rid), true);
			}
			tablesHeap.StandAloneSigTable.ReAddRows();
		}

		bool initdTypeSpec = false;
		void InitializeTypeSpecTableRows() {
			if (!PreserveTypeSpecRids || initdTypeSpec)
				return;
			initdTypeSpec = true;

			uint rows = mod.TablesStream.TypeSpecTable.Rows;
			for (uint rid = 1; rid <= rows; rid++) {
				if (tablesHeap.TypeSpecTable[rid].Signature != 0)
					continue;
				AddTypeSpec(mod.ResolveTypeSpec(rid), true);
			}
			tablesHeap.TypeSpecTable.ReAddRows();
		}

		bool initdMethodSpec = false;
		void InitializeMethodSpecTableRows() {
			if (!PreserveMethodSpecRids || initdMethodSpec)
				return;
			initdMethodSpec = true;

			uint rows = mod.TablesStream.MethodSpecTable.Rows;
			for (uint rid = 1; rid <= rows; rid++) {
				if (tablesHeap.MethodSpecTable[rid].Method != 0)
					continue;
				AddMethodSpec(mod.ResolveMethodSpec(rid), true);
			}
			tablesHeap.MethodSpecTable.ReAddRows();
		}

		/// <inheritdoc/>
		protected override void AllocateMemberDefRids() {
			FindMemberDefs();

			const int numEvents = 5;
			RaiseProgress(Writer.MetadataEvent.AllocateMemberDefRids, 0.0 / numEvents);

			for (int i = 1; i <= fieldDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.FieldTable.Create(new RawFieldRow()))
					throw new ModuleWriterException("Invalid field rid");
			}

			for (int i = 1; i <= methodDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.MethodTable.Create(new RawMethodRow()))
					throw new ModuleWriterException("Invalid method rid");
			}

			for (int i = 1; i <= paramDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.ParamTable.Create(new RawParamRow()))
					throw new ModuleWriterException("Invalid param rid");
			}

			for (int i = 1; i <= eventDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.EventTable.Create(new RawEventRow()))
					throw new ModuleWriterException("Invalid event rid");
			}

			for (int i = 1; i <= propertyDefInfos.TableSize; i++) {
				if ((uint)i != tablesHeap.PropertyTable.Create(new RawPropertyRow()))
					throw new ModuleWriterException("Invalid property rid");
			}

			SortFields();
			SortMethods();
			SortParameters();
			SortEvents();
			SortProperties();

			RaiseProgress(Writer.MetadataEvent.AllocateMemberDefRids, 1.0 / numEvents);

			if (fieldDefInfos.NeedPtrTable) {
				for (int i = 0; i < fieldDefInfos.Count; i++) {
					var info = fieldDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.FieldPtrTable.Add(new RawFieldPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid field ptr rid");
				}
				ReUseDeletedFieldRows();
			}

			if (methodDefInfos.NeedPtrTable) {
				for (int i = 0; i < methodDefInfos.Count; i++) {
					var info = methodDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.MethodPtrTable.Add(new RawMethodPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid method ptr rid");
				}
				ReUseDeletedMethodRows();
			}

			if (paramDefInfos.NeedPtrTable) {
				// NOTE: peverify does not support the ParamPtr table. It's a bug.
				for (int i = 0; i < paramDefInfos.Count; i++) {
					var info = paramDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.ParamPtrTable.Add(new RawParamPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid param ptr rid");
				}
				ReUseDeletedParamRows();
			}

			if (eventDefInfos.NeedPtrTable) {
				for (int i = 0; i < eventDefInfos.Count; i++) {
					var info = eventDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.EventPtrTable.Add(new RawEventPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid event ptr rid");
				}
			}

			if (propertyDefInfos.NeedPtrTable) {
				for (int i = 0; i < propertyDefInfos.Count; i++) {
					var info = propertyDefInfos.GetSorted(i);
					if ((uint)i + 1 != tablesHeap.PropertyPtrTable.Add(new RawPropertyPtrRow(info.Rid)))
						throw new ModuleWriterException("Invalid property ptr rid");
				}
			}

			RaiseProgress(Writer.MetadataEvent.AllocateMemberDefRids, 2.0 / numEvents);

			InitializeMethodAndFieldList();
			InitializeParamList();
			InitializeEventMap();
			InitializePropertyMap();

			RaiseProgress(Writer.MetadataEvent.AllocateMemberDefRids, 3.0 / numEvents);

			// We must re-use deleted event/property rows after we've initialized
			// the event/prop map tables.
			if (eventDefInfos.NeedPtrTable)
				ReUseDeletedEventRows();
			if (propertyDefInfos.NeedPtrTable)
				ReUseDeletedPropertyRows();

			RaiseProgress(Writer.MetadataEvent.AllocateMemberDefRids, 4.0 / numEvents);

			InitializeTypeRefTableRows();
			InitializeTypeSpecTableRows();
			InitializeMemberRefTableRows();
			InitializeMethodSpecTableRows();
		}

		/// <summary>
		/// Re-uses all <c>Field</c> rows which aren't owned by any type due to the fields
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>FieldPtr</c> and <c>Field</c> tables must be the same size.
		/// </summary>
		void ReUseDeletedFieldRows() {
			if (tablesHeap.FieldPtrTable.IsEmpty)
				return;
			if (fieldDefInfos.TableSize == tablesHeap.FieldPtrTable.Rows)
				return;

			var hasOwner = new bool[fieldDefInfos.TableSize];
			for (int i = 0; i < fieldDefInfos.Count; i++)
				hasOwner[(int)fieldDefInfos.Get(i).Rid - 1] = true;

			CreateDummyPtrTableType();

			uint fieldSig = GetSignature(new FieldSig(module.CorLibTypes.Byte));
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint frid = (uint)i + 1;

				var frow = new RawFieldRow((ushort)(FieldAttributes.Public | FieldAttributes.Static), stringsHeap.Add($"f{frid:X6}"), fieldSig);
				tablesHeap.FieldTable[frid] = frow;
				tablesHeap.FieldPtrTable.Create(new RawFieldPtrRow(frid));
			}

			if (fieldDefInfos.TableSize != tablesHeap.FieldPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy fields");
		}

		/// <summary>
		/// Re-uses all <c>Method</c> rows which aren't owned by any type due to the methods
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>MethodPtr</c> and <c>Method</c> tables must be the same size.
		/// </summary>
		void ReUseDeletedMethodRows() {
			if (tablesHeap.MethodPtrTable.IsEmpty)
				return;
			if (methodDefInfos.TableSize == tablesHeap.MethodPtrTable.Rows)
				return;

			var hasOwner = new bool[methodDefInfos.TableSize];
			for (int i = 0; i < methodDefInfos.Count; i++)
				hasOwner[(int)methodDefInfos.Get(i).Rid - 1] = true;

			CreateDummyPtrTableType();

			uint methodSig = GetSignature(MethodSig.CreateInstance(module.CorLibTypes.Void));
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint mrid = (uint)i + 1;

				var mrow = new RawMethodRow(0, (ushort)(MethodImplAttributes.IL | MethodImplAttributes.Managed),
					(ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract),
					stringsHeap.Add($"m{mrid:X6}"), methodSig, (uint)paramDefInfos.Count);
				tablesHeap.MethodTable[mrid] = mrow;
				tablesHeap.MethodPtrTable.Create(new RawMethodPtrRow(mrid));
			}

			if (methodDefInfos.TableSize != tablesHeap.MethodPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy methods");
		}

		/// <summary>
		/// Re-uses all <c>Param</c> rows which aren't owned by any type due to the params
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>ParamPtr</c> and <c>Param</c> tables must be the same size.
		/// This method must be called after <see cref="ReUseDeletedMethodRows()"/> since
		/// this method will create more methods at the end of the <c>Method</c> table.
		/// </summary>
		void ReUseDeletedParamRows() {
			if (tablesHeap.ParamPtrTable.IsEmpty)
				return;
			if (paramDefInfos.TableSize == tablesHeap.ParamPtrTable.Rows)
				return;

			var hasOwner = new bool[paramDefInfos.TableSize];
			for (int i = 0; i < paramDefInfos.Count; i++)
				hasOwner[(int)paramDefInfos.Get(i).Rid - 1] = true;

			CreateDummyPtrTableType();

			// For each param, attach it to a new method. Another alternative would be to create
			// one (or a few) methods with tons of parameters.
			uint methodSig = GetSignature(MethodSig.CreateInstance(module.CorLibTypes.Void));
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint prid = (uint)i + 1;

				var prow = new RawParamRow(0, 0, stringsHeap.Add($"p{prid:X6}"));
				tablesHeap.ParamTable[prid] = prow;
				uint ptrRid = tablesHeap.ParamPtrTable.Create(new RawParamPtrRow(prid));

				var mrow = new RawMethodRow(0,
					(ushort)(MethodImplAttributes.IL | MethodImplAttributes.Managed),
					(ushort)(MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Abstract),
					stringsHeap.Add($"mp{prid:X6}"),
					methodSig,
					ptrRid);
				uint mrid = tablesHeap.MethodTable.Create(mrow);
				if (tablesHeap.MethodPtrTable.Rows > 0)
					tablesHeap.MethodPtrTable.Create(new RawMethodPtrRow(mrid));
			}

			if (paramDefInfos.TableSize != tablesHeap.ParamPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy params");
		}

		/// <summary>
		/// Re-uses all <c>Event</c> rows which aren't owned by any type due to the events
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>EventPtr</c> and <c>Event</c> tables must be the same size.
		/// </summary>
		void ReUseDeletedEventRows() {
			if (tablesHeap.EventPtrTable.IsEmpty)
				return;
			if (eventDefInfos.TableSize == tablesHeap.EventPtrTable.Rows)
				return;

			var hasOwner = new bool[eventDefInfos.TableSize];
			for (int i = 0; i < eventDefInfos.Count; i++)
				hasOwner[(int)eventDefInfos.Get(i).Rid - 1] = true;

			uint typeRid = CreateDummyPtrTableType();
			tablesHeap.EventMapTable.Create(new RawEventMapRow(typeRid, (uint)tablesHeap.EventPtrTable.Rows + 1));

			uint eventType = AddTypeDefOrRef(module.CorLibTypes.Object.TypeDefOrRef);
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint erid = (uint)i + 1;

				var frow = new RawEventRow(0, stringsHeap.Add($"E{erid:X6}"), eventType);
				tablesHeap.EventTable[erid] = frow;
				tablesHeap.EventPtrTable.Create(new RawEventPtrRow(erid));
			}

			if (eventDefInfos.TableSize != tablesHeap.EventPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy events");
		}

		/// <summary>
		/// Re-uses all <c>Property</c> rows which aren't owned by any type due to the properties
		/// having been deleted by the user. The reason we must do this is that the
		/// <c>PropertyPtr</c> and <c>Property</c> tables must be the same size.
		/// </summary>
		void ReUseDeletedPropertyRows() {
			if (tablesHeap.PropertyPtrTable.IsEmpty)
				return;
			if (propertyDefInfos.TableSize == tablesHeap.PropertyPtrTable.Rows)
				return;

			var hasOwner = new bool[propertyDefInfos.TableSize];
			for (int i = 0; i < propertyDefInfos.Count; i++)
				hasOwner[(int)propertyDefInfos.Get(i).Rid - 1] = true;

			uint typeRid = CreateDummyPtrTableType();
			tablesHeap.PropertyMapTable.Create(new RawPropertyMapRow(typeRid, (uint)tablesHeap.PropertyPtrTable.Rows + 1));

			uint propertySig = GetSignature(PropertySig.CreateStatic(module.CorLibTypes.Object));
			for (int i = 0; i < hasOwner.Length; i++) {
				if (hasOwner[i])
					continue;
				uint prid = (uint)i + 1;

				var frow = new RawPropertyRow(0, stringsHeap.Add($"P{prid:X6}"), propertySig);
				tablesHeap.PropertyTable[prid] = frow;
				tablesHeap.PropertyPtrTable.Create(new RawPropertyPtrRow(prid));
			}

			if (propertyDefInfos.TableSize != tablesHeap.PropertyPtrTable.Rows)
				throw new ModuleWriterException("Didn't create all dummy properties");
		}

		/// <summary>
		/// Creates a dummy <c>TypeDef</c> at the end of the <c>TypeDef</c> table that will own
		/// dummy methods and fields. These dummy methods and fields are only created if the size
		/// of the ptr table is less than the size of the non-ptr table (eg. size MethodPtr table
		/// is less than size Method table). The only reason the ptr table would be smaller than
		/// the non-ptr table is when some field/method has been deleted and we must preserve
		/// all method/field rids.
		/// </summary>
		uint CreateDummyPtrTableType() {
			if (dummyPtrTableTypeRid != 0)
				return dummyPtrTableTypeRid;

			var flags = TypeAttributes.NotPublic | TypeAttributes.AutoLayout |
				TypeAttributes.Class | TypeAttributes.Abstract | TypeAttributes.AnsiClass;
			int numFields = fieldDefInfos.NeedPtrTable ? fieldDefInfos.Count : fieldDefInfos.TableSize;
			int numMethods = methodDefInfos.NeedPtrTable ? methodDefInfos.Count : methodDefInfos.TableSize;
			var row = new RawTypeDefRow((uint)flags,
						stringsHeap.Add(Guid.NewGuid().ToString("B")),
						stringsHeap.Add("dummy_ptr"),
						AddTypeDefOrRef(module.CorLibTypes.Object.TypeDefOrRef),
						(uint)numFields + 1,
						(uint)numMethods + 1);
			dummyPtrTableTypeRid = tablesHeap.TypeDefTable.Create(row);
			if (dummyPtrTableTypeRid == 1)
				throw new ModuleWriterException("Dummy ptr type is the first type");
			return dummyPtrTableTypeRid;
		}
		uint dummyPtrTableTypeRid;

		void FindMemberDefs() {
			int count;
			var added = new Dictionary<object, bool>();
			int pos;
			foreach (var type in allTypeDefs) {
				if (type is null)
					continue;

				pos = 0;
				var fields = type.Fields;
				count = fields.Count;
				for (int i = 0; i < count; i++) {
					var field = fields[i];
					if (field is null)
						continue;
					fieldDefInfos.Add(field, pos++);
				}

				pos = 0;
				var methods = type.Methods;
				count = methods.Count;
				for (int i = 0; i < count; i++) {
					var method = methods[i];
					if (method is null)
						continue;
					methodDefInfos.Add(method, pos++);
				}

				pos = 0;
				var events = type.Events;
				count = events.Count;
				for (int i = 0; i < count; i++) {
					var evt = events[i];
					if (evt is null || added.ContainsKey(evt))
						continue;
					added[evt] = true;
					eventDefInfos.Add(evt, pos++);
				}

				pos = 0;
				var properties = type.Properties;
				count = properties.Count;
				for (int i = 0; i < count; i++) {
					var prop = properties[i];
					if (prop is null || added.ContainsKey(prop))
						continue;
					added[prop] = true;
					propertyDefInfos.Add(prop, pos++);
				}
			}

			fieldDefInfos.SortDefs();
			methodDefInfos.SortDefs();
			eventDefInfos.SortDefs();
			propertyDefInfos.SortDefs();

			for (int i = 0; i < methodDefInfos.Count; i++) {
				var method = methodDefInfos.Get(i).Def;
				pos = 0;
				foreach (var param in Sort(method.ParamDefs)) {
					if (param is null)
						continue;
					paramDefInfos.Add(param, pos++);
				}
			}
			paramDefInfos.SortDefs();
		}

		void SortFields() =>
			fieldDefInfos.Sort((a, b) => {
				var dta = a.Def.DeclaringType is null ? 0 : typeToRid[a.Def.DeclaringType];
				var dtb = b.Def.DeclaringType is null ? 0 : typeToRid[b.Def.DeclaringType];
				if (dta == 0 || dtb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dta != dtb)
					return dta.CompareTo(dtb);
				return fieldDefInfos.GetCollectionPosition(a.Def).CompareTo(fieldDefInfos.GetCollectionPosition(b.Def));
			});

		void SortMethods() =>
			methodDefInfos.Sort((a, b) => {
				var dta = a.Def.DeclaringType is null ? 0 : typeToRid[a.Def.DeclaringType];
				var dtb = b.Def.DeclaringType is null ? 0 : typeToRid[b.Def.DeclaringType];
				if (dta == 0 || dtb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dta != dtb)
					return dta.CompareTo(dtb);
				return methodDefInfos.GetCollectionPosition(a.Def).CompareTo(methodDefInfos.GetCollectionPosition(b.Def));
			});

		void SortParameters() =>
			paramDefInfos.Sort((a, b) => {
				var dma = a.Def.DeclaringMethod is null ? 0 : methodDefInfos.Rid(a.Def.DeclaringMethod);
				var dmb = b.Def.DeclaringMethod is null ? 0 : methodDefInfos.Rid(b.Def.DeclaringMethod);
				if (dma == 0 || dmb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dma != dmb)
					return dma.CompareTo(dmb);
				return paramDefInfos.GetCollectionPosition(a.Def).CompareTo(paramDefInfos.GetCollectionPosition(b.Def));
			});

		void SortEvents() =>
			eventDefInfos.Sort((a, b) => {
				var dta = a.Def.DeclaringType is null ? 0 : typeToRid[a.Def.DeclaringType];
				var dtb = b.Def.DeclaringType is null ? 0 : typeToRid[b.Def.DeclaringType];
				if (dta == 0 || dtb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dta != dtb)
					return dta.CompareTo(dtb);
				return eventDefInfos.GetCollectionPosition(a.Def).CompareTo(eventDefInfos.GetCollectionPosition(b.Def));
			});

		void SortProperties() =>
			propertyDefInfos.Sort((a, b) => {
				var dta = a.Def.DeclaringType is null ? 0 : typeToRid[a.Def.DeclaringType];
				var dtb = b.Def.DeclaringType is null ? 0 : typeToRid[b.Def.DeclaringType];
				if (dta == 0 || dtb == 0)
					return a.Rid.CompareTo(b.Rid);
				if (dta != dtb)
					return dta.CompareTo(dtb);
				return propertyDefInfos.GetCollectionPosition(a.Def).CompareTo(propertyDefInfos.GetCollectionPosition(b.Def));
			});

		void InitializeMethodAndFieldList() {
			uint fieldList = 1, methodList = 1;
			foreach (var type in allTypeDefs) {
				uint index = typeToRid[type];
				var typeRow = tablesHeap.TypeDefTable[index];
				typeRow = new RawTypeDefRow(typeRow.Flags, typeRow.Name, typeRow.Namespace, typeRow.Extends, fieldList, methodList);
				tablesHeap.TypeDefTable[index] = typeRow;
				fieldList += (uint)type.Fields.Count;
				methodList += (uint)type.Methods.Count;
			}
		}

		void InitializeParamList() {
			uint ridList = 1;
			for (uint methodRid = 1; methodRid <= methodDefInfos.TableSize; methodRid++) {
				var methodInfo = methodDefInfos.GetByRid(methodRid);
				var row = tablesHeap.MethodTable[methodRid];
				row = new RawMethodRow(row.RVA, row.ImplFlags, row.Flags, row.Name, row.Signature, ridList);
				tablesHeap.MethodTable[methodRid] = row;
				if (methodInfo is not null)
					ridList += (uint)methodInfo.Def.ParamDefs.Count;
			}
		}

		void InitializeEventMap() {
			if (!tablesHeap.EventMapTable.IsEmpty)
				throw new ModuleWriterException("EventMap table isn't empty");
			TypeDef type = null;
			for (int i = 0; i < eventDefInfos.Count; i++) {
				var info = eventDefInfos.GetSorted(i);
				if (type == info.Def.DeclaringType)
					continue;
				type = info.Def.DeclaringType;
				var row = new RawEventMapRow(typeToRid[type], info.NewRid);
				uint eventMapRid = tablesHeap.EventMapTable.Create(row);
				eventMapInfos.Add(type, eventMapRid);
			}
		}

		void InitializePropertyMap() {
			if (!tablesHeap.PropertyMapTable.IsEmpty)
				throw new ModuleWriterException("PropertyMap table isn't empty");
			TypeDef type = null;
			for (int i = 0; i < propertyDefInfos.Count; i++) {
				var info = propertyDefInfos.GetSorted(i);
				if (type == info.Def.DeclaringType)
					continue;
				type = info.Def.DeclaringType;
				var row = new RawPropertyMapRow(typeToRid[type], info.NewRid);
				uint propertyMapRid = tablesHeap.PropertyMapTable.Create(row);
				propertyMapInfos.Add(type, propertyMapRid);
			}
		}

		/// <inheritdoc/>
		protected override uint AddTypeRef(TypeRef tr) {
			if (tr is null) {
				Error("TypeRef is null");
				return 0;
			}
			if (typeRefInfos.TryGetRid(tr, out uint rid)) {
				if (rid == 0)
					Error("TypeRef {0:X8} has an infinite ResolutionScope loop", tr.MDToken.Raw);
				return rid;
			}
			typeRefInfos.Add(tr, 0);	// Prevent inf recursion

			bool isOld = PreserveTypeRefRids && mod.ResolveTypeRef(tr.Rid) == tr;
			var row = new RawTypeRefRow(AddResolutionScope(tr.ResolutionScope), stringsHeap.Add(tr.Name), stringsHeap.Add(tr.Namespace));
			if (isOld) {
				rid = tr.Rid;
				tablesHeap.TypeRefTable[tr.Rid] = row;
			}
			else
				rid = tablesHeap.TypeRefTable.Add(row);
			typeRefInfos.SetRid(tr, rid);
			AddCustomAttributes(Table.TypeRef, rid, tr);
			AddCustomDebugInformationList(Table.TypeRef, rid, tr);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddTypeSpec(TypeSpec ts) => AddTypeSpec(ts, false);

		uint AddTypeSpec(TypeSpec ts, bool forceIsOld) {
			if (ts is null) {
				Error("TypeSpec is null");
				return 0;
			}
			if (typeSpecInfos.TryGetRid(ts, out uint rid)) {
				if (rid == 0)
					Error("TypeSpec {0:X8} has an infinite TypeSig loop", ts.MDToken.Raw);
				return rid;
			}
			typeSpecInfos.Add(ts, 0);	// Prevent inf recursion

			bool isOld = forceIsOld || (PreserveTypeSpecRids && mod.ResolveTypeSpec(ts.Rid) == ts);
			var row = new RawTypeSpecRow(GetSignature(ts.TypeSig, ts.ExtraData));
			if (isOld) {
				rid = ts.Rid;
				tablesHeap.TypeSpecTable[ts.Rid] = row;
			}
			else
				rid = tablesHeap.TypeSpecTable.Add(row);
			typeSpecInfos.SetRid(ts, rid);
			AddCustomAttributes(Table.TypeSpec, rid, ts);
			AddCustomDebugInformationList(Table.TypeSpec, rid, ts);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddMemberRef(MemberRef mr) => AddMemberRef(mr, false);

		uint AddMemberRef(MemberRef mr, bool forceIsOld) {
			if (mr is null) {
				Error("MemberRef is null");
				return 0;
			}
			if (memberRefInfos.TryGetRid(mr, out uint rid))
				return rid;

			bool isOld = forceIsOld || (PreserveMemberRefRids && mod.ResolveMemberRef(mr.Rid) == mr);
			var row = new RawMemberRefRow(AddMemberRefParent(mr.Class), stringsHeap.Add(mr.Name), GetSignature(mr.Signature));
			if (isOld) {
				rid = mr.Rid;
				tablesHeap.MemberRefTable[mr.Rid] = row;
			}
			else
				rid = tablesHeap.MemberRefTable.Add(row);
			memberRefInfos.Add(mr, rid);
			AddCustomAttributes(Table.MemberRef, rid, mr);
			AddCustomDebugInformationList(Table.MemberRef, rid, mr);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddStandAloneSig(StandAloneSig sas) => AddStandAloneSig(sas, false);

		uint AddStandAloneSig(StandAloneSig sas, bool forceIsOld) {
			if (sas is null) {
				Error("StandAloneSig is null");
				return 0;
			}
			if (standAloneSigInfos.TryGetRid(sas, out uint rid))
				return rid;

			bool isOld = forceIsOld || (PreserveStandAloneSigRids && mod.ResolveStandAloneSig(sas.Rid) == sas);
			var row = new RawStandAloneSigRow(GetSignature(sas.Signature));
			if (isOld) {
				rid = sas.Rid;
				tablesHeap.StandAloneSigTable[sas.Rid] = row;
			}
			else
				rid = tablesHeap.StandAloneSigTable.Add(row);
			standAloneSigInfos.Add(sas, rid);
			AddCustomAttributes(Table.StandAloneSig, rid, sas);
			AddCustomDebugInformationList(Table.StandAloneSig, rid, sas);
			return rid;
		}

		/// <inheritdoc/>
		public override MDToken GetToken(IList<TypeSig> locals, uint origToken) {
			if (!PreserveStandAloneSigRids || !IsValidStandAloneSigToken(origToken))
				return base.GetToken(locals, origToken);

			uint rid = AddStandAloneSig(new LocalSig(locals, false), origToken);
			if (rid == 0)
				return base.GetToken(locals, origToken);
			return new MDToken(Table.StandAloneSig, rid);
		}

		/// <inheritdoc/>
		protected override uint AddStandAloneSig(MethodSig methodSig, uint origToken) {
			if (!PreserveStandAloneSigRids || !IsValidStandAloneSigToken(origToken))
				return base.AddStandAloneSig(methodSig, origToken);

			uint rid = AddStandAloneSig(methodSig, origToken);
			if (rid == 0)
				return base.AddStandAloneSig(methodSig, origToken);
			return rid;
		}

		/// <inheritdoc/>
		protected override uint AddStandAloneSig(FieldSig fieldSig, uint origToken) {
			if (!PreserveStandAloneSigRids || !IsValidStandAloneSigToken(origToken))
				return base.AddStandAloneSig(fieldSig, origToken);

			uint rid = AddStandAloneSig(fieldSig, origToken);
			if (rid == 0)
				return base.AddStandAloneSig(fieldSig, origToken);
			return rid;
		}

		uint AddStandAloneSig(CallingConventionSig callConvSig, uint origToken) {
			uint sig = GetSignature(callConvSig);
			if (callConvTokenToSignature.TryGetValue(origToken, out uint otherSig)) {
				if (sig == otherSig)
					return MDToken.ToRID(origToken);
				Warning("Could not preserve StandAloneSig token {0:X8}", origToken);
				return 0;
			}

			uint rid = MDToken.ToRID(origToken);
			var sas = mod.ResolveStandAloneSig(rid);
			if (standAloneSigInfos.Exists(sas)) {
				Warning("StandAloneSig {0:X8} already exists", origToken);
				return 0;
			}

			// Make sure it uses the updated sig
			var oldSig = sas.Signature;
			try {
				sas.Signature = callConvSig;
				AddStandAloneSig(sas, true);
			}
			finally {
				sas.Signature = oldSig;
			}

			callConvTokenToSignature.Add(origToken, sig);
			return MDToken.ToRID(origToken);
		}

		bool IsValidStandAloneSigToken(uint token) {
			if (MDToken.ToTable(token) != Table.StandAloneSig)
				return false;
			uint rid = MDToken.ToRID(token);
			return mod.TablesStream.StandAloneSigTable.IsValidRID(rid);
		}

		/// <inheritdoc/>
		protected override uint AddMethodSpec(MethodSpec ms) => AddMethodSpec(ms, false);

		uint AddMethodSpec(MethodSpec ms, bool forceIsOld) {
			if (ms is null) {
				Error("MethodSpec is null");
				return 0;
			}
			if (methodSpecInfos.TryGetRid(ms, out uint rid))
				return rid;

			bool isOld = forceIsOld || (PreserveMethodSpecRids && mod.ResolveMethodSpec(ms.Rid) == ms);
			var row = new RawMethodSpecRow(AddMethodDefOrRef(ms.Method), GetSignature(ms.Instantiation));
			if (isOld) {
				rid = ms.Rid;
				tablesHeap.MethodSpecTable[ms.Rid] = row;
			}
			else
				rid = tablesHeap.MethodSpecTable.Add(row);
			methodSpecInfos.Add(ms, rid);
			AddCustomAttributes(Table.MethodSpec, rid, ms);
			AddCustomDebugInformationList(Table.MethodSpec, rid, ms);
			return rid;
		}

		/// <inheritdoc/>
		protected override void BeforeSortingCustomAttributes() => InitializeUninitializedTableRows();
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Relocations directory
	/// </summary>
	public sealed class RelocDirectory : IChunk {
		readonly Machine machine;
		readonly List<RelocInfo> allRelocRvas = new List<RelocInfo>();
		readonly List<List<uint>> relocSections = new List<List<uint>>();
		bool isReadOnly;
		FileOffset offset;
		RVA rva;
		uint totalSize;

		readonly struct RelocInfo {
			public readonly IChunk Chunk;
			public readonly uint OffsetOrRva;
			public RelocInfo(IChunk chunk, uint offset) {
				Chunk = chunk;
				OffsetOrRva = offset;
			}
		}

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		internal bool NeedsRelocSection => allRelocRvas.Count != 0;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="machine">Machine</param>
		public RelocDirectory(Machine machine) => this.machine = machine;

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			isReadOnly = true;
			this.offset = offset;
			this.rva = rva;

			var allRvas = new List<uint>(allRelocRvas.Count);
			foreach (var info in allRelocRvas) {
				uint relocRva;
				if (info.Chunk is not null)
					relocRva = (uint)info.Chunk.RVA + info.OffsetOrRva;
				else
					relocRva = info.OffsetOrRva;
				allRvas.Add(relocRva);
			}
			allRvas.Sort();

			uint prevPage = uint.MaxValue;
			List<uint> pageList = null;
			foreach (var relocRva in allRvas) {
				uint page = relocRva & ~0xFFFU;
				if (page != prevPage) {
					prevPage = page;
					if (pageList is not null)
						totalSize += (uint)(8 + ((pageList.Count + 1) & ~1) * 2);
					pageList = new List<uint>();
					relocSections.Add(pageList);
				}
				pageList.Add(relocRva);
			}
			if (pageList is not null)
				totalSize += (uint)(8 + ((pageList.Count + 1) & ~1) * 2);
		}

		/// <inheritdoc/>
		public uint GetFileLength() => totalSize;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			bool is64bit = machine.Is64Bit();
			// 3 = IMAGE_REL_BASED_HIGHLOW, A = IMAGE_REL_BASED_DIR64
			uint relocType = is64bit ? 0xA000U : 0x3000;
			foreach (var pageList in relocSections) {
				writer.WriteUInt32(pageList[0] & ~0xFFFU);
				writer.WriteUInt32((uint)(8 + ((pageList.Count + 1) & ~1) * 2));
				foreach (var rva in pageList)
					writer.WriteUInt16((ushort)(relocType | (rva & 0xFFF)));
				if ((pageList.Count & 1) != 0)
					writer.WriteUInt16(0);
			}
		}

		/// <summary>
		/// Adds a relocation
		/// </summary>
		/// <param name="rva">RVA of location</param>
		public void Add(RVA rva) {
			if (isReadOnly)
				throw new InvalidOperationException("Can't add a relocation when the relocs section is read-only");
			allRelocRvas.Add(new RelocInfo(null, (uint)rva));
		}

		/// <summary>
		/// Adds a relocation
		/// </summary>
		/// <param name="chunk">Chunk or null. If it's null, <paramref name="offset"/> is the RVA</param>
		/// <param name="offset">Offset relative to the start of <paramref name="chunk"/>, or if <paramref name="chunk"/> is null, this is the RVA</param>
		public void Add(IChunk chunk, uint offset) {
			if (isReadOnly)
				throw new InvalidOperationException("Can't add a relocation when the relocs section is read-only");
			allRelocRvas.Add(new RelocInfo(chunk, offset));
		}
	}
}





namespace dnlib.DotNet.Writer {
	static class RoslynContentIdProvider {
		public static void GetContentId(byte[] hash, out Guid guid, out uint timestamp) {
			if (hash.Length < 20)
				throw new InvalidOperationException();
			var guidBytes = new byte[16];
			Array.Copy(hash, 0, guidBytes, 0, guidBytes.Length);
			guidBytes[7] = (byte)((guidBytes[7] & 0x0F) | 0x40);
			guidBytes[8] = (byte)((guidBytes[8] & 0x3F) | 0x80);
			guid = new Guid(guidBytes);
			timestamp = 0x80000000 | (uint)((hash[19] << 24) | (hash[18] << 16) | (hash[17] << 8) | hash[16]);
		}
	}
}





namespace dnlib.DotNet.Writer {
	readonly struct SectionSizeInfo {
		/// <summary>
		/// Length of section
		/// </summary>
		public readonly uint length;

		/// <summary>
		/// Section characteristics
		/// </summary>
		public readonly uint characteristics;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Length of section</param>
		/// <param name="characteristics">Section characteristics</param>
		public SectionSizeInfo(uint length, uint characteristics) {
			this.length = length;
			this.characteristics = characteristics;
		}
	}

	/// <summary>
	/// Calculates the optional header section sizes
	/// </summary>
	readonly struct SectionSizes {
		public readonly uint SizeOfHeaders;
		public readonly uint SizeOfImage;
		public readonly uint BaseOfData, BaseOfCode;
		public readonly uint SizeOfCode, SizeOfInitdData, SizeOfUninitdData;

		public static uint GetSizeOfHeaders(uint fileAlignment, uint headerLen) => Utils.AlignUp(headerLen, fileAlignment);

		public SectionSizes(uint fileAlignment, uint sectionAlignment, uint headerLen, Func<IEnumerable<SectionSizeInfo>> getSectionSizeInfos) {
			SizeOfHeaders = GetSizeOfHeaders(fileAlignment, headerLen);
			SizeOfImage = Utils.AlignUp(SizeOfHeaders, sectionAlignment);
			BaseOfData = 0;
			BaseOfCode = 0;
			SizeOfCode = 0;
			SizeOfInitdData = 0;
			SizeOfUninitdData = 0;
			foreach (var section in getSectionSizeInfos()) {
				uint sectAlignedVs = Utils.AlignUp(section.length, sectionAlignment);
				uint fileAlignedVs = Utils.AlignUp(section.length, fileAlignment);

				bool isCode = (section.characteristics & 0x20) != 0;
				bool isInitdData = (section.characteristics & 0x40) != 0;
				bool isUnInitdData = (section.characteristics & 0x80) != 0;

				if (BaseOfCode == 0 && isCode)
					BaseOfCode = SizeOfImage;
				if (BaseOfData == 0 && (isInitdData || isUnInitdData))
					BaseOfData = SizeOfImage;
				if (isCode)
					SizeOfCode += fileAlignedVs;
				if (isInitdData)
					SizeOfInitdData += fileAlignedVs;
				if (isUnInitdData)
					SizeOfUninitdData += fileAlignedVs;

				SizeOfImage += sectAlignedVs;
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	sealed class SerializerMethodContext {
		readonly Dictionary<Instruction, uint> toOffset;
		readonly IWriterError helper;
		MethodDef method;
		CilBody body;
		uint bodySize;
		bool dictInitd;

		public bool HasBody => body is not null;

		public SerializerMethodContext(IWriterError helper) {
			toOffset = new Dictionary<Instruction, uint>();
			this.helper = helper;
		}

		internal void SetBody(MethodDef method) {
			if (this.method != method) {
				toOffset.Clear();
				this.method = method;
				body = method?.Body;
				dictInitd = false;
			}
		}

		public uint GetOffset(Instruction instr) {
			if (!dictInitd) {
				Debug.Assert(body is not null);
				if (body is null)
					return 0;
				InitializeDict();
			}
			if (instr is null)
				return bodySize;
			if (toOffset.TryGetValue(instr, out uint offset))
				return offset;
			helper.Error("Couldn't find an instruction, maybe it was removed. It's still being referenced by some code or by the PDB");
			return bodySize;
		}

		public bool IsSameMethod(MethodDef method) => this.method == method;

		void InitializeDict() {
			Debug.Assert(body is not null);
			Debug.Assert(toOffset.Count == 0);
			uint offset = 0;
			var instrs = body.Instructions;
			for(int i = 0; i < instrs.Count; i++) {
				var instr = instrs[i];
				toOffset[instr] = offset;
				offset += (uint)instr.GetSize();
			}
			bodySize = offset;
			dictInitd = true;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Helps <see cref="SignatureWriter"/> map <see cref="ITypeDefOrRef"/>s to tokens
	/// </summary>
	public interface ISignatureWriterHelper : IWriterError {
		/// <summary>
		/// Returns a <c>TypeDefOrRef</c> encoded token
		/// </summary>
		/// <param name="typeDefOrRef">A <c>TypeDefOrRef</c> type</param>
		uint ToEncodedToken(ITypeDefOrRef typeDefOrRef);
	}

	/// <summary>
	/// Writes signatures
	/// </summary>
	public struct SignatureWriter : IDisposable {
		readonly ISignatureWriterHelper helper;
		RecursionCounter recursionCounter;
		readonly MemoryStream outStream;
		readonly DataWriter writer;
		readonly bool disposeStream;

		/// <summary>
		/// Write a <see cref="TypeSig"/> signature
		/// </summary>
		/// <param name="helper">Helper</param>
		/// <param name="typeSig">The type</param>
		/// <returns>The signature as a byte array</returns>
		public static byte[] Write(ISignatureWriterHelper helper, TypeSig typeSig) {
			using (var writer = new SignatureWriter(helper)) {
				writer.Write(typeSig);
				return writer.GetResult();
			}
		}

		internal static byte[] Write(ISignatureWriterHelper helper, TypeSig typeSig, DataWriterContext context) {
			using (var writer = new SignatureWriter(helper, context)) {
				writer.Write(typeSig);
				return writer.GetResult();
			}
		}

		/// <summary>
		/// Write a <see cref="CallingConventionSig"/> signature
		/// </summary>
		/// <param name="helper">Helper</param>
		/// <param name="sig">The signature</param>
		/// <returns>The signature as a byte array</returns>
		public static byte[] Write(ISignatureWriterHelper helper, CallingConventionSig sig) {
			using (var writer = new SignatureWriter(helper)) {
				writer.Write(sig);
				return writer.GetResult();
			}
		}

		internal static byte[] Write(ISignatureWriterHelper helper, CallingConventionSig sig, DataWriterContext context) {
			using (var writer = new SignatureWriter(helper, context)) {
				writer.Write(sig);
				return writer.GetResult();
			}
		}

		SignatureWriter(ISignatureWriterHelper helper) {
			this.helper = helper;
			recursionCounter = new RecursionCounter();
			outStream = new MemoryStream();
			writer = new DataWriter(outStream);
			disposeStream = true;
		}

		SignatureWriter(ISignatureWriterHelper helper, DataWriterContext context) {
			this.helper = helper;
			recursionCounter = new RecursionCounter();
			outStream = context.OutStream;
			writer = context.Writer;
			disposeStream = false;
			outStream.SetLength(0);
			outStream.Position = 0;
		}

		byte[] GetResult() => outStream.ToArray();
		uint WriteCompressedUInt32(uint value) => writer.WriteCompressedUInt32(helper, value);
		int WriteCompressedInt32(int value) => writer.WriteCompressedInt32(helper, value);

		void Write(TypeSig typeSig) {
			const ElementType DEFAULT_ELEMENT_TYPE = ElementType.Boolean;
			if (typeSig is null) {
				helper.Error("TypeSig is null");
				writer.WriteByte((byte)DEFAULT_ELEMENT_TYPE);
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				writer.WriteByte((byte)DEFAULT_ELEMENT_TYPE);
				return;
			}

			uint count;
			switch (typeSig.ElementType) {
			case ElementType.Void:
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.String:
			case ElementType.TypedByRef:
			case ElementType.I:
			case ElementType.U:
			case ElementType.Object:
			case ElementType.Sentinel:
				writer.WriteByte((byte)typeSig.ElementType);
				break;

			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.SZArray:
			case ElementType.Pinned:
				writer.WriteByte((byte)typeSig.ElementType);
				Write(typeSig.Next);
				break;

			case ElementType.ValueType:
			case ElementType.Class:
				writer.WriteByte((byte)typeSig.ElementType);
				Write(((TypeDefOrRefSig)typeSig).TypeDefOrRef);
				break;

			case ElementType.Var:
			case ElementType.MVar:
				writer.WriteByte((byte)typeSig.ElementType);
				WriteCompressedUInt32(((GenericSig)typeSig).Number);
				break;

			case ElementType.Array:
				writer.WriteByte((byte)typeSig.ElementType);
				var ary = (ArraySig)typeSig;
				Write(ary.Next);
				WriteCompressedUInt32(ary.Rank);
				if (ary.Rank == 0)
					break;
				count = WriteCompressedUInt32((uint)ary.Sizes.Count);
				for (uint i = 0; i < count; i++)
					WriteCompressedUInt32(ary.Sizes[(int)i]);
				count = WriteCompressedUInt32((uint)ary.LowerBounds.Count);
				for (uint i = 0; i < count; i++)
					WriteCompressedInt32(ary.LowerBounds[(int)i]);
				break;

			case ElementType.GenericInst:
				writer.WriteByte((byte)typeSig.ElementType);
				var gis = (GenericInstSig)typeSig;
				Write(gis.GenericType);
				count = WriteCompressedUInt32((uint)gis.GenericArguments.Count);
				for (uint i = 0; i < count; i++)
					Write(gis.GenericArguments[(int)i]);
				break;

			case ElementType.ValueArray:
				writer.WriteByte((byte)typeSig.ElementType);
				Write(typeSig.Next);
				WriteCompressedUInt32((typeSig as ValueArraySig).Size);
				break;

			case ElementType.FnPtr:
				writer.WriteByte((byte)typeSig.ElementType);
				Write((typeSig as FnPtrSig).Signature);
				break;

			case ElementType.CModReqd:
			case ElementType.CModOpt:
				writer.WriteByte((byte)typeSig.ElementType);
				Write((typeSig as ModifierSig).Modifier);
				Write(typeSig.Next);
				break;

			case ElementType.Module:
				writer.WriteByte((byte)typeSig.ElementType);
				WriteCompressedUInt32((typeSig as ModuleSig).Index);
				Write(typeSig.Next);
				break;

			case ElementType.End:
			case ElementType.R:
			case ElementType.Internal:
			default:
				helper.Error("Unknown or unsupported element type");
				writer.WriteByte((byte)DEFAULT_ELEMENT_TYPE);
				break;
			}

			recursionCounter.Decrement();
		}

		void Write(ITypeDefOrRef tdr) {
			if (tdr is null) {
				helper.Error("TypeDefOrRef is null");
				WriteCompressedUInt32(0);
				return;
			}

			uint encodedToken = helper.ToEncodedToken(tdr);
			if (encodedToken > 0x1FFFFFFF) {
				helper.Error("Encoded token doesn't fit in 29 bits");
				encodedToken = 0;
			}
			WriteCompressedUInt32(encodedToken);
		}

		void Write(CallingConventionSig sig) {
			if (sig is null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			MethodBaseSig mbs;
			FieldSig fs;
			LocalSig ls;
			GenericInstMethodSig gim;

			if ((mbs = sig as MethodBaseSig) is not null)
				Write(mbs);
			else if ((fs = sig as FieldSig) is not null)
				Write(fs);
			else if ((ls = sig as LocalSig) is not null)
				Write(ls);
			else if ((gim = sig as GenericInstMethodSig) is not null)
				Write(gim);
			else {
				helper.Error("Unknown calling convention sig");
				writer.WriteByte((byte)sig.GetCallingConvention());
			}

			recursionCounter.Decrement();
		}

		void Write(MethodBaseSig sig) {
			if (sig is null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			writer.WriteByte((byte)sig.GetCallingConvention());
			if (sig.Generic)
				WriteCompressedUInt32(sig.GenParamCount);

			uint numParams = (uint)sig.Params.Count;
			if (sig.ParamsAfterSentinel is not null)
				numParams += (uint)sig.ParamsAfterSentinel.Count;

			uint count = WriteCompressedUInt32(numParams);
			Write(sig.RetType);
			for (uint i = 0; i < count && i < (uint)sig.Params.Count; i++)
				Write(sig.Params[(int)i]);

			if (sig.ParamsAfterSentinel is not null && sig.ParamsAfterSentinel.Count > 0) {
				writer.WriteByte((byte)ElementType.Sentinel);
				for (uint i = 0, j = (uint)sig.Params.Count; i < (uint)sig.ParamsAfterSentinel.Count && j < count; i++, j++)
					Write(sig.ParamsAfterSentinel[(int)i]);
			}

			recursionCounter.Decrement();
		}

		void Write(FieldSig sig) {
			if (sig is null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			writer.WriteByte((byte)sig.GetCallingConvention());
			Write(sig.Type);

			recursionCounter.Decrement();
		}

		void Write(LocalSig sig) {
			if (sig is null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			writer.WriteByte((byte)sig.GetCallingConvention());
			uint count = WriteCompressedUInt32((uint)sig.Locals.Count);
			if (count >= 0x10000) {
				// ldloc 0xFFFF is invalid, see the ldloc documentation
				helper.Error("Too many locals, max number of locals is 65535 (0xFFFF)");
			}
			for (uint i = 0; i < count; i++)
				Write(sig.Locals[(int)i]);

			recursionCounter.Decrement();
		}

		void Write(GenericInstMethodSig sig) {
			if (sig is null) {
				helper.Error("sig is null");
				return;
			}
			if (!recursionCounter.Increment()) {
				helper.Error("Infinite recursion");
				return;
			}

			writer.WriteByte((byte)sig.GetCallingConvention());
			uint count = WriteCompressedUInt32((uint)sig.GenericArguments.Count);
			for (uint i = 0; i < count; i++)
				Write(sig.GenericArguments[(int)i]);

			recursionCounter.Decrement();
		}

		/// <inheritdoc/>
		public void Dispose() {
			if (!disposeStream)
				return;
			if (outStream is not null)
				outStream.Dispose();
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Stores the instruction that jumps to _CorExeMain/_CorDllMain
	/// </summary>
	public sealed class StartupStub : IChunk {
		const StubType stubType = StubType.EntryPoint;
		readonly RelocDirectory relocDirectory;
		readonly Machine machine;
		readonly CpuArch cpuArch;
		readonly Action<string, object[]> logError;
		FileOffset offset;
		RVA rva;

		/// <summary>
		/// Gets/sets the <see cref="ImportDirectory"/>
		/// </summary>
		public ImportDirectory ImportDirectory { get; set; }

		/// <summary>
		/// Gets/sets the <see cref="PEHeaders"/>
		/// </summary>
		public PEHeaders PEHeaders { get; set; }

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Gets the address of the JMP instruction
		/// </summary>
		public RVA EntryPointRVA => rva + (cpuArch is null ? 0 : cpuArch.GetStubCodeOffset(stubType));

		internal bool Enable { get; set; }
		internal uint Alignment => cpuArch is null ? 1 : cpuArch.GetStubAlignment(stubType);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="relocDirectory">Reloc directory</param>
		/// <param name="machine">Machine</param>
		/// <param name="logError">Error logger</param>
		internal StartupStub(RelocDirectory relocDirectory, Machine machine, Action<string, object[]> logError) {
			this.relocDirectory = relocDirectory;
			this.machine = machine;
			this.logError = logError;
			CpuArch.TryGetCpuArch(machine, out cpuArch);
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			if (!Enable)
				return;

			if (cpuArch is null) {
				logError("The module needs an unmanaged entry point but the CPU architecture isn't supported: {0} (0x{1:X4})", new object[] { machine, (ushort)machine });
				return;
			}

			cpuArch.WriteStubRelocs(stubType, relocDirectory, this, 0);
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			if (!Enable)
				return 0;
			if (cpuArch is null)
				return 0;
			return cpuArch.GetStubSize(stubType);
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			if (!Enable)
				return;
			if (cpuArch is null)
				return;
			cpuArch.WriteStub(stubType, writer, PEHeaders.ImageBase, (uint)rva, (uint)ImportDirectory.IatCorXxxMainRVA);
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #Strings heap
	/// </summary>
	public sealed class StringsHeap : HeapBase, IOffsetHeap<UTF8String> {
		readonly Dictionary<UTF8String, uint> cachedDict = new Dictionary<UTF8String, uint>(UTF8StringEqualityComparer.Instance);
		readonly List<UTF8String> cached = new List<UTF8String>();
		uint nextOffset = 1;
		byte[] originalData;
		Dictionary<uint, byte[]> userRawData;
		readonly Dictionary<UTF8String, StringsOffsetInfo> toStringsOffsetInfo = new Dictionary<UTF8String, StringsOffsetInfo>(UTF8StringEqualityComparer.Instance);
		readonly Dictionary<uint, StringsOffsetInfo> offsetIdToInfo = new Dictionary<uint, StringsOffsetInfo>();
		readonly List<StringsOffsetInfo> stringsOffsetInfos = new List<StringsOffsetInfo>();
		const uint STRINGS_ID_FLAG = 0x80000000;
		uint stringsId = STRINGS_ID_FLAG | 0;

		sealed class StringsOffsetInfo {
			public StringsOffsetInfo(UTF8String value, uint stringsId) {
				Value = value;
				StringsId = stringsId;
				Debug.Assert((stringsId & STRINGS_ID_FLAG) != 0);
			}
			public readonly UTF8String Value;
			public readonly uint StringsId;
			public uint StringsOffset;
			public override string ToString() => $"{StringsId:X8} {StringsOffset:X4} {Value.String}";
		}

		/// <inheritdoc/>
		public override string Name => "#Strings";

		/// <summary>
		/// Populates strings from an existing <see cref="StringsStream"/> (eg. to preserve
		/// string offsets)
		/// </summary>
		/// <param name="stringsStream">The #Strings stream with the original content</param>
		public void Populate(StringsStream stringsStream) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Strings when it's read-only");
			if (originalData is not null)
				throw new InvalidOperationException("Can't call method twice");
			if (nextOffset != 1)
				throw new InvalidOperationException("Add() has already been called");
			if (stringsStream is null || stringsStream.StreamLength == 0)
				return;

			var reader = stringsStream.CreateReader();
			originalData = reader.ToArray();
			nextOffset = (uint)originalData.Length;
			Populate(ref reader);
		}

		void Populate(ref DataReader reader) {
			reader.Position = 1;
			while (reader.Position < reader.Length) {
				uint offset = (uint)reader.Position;
				var bytes = reader.TryReadBytesUntil(0);
				if (bytes is null)
					break;

				reader.ReadByte();	// terminating zero
				if (bytes.Length == 0)
					continue;

				var s = new UTF8String(bytes);
				if (!cachedDict.ContainsKey(s))
					cachedDict[s] = offset;
			}
		}

		internal void AddOptimizedStringsAndSetReadOnly() {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Strings when it's read-only");
			SetReadOnly();

			stringsOffsetInfos.Sort(Comparison_StringsOffsetInfoSorter);

			StringsOffsetInfo prevInfo = null;
			foreach (var info in stringsOffsetInfos) {
				if (prevInfo is not null && EndsWith(prevInfo.Value, info.Value))
					info.StringsOffset = prevInfo.StringsOffset + (uint)(prevInfo.Value.Data.Length - info.Value.Data.Length);
				else
					info.StringsOffset = AddToCache(info.Value);
				prevInfo = info;
			}
		}

		static bool EndsWith(UTF8String s, UTF8String value) {
			var d = s.Data;
			var vd = value.Data;
			int i = d.Length - vd.Length;
			if (i < 0)
				return false;
			for (int vi = 0; vi < vd.Length; vi++) {
				if (d[i] != vd[vi])
					return false;
				i++;
			}
			return true;
		}

		static readonly Comparison<StringsOffsetInfo> Comparison_StringsOffsetInfoSorter = StringsOffsetInfoSorter;
		static int StringsOffsetInfoSorter(StringsOffsetInfo a, StringsOffsetInfo b) {
			var da = a.Value.Data;
			var db = b.Value.Data;
			int ai = da.Length - 1;
			int bi = db.Length - 1;
			int len = Math.Min(da.Length, db.Length);
			while (len > 0) {
				int c = da[ai] - db[bi];
				if (c != 0)
					return c;
				ai--;
				bi--;
				len--;
			}
			return db.Length - da.Length;
		}

		/// <summary>
		/// Adds a string to the #Strings heap. The returned value is not necessarily an offset in
		/// the #Strings heap. Call <see cref="GetOffset(uint)"/> to get the offset.
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>The offset id. This is not a #Strings offset. Call <see cref="GetOffset(uint)"/> to get the #Strings offset</returns>
		public uint Add(UTF8String s) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Strings when it's read-only");
			if (UTF8String.IsNullOrEmpty(s))
				return 0;

			if (toStringsOffsetInfo.TryGetValue(s, out var info))
				return info.StringsId;
			if (cachedDict.TryGetValue(s, out uint offset))
				return offset;

			if (Array.IndexOf(s.Data, (byte)0) >= 0)
				throw new ArgumentException("Strings in the #Strings heap can't contain NUL bytes");
			info = new StringsOffsetInfo(s, stringsId++);
			Debug.Assert(!toStringsOffsetInfo.ContainsKey(s));
			Debug.Assert(!offsetIdToInfo.ContainsKey(info.StringsId));
			toStringsOffsetInfo[s] = info;
			offsetIdToInfo[info.StringsId] = info;
			stringsOffsetInfos.Add(info);
			return info.StringsId;
		}

		/// <summary>
		/// Gets the offset of a string in the #Strings heap. This method can only be called after
		/// all strings have been added.
		/// </summary>
		/// <param name="offsetId">Offset id returned by <see cref="Add(UTF8String)"/></param>
		/// <returns></returns>
		public uint GetOffset(uint offsetId) {
			if (!isReadOnly)
				throw new ModuleWriterException("This method can only be called after all strings have been added and this heap is read-only");
			if ((offsetId & STRINGS_ID_FLAG) == 0)
				return offsetId;
			if (offsetIdToInfo.TryGetValue(offsetId, out var info)) {
				Debug.Assert(info.StringsOffset != 0);
				return info.StringsOffset;
			}
			throw new ArgumentOutOfRangeException(nameof(offsetId));
		}

		/// <summary>
		/// Adds a string to the #Strings heap, but does not re-use an existing position
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>The offset of the string in the #Strings heap</returns>
		public uint Create(UTF8String s) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Strings when it's read-only");
			if (UTF8String.IsNullOrEmpty(s))
				s = UTF8String.Empty;
			if (Array.IndexOf(s.Data, (byte)0) >= 0)
				throw new ArgumentException("Strings in the #Strings heap can't contain NUL bytes");
			return AddToCache(s);
		}

		uint AddToCache(UTF8String s) {
			uint offset;
			cached.Add(s);
			cachedDict[s] = offset = nextOffset;
			nextOffset += (uint)s.Data.Length + 1;
			return offset;
		}

		/// <inheritdoc/>
		public override uint GetRawLength() => nextOffset;

		/// <inheritdoc/>
		protected override void WriteToImpl(DataWriter writer) {
			if (originalData is not null)
				writer.WriteBytes(originalData);
			else
				writer.WriteByte(0);

			uint offset = originalData is not null ? (uint)originalData.Length : 1;
			foreach (var s in cached) {
				if (userRawData is not null && userRawData.TryGetValue(offset, out var rawData)) {
					if (rawData.Length != s.Data.Length + 1)
						throw new InvalidOperationException("Invalid length of raw data");
					writer.WriteBytes(rawData);
				}
				else {
					writer.WriteBytes(s.Data);
					writer.WriteByte(0);
				}
				offset += (uint)s.Data.Length + 1;
			}
		}

		/// <inheritdoc/>
		public int GetRawDataSize(UTF8String data) => data.Data.Length + 1;

		/// <inheritdoc/>
		public void SetRawData(uint offset, byte[] rawData) {
			if (userRawData is null)
				userRawData = new Dictionary<uint, byte[]>();
			userRawData[offset] = rawData ?? throw new ArgumentNullException(nameof(rawData));
		}

		/// <inheritdoc/>
		public IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData() {
			uint offset = originalData is not null ? (uint)originalData.Length : 1;
			foreach (var s in cached) {
				var rawData = new byte[s.Data.Length + 1];
				Array.Copy(s.Data, rawData, s.Data.Length);
				yield return new KeyValuePair<uint, byte[]>(offset, rawData);
				offset += (uint)rawData.Length;
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Strong name signature chunk
	/// </summary>
	public sealed class StrongNameSignature : IReuseChunk {
		FileOffset offset;
		RVA rva;
		int size;

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="size">Size of strong name signature</param>
		public StrongNameSignature(int size) => this.size = size;

		bool IReuseChunk.CanReuse(RVA origRva, uint origSize) => (uint)size <= origSize;

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;
		}

		/// <inheritdoc/>
		public uint GetFileLength() => (uint)size;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) => writer.WriteZeroes(size);
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// <see cref="TablesHeap"/> options
	/// </summary>
	public sealed class TablesHeapOptions {
		/// <summary>
		/// Should be 0
		/// </summary>
		public uint? Reserved1;

		/// <summary>
		/// Major version number. Default is 2. Valid versions are v1.0 (no generics),
		/// v1.1 (generics are supported), or v2.0 (recommended).
		/// </summary>
		public byte? MajorVersion;

		/// <summary>
		/// Minor version number. Default is 0.
		/// </summary>
		public byte? MinorVersion;

		/// <summary>
		/// Force #- or #~ stream. Default value is <c>null</c> and recommended because the correct
		/// tables stream will be used. <c>true</c> will force <c>#-</c> (Edit N' Continue)
		/// stream, and <c>false</c> will force <c>#~</c> (normal compressed) stream.
		/// </summary>
		public bool? UseENC;

		/// <summary>
		/// All columns that can be 2 or 4 bytes are forced to be 4 bytes.
		/// Set this to <c>true</c> if you add a <c>#JTD</c> heap and (if CLR) a <c>#-</c> tables heap is used
		/// or (if Mono/Unity) a <c>#~</c> or <c>#-</c> tables heap is used.
		/// dnlib won't try to auto detect this from your added heaps since the CLR/CoreCLR vs Mono/Unity behavior
		/// is a little bit different. You may need to set <see cref="UseENC"/> to <c>true</c> if you target CLR/CoreCLR.
		/// </summary>
		public bool? ForceBigColumns;

		/// <summary>
		/// Extra data to write
		/// </summary>
		public uint? ExtraData;

		/// <summary>
		/// Log2Rid to write
		/// </summary>
		public byte? Log2Rid;

		/// <summary>
		/// <c>true</c> if there are deleted <see cref="TypeDef"/>s, <see cref="ExportedType"/>s,
		/// <see cref="FieldDef"/>s, <see cref="MethodDef"/>s, <see cref="EventDef"/>s and/or
		/// <see cref="PropertyDef"/>s.
		/// </summary>
		public bool? HasDeletedRows;

		/// <summary>
		/// Creates portable PDB v1.0 options
		/// </summary>
		/// <returns></returns>
		public static TablesHeapOptions CreatePortablePdbV1_0() =>
			new TablesHeapOptions {
				Reserved1 = 0,
				MajorVersion = 2,
				MinorVersion = 0,
				UseENC = null,
				ExtraData = null,
				Log2Rid = null,
				HasDeletedRows = null,
			};
	}

	/// <summary>
	/// Contains all .NET tables
	/// </summary>
	public sealed class TablesHeap : IHeap {
		uint length;
		byte majorVersion;
		byte minorVersion;
		bool bigStrings;
		bool bigGuid;
		bool bigBlob;
		bool hasDeletedRows;
		readonly Metadata metadata;
		readonly TablesHeapOptions options;
		FileOffset offset;
		RVA rva;

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

#pragma warning disable 1591	// XML doc comment
		public readonly MDTable<RawModuleRow> ModuleTable = new MDTable<RawModuleRow>(Table.Module, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawTypeRefRow> TypeRefTable = new MDTable<RawTypeRefRow>(Table.TypeRef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawTypeDefRow> TypeDefTable = new MDTable<RawTypeDefRow>(Table.TypeDef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldPtrRow> FieldPtrTable = new MDTable<RawFieldPtrRow>(Table.FieldPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldRow> FieldTable = new MDTable<RawFieldRow>(Table.Field, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodPtrRow> MethodPtrTable = new MDTable<RawMethodPtrRow>(Table.MethodPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodRow> MethodTable = new MDTable<RawMethodRow>(Table.Method, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawParamPtrRow> ParamPtrTable = new MDTable<RawParamPtrRow>(Table.ParamPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawParamRow> ParamTable = new MDTable<RawParamRow>(Table.Param, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawInterfaceImplRow> InterfaceImplTable = new MDTable<RawInterfaceImplRow>(Table.InterfaceImpl, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMemberRefRow> MemberRefTable = new MDTable<RawMemberRefRow>(Table.MemberRef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawConstantRow> ConstantTable = new MDTable<RawConstantRow>(Table.Constant, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawCustomAttributeRow> CustomAttributeTable = new MDTable<RawCustomAttributeRow>(Table.CustomAttribute, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldMarshalRow> FieldMarshalTable = new MDTable<RawFieldMarshalRow>(Table.FieldMarshal, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawDeclSecurityRow> DeclSecurityTable = new MDTable<RawDeclSecurityRow>(Table.DeclSecurity, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawClassLayoutRow> ClassLayoutTable = new MDTable<RawClassLayoutRow>(Table.ClassLayout, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldLayoutRow> FieldLayoutTable = new MDTable<RawFieldLayoutRow>(Table.FieldLayout, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawStandAloneSigRow> StandAloneSigTable = new MDTable<RawStandAloneSigRow>(Table.StandAloneSig, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawEventMapRow> EventMapTable = new MDTable<RawEventMapRow>(Table.EventMap, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawEventPtrRow> EventPtrTable = new MDTable<RawEventPtrRow>(Table.EventPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawEventRow> EventTable = new MDTable<RawEventRow>(Table.Event, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawPropertyMapRow> PropertyMapTable = new MDTable<RawPropertyMapRow>(Table.PropertyMap, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawPropertyPtrRow> PropertyPtrTable = new MDTable<RawPropertyPtrRow>(Table.PropertyPtr, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawPropertyRow> PropertyTable = new MDTable<RawPropertyRow>(Table.Property, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodSemanticsRow> MethodSemanticsTable = new MDTable<RawMethodSemanticsRow>(Table.MethodSemantics, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodImplRow> MethodImplTable = new MDTable<RawMethodImplRow>(Table.MethodImpl, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawModuleRefRow> ModuleRefTable = new MDTable<RawModuleRefRow>(Table.ModuleRef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawTypeSpecRow> TypeSpecTable = new MDTable<RawTypeSpecRow>(Table.TypeSpec, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawImplMapRow> ImplMapTable = new MDTable<RawImplMapRow>(Table.ImplMap, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFieldRVARow> FieldRVATable = new MDTable<RawFieldRVARow>(Table.FieldRVA, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawENCLogRow> ENCLogTable = new MDTable<RawENCLogRow>(Table.ENCLog, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawENCMapRow> ENCMapTable = new MDTable<RawENCMapRow>(Table.ENCMap, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyRow> AssemblyTable = new MDTable<RawAssemblyRow>(Table.Assembly, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyProcessorRow> AssemblyProcessorTable = new MDTable<RawAssemblyProcessorRow>(Table.AssemblyProcessor, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyOSRow> AssemblyOSTable = new MDTable<RawAssemblyOSRow>(Table.AssemblyOS, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyRefRow> AssemblyRefTable = new MDTable<RawAssemblyRefRow>(Table.AssemblyRef, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyRefProcessorRow> AssemblyRefProcessorTable = new MDTable<RawAssemblyRefProcessorRow>(Table.AssemblyRefProcessor, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawAssemblyRefOSRow> AssemblyRefOSTable = new MDTable<RawAssemblyRefOSRow>(Table.AssemblyRefOS, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawFileRow> FileTable = new MDTable<RawFileRow>(Table.File, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawExportedTypeRow> ExportedTypeTable = new MDTable<RawExportedTypeRow>(Table.ExportedType, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawManifestResourceRow> ManifestResourceTable = new MDTable<RawManifestResourceRow>(Table.ManifestResource, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawNestedClassRow> NestedClassTable = new MDTable<RawNestedClassRow>(Table.NestedClass, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawGenericParamRow> GenericParamTable = new MDTable<RawGenericParamRow>(Table.GenericParam, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodSpecRow> MethodSpecTable = new MDTable<RawMethodSpecRow>(Table.MethodSpec, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawGenericParamConstraintRow> GenericParamConstraintTable = new MDTable<RawGenericParamConstraintRow>(Table.GenericParamConstraint, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawDocumentRow> DocumentTable = new MDTable<RawDocumentRow>(Table.Document, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawMethodDebugInformationRow> MethodDebugInformationTable = new MDTable<RawMethodDebugInformationRow>(Table.MethodDebugInformation, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawLocalScopeRow> LocalScopeTable = new MDTable<RawLocalScopeRow>(Table.LocalScope, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawLocalVariableRow> LocalVariableTable = new MDTable<RawLocalVariableRow>(Table.LocalVariable, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawLocalConstantRow> LocalConstantTable = new MDTable<RawLocalConstantRow>(Table.LocalConstant, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawImportScopeRow> ImportScopeTable = new MDTable<RawImportScopeRow>(Table.ImportScope, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawStateMachineMethodRow> StateMachineMethodTable = new MDTable<RawStateMachineMethodRow>(Table.StateMachineMethod, RawRowEqualityComparer.Instance);
		public readonly MDTable<RawCustomDebugInformationRow> CustomDebugInformationTable = new MDTable<RawCustomDebugInformationRow>(Table.CustomDebugInformation, RawRowEqualityComparer.Instance);
#pragma warning restore

		/// <summary>
		/// All tables
		/// </summary>
		public readonly IMDTable[] Tables;

		/// <inheritdoc/>
		public string Name => IsENC ? "#-" : "#~";

		/// <inheritdoc/>
		public bool IsEmpty => false;

		/// <summary>
		/// <c>true</c> if the Edit 'N Continue name will be used (#-)
		/// </summary>
		public bool IsENC {
			get {
				if (options.UseENC.HasValue)
					return options.UseENC.Value;
				return hasDeletedRows ||
						!FieldPtrTable.IsEmpty ||
						!MethodPtrTable.IsEmpty ||
						!ParamPtrTable.IsEmpty ||
						!EventPtrTable.IsEmpty ||
						!PropertyPtrTable.IsEmpty ||
						!(InterfaceImplTable.IsEmpty || InterfaceImplTable.IsSorted) ||
						!(ConstantTable.IsEmpty || ConstantTable.IsSorted) ||
						!(CustomAttributeTable.IsEmpty || CustomAttributeTable.IsSorted) ||
						!(FieldMarshalTable.IsEmpty || FieldMarshalTable.IsSorted) ||
						!(DeclSecurityTable.IsEmpty || DeclSecurityTable.IsSorted) ||
						!(ClassLayoutTable.IsEmpty || ClassLayoutTable.IsSorted) ||
						!(FieldLayoutTable.IsEmpty || FieldLayoutTable.IsSorted) ||
						!(EventMapTable.IsEmpty || EventMapTable.IsSorted) ||
						!(PropertyMapTable.IsEmpty || PropertyMapTable.IsSorted) ||
						!(MethodSemanticsTable.IsEmpty || MethodSemanticsTable.IsSorted) ||
						!(MethodImplTable.IsEmpty || MethodImplTable.IsSorted) ||
						!(ImplMapTable.IsEmpty || ImplMapTable.IsSorted) ||
						!(FieldRVATable.IsEmpty || FieldRVATable.IsSorted) ||
						!(NestedClassTable.IsEmpty || NestedClassTable.IsSorted) ||
						!(GenericParamTable.IsEmpty || GenericParamTable.IsSorted) ||
						!(GenericParamConstraintTable.IsEmpty || GenericParamConstraintTable.IsSorted);
			}
		}

		/// <summary>
		/// <c>true</c> if any rows have been deleted (eg. a deleted TypeDef, Method, Field, etc.
		/// Its name has been renamed to _Deleted).
		/// </summary>
		public bool HasDeletedRows {
			get => hasDeletedRows;
			set => hasDeletedRows = value;
		}

		/// <summary>
		/// <c>true</c> if #Strings heap size > <c>0xFFFF</c>
		/// </summary>
		public bool BigStrings {
			get => bigStrings;
			set => bigStrings = value;
		}

		/// <summary>
		/// <c>true</c> if #GUID heap size > <c>0xFFFF</c>
		/// </summary>
		public bool BigGuid {
			get => bigGuid;
			set => bigGuid = value;
		}

		/// <summary>
		/// <c>true</c> if #Blob heap size > <c>0xFFFF</c>
		/// </summary>
		public bool BigBlob {
			get => bigBlob;
			set => bigBlob = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="metadata">Metadata owner</param>
		/// <param name="options">Options</param>
		public TablesHeap(Metadata metadata, TablesHeapOptions options) {
			this.metadata = metadata;
			this.options = options ?? new TablesHeapOptions();
			hasDeletedRows = this.options.HasDeletedRows ?? false;
			Tables = new IMDTable[] {
				ModuleTable,
				TypeRefTable,
				TypeDefTable,
				FieldPtrTable,
				FieldTable,
				MethodPtrTable,
				MethodTable,
				ParamPtrTable,
				ParamTable,
				InterfaceImplTable,
				MemberRefTable,
				ConstantTable,
				CustomAttributeTable,
				FieldMarshalTable,
				DeclSecurityTable,
				ClassLayoutTable,
				FieldLayoutTable,
				StandAloneSigTable,
				EventMapTable,
				EventPtrTable,
				EventTable,
				PropertyMapTable,
				PropertyPtrTable,
				PropertyTable,
				MethodSemanticsTable,
				MethodImplTable,
				ModuleRefTable,
				TypeSpecTable,
				ImplMapTable,
				FieldRVATable,
				ENCLogTable,
				ENCMapTable,
				AssemblyTable,
				AssemblyProcessorTable,
				AssemblyOSTable,
				AssemblyRefTable,
				AssemblyRefProcessorTable,
				AssemblyRefOSTable,
				FileTable,
				ExportedTypeTable,
				ManifestResourceTable,
				NestedClassTable,
				GenericParamTable,
				MethodSpecTable,
				GenericParamConstraintTable,
				new MDTable<RawDummyRow>((Table)0x2D, RawDummyRow.Comparer),
				new MDTable<RawDummyRow>((Table)0x2E, RawDummyRow.Comparer),
				new MDTable<RawDummyRow>((Table)0x2F, RawDummyRow.Comparer),
				DocumentTable,
				MethodDebugInformationTable,
				LocalScopeTable,
				LocalVariableTable,
				LocalConstantTable,
				ImportScopeTable,
				StateMachineMethodTable,
				CustomDebugInformationTable,
			};
		}

		struct RawDummyRow {
			public static readonly IEqualityComparer<RawDummyRow> Comparer = new RawDummyRowEqualityComparer();
			sealed class RawDummyRowEqualityComparer : IEqualityComparer<RawDummyRow> {
				public bool Equals(RawDummyRow x, RawDummyRow y) => throw new NotSupportedException();
				public int GetHashCode(RawDummyRow obj) => throw new NotSupportedException();
			}
		}

		/// <inheritdoc/>
		public void SetReadOnly() {
			foreach (var mdt in Tables)
				mdt.SetReadOnly();
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			this.offset = offset;
			this.rva = rva;

			// NOTE: This method can be called twice by NativeModuleWriter, see Metadata.SetOffset() for more info
		}

		/// <inheritdoc/>
		public uint GetFileLength() {
			if (length == 0)
				CalculateLength();
			return Utils.AlignUp(length, HeapBase.ALIGNMENT);
		}

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <summary>
		/// Calculates the length. This will set all MD tables to read-only.
		/// </summary>
		public void CalculateLength() {
			if (length != 0)
				return;
			SetReadOnly();

			majorVersion = options.MajorVersion ?? 2;
			minorVersion = options.MinorVersion ?? 0;

			if (((majorVersion << 8) | minorVersion) <= 0x100) {
				if (!GenericParamTable.IsEmpty || !MethodSpecTable.IsEmpty || !GenericParamConstraintTable.IsEmpty)
					throw new ModuleWriterException("Tables heap version <= v1.0 but generic tables are not empty");
			}

			var dnTableSizes = new DotNetTableSizes();
			var tableInfos = dnTableSizes.CreateTables(majorVersion, minorVersion);
			var rowCounts = GetRowCounts();
			dnTableSizes.InitializeSizes(bigStrings, bigGuid, bigBlob, systemTables ?? rowCounts, rowCounts, options.ForceBigColumns ?? false);
			for (int i = 0; i < Tables.Length; i++)
				Tables[i].TableInfo = tableInfos[i];

			length = 24;
			foreach (var mdt in Tables) {
				if (mdt.IsEmpty)
					continue;
				length += (uint)(4 + mdt.TableInfo.RowSize * mdt.Rows);
			}
			if (options.ExtraData.HasValue)
				length += 4;
		}

		uint[] GetRowCounts() {
			var sizes = new uint[Tables.Length];
			for (int i = 0; i < sizes.Length; i++)
				sizes[i] = (uint)Tables[i].Rows;
			return sizes;
		}

		internal void GetSystemTableRows(out ulong mask, uint[] tables) {
			if (tables.Length != 0x40)
				throw new InvalidOperationException();
			var tablesMask = GetValidMask();
			ulong bit = 1;
			mask = 0;
			for (int i = 0; i < 0x40; i++, bit <<= 1) {
				var table = (Table)i;
				if (DotNetTableSizes.IsSystemTable(table)) {
					if ((tablesMask & bit) != 0) {
						tables[i] = (uint)Tables[i].Rows;
						mask |= bit;
					}
					else
						tables[i] = 0;
				}
				else
					tables[i] = 0;
			}
		}

		internal void SetSystemTableRows(uint[] systemTables) => this.systemTables = (uint[])systemTables.Clone();
		uint[] systemTables;

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			writer.WriteUInt32(options.Reserved1 ?? 0);
			writer.WriteByte(majorVersion);
			writer.WriteByte(minorVersion);
			writer.WriteByte((byte)GetMDStreamFlags());
			writer.WriteByte(GetLog2Rid());
			writer.WriteUInt64(GetValidMask());
			writer.WriteUInt64(GetSortedMask());
			foreach (var mdt in Tables) {
				if (!mdt.IsEmpty)
					writer.WriteInt32(mdt.Rows);
			}
			if (options.ExtraData.HasValue)
				writer.WriteUInt32(options.ExtraData.Value);

			writer.Write(metadata, ModuleTable);
			writer.Write(metadata, TypeRefTable);
			writer.Write(metadata, TypeDefTable);
			writer.Write(metadata, FieldPtrTable);
			writer.Write(metadata, FieldTable);
			writer.Write(metadata, MethodPtrTable);
			writer.Write(metadata, MethodTable);
			writer.Write(metadata, ParamPtrTable);
			writer.Write(metadata, ParamTable);
			writer.Write(metadata, InterfaceImplTable);
			writer.Write(metadata, MemberRefTable);
			writer.Write(metadata, ConstantTable);
			writer.Write(metadata, CustomAttributeTable);
			writer.Write(metadata, FieldMarshalTable);
			writer.Write(metadata, DeclSecurityTable);
			writer.Write(metadata, ClassLayoutTable);
			writer.Write(metadata, FieldLayoutTable);
			writer.Write(metadata, StandAloneSigTable);
			writer.Write(metadata, EventMapTable);
			writer.Write(metadata, EventPtrTable);
			writer.Write(metadata, EventTable);
			writer.Write(metadata, PropertyMapTable);
			writer.Write(metadata, PropertyPtrTable);
			writer.Write(metadata, PropertyTable);
			writer.Write(metadata, MethodSemanticsTable);
			writer.Write(metadata, MethodImplTable);
			writer.Write(metadata, ModuleRefTable);
			writer.Write(metadata, TypeSpecTable);
			writer.Write(metadata, ImplMapTable);
			writer.Write(metadata, FieldRVATable);
			writer.Write(metadata, ENCLogTable);
			writer.Write(metadata, ENCMapTable);
			writer.Write(metadata, AssemblyTable);
			writer.Write(metadata, AssemblyProcessorTable);
			writer.Write(metadata, AssemblyOSTable);
			writer.Write(metadata, AssemblyRefTable);
			writer.Write(metadata, AssemblyRefProcessorTable);
			writer.Write(metadata, AssemblyRefOSTable);
			writer.Write(metadata, FileTable);
			writer.Write(metadata, ExportedTypeTable);
			writer.Write(metadata, ManifestResourceTable);
			writer.Write(metadata, NestedClassTable);
			writer.Write(metadata, GenericParamTable);
			writer.Write(metadata, MethodSpecTable);
			writer.Write(metadata, GenericParamConstraintTable);
			writer.Write(metadata, DocumentTable);
			writer.Write(metadata, MethodDebugInformationTable);
			writer.Write(metadata, LocalScopeTable);
			writer.Write(metadata, LocalVariableTable);
			writer.Write(metadata, LocalConstantTable);
			writer.Write(metadata, ImportScopeTable);
			writer.Write(metadata, StateMachineMethodTable);
			writer.Write(metadata, CustomDebugInformationTable);
			writer.WriteZeroes((int)(Utils.AlignUp(length, HeapBase.ALIGNMENT) - length));
		}

		MDStreamFlags GetMDStreamFlags() {
			MDStreamFlags flags = 0;
			if (bigStrings)
				flags |= MDStreamFlags.BigStrings;
			if (bigGuid)
				flags |= MDStreamFlags.BigGUID;
			if (bigBlob)
				flags |= MDStreamFlags.BigBlob;
			if (options.ExtraData.HasValue)
				flags |= MDStreamFlags.ExtraData;
			if (hasDeletedRows)
				flags |= MDStreamFlags.HasDelete;
			return flags;
		}

		byte GetLog2Rid() {
			//TODO: Sometimes this is 16. Probably when at least one of the table indexes requires 4 bytes.
			return options.Log2Rid ?? 1;
		}

		ulong GetValidMask() {
			ulong mask = 0;
			foreach (var mdt in Tables) {
				if (!mdt.IsEmpty)
					mask |= 1UL << (int)mdt.Table;
			}
			return mask;
		}

		ulong GetSortedMask() {
			ulong mask = 0;
			foreach (var mdt in Tables) {
				if (mdt.IsSorted)
					mask |= 1UL << (int)mdt.Table;
			}
			return mask;
		}

		/// <inheritdoc/>
		public override string ToString() => Name;
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Re-uses existing chunks to save space
	/// </summary>
	/// <typeparam name="T">Chunk type</typeparam>
	public sealed class UniqueChunkList<T> : ChunkListBase<T> where T : class, IChunk {
		Dictionary<Elem, Elem> dict;

		/// <summary>
		/// Default constructor
		/// </summary>
		public UniqueChunkList()
			: this(EqualityComparer<T>.Default) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="chunkComparer">Compares the chunk type</param>
		public UniqueChunkList(IEqualityComparer<T> chunkComparer) {
			chunks = new List<Elem>();
			dict = new Dictionary<Elem, Elem>(new ElemEqualityComparer(chunkComparer));
		}

		/// <inheritdoc/>
		public override void SetOffset(FileOffset offset, RVA rva) {
			dict = null;
			base.SetOffset(offset, rva);
		}

		/// <summary>
		/// Adds a <see cref="IChunk"/> if not already present
		/// </summary>
		/// <param name="chunk">The chunk to add or <c>null</c> if none</param>
		/// <param name="alignment">Chunk alignment</param>
		/// <returns>The original input if it wasn't present, or the cached one</returns>
		public T Add(T chunk, uint alignment) {
			if (setOffsetCalled)
				throw new InvalidOperationException("SetOffset() has already been called");
			if (chunk is null)
				return null;
			var elem = new Elem(chunk, alignment);
			if (dict.TryGetValue(elem, out var other))
				return other.chunk;
			dict[elem] = elem;
			chunks.Add(elem);
			return elem.chunk;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #US heap
	/// </summary>
	public sealed class USHeap : HeapBase, IOffsetHeap<string> {
		readonly Dictionary<string, uint> cachedDict = new Dictionary<string, uint>(StringComparer.Ordinal);
		readonly List<string> cached = new List<string>();
		uint nextOffset = 1;
		byte[] originalData;
		Dictionary<uint, byte[]> userRawData;

		/// <inheritdoc/>
		public override string Name => "#US";

		/// <summary>
		/// Populates strings from an existing <see cref="USStream"/> (eg. to preserve
		/// string tokens)
		/// </summary>
		/// <param name="usStream">The #US stream with the original content</param>
		public void Populate(USStream usStream) {
			if (originalData is not null)
				throw new InvalidOperationException("Can't call method twice");
			if (nextOffset != 1)
				throw new InvalidOperationException("Add() has already been called");
			if (usStream is null || usStream.StreamLength == 0)
				return;

			var reader = usStream.CreateReader();
			originalData = reader.ToArray();
			nextOffset = (uint)originalData.Length;
			Populate(ref reader);
		}

		void Populate(ref DataReader reader) {
			reader.Position = 1;
			while (reader.Position < reader.Length) {
				uint offset = (uint)reader.Position;
				if (!reader.TryReadCompressedUInt32(out uint len)) {
					if (offset == reader.Position)
						reader.Position++;
					continue;
				}
				if (len == 0 || (ulong)reader.Position + len > reader.Length)
					continue;

				int stringLen = (int)len / 2;
				var s = reader.ReadUtf16String(stringLen);
				if ((len & 1) != 0)
					reader.ReadByte();

				if (!cachedDict.ContainsKey(s))
					cachedDict[s] = offset;
			}
		}

		/// <summary>
		/// Adds a string to the #US heap
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>The offset of the string in the #US heap</returns>
		public uint Add(string s) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #US when it's read-only");
			if (s is null)
				s = string.Empty;

			if (cachedDict.TryGetValue(s, out uint offset))
				return offset;
			return AddToCache(s);
		}

		/// <summary>
		/// Adds a string to the #US heap
		/// </summary>
		/// <param name="s">The string</param>
		/// <returns>The offset of the string in the #US heap</returns>
		public uint Create(string s) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #US when it's read-only");
			return AddToCache(s ?? string.Empty);
		}

		uint AddToCache(string s) {
			uint offset;
			cached.Add(s);
			cachedDict[s] = offset = nextOffset;
			nextOffset += (uint)GetRawDataSize(s);
			if (offset > 0x00FFFFFF)
				throw new ModuleWriterException("#US heap is too big");
			return offset;
		}

		/// <inheritdoc/>
		public override uint GetRawLength() => nextOffset;

		/// <inheritdoc/>
		protected override void WriteToImpl(DataWriter writer) {
			if (originalData is not null)
				writer.WriteBytes(originalData);
			else
				writer.WriteByte(0);

			uint offset = originalData is not null ? (uint)originalData.Length : 1;
			foreach (var s in cached) {
				int rawLen = GetRawDataSize(s);
				if (userRawData is not null && userRawData.TryGetValue(offset, out var rawData)) {
					if (rawData.Length != rawLen)
						throw new InvalidOperationException("Invalid length of raw data");
					writer.WriteBytes(rawData);
				}
				else
					WriteString(writer, s);
				offset += (uint)rawLen;
			}
		}

		void WriteString(DataWriter writer, string s) {
			writer.WriteCompressedUInt32((uint)s.Length * 2 + 1);
			byte last = 0;
			for (int i = 0; i < s.Length; i++) {
				ushort c = (ushort)s[i];
				writer.WriteUInt16(c);
				if (c > 0xFF || (1 <= c && c <= 8) || (0x0E <= c && c <= 0x1F) || c == 0x27 || c == 0x2D || c == 0x7F)
					last = 1;
			}
			writer.WriteByte(last);
		}

		/// <inheritdoc/>
		public int GetRawDataSize(string data) => DataWriter.GetCompressedUInt32Length((uint)data.Length * 2 + 1) + data.Length * 2 + 1;

		/// <inheritdoc/>
		public void SetRawData(uint offset, byte[] rawData) {
			if (userRawData is null)
				userRawData = new Dictionary<uint, byte[]>();
			userRawData[offset] = rawData ?? throw new ArgumentNullException(nameof(rawData));
		}

		/// <inheritdoc/>
		public IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData() {
			var memStream = new MemoryStream();
			var writer = new DataWriter(memStream);
			uint offset = originalData is not null ? (uint)originalData.Length : 1;
			foreach (var s in cached) {
				memStream.Position = 0;
				memStream.SetLength(0);
				WriteString(writer, s);
				yield return new KeyValuePair<uint, byte[]>(offset, memStream.ToArray());
				offset += (uint)memStream.Length;
			}
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes Win32 resources
	/// </summary>
	public sealed class Win32ResourcesChunk : IReuseChunk {
		readonly Win32Resources win32Resources;
		FileOffset offset;
		RVA rva;
		uint length;
		readonly Dictionary<ResourceDirectory, uint> dirDict = new Dictionary<ResourceDirectory, uint>();
		readonly List<ResourceDirectory> dirList = new List<ResourceDirectory>();
		readonly Dictionary<ResourceData, uint> dataHeaderDict = new Dictionary<ResourceData, uint>();
		readonly List<ResourceData> dataHeaderList = new List<ResourceData>();
		readonly Dictionary<string, uint> stringsDict = new Dictionary<string, uint>(StringComparer.Ordinal);
		readonly List<string> stringsList = new List<string>();
		readonly Dictionary<ResourceData, uint> dataDict = new Dictionary<ResourceData, uint>();
		readonly List<ResourceData> dataList = new List<ResourceData>();

		/// <inheritdoc/>
		public FileOffset FileOffset => offset;

		/// <inheritdoc/>
		public RVA RVA => rva;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="win32Resources">Win32 resources</param>
		public Win32ResourcesChunk(Win32Resources win32Resources) => this.win32Resources = win32Resources;

		/// <summary>
		/// Returns the <see cref="FileOffset"/> and <see cref="RVA"/> of a
		/// <see cref="ResourceDirectoryEntry"/>. <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dirEntry">A <see cref="ResourceDirectoryEntry"/></param>
		/// <param name="fileOffset">Updated with the file offset</param>
		/// <param name="rva">Updated with the RVA</param>
		/// <returns><c>true</c> if <paramref name="dirEntry"/> is valid and
		/// <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
		/// if <paramref name="dirEntry"/> is not part of the Win32 resources.</returns>
		public bool GetFileOffsetAndRvaOf(ResourceDirectoryEntry dirEntry, out FileOffset fileOffset, out RVA rva) {
			if (dirEntry is ResourceDirectory dir)
				return GetFileOffsetAndRvaOf(dir, out fileOffset, out rva);

			if (dirEntry is ResourceData dataHeader)
				return GetFileOffsetAndRvaOf(dataHeader, out fileOffset, out rva);

			fileOffset = 0;
			rva = 0;
			return false;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> of a <see cref="ResourceDirectoryEntry"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dirEntry">A <see cref="ResourceDirectoryEntry"/></param>
		/// <returns>The file offset or 0 if <paramref name="dirEntry"/> is invalid</returns>
		public FileOffset GetFileOffset(ResourceDirectoryEntry dirEntry) {
			GetFileOffsetAndRvaOf(dirEntry, out var fileOffset, out var rva);
			return fileOffset;
		}

		/// <summary>
		/// Returns the <see cref="RVA"/> of a <see cref="ResourceDirectoryEntry"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dirEntry">A <see cref="ResourceDirectoryEntry"/></param>
		/// <returns>The RVA or 0 if <paramref name="dirEntry"/> is invalid</returns>
		public RVA GetRVA(ResourceDirectoryEntry dirEntry) {
			GetFileOffsetAndRvaOf(dirEntry, out var fileOffset, out var rva);
			return rva;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> and <see cref="RVA"/> of a
		/// <see cref="ResourceDirectory"/>. <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dir">A <see cref="ResourceDirectory"/></param>
		/// <param name="fileOffset">Updated with the file offset</param>
		/// <param name="rva">Updated with the RVA</param>
		/// <returns><c>true</c> if <paramref name="dir"/> is valid and
		/// <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
		/// if <paramref name="dir"/> is not part of the Win32 resources.</returns>
		public bool GetFileOffsetAndRvaOf(ResourceDirectory dir, out FileOffset fileOffset, out RVA rva) {
			if (dir is null || !dirDict.TryGetValue(dir, out uint offs)) {
				fileOffset = 0;
				rva = 0;
				return false;
			}

			fileOffset = offset + offs;
			rva = this.rva + offs;
			return true;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> of a <see cref="ResourceDirectory"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dir">A <see cref="ResourceDirectory"/></param>
		/// <returns>The file offset or 0 if <paramref name="dir"/> is invalid</returns>
		public FileOffset GetFileOffset(ResourceDirectory dir) {
			GetFileOffsetAndRvaOf(dir, out var fileOffset, out var rva);
			return fileOffset;
		}

		/// <summary>
		/// Returns the <see cref="RVA"/> of a <see cref="ResourceDirectory"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dir">A <see cref="ResourceDirectory"/></param>
		/// <returns>The RVA or 0 if <paramref name="dir"/> is invalid</returns>
		public RVA GetRVA(ResourceDirectory dir) {
			GetFileOffsetAndRvaOf(dir, out var fileOffset, out var rva);
			return rva;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> and <see cref="RVA"/> of a
		/// <see cref="ResourceData"/>. <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dataHeader">A <see cref="ResourceData"/></param>
		/// <param name="fileOffset">Updated with the file offset</param>
		/// <param name="rva">Updated with the RVA</param>
		/// <returns><c>true</c> if <paramref name="dataHeader"/> is valid and
		/// <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
		/// if <paramref name="dataHeader"/> is not part of the Win32 resources.</returns>
		public bool GetFileOffsetAndRvaOf(ResourceData dataHeader, out FileOffset fileOffset, out RVA rva) {
			if (dataHeader is null || !dataHeaderDict.TryGetValue(dataHeader, out uint offs)) {
				fileOffset = 0;
				rva = 0;
				return false;
			}

			fileOffset = offset + offs;
			rva = this.rva + offs;
			return true;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> of a <see cref="ResourceData"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dataHeader">A <see cref="ResourceData"/></param>
		/// <returns>The file offset or 0 if <paramref name="dataHeader"/> is invalid</returns>
		public FileOffset GetFileOffset(ResourceData dataHeader) {
			GetFileOffsetAndRvaOf(dataHeader, out var fileOffset, out var rva);
			return fileOffset;
		}

		/// <summary>
		/// Returns the <see cref="RVA"/> of a <see cref="ResourceData"/>.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="dataHeader">A <see cref="ResourceData"/></param>
		/// <returns>The RVA or 0 if <paramref name="dataHeader"/> is invalid</returns>
		public RVA GetRVA(ResourceData dataHeader) {
			GetFileOffsetAndRvaOf(dataHeader, out var fileOffset, out var rva);
			return rva;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> and <see cref="RVA"/> of a
		/// <see cref="ResourceDirectoryEntry"/>'s name. <see cref="SetOffset"/> must have been
		/// called.
		/// </summary>
		/// <param name="name">The name of a <see cref="ResourceDirectoryEntry"/></param>
		/// <param name="fileOffset">Updated with the file offset</param>
		/// <param name="rva">Updated with the RVA</param>
		/// <returns><c>true</c> if <paramref name="name"/> is valid and
		/// <paramref name="fileOffset"/> and <paramref name="rva"/> have been updated. <c>false</c>
		/// if <paramref name="name"/> is not part of the Win32 resources.</returns>
		public bool GetFileOffsetAndRvaOf(string name, out FileOffset fileOffset, out RVA rva) {
			if (name is null || !stringsDict.TryGetValue(name, out uint offs)) {
				fileOffset = 0;
				rva = 0;
				return false;
			}

			fileOffset = offset + offs;
			rva = this.rva + offs;
			return true;
		}

		/// <summary>
		/// Returns the <see cref="FileOffset"/> of a <see cref="ResourceDirectoryEntry"/>'s name.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="name">The name of a <see cref="ResourceDirectoryEntry"/></param>
		/// <returns>The file offset or 0 if <paramref name="name"/> is invalid</returns>
		public FileOffset GetFileOffset(string name) {
			GetFileOffsetAndRvaOf(name, out var fileOffset, out var rva);
			return fileOffset;
		}

		/// <summary>
		/// Returns the <see cref="RVA"/> of a <see cref="ResourceDirectoryEntry"/>'s name.
		/// <see cref="SetOffset"/> must have been called.
		/// </summary>
		/// <param name="name">The name of a <see cref="ResourceDirectoryEntry"/></param>
		/// <returns>The RVA or 0 if <paramref name="name"/> is invalid</returns>
		public RVA GetRVA(string name) {
			GetFileOffsetAndRvaOf(name, out var fileOffset, out var rva);
			return rva;
		}

		const uint RESOURCE_DIR_ALIGNMENT = 4;
		const uint RESOURCE_DATA_HEADER_ALIGNMENT = 4;
		const uint RESOURCE_STRING_ALIGNMENT = 2;
		const uint RESOURCE_DATA_ALIGNMENT = 4;

		bool IReuseChunk.CanReuse(RVA origRva, uint origSize) {
			Debug.Assert(rva != 0);
			if (rva == 0)
				throw new InvalidOperationException();
			return length <= origSize;
		}

		internal bool CheckValidOffset(FileOffset offset) {
			GetMaxAlignment(offset, out var error);
			return error is null;
		}

		static uint GetMaxAlignment(FileOffset offset, out string error) {
			error = null;
			uint maxAlignment = 1;
			maxAlignment = Math.Max(maxAlignment, RESOURCE_DIR_ALIGNMENT);
			maxAlignment = Math.Max(maxAlignment, RESOURCE_DATA_HEADER_ALIGNMENT);
			maxAlignment = Math.Max(maxAlignment, RESOURCE_STRING_ALIGNMENT);
			maxAlignment = Math.Max(maxAlignment, RESOURCE_DATA_ALIGNMENT);
			if (((uint)offset & (maxAlignment - 1)) != 0)
				error = $"Win32 resources section isn't {maxAlignment}-byte aligned";
			else if (maxAlignment > ModuleWriterBase.DEFAULT_WIN32_RESOURCES_ALIGNMENT)
				error = "maxAlignment > DEFAULT_WIN32_RESOURCES_ALIGNMENT";
			return maxAlignment;
		}

		/// <inheritdoc/>
		public void SetOffset(FileOffset offset, RVA rva) {
			// NOTE: This method can be called twice by NativeModuleWriter, see Metadata.SetOffset() for more info
			bool initAll = this.offset == 0;
			this.offset = offset;
			this.rva = rva;
			if (win32Resources is null)
				return;

			if (!initAll) {
				// If it's called a second time, re-do everything
				dirDict.Clear();
				dirList.Clear();
				dataHeaderDict.Clear();
				dataHeaderList.Clear();
				stringsDict.Clear();
				stringsList.Clear();
				dataDict.Clear();
				dataList.Clear();
			}

			FindDirectoryEntries();

			// Place everything in the following order:
			//	1. All resource directories. The root is always first.
			//	2. All resource data headers.
			//	3. All the strings.
			//	4. All resource data.

			uint rsrcOffset = 0;
			var maxAlignment = GetMaxAlignment(offset, out var error);
			if (error is not null)
				throw new ModuleWriterException(error);

			foreach (var dir in dirList) {
				rsrcOffset = Utils.AlignUp(rsrcOffset, RESOURCE_DIR_ALIGNMENT);
				dirDict[dir] = rsrcOffset;
				if (dir != dirList[0])
					AddString(dir.Name);
				rsrcOffset += 16 + (uint)(dir.Directories.Count + dir.Data.Count) * 8;
			}

			foreach (var data in dataHeaderList) {
				rsrcOffset = Utils.AlignUp(rsrcOffset, RESOURCE_DATA_HEADER_ALIGNMENT);
				dataHeaderDict[data] = rsrcOffset;
				AddString(data.Name);
				AddData(data);
				rsrcOffset += 16;
			}

			foreach (var s in stringsList) {
				rsrcOffset = Utils.AlignUp(rsrcOffset, RESOURCE_STRING_ALIGNMENT);
				stringsDict[s] = rsrcOffset;
				rsrcOffset += 2 + (uint)(s.Length * 2);
			}

			foreach (var data in dataList) {
				rsrcOffset = Utils.AlignUp(rsrcOffset, RESOURCE_DATA_ALIGNMENT);
				dataDict[data] = rsrcOffset;
				rsrcOffset += data.CreateReader().Length;
			}

			length = rsrcOffset;
		}

		void AddData(ResourceData data) {
			if (dataDict.ContainsKey(data))
				return;
			dataList.Add(data);
			dataDict.Add(data, 0);
		}

		void AddString(ResourceName name) {
			if (!name.HasName || stringsDict.ContainsKey(name.Name))
				return;
			stringsList.Add(name.Name);
			stringsDict.Add(name.Name, 0);
		}

		void FindDirectoryEntries() => FindDirectoryEntries(win32Resources.Root);

		void FindDirectoryEntries(ResourceDirectory dir) {
			if (dirDict.ContainsKey(dir))
				return;
			dirList.Add(dir);
			dirDict[dir] = 0;
			var dirs = dir.Directories;
			int count = dirs.Count;
			for (int i = 0; i < count; i++)
				FindDirectoryEntries(dirs[i]);
			var dirData = dir.Data;
			count = dirData.Count;
			for (int i = 0; i < count; i++) {
				var data = dirData[i];
				if (dataHeaderDict.ContainsKey(data))
					continue;
				dataHeaderList.Add(data);
				dataHeaderDict[data] = 0;
			}
		}

		/// <inheritdoc/>
		public uint GetFileLength() => length;

		/// <inheritdoc/>
		public uint GetVirtualSize() => GetFileLength();

		/// <inheritdoc/>
		public void WriteTo(DataWriter writer) {
			uint offset = 0;

			// The order here must be the same as in SetOffset()

			foreach (var dir in dirList) {
				uint padding = Utils.AlignUp(offset, RESOURCE_DIR_ALIGNMENT) - offset;
				writer.WriteZeroes((int)padding);
				offset += padding;
				if (dirDict[dir] != offset)
					throw new ModuleWriterException("Invalid Win32 resource directory offset");
				offset += WriteTo(writer, dir);
			}

			foreach (var dataHeader in dataHeaderList) {
				uint padding = Utils.AlignUp(offset, RESOURCE_DATA_HEADER_ALIGNMENT) - offset;
				writer.WriteZeroes((int)padding);
				offset += padding;
				if (dataHeaderDict[dataHeader] != offset)
					throw new ModuleWriterException("Invalid Win32 resource data header offset");
				offset += WriteTo(writer, dataHeader);
			}

			foreach (var s in stringsList) {
				uint padding = Utils.AlignUp(offset, RESOURCE_STRING_ALIGNMENT) - offset;
				writer.WriteZeroes((int)padding);
				offset += padding;
				if (stringsDict[s] != offset)
					throw new ModuleWriterException("Invalid Win32 resource string offset");

				var bytes = Encoding.Unicode.GetBytes(s);
				if (bytes.Length / 2 > ushort.MaxValue)
					throw new ModuleWriterException("Win32 resource entry name is too long");
				writer.WriteUInt16((ushort)(bytes.Length / 2));
				writer.WriteBytes(bytes);
				offset += 2 + (uint)bytes.Length;
			}

			var dataBuffer = new byte[0x2000];
			foreach (var data in dataList) {
				uint padding = Utils.AlignUp(offset, RESOURCE_DATA_ALIGNMENT) - offset;
				writer.WriteZeroes((int)padding);
				offset += padding;
				if (dataDict[data] != offset)
					throw new ModuleWriterException("Invalid Win32 resource data offset");

				var reader = data.CreateReader();
				offset += reader.BytesLeft;
				reader.CopyTo(writer, dataBuffer);
			}
		}

		uint WriteTo(DataWriter writer, ResourceDirectory dir) {
			writer.WriteUInt32(dir.Characteristics);
			writer.WriteUInt32(dir.TimeDateStamp);
			writer.WriteUInt16(dir.MajorVersion);
			writer.WriteUInt16(dir.MinorVersion);

			GetNamedAndIds(dir, out var named, out var ids);
			if (named.Count > ushort.MaxValue || ids.Count > ushort.MaxValue)
				throw new ModuleWriterException("Too many named/id Win32 resource entries");
			writer.WriteUInt16((ushort)named.Count);
			writer.WriteUInt16((ushort)ids.Count);

			// These must be sorted in ascending order. Names are case insensitive.
			named.Sort((a, b) => a.Name.Name.ToUpperInvariant().CompareTo(b.Name.Name.ToUpperInvariant()));
			ids.Sort((a, b) => a.Name.Id.CompareTo(b.Name.Id));

			foreach (var d in named) {
				writer.WriteUInt32(0x80000000 | stringsDict[d.Name.Name]);
				writer.WriteUInt32(GetDirectoryEntryOffset(d));
			}

			foreach (var d in ids) {
				writer.WriteInt32(d.Name.Id);
				writer.WriteUInt32(GetDirectoryEntryOffset(d));
			}

			return 16 + (uint)(named.Count + ids.Count) * 8;
		}

		uint GetDirectoryEntryOffset(ResourceDirectoryEntry e) {
			if (e is ResourceData)
				return dataHeaderDict[(ResourceData)e];
			return 0x80000000 | dirDict[(ResourceDirectory)e];
		}

		static void GetNamedAndIds(ResourceDirectory dir, out List<ResourceDirectoryEntry> named, out List<ResourceDirectoryEntry> ids) {
			named = new List<ResourceDirectoryEntry>();
			ids = new List<ResourceDirectoryEntry>();
			var dirs = dir.Directories;
			int count = dirs.Count;
			for (int i = 0; i < count; i++) {
				var d = dirs[i];
				if (d.Name.HasId)
					ids.Add(d);
				else
					named.Add(d);
			}
			var dirData = dir.Data;
			count = dirData.Count;
			for (int i = 0; i < count; i++) {
				var d = dirData[i];
				if (d.Name.HasId)
					ids.Add(d);
				else
					named.Add(d);
			}
		}

		uint WriteTo(DataWriter writer, ResourceData dataHeader) {
			writer.WriteUInt32((uint)rva + dataDict[dataHeader]);
			writer.WriteUInt32((uint)dataHeader.CreateReader().Length);
			writer.WriteUInt32(dataHeader.CodePage);
			writer.WriteUInt32(dataHeader.Reserved);
			return 16;
		}
	}
}




namespace dnlib.DotNet.Writer {
	static class WriterUtils {
		public static uint WriteCompressedUInt32(this DataWriter writer, IWriterError helper, uint value) {
			if (value > 0x1FFFFFFF) {
				helper.Error("UInt32 value is too big and can't be compressed");
				value = 0x1FFFFFFF;
			}
			writer.WriteCompressedUInt32(value);
			return value;
		}

		public static int WriteCompressedInt32(this DataWriter writer, IWriterError helper, int value) {
			if (value < -0x10000000) {
				helper.Error("Int32 value is too small and can't be compressed.");
				value = -0x10000000;
			}
			else if (value > 0x0FFFFFFF) {
				helper.Error("Int32 value is too big and can't be compressed.");
				value = 0x0FFFFFFF;
			}
			writer.WriteCompressedInt32(value);
			return value;
		}

		public static void Write(this DataWriter writer, IWriterError helper, UTF8String s) {
			if (UTF8String.IsNull(s)) {
				helper.Error("UTF8String is null");
				s = UTF8String.Empty;
			}

			writer.WriteCompressedUInt32(helper, (uint)s.DataLength);
			writer.WriteBytes(s.Data);
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// Writes data
	/// </summary>
	public unsafe struct ArrayWriter {
		/// <summary>
		/// Gets the current position
		/// </summary>
		public int Position => position;

		readonly byte[] data;
		int position;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">Destination array</param>
		public ArrayWriter(byte[] data) {
			this.data = data;
			position = 0;
		}

		/// <summary>
		/// Writes a <see cref="sbyte"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteSByte(sbyte value) => data[position++] = (byte)value;

		/// <summary>
		/// Writes a <see cref="byte"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteByte(byte value) => data[position++] = value;

		/// <summary>
		/// Writes a <see cref="short"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteInt16(short value) {
			data[position++] = (byte)value;
			data[position++] = (byte)(value >> 8);
		}

		/// <summary>
		/// Writes a <see cref="ushort"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteUInt16(ushort value) {
			data[position++] = (byte)value;
			data[position++] = (byte)(value >> 8);
		}

		/// <summary>
		/// Writes a <see cref="int"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteInt32(int value) {
			Debug.Assert(this.position + 4 <= data.Length);
			var position = this.position;
			fixed (byte* p = data)
				*(int*)(p + position) = value;
			this.position = position + 4;
		}

		/// <summary>
		/// Writes a <see cref="uint"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteUInt32(uint value) {
			Debug.Assert(this.position + 4 <= data.Length);
			var position = this.position;
			fixed (byte* p = data)
				*(uint*)(p + position) = value;
			this.position = position + 4;
		}

		/// <summary>
		/// Writes a <see cref="long"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteInt64(long value) {
			Debug.Assert(this.position + 8 <= data.Length);
			var position = this.position;
			fixed (byte* p = data)
				*(long*)(p + position) = value;
			this.position = position + 8;
		}

		/// <summary>
		/// Writes a <see cref="ulong"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteUInt64(ulong value) {
			Debug.Assert(this.position + 8 <= data.Length);
			var position = this.position;
			fixed (byte* p = data)
				*(ulong*)(p + position) = value;
			this.position = position + 8;
		}

		/// <summary>
		/// Writes a <see cref="float"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteSingle(float value) {
			Debug.Assert(this.position + 4 <= data.Length);
			var position = this.position;
			fixed (byte* p = data)
				*(float*)(p + position) = value;
			this.position = position + 4;
		}

		/// <summary>
		/// Writes a <see cref="double"/>
		/// </summary>
		/// <param name="value">Value</param>
		public void WriteDouble(double value) {
			Debug.Assert(this.position + 8 <= data.Length);
			var position = this.position;
			fixed (byte* p = data)
				*(double*)(p + position) = value;
			this.position = position + 8;
		}

		/// <summary>
		/// Writes bytes
		/// </summary>
		/// <param name="source">Bytes</param>
		public void WriteBytes(byte[] source) => WriteBytes(source, 0, source.Length);

		/// <summary>
		/// Writes bytes
		/// </summary>
		/// <param name="source">Bytes</param>
		/// <param name="index">Source index</param>
		/// <param name="length">Number of bytes to write</param>
		public void WriteBytes(byte[] source, int index, int length) {
			Array.Copy(source, index, data, position, length);
			position += length;
		}
	}
}





namespace dnlib.DotNet.Writer {
	/// <summary>
	/// #Blob heap
	/// </summary>
	public sealed class BlobHeap : HeapBase, IOffsetHeap<byte[]> {
		readonly Dictionary<byte[], uint> cachedDict = new Dictionary<byte[], uint>(ByteArrayEqualityComparer.Instance);
		readonly List<byte[]> cached = new List<byte[]>();
		uint nextOffset = 1;
		byte[] originalData;
		Dictionary<uint, byte[]> userRawData;

		/// <inheritdoc/>
		public override string Name => "#Blob";

		/// <summary>
		/// Populates blobs from an existing <see cref="BlobStream"/> (eg. to preserve
		/// blob offsets)
		/// </summary>
		/// <param name="blobStream">The #Blob stream with the original content</param>
		public void Populate(BlobStream blobStream) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Blob when it's read-only");
			if (originalData is not null)
				throw new InvalidOperationException("Can't call method twice");
			if (nextOffset != 1)
				throw new InvalidOperationException("Add() has already been called");
			if (blobStream is null || blobStream.StreamLength == 0)
				return;

			var reader = blobStream.CreateReader();
			originalData = reader.ToArray();
			nextOffset = (uint)originalData.Length;
			Populate(ref reader);
		}

		void Populate(ref DataReader reader) {
			reader.Position = 1;
			while (reader.Position < reader.Length) {
				uint offset = reader.Position;
				if (!reader.TryReadCompressedUInt32(out uint len)) {
					if (offset == reader.Position)
						reader.Position++;
					continue;
				}
				if (len == 0 || (ulong)reader.Position + len > reader.Length)
					continue;

				var data = reader.ReadBytes((int)len);
				if (!cachedDict.ContainsKey(data))
					cachedDict[data] = offset;
			}
		}

		/// <summary>
		/// Adds data to the #Blob heap
		/// </summary>
		/// <param name="data">The data</param>
		/// <returns>The offset of the data in the #Blob heap</returns>
		public uint Add(byte[] data) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Blob when it's read-only");
			if (data is null || data.Length == 0)
				return 0;

			if (cachedDict.TryGetValue(data, out uint offset))
				return offset;
			return AddToCache(data);
		}

		/// <summary>
		/// Adds data to the #Blob heap, but does not re-use an existing position
		/// </summary>
		/// <param name="data">The data</param>
		/// <returns>The offset of the data in the #Blob heap</returns>
		public uint Create(byte[] data) {
			if (isReadOnly)
				throw new ModuleWriterException("Trying to modify #Blob when it's read-only");
			return AddToCache(data ?? Array2.Empty<byte>());
		}

		uint AddToCache(byte[] data) {
			uint offset;
			cached.Add(data);
			cachedDict[data] = offset = nextOffset;
			nextOffset += (uint)GetRawDataSize(data);
			return offset;
		}

		/// <inheritdoc/>
		public override uint GetRawLength() => nextOffset;

		/// <inheritdoc/>
		protected override void WriteToImpl(DataWriter writer) {
			if (originalData is not null)
				writer.WriteBytes(originalData);
			else
				writer.WriteByte(0);

			uint offset = originalData is not null ? (uint)originalData.Length : 1;
			foreach (var data in cached) {
				int rawLen = GetRawDataSize(data);
				if (userRawData is not null && userRawData.TryGetValue(offset, out var rawData)) {
					if (rawData.Length != rawLen)
						throw new InvalidOperationException("Invalid length of raw data");
					writer.WriteBytes(rawData);
				}
				else {
					writer.WriteCompressedUInt32((uint)data.Length);
					writer.WriteBytes(data);
				}
				offset += (uint)rawLen;
			}
		}

		/// <inheritdoc/>
		public int GetRawDataSize(byte[] data) => DataWriter.GetCompressedUInt32Length((uint)data.Length) + data.Length;

		/// <inheritdoc/>
		public void SetRawData(uint offset, byte[] rawData) {
			if (userRawData is null)
				userRawData = new Dictionary<uint, byte[]>();
			userRawData[offset] = rawData ?? throw new ArgumentNullException(nameof(rawData));
		}

		/// <inheritdoc/>
		public IEnumerable<KeyValuePair<uint, byte[]>> GetAllRawData() {
			var memStream = new MemoryStream();
			var writer = new DataWriter(memStream);
			uint offset = originalData is not null ? (uint)originalData.Length : 1;
			foreach (var data in cached) {
				memStream.Position = 0;
				memStream.SetLength(0);
				writer.WriteCompressedUInt32((uint)data.Length);
				writer.WriteBytes(data);
				yield return new KeyValuePair<uint, byte[]>(offset, memStream.ToArray());
				offset += (uint)memStream.Length;
			}
		}
	}
}





namespace dnlib.IO {
	/// <summary>
	/// Creates <see cref="DataReader"/>s that can read its data.
	/// 
	/// This factory class is thread safe and its data can be read by <see cref="DataReader"/> on any thread.
	/// </summary>
	public abstract class DataReaderFactory : IDisposable {
		/// <summary>
		/// The filename or null if the data is not from a file
		/// </summary>
		public abstract string Filename { get; }

		/// <summary>
		/// Gets the total length of the data
		/// </summary>
		public abstract uint Length { get; }

		/// <summary>
		/// Creates a data reader that can read all data
		/// </summary>
		/// <returns></returns>
		public DataReader CreateReader() => CreateReader(0U, Length);

		/// <summary>
		/// Creates a data reader
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public abstract DataReader CreateReader(uint offset, uint length);

		static void ThrowArgumentOutOfRangeException(string paramName) =>
			throw new ArgumentOutOfRangeException(paramName);

		static void Throw_CreateReader_2(int offset, int length) {
			if (offset < 0)
				throw new ArgumentOutOfRangeException(nameof(offset));
			Debug.Assert(length < 0);
			throw new ArgumentOutOfRangeException(nameof(length));
		}

		/// <summary>
		/// Creates a data reader
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public DataReader CreateReader(uint offset, int length) {
			if (length < 0)
				ThrowArgumentOutOfRangeException(nameof(length));
			return CreateReader(offset, (uint)length);
		}

		/// <summary>
		/// Creates a data reader
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public DataReader CreateReader(int offset, uint length) {
			if (offset < 0)
				ThrowArgumentOutOfRangeException(nameof(offset));
			return CreateReader((uint)offset, length);
		}

		/// <summary>
		/// Creates a data reader
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public DataReader CreateReader(int offset, int length) {
			if (offset < 0 || length < 0)
				Throw_CreateReader_2(offset, length);
			return CreateReader((uint)offset, (uint)length);
		}

		/// <summary>
		/// Creates a data reader
		/// </summary>
		/// <param name="stream">Stream</param>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		protected DataReader CreateReader(DataStream stream, uint offset, uint length) {
			uint maxOffset = Length;
			if (offset > maxOffset)
				offset = maxOffset;
			if ((ulong)offset + length > maxOffset)
				length = maxOffset - offset;
			return new DataReader(stream, offset, length);
		}

		/// <summary>
		/// Raised when all cached <see cref="DataReader"/>s created by this instance must be recreated
		/// </summary>
		public virtual event EventHandler DataReaderInvalidated { add { } remove { } }

		/// <summary>
		/// Disposes of this instance
		/// </summary>
		public abstract void Dispose();
	}
}





namespace dnlib.IO {
	static class DataReaderFactoryFactory {
		static readonly bool isUnix;

		static DataReaderFactoryFactory() {
			// See http://mono-project.com/FAQ:_Technical#Mono_Platforms for platform detection.
			int p = (int)Environment.OSVersion.Platform;
			if (p == 4 || p == 6 || p == 128)
				isUnix = true;
		}

		public static DataReaderFactory Create(string fileName, bool mapAsImage) {
			var creator = CreateDataReaderFactory(fileName, mapAsImage);
			if (creator is not null)
				return creator;

			return ByteArrayDataReaderFactory.Create(File.ReadAllBytes(fileName), fileName);
		}

		static DataReaderFactory CreateDataReaderFactory(string fileName, bool mapAsImage) {
			if (!isUnix)
				return MemoryMappedDataReaderFactory.CreateWindows(fileName, mapAsImage);
			else
				return MemoryMappedDataReaderFactory.CreateUnix(fileName, mapAsImage);
		}
	}
}





namespace dnlib.IO {
	sealed class DataReaderStream : Stream {
		public override bool CanRead => true;
		public override bool CanSeek => true;
		public override bool CanWrite => false;
		public override long Length => reader.Length;

		public override long Position {
			get => position;
			set => position = value;
		}

		DataReader reader;
		long position;

		public DataReaderStream(in DataReader reader) {
			this.reader = reader;
			position = reader.Position;
		}

		public override void Flush() { }

		bool CheckAndSetPosition() {
			if ((ulong)position > reader.Length)
				return false;
			reader.Position = (uint)position;
			return true;
		}

		public override long Seek(long offset, SeekOrigin origin) {
			switch (origin) {
			case SeekOrigin.Begin:		Position = offset; break;
			case SeekOrigin.Current:	Position += offset; break;
			case SeekOrigin.End:		Position = Length + offset; break;
			}
			return Position;
		}

		public override int Read(byte[] buffer, int offset, int count) {
			if (buffer is null)
				throw new ArgumentNullException(nameof(buffer));
			if (offset < 0)
				throw new ArgumentOutOfRangeException(nameof(offset));
			if (count < 0)
				throw new ArgumentOutOfRangeException(nameof(count));
			if (!CheckAndSetPosition())
				return 0;
			int bytesToRead = (int)Math.Min((uint)count, reader.BytesLeft);
			reader.ReadBytes(buffer, offset, bytesToRead);
			Position += bytesToRead;
			return bytesToRead;
		}

		public override int ReadByte() {
			if (!CheckAndSetPosition() || !reader.CanRead(1U))
				return -1;
			Position++;
			return reader.ReadByte();
		}

		public override void SetLength(long value) => throw new NotSupportedException();
		public override void Write(byte[] buffer, int offset, int count) => throw new NotSupportedException();
	}
}





namespace dnlib.IO {
	/// <summary>
	/// This class is used by a <see cref="DataReader"/>. The <see cref="DataReader"/> instance
	/// verifies that all input are valid before calling any methods in this class.
	/// This class is thread safe.
	/// </summary>
	public abstract class DataStream {
		/// <summary>
		/// Reads bytes
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="destination">Destination pointer</param>
		/// <param name="length">Number of bytes to read</param>
		public unsafe abstract void ReadBytes(uint offset, void* destination, int length);

		/// <summary>
		/// Reads bytes
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="destination">Destination array</param>
		/// <param name="destinationIndex">Destination index</param>
		/// <param name="length">Number of bytes to read</param>
		public abstract void ReadBytes(uint offset, byte[] destination, int destinationIndex, int length);

		/// <summary>
		/// Reads a <see cref="byte"/>
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns></returns>
		public abstract byte ReadByte(uint offset);

		/// <summary>
		/// Reads a <see cref="ushort"/>
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns></returns>
		public abstract ushort ReadUInt16(uint offset);

		/// <summary>
		/// Reads a <see cref="uint"/>
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns></returns>
		public abstract uint ReadUInt32(uint offset);

		/// <summary>
		/// Reads a <see cref="ulong"/>
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns></returns>
		public abstract ulong ReadUInt64(uint offset);

		/// <summary>
		/// Reads a <see cref="float"/>
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns></returns>
		public abstract float ReadSingle(uint offset);

		/// <summary>
		/// Reads a <see cref="double"/>
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns></returns>
		public abstract double ReadDouble(uint offset);

		/// <summary>
		/// Reads a <see cref="Guid"/>
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns></returns>
		public virtual Guid ReadGuid(uint offset) =>
			new Guid(ReadUInt32(offset), ReadUInt16(offset + 4), ReadUInt16(offset + 6),
				ReadByte(offset + 8), ReadByte(offset + 9), ReadByte(offset + 10), ReadByte(offset + 11),
				ReadByte(offset + 12), ReadByte(offset + 13), ReadByte(offset + 14), ReadByte(offset + 15));

		/// <summary>
		/// Reads a UTF-16 encoded <see cref="string"/>
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="chars">Number of characters to read</param>
		/// <returns></returns>
		public abstract string ReadUtf16String(uint offset, int chars);

		/// <summary>
		/// Reads a string
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of string in bytes</param>
		/// <param name="encoding">Encoding</param>
		/// <returns></returns>
		public abstract string ReadString(uint offset, int length, Encoding encoding);

		/// <summary>
		/// Gets the data offset of a byte or returns false if the byte wasn't found
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="endOffset">End offset of data (not inclusive)</param>
		/// <param name="value">Byte value to search for</param>
		/// <param name="valueOffset">Offset of the byte if found</param>
		/// <returns></returns>
		public abstract bool TryGetOffsetOf(uint offset, uint endOffset, byte value, out uint valueOffset);
	}
}





namespace dnlib.IO {
	/// <summary>
	/// Creates <see cref="DataStream"/>s
	/// </summary>
	public static unsafe class DataStreamFactory {
		//TODO: There are other places that use pointers that also need to be updated
		static bool supportsUnalignedAccesses = CalculateSupportsUnalignedAccesses();

		static bool CalculateSupportsUnalignedAccesses() {
			var machine = ProcessorArchUtils.GetProcessCpuArchitecture();
			switch (machine) {
			case Machine.I386:
			case Machine.AMD64:
				return true;
			case Machine.ARMNT:
			case Machine.ARM64:
				return false;
			default:
				Debug.Fail($"Unknown CPU arch: {machine}");
				return true;
			}
		}

		/// <summary>
		/// Creates a <see cref="DataStream"/> that reads from native memory
		/// </summary>
		/// <param name="data">Pointer to data</param>
		/// <returns></returns>
		public static DataStream Create(byte* data) {
			if (data is null)
				throw new ArgumentNullException(nameof(data));
			if (supportsUnalignedAccesses)
				return new UnalignedNativeMemoryDataStream(data);
			return new AlignedNativeMemoryDataStream(data);
		}

		/// <summary>
		/// Creates a <see cref="DataStream"/> that reads from a byte array
		/// </summary>
		/// <param name="data">Data</param>
		/// <returns></returns>
		public static DataStream Create(byte[] data) {
			if (data is null)
				throw new ArgumentNullException(nameof(data));
			if (supportsUnalignedAccesses)
				return new UnalignedByteArrayDataStream(data);
			return new AlignedByteArrayDataStream(data);
		}
	}
}





namespace dnlib.IO {
	sealed unsafe class EmptyDataStream : DataStream {
		public static readonly DataStream Instance = new EmptyDataStream();

		EmptyDataStream() { }

		public override void ReadBytes(uint offset, void* destination, int length) {
			var p = (byte*)destination;
			for (int i = 0; i < length; i++)
				*p = 0;
		}
		public override void ReadBytes(uint offset, byte[] destination, int destinationIndex, int length) {
			for (int i = 0; i < length; i++)
				destination[destinationIndex + i] = 0;
		}
		public override byte ReadByte(uint offset) => 0;
		public override ushort ReadUInt16(uint offset) => 0;
		public override uint ReadUInt32(uint offset) => 0;
		public override ulong ReadUInt64(uint offset) => 0;
		public override float ReadSingle(uint offset) => 0;
		public override double ReadDouble(uint offset) => 0;
		public override string ReadUtf16String(uint offset, int chars) => string.Empty;
		public override string ReadString(uint offset, int length, Encoding encoding) => string.Empty;
		public override bool TryGetOffsetOf(uint offset, uint endOffset, byte value, out uint valueOffset) {
			valueOffset = 0;
			return false;
		}
	}
}




namespace dnlib.IO {
	/// <summary>
	/// Represents a file offset
	/// </summary>
	public enum FileOffset : uint {
	}

	partial class IOExtensions {
		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="offset">this</param>
		/// <param name="alignment">Alignment</param>
		public static FileOffset AlignUp(this FileOffset offset, uint alignment) => (FileOffset)(((uint)offset + alignment - 1) & ~(alignment - 1));

		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="offset">this</param>
		/// <param name="alignment">Alignment</param>
		public static FileOffset AlignUp(this FileOffset offset, int alignment) => (FileOffset)(((uint)offset + alignment - 1) & ~(alignment - 1));
	}
}





namespace dnlib.IO {
	/// <summary>
	/// Base class for classes needing to implement IFileSection
	/// </summary>
	[DebuggerDisplay("O:{startOffset} L:{size} {GetType().Name}")]
	public class FileSection : IFileSection {
		/// <summary>
		/// The start file offset of this section
		/// </summary>
		protected FileOffset startOffset;

		/// <summary>
		/// Size of the section
		/// </summary>
		protected uint size;

		/// <inheritdoc/>
		public FileOffset StartOffset => startOffset;

		/// <inheritdoc/>
		public FileOffset EndOffset => startOffset + size;

		/// <summary>
		/// Set <see cref="startOffset"/> to <paramref name="reader"/>'s current position
		/// </summary>
		/// <param name="reader">The reader</param>
		protected void SetStartOffset(ref DataReader reader) =>
			startOffset = (FileOffset)reader.CurrentOffset;

		/// <summary>
		/// Set <see cref="size"/> according to <paramref name="reader"/>'s current position
		/// </summary>
		/// <param name="reader">The reader</param>
		protected void SetEndoffset(ref DataReader reader) =>
			size = reader.CurrentOffset - (uint)startOffset;
	}
}




namespace dnlib.IO {
	/// <summary>
	/// Represents a section in a file
	/// </summary>
	public interface IFileSection {
		/// <summary>
		/// Start offset of the section in the file
		/// </summary>
		FileOffset StartOffset { get; }

		/// <summary>
		/// End offset of the section in the file. This is one byte after the last
		/// valid offset in the section.
		/// </summary>
		FileOffset EndOffset { get; }
	}
}




namespace dnlib.IO {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class IOExtensions {
	}
}




namespace dnlib.IO {
	/// <summary>
	/// Creates <see cref="DataReader"/>s that read memory mapped data
	/// </summary>
	sealed unsafe class MemoryMappedDataReaderFactory : DataReaderFactory {
		/// <summary>
		/// The filename or null if the data is not from a file
		/// </summary>
		public override string Filename => filename;

		/// <summary>
		/// Gets the total length of the data
		/// </summary>
		public override uint Length => length;

		/// <summary>
		/// Raised when all cached <see cref="DataReader"/>s created by this instance must be recreated
		/// </summary>
		public override event EventHandler DataReaderInvalidated;

		DataStream stream;
		uint length;
		string filename;
		GCHandle gcHandle;
		byte[] dataAry;
		IntPtr data;
		OSType osType;
		long origDataLength;

		MemoryMappedDataReaderFactory(string filename) {
			osType = OSType.Unknown;
			this.filename = filename;
		}

		~MemoryMappedDataReaderFactory() {
			Dispose(false);
		}

		/// <summary>
		/// Creates a data reader
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public override DataReader CreateReader(uint offset, uint length) => CreateReader(stream, offset, length);

		/// <summary>
		/// Cleans up and frees all allocated memory
		/// </summary>
		public override void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		internal void SetLength(uint length) => this.length = length;

		enum OSType : byte {
			Unknown,
			Windows,
			Unix,
		}

		[Serializable]
		sealed class MemoryMappedIONotSupportedException : IOException {
			public MemoryMappedIONotSupportedException(string s) : base(s) { }
			public MemoryMappedIONotSupportedException(SerializationInfo info, StreamingContext context) : base(info, context) { }
		}

		static class Windows {
			const uint GENERIC_READ = 0x80000000;
			const uint FILE_SHARE_READ = 0x00000001;
			const uint OPEN_EXISTING = 3;
			const uint FILE_ATTRIBUTE_NORMAL = 0x00000080;
			const uint PAGE_READONLY = 0x02;
			const uint SEC_IMAGE = 0x1000000;
			const uint SECTION_MAP_READ = 0x0004;
			const uint FILE_MAP_READ = SECTION_MAP_READ;

			[DllImport("kernel32", SetLastError = true, CharSet = CharSet.Auto)]
			static extern SafeFileHandle CreateFile(string lpFileName, uint dwDesiredAccess, uint dwShareMode, IntPtr lpSecurityAttributes, uint dwCreationDisposition, uint dwFlagsAndAttributes, IntPtr hTemplateFile);

			[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
			static extern SafeFileHandle CreateFileMapping(SafeFileHandle hFile, IntPtr lpAttributes, uint flProtect, uint dwMaximumSizeHigh, uint dwMaximumSizeLow, string lpName);

			[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
			static extern IntPtr MapViewOfFile(SafeFileHandle hFileMappingObject, uint dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, UIntPtr dwNumberOfBytesToMap);

			[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			static extern bool UnmapViewOfFile(IntPtr lpBaseAddress);

			[DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]
			static extern uint GetFileSize(SafeFileHandle hFile, out uint lpFileSizeHigh);
			const uint INVALID_FILE_SIZE = 0xFFFFFFFF;
			const int NO_ERROR = 0;

			public static void Mmap(MemoryMappedDataReaderFactory creator, bool mapAsImage) {
				using (var fileHandle = CreateFile(creator.filename, GENERIC_READ, FILE_SHARE_READ, IntPtr.Zero, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, IntPtr.Zero)) {
					if (fileHandle.IsInvalid)
						throw new IOException($"Could not open file {creator.filename} for reading. Error: {Marshal.GetLastWin32Error():X8}");

					uint sizeLo = GetFileSize(fileHandle, out uint sizeHi);
					int hr;
					if (sizeLo == INVALID_FILE_SIZE && (hr = Marshal.GetLastWin32Error()) != NO_ERROR)
						throw new IOException($"Could not get file size. File: {creator.filename}, error: {hr:X8}");
					var fileSize = ((long)sizeHi << 32) | sizeLo;

					using (var fileMapping = CreateFileMapping(fileHandle, IntPtr.Zero, PAGE_READONLY | (mapAsImage ? SEC_IMAGE : 0), 0, 0, null)) {
						if (fileMapping.IsInvalid)
							throw new MemoryMappedIONotSupportedException($"Could not create a file mapping object. File: {creator.filename}, error: {Marshal.GetLastWin32Error():X8}");
						creator.data = MapViewOfFile(fileMapping, FILE_MAP_READ, 0, 0, UIntPtr.Zero);
						if (creator.data == IntPtr.Zero)
							throw new MemoryMappedIONotSupportedException($"Could not map file {creator.filename}. Error: {Marshal.GetLastWin32Error():X8}");
						creator.length = (uint)fileSize;
						creator.osType = OSType.Windows;
						creator.stream = DataStreamFactory.Create((byte*)creator.data);
					}
				}
			}

			public static void Dispose(IntPtr addr) {
				if (addr != IntPtr.Zero)
					UnmapViewOfFile(addr);
			}
		}

		static class Unix {
			// Can't use SafeFileHandle. Seems like a bug in mono. You'll get
			// "_wapi_handle_unref_full: Attempting to unref unused handle 0xYYY" when Dispose() is called.
			[DllImport("libc")]
			static extern int open(string pathname, int flags);
			const int O_RDONLY = 0;

			[DllImport("libc")]
			static extern int close(int fd);

			[DllImport("libc", EntryPoint = "lseek", SetLastError = true)]
			static extern int lseek32(int fd, int offset, int whence);
			[DllImport("libc", EntryPoint = "lseek", SetLastError = true)]
			static extern long lseek64(int fd, long offset, int whence);
			const int SEEK_END = 2;

			[DllImport("libc", EntryPoint = "mmap", SetLastError = true)]
			static extern IntPtr mmap32(IntPtr addr, IntPtr length, int prot, int flags, int fd, int offset);
			[DllImport("libc", EntryPoint = "mmap", SetLastError = true)]
			static extern IntPtr mmap64(IntPtr addr, IntPtr length, int prot, int flags, int fd, long offset);
			const int PROT_READ = 1;
			const int MAP_PRIVATE = 0x02;

			[DllImport("libc")]
			static extern int munmap(IntPtr addr, IntPtr length);

			public static void Mmap(MemoryMappedDataReaderFactory creator, bool mapAsImage) {
				int fd = open(creator.filename, O_RDONLY);
				try {
					if (fd < 0)
						throw new IOException($"Could not open file {creator.filename} for reading. Error: {fd}");

					long size;
					IntPtr data;

					if (IntPtr.Size == 4) {
						size = lseek32(fd, 0, SEEK_END);
						if (size == -1)
							throw new MemoryMappedIONotSupportedException($"Could not get length of {creator.filename} (lseek failed): {Marshal.GetLastWin32Error()}");

						data = mmap32(IntPtr.Zero, (IntPtr)size, PROT_READ, MAP_PRIVATE, fd, 0);
						if (data == new IntPtr(-1) || data == IntPtr.Zero)
							throw new MemoryMappedIONotSupportedException($"Could not map file {creator.filename}. Error: {Marshal.GetLastWin32Error()}");
					}
					else {
						size = lseek64(fd, 0, SEEK_END);
						if (size == -1)
							throw new MemoryMappedIONotSupportedException($"Could not get length of {creator.filename} (lseek failed): {Marshal.GetLastWin32Error()}");

						data = mmap64(IntPtr.Zero, (IntPtr)size, PROT_READ, MAP_PRIVATE, fd, 0);
						if (data == new IntPtr(-1) || data == IntPtr.Zero)
							throw new MemoryMappedIONotSupportedException($"Could not map file {creator.filename}. Error: {Marshal.GetLastWin32Error()}");
					}

					creator.data = data;
					creator.length = (uint)size;
					creator.origDataLength = size;
					creator.osType = OSType.Unix;
					creator.stream = DataStreamFactory.Create((byte*)creator.data);
				}
				finally {
					if (fd >= 0)
						close(fd);
				}
			}

			public static void Dispose(IntPtr addr, long size) {
				if (addr != IntPtr.Zero)
					munmap(addr, new IntPtr(size));
			}
		}

		static volatile bool canTryWindows = true;
		static volatile bool canTryUnix = true;

		internal static MemoryMappedDataReaderFactory CreateWindows(string filename, bool mapAsImage) {
			if (!canTryWindows)
				return null;

			var creator = new MemoryMappedDataReaderFactory(GetFullPath(filename));
			try {
				Windows.Mmap(creator, mapAsImage);
				return creator;
			}
			catch (EntryPointNotFoundException) {
			}
			catch (DllNotFoundException) {
			}
			canTryWindows = false;
			return null;
		}

		internal static MemoryMappedDataReaderFactory CreateUnix(string filename, bool mapAsImage) {
			if (!canTryUnix)
				return null;

			var creator = new MemoryMappedDataReaderFactory(GetFullPath(filename));
			try {
				Unix.Mmap(creator, mapAsImage);
				if (mapAsImage) { // Only check this if we know that mmap() works, i.e., if above call succeeds
					creator.Dispose();
					throw new ArgumentException("mapAsImage == true is not supported on this OS");
				}
				return creator;
			}
			catch (MemoryMappedIONotSupportedException ex) {
				Debug.WriteLine($"mmap'd IO didn't work: {ex.Message}");
			}
			catch (EntryPointNotFoundException) {
			}
			catch (DllNotFoundException) {
			}
			canTryUnix = false;
			return null;
		}

		static string GetFullPath(string filename) {
			try {
				return Path.GetFullPath(filename);
			}
			catch {
				return filename;
			}
		}

		void Dispose(bool disposing) {
			FreeMemoryMappedIoData();
			if (disposing) {
				length = 0;
				stream = EmptyDataStream.Instance;
				data = IntPtr.Zero;
				filename = null;
			}
		}

		/// <summary>
		/// <c>true</c> if memory mapped I/O is enabled
		/// </summary>
		internal bool IsMemoryMappedIO => dataAry is null;

		/// <summary>
		/// Call this to disable memory mapped I/O. This must only be called if no other code is
		/// trying to access the memory since that could lead to an exception.
		/// </summary>
		internal void UnsafeDisableMemoryMappedIO() {
			if (dataAry is not null)
				return;
			var newAry = new byte[length];
			Marshal.Copy(data, newAry, 0, newAry.Length);
			FreeMemoryMappedIoData();
			length = (uint)newAry.Length;
			dataAry = newAry;
			gcHandle = GCHandle.Alloc(dataAry, GCHandleType.Pinned);
			data = gcHandle.AddrOfPinnedObject();
			stream = DataStreamFactory.Create((byte*)data);
			DataReaderInvalidated?.Invoke(this, EventArgs.Empty);
		}

		void FreeMemoryMappedIoData() {
			if (dataAry is null) {
				var origData = Interlocked.Exchange(ref data, IntPtr.Zero);
				if (origData != IntPtr.Zero) {
					length = 0;
					switch (osType) {
					case OSType.Windows:
						Windows.Dispose(origData);
						break;

					case OSType.Unix:
						Unix.Dispose(origData, origDataLength);
						break;

					default:
						throw new InvalidOperationException("Shouldn't be here");
					}
				}
			}

			if (gcHandle.IsAllocated) {
				try {
					gcHandle.Free();
				}
				catch (InvalidOperationException) {
				}
			}
			dataAry = null;
		}
	}
}





namespace dnlib.IO {
	/// <summary>
	/// Creates <see cref="DataReader"/>s that read native memory
	/// </summary>
	public sealed unsafe class NativeMemoryDataReaderFactory : DataReaderFactory {
		/// <summary>
		/// The filename or null if the data is not from a file
		/// </summary>
		public override string Filename => filename;

		/// <summary>
		/// Gets the total length of the data
		/// </summary>
		public override uint Length => length;

		DataStream stream;
		string filename;
		uint length;

		NativeMemoryDataReaderFactory(byte* data, uint length, string filename) {
			this.filename = filename;
			this.length = length;
			stream = DataStreamFactory.Create(data);
		}

		internal void SetLength(uint length) => this.length = length;

		/// <summary>
		/// Creates a <see cref="NativeMemoryDataReaderFactory"/> instance
		/// </summary>
		/// <param name="data">Pointer to data</param>
		/// <param name="length">Length of data</param>
		/// <param name="filename">The filename or null if the data is not from a file</param>
		/// <returns></returns>
		public static NativeMemoryDataReaderFactory Create(byte* data, uint length, string filename) {
			if (data is null)
				throw new ArgumentNullException(nameof(data));
			return new NativeMemoryDataReaderFactory(data, length, filename);
		}

		/// <summary>
		/// Creates a data reader
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public override DataReader CreateReader(uint offset, uint length) => CreateReader(stream, offset, length);

		/// <summary>
		/// This method doesn't need to be called since this instance doesn't own the native memory
		/// </summary>
		public override void Dispose() {
			stream = EmptyDataStream.Instance;
			length = 0;
			filename = null;
		}
	}
}





namespace dnlib.IO {
	sealed unsafe class UnalignedByteArrayDataStream : DataStream {
		readonly byte[] data;

		public UnalignedByteArrayDataStream(byte[] data) => this.data = data;

		public override void ReadBytes(uint offset, void* destination, int length) =>
			Marshal.Copy(data, (int)offset, (IntPtr)destination, length);

		public override void ReadBytes(uint offset, byte[] destination, int destinationIndex, int length) =>
			Array.Copy(data, (int)offset, destination, destinationIndex, length);

		public override byte ReadByte(uint offset) => data[(int)offset];

		public override ushort ReadUInt16(uint offset) {
			int i = (int)offset;
			var data = this.data;
			return (ushort)(data[i++] | (data[i] << 8));
		}

		public override uint ReadUInt32(uint offset) {
			fixed (byte* p = data)
				return *(uint*)(p + offset);
		}

		public override ulong ReadUInt64(uint offset) {
			fixed (byte* p = data)
				return *(ulong*)(p + offset);
		}

		public override float ReadSingle(uint offset) {
			fixed (byte* p = data)
				return *(float*)(p + offset);
		}

		public override double ReadDouble(uint offset) {
			fixed (byte* p = data)
				return *(double*)(p + offset);
		}

		public override Guid ReadGuid(uint offset) {
			fixed (byte* p = data)
				return *(Guid*)(p + offset);
		}

		public override string ReadUtf16String(uint offset, int chars) {
			fixed (byte* p = data)
				return new string((char*)(p + offset), 0, chars);
		}

		public override string ReadString(uint offset, int length, Encoding encoding) {
			fixed (byte* p = data)
				return new string((sbyte*)(p + offset), 0, length, encoding);
		}

		public override bool TryGetOffsetOf(uint offset, uint endOffset, byte value, out uint valueOffset) {
			fixed (byte* pd = data) {
				// If this code gets updated, also update the other DataStream implementations

				byte* p = pd + offset;

				uint count = (endOffset - offset) / 4;
				for (uint i = 0; i < count; i++) {
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
				}

				byte* pe = pd + endOffset;
				while (p != pe) {
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
				}
				valueOffset = 0;
				return false;
			}
		}
	}
}





namespace dnlib.IO {
	sealed unsafe class UnalignedNativeMemoryDataStream : DataStream {
		readonly byte* data;

		public UnalignedNativeMemoryDataStream(byte* data) => this.data = data;

		public override void ReadBytes(uint offset, void* destination, int length) {
			var ps = data + offset;
			var pd = (byte*)destination;
			int count = length / 4;
			length = length % 4;
			for (int i = 0; i < count; i++) {
				//TODO: Align one of the pointers. destination is more likely to be aligned
				*(uint*)pd = *(uint*)ps;
				pd += 4;
				ps += 4;
			}
			for (int i = 0; i < length; i++, ps++, pd++)
				*pd = *ps;
		}

		public override void ReadBytes(uint offset, byte[] destination, int destinationIndex, int length) =>
			Marshal.Copy((IntPtr)(data + offset), destination, destinationIndex, length);

		public override byte ReadByte(uint offset) => *(data + offset);
		public override ushort ReadUInt16(uint offset) => *(ushort*)(data + offset);
		public override uint ReadUInt32(uint offset) => *(uint*)(data + offset);
		public override ulong ReadUInt64(uint offset) => *(ulong*)(data + offset);
		public override float ReadSingle(uint offset) => *(float*)(data + offset);
		public override double ReadDouble(uint offset) => *(double*)(data + offset);
		public override Guid ReadGuid(uint offset) => *(Guid*)(data + offset);
		public override string ReadUtf16String(uint offset, int chars) => new string((char*)(data + offset), 0, chars);
		public override string ReadString(uint offset, int length, Encoding encoding) => new string((sbyte*)(data + offset), 0, length, encoding);

		public override bool TryGetOffsetOf(uint offset, uint endOffset, byte value, out uint valueOffset) {
			var pd = data;

			// If this code gets updated, also update the other DataStream implementations

			byte* p = pd + offset;

			uint count = (endOffset - offset) / 4;
			for (uint i = 0; i < count; i++) {
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
			}

			byte* pe = pd + endOffset;
			while (p != pe) {
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
			}
			valueOffset = 0;
			return false;
		}
	}
}





namespace dnlib.IO {
	sealed unsafe class AlignedByteArrayDataStream : DataStream {
		readonly byte[] data;

		public AlignedByteArrayDataStream(byte[] data) => this.data = data;

		public override void ReadBytes(uint offset, void* destination, int length) =>
			Marshal.Copy(data, (int)offset, (IntPtr)destination, length);

		public override void ReadBytes(uint offset, byte[] destination, int destinationIndex, int length) =>
			Array.Copy(data, (int)offset, destination, destinationIndex, length);

		public override byte ReadByte(uint offset) => data[(int)offset];

		public override ushort ReadUInt16(uint offset) {
			int i = (int)offset;
			var data = this.data;
			return (ushort)(data[i++] | (data[i] << 8));
		}

		public override uint ReadUInt32(uint offset) {
			int i = (int)offset;
			var data = this.data;
			return data[i++] | ((uint)data[i++] << 8) | ((uint)data[i++] << 16) | ((uint)data[i] << 24);
		}

		public override ulong ReadUInt64(uint offset) {
			int i = (int)offset;
			var data = this.data;
			return data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |
				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
		}

		public override float ReadSingle(uint offset) {
			int i = (int)offset;
			var data = this.data;
			uint value = data[i++] | ((uint)data[i++] << 8) | ((uint)data[i++] << 16) | ((uint)data[i] << 24);
			return *(float*)&value;
		}

		public override double ReadDouble(uint offset) {
			int i = (int)offset;
			var data = this.data;
			ulong value = data[i++] | ((ulong)data[i++] << 8) | ((ulong)data[i++] << 16) | ((ulong)data[i++] << 24) |
				((ulong)data[i++] << 32) | ((ulong)data[i++] << 40) | ((ulong)data[i++] << 48) | ((ulong)data[i] << 56);
			return *(double*)&value;
		}

		public override string ReadUtf16String(uint offset, int chars) {
			fixed (byte* p = data)
				return new string((char*)(p + offset), 0, chars);
		}

		public override string ReadString(uint offset, int length, Encoding encoding) {
			fixed (byte* p = data)
				return new string((sbyte*)(p + offset), 0, length, encoding);
		}

		public override bool TryGetOffsetOf(uint offset, uint endOffset, byte value, out uint valueOffset) {
			fixed (byte* pd = data) {
				// If this code gets updated, also update the other DataStream implementations

				byte* p = pd + offset;

				uint count = (endOffset - offset) / 4;
				for (uint i = 0; i < count; i++) {
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
				}

				byte* pe = pd + endOffset;
				while (p != pe) {
					if (*p == value) {
						valueOffset = (uint)(p - pd);
						return true;
					}
					p++;
				}
				valueOffset = 0;
				return false;
			}
		}
	}
}





namespace dnlib.IO {
	sealed unsafe class AlignedNativeMemoryDataStream : DataStream {
		readonly byte* data;

		public AlignedNativeMemoryDataStream(byte* data) => this.data = data;

		public override void ReadBytes(uint offset, void* destination, int length) {
			var ps = data + offset;
			var pd = (byte*)destination;
			int count = length / 4;
			length = length % 4;
			for (int i = 0; i < count; i++) {
				*pd = *ps;
				pd++;
				ps++;

				*pd = *ps;
				pd++;
				ps++;

				*pd = *ps;
				pd++;
				ps++;

				*pd = *ps;
				pd++;
				ps++;
			}
			for (int i = 0; i < length; i++, ps++, pd++)
				*pd = *ps;
		}

		public override void ReadBytes(uint offset, byte[] destination, int destinationIndex, int length) =>
			Marshal.Copy((IntPtr)(data + offset), destination, destinationIndex, length);

		public override byte ReadByte(uint offset) => *(data + offset);

		public override ushort ReadUInt16(uint offset) {
			var p = data + offset;
			return (ushort)(*p++ | (*p << 8));
		}

		public override uint ReadUInt32(uint offset) {
			var p = data + offset;
			return *p++ | ((uint)*p++ << 8) | ((uint)*p++ << 16) | ((uint)*p << 24);
		}

		public override ulong ReadUInt64(uint offset) {
			var p = data + offset;
			return *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |
				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
		}

		public override float ReadSingle(uint offset) {
			var p = data + offset;
			uint value = *p++ | ((uint)*p++ << 8) | ((uint)*p++ << 16) | ((uint)*p << 24);
			return *(float*)&value;
		}

		public override double ReadDouble(uint offset) {
			var p = data + offset;
			ulong value = *p++ | ((ulong)*p++ << 8) | ((ulong)*p++ << 16) | ((ulong)*p++ << 24) |
				((ulong)*p++ << 32) | ((ulong)*p++ << 40) | ((ulong)*p++ << 48) | ((ulong)*p << 56);
			return *(double*)&value;
		}

		public override string ReadUtf16String(uint offset, int chars) => new string((char*)(data + offset), 0, chars);
		public override string ReadString(uint offset, int length, Encoding encoding) => new string((sbyte*)(data + offset), 0, length, encoding);

		public override bool TryGetOffsetOf(uint offset, uint endOffset, byte value, out uint valueOffset) {
			var pd = data;

			// If this code gets updated, also update the other DataStream implementations

			byte* p = pd + offset;

			uint count = (endOffset - offset) / 4;
			for (uint i = 0; i < count; i++) {
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
			}

			byte* pe = pd + endOffset;
			while (p != pe) {
				if (*p == value) {
					valueOffset = (uint)(p - pd);
					return true;
				}
				p++;
			}
			valueOffset = 0;
			return false;
		}
	}
}





namespace dnlib.IO {
	/// <summary>
	/// A <see cref="DataReaderFactory"/> that reads from a byte array
	/// </summary>
	public sealed class ByteArrayDataReaderFactory : DataReaderFactory {
		/// <summary>
		/// The filename or null if the data is not from a file
		/// </summary>
		public override string Filename => filename;

		/// <summary>
		/// Gets the total length of the data
		/// </summary>
		public override uint Length => length;

		internal byte[] DataArray => data;
		internal uint DataOffset => 0;

		DataStream stream;
		string filename;
		uint length;
		byte[] data;

		ByteArrayDataReaderFactory(byte[] data, string filename) {
			this.filename = filename;
			length = (uint)data.Length;
			stream = DataStreamFactory.Create(data);
			this.data = data;
		}

		/// <summary>
		/// Creates a <see cref="ByteArrayDataReaderFactory"/> instance
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="filename">The filename or null if the data is not from a file</param>
		/// <returns></returns>
		public static ByteArrayDataReaderFactory Create(byte[] data, string filename) {
			if (data is null)
				throw new ArgumentNullException(nameof(data));
			return new ByteArrayDataReaderFactory(data, filename);
		}

		/// <summary>
		/// Creates a data reader
		/// </summary>
		/// <param name="data">Data</param>
		/// <returns></returns>
		public static DataReader CreateReader(byte[] data) => Create(data, filename: null).CreateReader();

		/// <summary>
		/// Creates a data reader
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public override DataReader CreateReader(uint offset, uint length) => CreateReader(stream, offset, length);

		/// <summary>
		/// This method doesn't need to be called since a <see cref="ByteArrayDataReaderFactory"/> has nothing that must be cleaned up
		/// </summary>
		public override void Dispose() {
			stream = EmptyDataStream.Instance;
			length = 0;
			filename = null;
			data = null;
		}
	}
}





namespace dnlib.IO {
	/// <summary>
	/// Thrown by a <see cref="DataReader"/> when it can't read data or if the caller tries to set an invalid offset
	/// </summary>
	[Serializable]
	public sealed class DataReaderException : IOException {
		internal DataReaderException(string message) : base(message) { }
		internal DataReaderException(SerializationInfo info, StreamingContext context) : base(info, context) { }
	}

	/// <summary>
	/// Reads data
	/// </summary>
	[DebuggerDisplay("{StartOffset,h}-{EndOffset,h} Length={Length} BytesLeft={BytesLeft}")]
	public struct DataReader {
		/// <summary>
		/// Gets the start offset of the data
		/// </summary>
		public readonly uint StartOffset => startOffset;

		/// <summary>
		/// Gets the end offset of the data, not inclusive
		/// </summary>
		public readonly uint EndOffset => endOffset;

		/// <summary>
		/// Gets the total length of the data
		/// </summary>
		public readonly uint Length => endOffset - startOffset;

		/// <summary>
		/// Gets the current offset. This is between <see cref="StartOffset"/> and <see cref="EndOffset"/> (inclusive)
		/// </summary>
		public uint CurrentOffset {
			readonly get => currentOffset;
			set {
				VerifyState();
				if (value < startOffset || value > endOffset) {
					// Invalid offsets should be an IOException and not an ArgumentException
					ThrowDataReaderException("Invalid new " + nameof(CurrentOffset));
				}
				currentOffset = value;
				VerifyState();
			}
		}

		/// <summary>
		/// Gets/sets the position relative to <see cref="StartOffset"/>
		/// </summary>
		public uint Position {
			readonly get => currentOffset - startOffset;
			set {
				VerifyState();
				if (value > Length) {
					// Invalid positions should be an IOException and not an ArgumentException
					ThrowDataReaderException("Invalid new " + nameof(Position));
				}
				currentOffset = startOffset + value;
				VerifyState();
			}
		}

		/// <summary>
		/// Gets the number of bytes that can be read without throwing an exception
		/// </summary>
		public readonly uint BytesLeft => endOffset - currentOffset;

		readonly DataStream stream;
		readonly uint startOffset;
		readonly uint endOffset;
		uint currentOffset;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="stream">Stream</param>
		/// <param name="offset">Start offset of data</param>
		/// <param name="length">Length of data</param>
		public DataReader(DataStream stream, uint offset, uint length) {
			Debug.Assert(stream is not null || (offset == 0 && length == 0));
			Debug.Assert(offset + length >= offset);
			this.stream = stream;
			startOffset = offset;
			endOffset = offset + length;
			currentOffset = offset;
			VerifyState();
		}

		[Conditional("DEBUG")]
		readonly void VerifyState() {
			Debug.Assert(startOffset <= currentOffset);
			Debug.Assert(currentOffset <= endOffset);
		}

		static void ThrowNoMoreBytesLeft() => throw new DataReaderException("There's not enough bytes left to read");
		static void ThrowDataReaderException(string message) => throw new DataReaderException(message);
		static void ThrowInvalidOperationException() => throw new InvalidOperationException();
		static void ThrowArgumentNullException(string paramName) => throw new ArgumentNullException(paramName);
		static void ThrowInvalidArgument(string paramName) => throw new DataReaderException("Invalid argument value");

		/// <summary>
		/// Resets the reader so it points to the start of the data
		/// </summary>
		public void Reset() => currentOffset = startOffset;

		/// <summary>
		/// Creates a new reader that can access a smaller part of this reader
		/// </summary>
		/// <param name="start">Start position relative to <see cref="StartOffset"/></param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public readonly DataReader Slice(uint start, uint length) {
			if ((ulong)start + length > Length)
				ThrowInvalidArgument(nameof(length));
			return new DataReader(stream, startOffset + start, length);
		}

		/// <summary>
		/// Creates a new reader that can access everything from <paramref name="start"/> to the end of the data
		/// </summary>
		/// <param name="start">Start position relative to <see cref="StartOffset"/></param>
		/// <returns></returns>
		public readonly DataReader Slice(uint start) {
			if (start > Length)
				ThrowInvalidArgument(nameof(start));
			return Slice(start, Length - start);
		}

		/// <summary>
		/// Creates a new reader that can access a smaller part of this reader
		/// </summary>
		/// <param name="start">Start position relative to <see cref="StartOffset"/></param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public readonly DataReader Slice(int start, int length) {
			if (start < 0)
				ThrowInvalidArgument(nameof(start));
			if (length < 0)
				ThrowInvalidArgument(nameof(length));
			return Slice((uint)start, (uint)length);
		}

		/// <summary>
		/// Creates a new reader that can access everything from <paramref name="start"/> to the end of the data
		/// </summary>
		/// <param name="start">Start position relative to <see cref="StartOffset"/></param>
		/// <returns></returns>
		public readonly DataReader Slice(int start) {
			if (start < 0)
				ThrowInvalidArgument(nameof(start));
			if ((uint)start > Length)
				ThrowInvalidArgument(nameof(start));
			return Slice((uint)start, Length - (uint)start);
		}

		/// <summary>
		/// Checks if it's possible to read <paramref name="length"/> bytes
		/// </summary>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public readonly bool CanRead(int length) => length >= 0 && (uint)length <= BytesLeft;

		/// <summary>
		/// Checks if it's possible to read <paramref name="length"/> bytes
		/// </summary>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		public readonly bool CanRead(uint length) => length <= BytesLeft;

		/// <summary>
		/// Reads a <see cref="bool"/>
		/// </summary>
		/// <returns></returns>
		public bool ReadBoolean() => ReadByte() != 0;

		/// <summary>
		/// Reads a <see cref="char"/>
		/// </summary>
		/// <returns></returns>
		public char ReadChar() => (char)ReadUInt16();

		/// <summary>
		/// Reads a <see cref="sbyte"/>
		/// </summary>
		/// <returns></returns>
		public sbyte ReadSByte() => (sbyte)ReadByte();

		/// <summary>
		/// Reads a <see cref="byte"/>
		/// </summary>
		/// <returns></returns>
		public byte ReadByte() {
			VerifyState();
			const uint SIZE = 1;
			var currentOffset = this.currentOffset;
			if (currentOffset == endOffset)
				ThrowNoMoreBytesLeft();
			var value = stream.ReadByte(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		/// <summary>
		/// Reads a <see cref="short"/>
		/// </summary>
		/// <returns></returns>
		public short ReadInt16() => (short)ReadUInt16();

		/// <summary>
		/// Reads a <see cref="ushort"/>
		/// </summary>
		/// <returns></returns>
		public ushort ReadUInt16() {
			VerifyState();
			const uint SIZE = 2;
			var currentOffset = this.currentOffset;
			if (endOffset - currentOffset < SIZE)
				ThrowNoMoreBytesLeft();
			var value = stream.ReadUInt16(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		/// <summary>
		/// Reads a <see cref="int"/>
		/// </summary>
		/// <returns></returns>
		public int ReadInt32() => (int)ReadUInt32();

		/// <summary>
		/// Reads a <see cref="uint"/>
		/// </summary>
		/// <returns></returns>
		public uint ReadUInt32() {
			VerifyState();
			const uint SIZE = 4;
			var currentOffset = this.currentOffset;
			if (endOffset - currentOffset < SIZE)
				ThrowNoMoreBytesLeft();
			var value = stream.ReadUInt32(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		internal byte Unsafe_ReadByte() {
			VerifyState();
			const uint SIZE = 1;
			var currentOffset = this.currentOffset;
			Debug.Assert(currentOffset != endOffset);
			var value = stream.ReadByte(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		internal ushort Unsafe_ReadUInt16() {
			VerifyState();
			const uint SIZE = 2;
			var currentOffset = this.currentOffset;
			Debug.Assert(endOffset - currentOffset >= SIZE);
			var value = stream.ReadUInt16(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		internal uint Unsafe_ReadUInt32() {
			VerifyState();
			const uint SIZE = 4;
			var currentOffset = this.currentOffset;
			Debug.Assert(endOffset - currentOffset >= SIZE);
			var value = stream.ReadUInt32(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		/// <summary>
		/// Reads a <see cref="long"/>
		/// </summary>
		/// <returns></returns>
		public long ReadInt64() => (long)ReadUInt64();

		/// <summary>
		/// Reads a <see cref="ulong"/>
		/// </summary>
		/// <returns></returns>
		public ulong ReadUInt64() {
			VerifyState();
			const uint SIZE = 8;
			var currentOffset = this.currentOffset;
			if (endOffset - currentOffset < SIZE)
				ThrowNoMoreBytesLeft();
			var value = stream.ReadUInt64(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		/// <summary>
		/// Reads a <see cref="float"/>
		/// </summary>
		/// <returns></returns>
		public float ReadSingle() {
			VerifyState();
			const uint SIZE = 4;
			var currentOffset = this.currentOffset;
			if (endOffset - currentOffset < SIZE)
				ThrowNoMoreBytesLeft();
			var value = stream.ReadSingle(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		/// <summary>
		/// Reads a <see cref="double"/>
		/// </summary>
		/// <returns></returns>
		public double ReadDouble() {
			VerifyState();
			const uint SIZE = 8;
			var currentOffset = this.currentOffset;
			if (endOffset - currentOffset < SIZE)
				ThrowNoMoreBytesLeft();
			var value = stream.ReadDouble(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		/// <summary>
		/// Reads a <see cref="Guid"/>
		/// </summary>
		/// <returns></returns>
		public Guid ReadGuid() {
			VerifyState();
			const uint SIZE = 16;
			var currentOffset = this.currentOffset;
			if (endOffset - currentOffset < SIZE)
				ThrowNoMoreBytesLeft();
			var value = stream.ReadGuid(currentOffset);
			this.currentOffset = currentOffset + SIZE;
			VerifyState();
			return value;
		}

		/// <summary>
		/// Reads a <see cref="decimal"/>
		/// </summary>
		/// <returns></returns>
		public decimal ReadDecimal() {
			var bits = new int[4] {
				ReadInt32(),	// lo
				ReadInt32(),	// mid
				ReadInt32(),	// hi
				ReadInt32(),	// flags
			};
			return new decimal(bits);
		}

		/// <summary>
		/// Reads a UTF-16 encoded <see cref="string"/>
		/// </summary>
		/// <param name="chars">Number of characters to read</param>
		/// <returns></returns>
		public string ReadUtf16String(int chars) {
			if (chars < 0)
				ThrowInvalidArgument(nameof(chars));
			if (chars == 0)
				return string.Empty;
			VerifyState();
			uint length = (uint)chars * 2;
			var currentOffset = this.currentOffset;
			if (endOffset - currentOffset < length)
				ThrowNoMoreBytesLeft();
			var s = length == 0 ? string.Empty : stream.ReadUtf16String(currentOffset, chars);
			this.currentOffset = currentOffset + length;
			VerifyState();
			return s;
		}

		/// <summary>
		/// Reads bytes
		/// </summary>
		/// <param name="destination">Destination pointer</param>
		/// <param name="length">Number of bytes to read</param>
		public unsafe void ReadBytes(void* destination, int length) {
			if (destination is null && length != 0)
				ThrowArgumentNullException(nameof(destination));
			if (length < 0)
				ThrowInvalidArgument(nameof(length));
			// This is also true if 'this' is the 'default' instance ('stream' is null)
			if (length == 0)
				return;
			VerifyState();
			var currentOffset = this.currentOffset;
			if (endOffset - currentOffset < (uint)length)
				ThrowNoMoreBytesLeft();
			stream.ReadBytes(currentOffset, destination, length);
			this.currentOffset = currentOffset + (uint)length;
			VerifyState();
		}

		/// <summary>
		/// Reads bytes
		/// </summary>
		/// <param name="destination">Destination array</param>
		/// <param name="destinationIndex">Destination index</param>
		/// <param name="length">Number of bytes to read</param>
		public void ReadBytes(byte[] destination, int destinationIndex, int length) {
			if (destination is null)
				ThrowArgumentNullException(nameof(destination));
			if (destinationIndex < 0)
				ThrowInvalidArgument(nameof(destinationIndex));
			if (length < 0)
				ThrowInvalidArgument(nameof(length));
			// This is also true if 'this' is the 'default' instance ('stream' is null)
			if (length == 0)
				return;
			VerifyState();
			var currentOffset = this.currentOffset;
			if (endOffset - currentOffset < (uint)length)
				ThrowNoMoreBytesLeft();
			stream.ReadBytes(currentOffset, destination, destinationIndex, length);
			this.currentOffset = currentOffset + (uint)length;
			VerifyState();
		}

		/// <summary>
		/// Reads bytes
		/// </summary>
		/// <param name="length">Number of bytes to read</param>
		/// <returns></returns>
		public byte[] ReadBytes(int length) {
			if (length < 0)
				ThrowInvalidArgument(nameof(length));
			if (length == 0)
				return Array2.Empty<byte>();
			var data = new byte[length];
			ReadBytes(data, 0, length);
			return data;
		}

		/// <summary>
		/// Reads a compressed <see cref="uint"/>
		/// </summary>
		/// <param name="value">Uncompressed <see cref="uint"/></param>
		/// <returns></returns>
		public bool TryReadCompressedUInt32(out uint value) {
			VerifyState();
			var currentOffset = this.currentOffset;
			var bytesLeft = endOffset - currentOffset;
			if (bytesLeft == 0) {
				value = 0;
				VerifyState();
				return false;
			}

			var stream = this.stream;
			byte b = stream.ReadByte(currentOffset++);
			if ((b & 0x80) == 0) {
				value = b;
				this.currentOffset = currentOffset;
				VerifyState();
				return true;
			}

			if ((b & 0xC0) == 0x80) {
				if (bytesLeft < 2) {
					value = 0;
					VerifyState();
					return false;
				}
				value = (uint)(((b & 0x3F) << 8) | stream.ReadByte(currentOffset++));
				this.currentOffset = currentOffset;
				VerifyState();
				return true;
			}

			// The encoding 111x isn't allowed but the CLR sometimes doesn't verify this
			// and just assumes it's 110x. Don't fail if it's 111x, just assume it's 110x.

			if (bytesLeft < 4) {
				value = 0;
				VerifyState();
				return false;
			}
			value = (uint)(((b & 0x1F) << 24) | (stream.ReadByte(currentOffset++) << 16) |
					(stream.ReadByte(currentOffset++) << 8) | stream.ReadByte(currentOffset++));
			this.currentOffset = currentOffset;
			VerifyState();
			return true;
		}

		/// <summary>
		/// Reads a compressed <see cref="uint"/>
		/// </summary>
		/// <returns></returns>
		public uint ReadCompressedUInt32() {
			if (!TryReadCompressedUInt32(out uint value))
				ThrowNoMoreBytesLeft();
			return value;
		}

		/// <summary>
		/// Reads a compressed <see cref="int"/>
		/// </summary>
		/// <param name="value">Uncompressed <see cref="int"/></param>
		/// <returns></returns>
		public bool TryReadCompressedInt32(out int value) {
			VerifyState();
			var currentOffset = this.currentOffset;
			var bytesLeft = endOffset - currentOffset;
			if (bytesLeft == 0) {
				value = 0;
				VerifyState();
				return false;
			}

			var stream = this.stream;
			byte b = stream.ReadByte(currentOffset++);
			if ((b & 0x80) == 0) {
				if ((b & 1) != 0)
					value = -0x40 | (b >> 1);
				else
					value = (b >> 1);
				this.currentOffset = currentOffset;
				VerifyState();
				return true;
			}

			if ((b & 0xC0) == 0x80) {
				if (bytesLeft < 2) {
					value = 0;
					VerifyState();
					return false;
				}
				uint tmp = (uint)(((b & 0x3F) << 8) | stream.ReadByte(currentOffset++));
				if ((tmp & 1) != 0)
					value = -0x2000 | (int)(tmp >> 1);
				else
					value = (int)(tmp >> 1);
				this.currentOffset = currentOffset;
				VerifyState();
				return true;
			}

			if ((b & 0xE0) == 0xC0) {
				if (bytesLeft < 4) {
					value = 0;
					VerifyState();
					return false;
				}
				uint tmp = (uint)(((b & 0x1F) << 24) | (stream.ReadByte(currentOffset++) << 16) |
						(stream.ReadByte(currentOffset++) << 8) | stream.ReadByte(currentOffset++));
				if ((tmp & 1) != 0)
					value = -0x10000000 | (int)(tmp >> 1);
				else
					value = (int)(tmp >> 1);
				this.currentOffset = currentOffset;
				VerifyState();
				return true;
			}

			value = 0;
			VerifyState();
			return false;
		}

		/// <summary>
		/// Reads a compressed <see cref="int"/>
		/// </summary>
		/// <returns></returns>
		public int ReadCompressedInt32() {
			if (!TryReadCompressedInt32(out int value))
				ThrowNoMoreBytesLeft();
			return value;
		}

		/// <summary>
		/// Reads a 7-bit encoded integer
		/// </summary>
		/// <returns></returns>
		public uint Read7BitEncodedUInt32() {
			uint val = 0;
			int bits = 0;
			for (int i = 0; i < 5; i++) {
				byte b = ReadByte();
				val |= (uint)(b & 0x7F) << bits;
				if ((b & 0x80) == 0)
					return val;
				bits += 7;
			}
			ThrowDataReaderException("Invalid encoded UInt32");
			return 0;
		}

		/// <summary>
		/// Reads a 7-bit encoded integer
		/// </summary>
		/// <returns></returns>
		public int Read7BitEncodedInt32() => (int)Read7BitEncodedUInt32();

		/// <summary>
		/// Reads a serialized UTF-8 string
		/// </summary>
		/// <returns></returns>
		public string ReadSerializedString() => ReadSerializedString(Encoding.UTF8);

		/// <summary>
		/// Reads a serialized string
		/// </summary>
		/// <param name="encoding">Encoding</param>
		/// <returns></returns>
		public string ReadSerializedString(Encoding encoding) {
			if (encoding is null)
				ThrowArgumentNullException(nameof(encoding));
			int length = Read7BitEncodedInt32();
			if (length < 0)
				ThrowNoMoreBytesLeft();
			if (length == 0)
				return string.Empty;
			return ReadString(length, encoding);
		}

		/// <summary>
		/// Returns all data without updating the current position
		/// </summary>
		/// <returns></returns>
		public readonly byte[] ToArray() {
			int length = (int)Length;
			if (length < 0)
				ThrowInvalidOperationException();
			// This is also true if 'this' is the 'default' instance ('stream' is null)
			if (length == 0)
				return Array2.Empty<byte>();
			var data = new byte[length];
			stream.ReadBytes(startOffset, data, 0, data.Length);
			return data;
		}

		/// <summary>
		/// Returns the remaining data
		/// </summary>
		/// <returns></returns>
		public byte[] ReadRemainingBytes() {
			int length = (int)BytesLeft;
			if (length < 0)
				ThrowInvalidOperationException();
			return ReadBytes(length);
		}

		/// <summary>
		/// Reads all bytes until a terminating byte or returns null if <paramref name="value"/> wasn't found.
		/// If found, the current offset is incremented by the length of the returned data
		/// </summary>
		/// <param name="value">Terminating byte value</param>
		/// <returns></returns>
		public byte[] TryReadBytesUntil(byte value) {
			var currentOffset = this.currentOffset;
			var endOffset = this.endOffset;
			// This is also true if 'this' is the 'default' instance ('stream' is null)
			if (currentOffset == endOffset)
				return null;
			if (!stream.TryGetOffsetOf(currentOffset, endOffset, value, out var valueOffset))
				return null;
			int length = (int)(valueOffset - currentOffset);
			if (length < 0)
				return null;
			return ReadBytes(length);
		}

		/// <summary>
		/// Reads a zero-terminated UTF-8 string or returns null if the string couldn't be read.
		/// If successful, the current offset is incremented past the terminating zero.
		/// </summary>
		/// <returns></returns>
		public string TryReadZeroTerminatedUtf8String() => TryReadZeroTerminatedString(Encoding.UTF8);

		/// <summary>
		/// Reads a zero-terminated string or returns null if the string couldn't be read.
		/// If successful, the current offset is incremented past the terminating zero.
		/// </summary>
		/// <param name="encoding">Encoding</param>
		/// <returns></returns>
		public string TryReadZeroTerminatedString(Encoding encoding) {
			if (encoding is null)
				ThrowArgumentNullException(nameof(encoding));
			VerifyState();
			var currentOffset = this.currentOffset;
			var endOffset = this.endOffset;
			// This is also true if 'this' is the 'default' instance ('stream' is null)
			if (currentOffset == endOffset)
				return null;
			if (!stream.TryGetOffsetOf(currentOffset, endOffset, 0, out var valueOffset))
				return null;
			int length = (int)(valueOffset - currentOffset);
			if (length < 0)
				return null;
			var value = length == 0 ? string.Empty : stream.ReadString(currentOffset, length, encoding);
			this.currentOffset = valueOffset + 1;
			VerifyState();
			return value;
		}

		/// <summary>
		/// Reads a UTF-8 encoded string
		/// </summary>
		/// <param name="byteCount">Number of bytes to read (not characters)</param>
		/// <returns></returns>
		public string ReadUtf8String(int byteCount) => ReadString(byteCount, Encoding.UTF8);

		/// <summary>
		/// Reads a string
		/// </summary>
		/// <param name="byteCount">Number of bytes to read (not characters)</param>
		/// <param name="encoding">Encoding</param>
		/// <returns></returns>
		public string ReadString(int byteCount, Encoding encoding) {
			if (byteCount < 0)
				ThrowInvalidArgument(nameof(byteCount));
			if (encoding is null)
				ThrowArgumentNullException(nameof(encoding));
			if (byteCount == 0)
				return string.Empty;
			if ((uint)byteCount > Length)
				ThrowInvalidArgument(nameof(byteCount));
			VerifyState();
			var currentOffset = this.currentOffset;
			var value = stream.ReadString(currentOffset, byteCount, encoding);
			this.currentOffset = currentOffset + (uint)byteCount;
			VerifyState();
			return value;
		}

		/// <summary>
		/// Creates a <see cref="Stream"/> that can access this content. The caller doesn't have to dispose of the returned stream.
		/// </summary>
		/// <returns></returns>
		public readonly Stream AsStream() => new DataReaderStream(this);

		readonly byte[] AllocTempBuffer() => new byte[(int)Math.Min(0x2000, BytesLeft)];

		/// <summary>
		/// Copies the data, starting from <see cref="Position"/>, to <paramref name="destination"/>
		/// </summary>
		/// <param name="destination">Destination</param>
		/// <returns>Number of bytes written</returns>
		public void CopyTo(DataWriter destination) {
			if (destination is null)
				ThrowArgumentNullException(nameof(destination));
			if (Position >= Length)
				return;
			CopyTo(destination.InternalStream, AllocTempBuffer());
		}

		/// <summary>
		/// Copies the data, starting from <see cref="Position"/>, to <paramref name="destination"/>
		/// </summary>
		/// <param name="destination">Destination</param>
		/// <param name="dataBuffer">Temp buffer during writing</param>
		/// <returns>Number of bytes written</returns>
		public void CopyTo(DataWriter destination, byte[] dataBuffer) {
			if (destination is null)
				ThrowArgumentNullException(nameof(destination));
			CopyTo(destination.InternalStream, dataBuffer);
		}

		/// <summary>
		/// Copies the data, starting from <see cref="Position"/>, to <paramref name="destination"/>
		/// </summary>
		/// <param name="destination">Destination</param>
		/// <returns>Number of bytes written</returns>
		public void CopyTo(BinaryWriter destination) {
			if (destination is null)
				ThrowArgumentNullException(nameof(destination));
			if (Position >= Length)
				return;
			CopyTo(destination.BaseStream, AllocTempBuffer());
		}

		/// <summary>
		/// Copies the data, starting from <see cref="Position"/>, to <paramref name="destination"/>
		/// </summary>
		/// <param name="destination">Destination</param>
		/// <param name="dataBuffer">Temp buffer during writing</param>
		/// <returns>Number of bytes written</returns>
		public void CopyTo(BinaryWriter destination, byte[] dataBuffer) {
			if (destination is null)
				ThrowArgumentNullException(nameof(destination));
			CopyTo(destination.BaseStream, dataBuffer);
		}

		/// <summary>
		/// Copies the data, starting from <see cref="Position"/>, to <paramref name="destination"/>
		/// </summary>
		/// <param name="destination">Destination</param>
		/// <returns>Number of bytes written</returns>
		public void CopyTo(Stream destination) {
			if (destination is null)
				ThrowArgumentNullException(nameof(destination));
			if (Position >= Length)
				return;
			CopyTo(destination, AllocTempBuffer());
		}

		/// <summary>
		/// Copies the data, starting from <see cref="Position"/>, to <paramref name="destination"/>
		/// </summary>
		/// <param name="destination">Destination</param>
		/// <param name="dataBuffer">Temp buffer during writing</param>
		/// <returns>Number of bytes written</returns>
		public void CopyTo(Stream destination, byte[] dataBuffer) {
			if (destination is null)
				ThrowArgumentNullException(nameof(destination));
			if (dataBuffer is null)
				ThrowArgumentNullException(nameof(dataBuffer));
			if (Position >= Length)
				return;
			if (dataBuffer.Length == 0)
				ThrowInvalidArgument(nameof(dataBuffer));
			uint lenLeft = BytesLeft;
			while (lenLeft > 0) {
				int num = (int)Math.Min((uint)dataBuffer.Length, lenLeft);
				lenLeft -= (uint)num;
				ReadBytes(dataBuffer, 0, num);
				destination.Write(dataBuffer, 0, num);
			}
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Interface for PE optional header classes
	/// </summary>
	public interface IImageOptionalHeader : IFileSection {
		/// <summary>
		/// Returns the Magic field
		/// </summary>
		ushort Magic { get; }

		/// <summary>
		/// Returns the MajorLinkerVersion field
		/// </summary>
		byte MajorLinkerVersion { get; }

		/// <summary>
		/// Returns the MinorLinkerVersion field
		/// </summary>
		byte MinorLinkerVersion { get; }

		/// <summary>
		/// Returns the SizeOfCode field
		/// </summary>
		uint SizeOfCode { get; }

		/// <summary>
		/// Returns the SizeOfInitializedData field
		/// </summary>
		uint SizeOfInitializedData { get; }

		/// <summary>
		/// Returns the SizeOfUninitializedData field
		/// </summary>
		uint SizeOfUninitializedData { get; }

		/// <summary>
		/// Returns the AddressOfEntryPoint field
		/// </summary>
		RVA AddressOfEntryPoint { get; }

		/// <summary>
		/// Returns the BaseOfCode field
		/// </summary>
		RVA BaseOfCode { get; }

		/// <summary>
		/// Returns the BaseOfData field
		/// </summary>
		RVA BaseOfData { get; }

		/// <summary>
		/// Returns the ImageBase field
		/// </summary>
		ulong ImageBase { get; }

		/// <summary>
		/// Returns the SectionAlignment field
		/// </summary>
		uint SectionAlignment { get; }

		/// <summary>
		/// Returns the FileAlignment field
		/// </summary>
		uint FileAlignment { get; }

		/// <summary>
		/// Returns the MajorOperatingSystemVersion field
		/// </summary>
		ushort MajorOperatingSystemVersion { get; }

		/// <summary>
		/// Returns the MinorOperatingSystemVersion field
		/// </summary>
		ushort MinorOperatingSystemVersion { get; }

		/// <summary>
		/// Returns the MajorImageVersion field
		/// </summary>
		ushort MajorImageVersion { get; }

		/// <summary>
		/// Returns the MinorImageVersion field
		/// </summary>
		ushort MinorImageVersion { get; }

		/// <summary>
		/// Returns the MajorSubsystemVersion field
		/// </summary>
		ushort MajorSubsystemVersion { get; }

		/// <summary>
		/// Returns the MinorSubsystemVersion field
		/// </summary>
		ushort MinorSubsystemVersion { get; }

		/// <summary>
		/// Returns the Win32VersionValue field
		/// </summary>
		uint Win32VersionValue { get; }

		/// <summary>
		/// Returns the SizeOfImage field
		/// </summary>
		uint SizeOfImage { get; }

		/// <summary>
		/// Returns the SizeOfHeaders field
		/// </summary>
		uint SizeOfHeaders { get; }

		/// <summary>
		/// Returns the CheckSum field
		/// </summary>
		uint CheckSum { get; }

		/// <summary>
		/// Returns the Subsystem field
		/// </summary>
		Subsystem Subsystem { get; }

		/// <summary>
		/// Returns the DllCharacteristics field
		/// </summary>
		DllCharacteristics DllCharacteristics { get; }

		/// <summary>
		/// Returns the SizeOfStackReserve field
		/// </summary>
		ulong SizeOfStackReserve { get; }

		/// <summary>
		/// Returns the SizeOfStackCommit field
		/// </summary>
		ulong SizeOfStackCommit { get; }

		/// <summary>
		/// Returns the SizeOfHeapReserve field
		/// </summary>
		ulong SizeOfHeapReserve { get; }

		/// <summary>
		/// Returns the SizeOfHeapCommit field
		/// </summary>
		ulong SizeOfHeapCommit { get; }

		/// <summary>
		/// Returns the LoaderFlags field
		/// </summary>
		uint LoaderFlags { get; }

		/// <summary>
		/// Returns the NumberOfRvaAndSizes field
		/// </summary>
		uint NumberOfRvaAndSizes { get; }

		/// <summary>
		/// Returns the DataDirectories field. This array contains exactly 16 elements.
		/// </summary>
		ImageDataDirectory[] DataDirectories { get; }
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_DATA_DIRECTORY PE section
	/// </summary>
	[DebuggerDisplay("{virtualAddress} {dataSize}")]
	public sealed class ImageDataDirectory : FileSection {
		readonly RVA virtualAddress;
		readonly uint dataSize;

		/// <summary>
		/// Returns the IMAGE_DATA_DIRECTORY.VirtualAddress field
		/// </summary>
		public RVA VirtualAddress => virtualAddress;

		/// <summary>
		/// Returns the IMAGE_DATA_DIRECTORY.Size field
		/// </summary>
		public uint Size => dataSize;

		/// <summary>
		/// Default constructor
		/// </summary>
		public ImageDataDirectory() {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageDataDirectory(ref DataReader reader, bool verify) {
			SetStartOffset(ref reader);
			virtualAddress = (RVA)reader.ReadUInt32();
			dataSize = reader.ReadUInt32();
			SetEndoffset(ref reader);
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// A <c>IMAGE_DEBUG_DIRECTORY</c>
	/// </summary>
	[DebuggerDisplay("{type}: TS:{timeDateStamp,h} V:{majorVersion,d}.{minorVersion,d} SZ:{sizeOfData} RVA:{addressOfRawData,h} FO:{pointerToRawData,h}")]
	public sealed class ImageDebugDirectory : FileSection {
		readonly uint characteristics;
		readonly uint timeDateStamp;
		readonly ushort majorVersion;
		readonly ushort minorVersion;
		readonly ImageDebugType type;
		readonly uint sizeOfData;
		readonly uint addressOfRawData;
		readonly uint pointerToRawData;

		/// <summary>
		/// Gets the characteristics (reserved)
		/// </summary>
		public uint Characteristics => characteristics;

		/// <summary>
		/// Gets the timestamp
		/// </summary>
		public uint TimeDateStamp => timeDateStamp;

		/// <summary>
		/// Gets the major version
		/// </summary>
		public ushort MajorVersion => majorVersion;

		/// <summary>
		/// Gets the minor version
		/// </summary>
		public ushort MinorVersion => minorVersion;

		/// <summary>
		/// Gets the type
		/// </summary>
		public ImageDebugType Type => type;

		/// <summary>
		/// Gets the size of data
		/// </summary>
		public uint SizeOfData => sizeOfData;

		/// <summary>
		/// RVA of the data
		/// </summary>
		public RVA AddressOfRawData => (RVA)addressOfRawData;

		/// <summary>
		/// File offset of the data
		/// </summary>
		public FileOffset PointerToRawData => (FileOffset)pointerToRawData;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageDebugDirectory(ref DataReader reader, bool verify) {
			SetStartOffset(ref reader);
			characteristics = reader.ReadUInt32();
			timeDateStamp = reader.ReadUInt32();
			majorVersion = reader.ReadUInt16();
			minorVersion = reader.ReadUInt16();
			type = (ImageDebugType)reader.ReadUInt32();
			sizeOfData = reader.ReadUInt32();
			addressOfRawData = reader.ReadUInt32();
			pointerToRawData = reader.ReadUInt32();
			SetEndoffset(ref reader);
		}
	}
}




namespace dnlib.PE {
	/// <summary>
	/// Image debug type, see <c>IMAGE_DEBUG_TYPE_*</c> in winnt.n
	/// </summary>
	public enum ImageDebugType : uint {
#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
		Unknown = 0,
		Coff = 1,

		/// <summary>
		/// Contains PDB info
		/// </summary>
		CodeView = 2,

		FPO = 3,
		Misc = 4,
		Exception = 5,
		Fixup = 6,
		OmapToSrc = 7,
		OmapFromSrc = 8,
		Borland = 9,
		Reserved10 = 10,
		CLSID = 11,
		VcFeature = 12,
		POGO = 13,
		ILTCG = 14,
		MPX = 15,

		/// <summary>
		/// It's a deterministic (reproducible) PE file
		/// </summary>
		Reproducible = 16,

		/// <summary>
		/// Embedded portable PDB data
		/// </summary>
		EmbeddedPortablePdb = 17,

		/// <summary>
		/// Checksum of the PDB file. 0 or more entries allowed.
		/// </summary>
		PdbChecksum = 19,
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_DOS_HEADER PE section
	/// </summary>
	public sealed class ImageDosHeader : FileSection {
		readonly uint ntHeadersOffset;

		/// <summary>
		/// File offset of the NT headers
		/// </summary>
		public uint NTHeadersOffset => ntHeadersOffset;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageDosHeader(ref DataReader reader, bool verify) {
			SetStartOffset(ref reader);
			ushort sig = reader.ReadUInt16();
			if (verify && sig != 0x5A4D)
				throw new BadImageFormatException("Invalid DOS signature");
			reader.Position = (uint)startOffset + 0x3C;
			ntHeadersOffset = reader.ReadUInt32();
			SetEndoffset(ref reader);
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_FILE_HEADER PE section
	/// </summary>
	public sealed class ImageFileHeader : FileSection {
		readonly Machine machine;
		readonly ushort numberOfSections;
		readonly uint timeDateStamp;
		readonly uint pointerToSymbolTable;
		readonly uint numberOfSymbols;
		readonly ushort sizeOfOptionalHeader;
		readonly Characteristics characteristics;

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.Machine field
		/// </summary>
		public Machine Machine => machine;

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.NumberOfSections field
		/// </summary>
		public int NumberOfSections => numberOfSections;

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.TimeDateStamp field
		/// </summary>
		public uint TimeDateStamp => timeDateStamp;

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.PointerToSymbolTable field
		/// </summary>
		public uint PointerToSymbolTable => pointerToSymbolTable;

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.NumberOfSymbols field
		/// </summary>
		public uint NumberOfSymbols => numberOfSymbols;

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.SizeOfOptionalHeader field
		/// </summary>
		public uint SizeOfOptionalHeader => sizeOfOptionalHeader;

		/// <summary>
		/// Returns the IMAGE_FILE_HEADER.Characteristics field
		/// </summary>
		public Characteristics Characteristics => characteristics;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageFileHeader(ref DataReader reader, bool verify) {
			SetStartOffset(ref reader);
			machine = (Machine)reader.ReadUInt16();
			numberOfSections = reader.ReadUInt16();
			timeDateStamp = reader.ReadUInt32();
			pointerToSymbolTable = reader.ReadUInt32();
			numberOfSymbols = reader.ReadUInt32();
			sizeOfOptionalHeader = reader.ReadUInt16();
			characteristics = (Characteristics)reader.ReadUInt16();
			SetEndoffset(ref reader);
			if (verify && sizeOfOptionalHeader == 0)
				throw new BadImageFormatException("Invalid SizeOfOptionalHeader");
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_NT_HEADERS PE section
	/// </summary>
	public sealed class ImageNTHeaders : FileSection {
		readonly uint signature;
		readonly ImageFileHeader imageFileHeader;
		readonly IImageOptionalHeader imageOptionalHeader;

		/// <summary>
		/// Returns the IMAGE_NT_HEADERS.Signature field
		/// </summary>
		public uint Signature => signature;

		/// <summary>
		/// Returns the IMAGE_NT_HEADERS.FileHeader field
		/// </summary>
		public ImageFileHeader FileHeader => imageFileHeader;

		/// <summary>
		/// Returns the IMAGE_NT_HEADERS.OptionalHeader field
		/// </summary>
		public IImageOptionalHeader OptionalHeader => imageOptionalHeader;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageNTHeaders(ref DataReader reader, bool verify) {
			SetStartOffset(ref reader);
			signature = reader.ReadUInt32();
			// Mono only checks the low 2 bytes
			if (verify && (ushort)signature != 0x4550)
				throw new BadImageFormatException("Invalid NT headers signature");
			imageFileHeader = new ImageFileHeader(ref reader, verify);
			imageOptionalHeader = CreateImageOptionalHeader(ref reader, verify);
			SetEndoffset(ref reader);
		}

		/// <summary>
		/// Creates an IImageOptionalHeader
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of the optional header</param>
		/// <param name="verify">Verify section</param>
		/// <returns>The created IImageOptionalHeader</returns>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		IImageOptionalHeader CreateImageOptionalHeader(ref DataReader reader, bool verify) {
			ushort magic = reader.ReadUInt16();
			reader.Position -= 2;
			return magic switch {
				0x010B => new ImageOptionalHeader32(ref reader, imageFileHeader.SizeOfOptionalHeader, verify),
				0x020B => new ImageOptionalHeader64(ref reader, imageFileHeader.SizeOfOptionalHeader, verify),
				_ => throw new BadImageFormatException("Invalid optional header magic"),
			};
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_OPTIONAL_HEADER (32-bit) PE section
	/// </summary>
	public sealed class ImageOptionalHeader32 : FileSection, IImageOptionalHeader {
		readonly ushort magic;
		readonly byte majorLinkerVersion;
		readonly byte minorLinkerVersion;
		readonly uint sizeOfCode;
		readonly uint sizeOfInitializedData;
		readonly uint sizeOfUninitializedData;
		readonly RVA addressOfEntryPoint;
		readonly RVA baseOfCode;
		readonly RVA baseOfData;
		readonly uint imageBase;
		readonly uint sectionAlignment;
		readonly uint fileAlignment;
		readonly ushort majorOperatingSystemVersion;
		readonly ushort minorOperatingSystemVersion;
		readonly ushort majorImageVersion;
		readonly ushort minorImageVersion;
		readonly ushort majorSubsystemVersion;
		readonly ushort minorSubsystemVersion;
		readonly uint win32VersionValue;
		readonly uint sizeOfImage;
		readonly uint sizeOfHeaders;
		readonly uint checkSum;
		readonly Subsystem subsystem;
		readonly DllCharacteristics dllCharacteristics;
		readonly uint sizeOfStackReserve;
		readonly uint sizeOfStackCommit;
		readonly uint sizeOfHeapReserve;
		readonly uint sizeOfHeapCommit;
		readonly uint loaderFlags;
		readonly uint numberOfRvaAndSizes;
		readonly ImageDataDirectory[] dataDirectories = new ImageDataDirectory[16];

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.Magic field
		/// </summary>
		public ushort Magic => magic;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MajorLinkerVersion field
		/// </summary>
		public byte MajorLinkerVersion => majorLinkerVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MinorLinkerVersion field
		/// </summary>
		public byte MinorLinkerVersion => minorLinkerVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfCode field
		/// </summary>
		public uint SizeOfCode => sizeOfCode;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfInitializedData field
		/// </summary>
		public uint SizeOfInitializedData => sizeOfInitializedData;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfUninitializedData field
		/// </summary>
		public uint SizeOfUninitializedData => sizeOfUninitializedData;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.AddressOfEntryPoint field
		/// </summary>
		public RVA AddressOfEntryPoint => addressOfEntryPoint;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.BaseOfCode field
		/// </summary>
		public RVA BaseOfCode => baseOfCode;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.BaseOfData field
		/// </summary>
		public RVA BaseOfData => baseOfData;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.ImageBase field
		/// </summary>
		public ulong ImageBase => imageBase;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SectionAlignment field
		/// </summary>
		public uint SectionAlignment => sectionAlignment;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.FileAlignment field
		/// </summary>
		public uint FileAlignment => fileAlignment;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MajorOperatingSystemVersion field
		/// </summary>
		public ushort MajorOperatingSystemVersion => majorOperatingSystemVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MinorOperatingSystemVersion field
		/// </summary>
		public ushort MinorOperatingSystemVersion => minorOperatingSystemVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MajorImageVersion field
		/// </summary>
		public ushort MajorImageVersion => majorImageVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MinorImageVersion field
		/// </summary>
		public ushort MinorImageVersion => minorImageVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MajorSubsystemVersion field
		/// </summary>
		public ushort MajorSubsystemVersion => majorSubsystemVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.MinorSubsystemVersion field
		/// </summary>
		public ushort MinorSubsystemVersion => minorSubsystemVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.Win32VersionValue field
		/// </summary>
		public uint Win32VersionValue => win32VersionValue;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfImage field
		/// </summary>
		public uint SizeOfImage => sizeOfImage;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfHeaders field
		/// </summary>
		public uint SizeOfHeaders => sizeOfHeaders;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.CheckSum field
		/// </summary>
		public uint CheckSum => checkSum;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.Subsystem field
		/// </summary>
		public Subsystem Subsystem => subsystem;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.DllCharacteristics field
		/// </summary>
		public DllCharacteristics DllCharacteristics => dllCharacteristics;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfStackReserve field
		/// </summary>
		public ulong SizeOfStackReserve => sizeOfStackReserve;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfStackCommit field
		/// </summary>
		public ulong SizeOfStackCommit => sizeOfStackCommit;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfHeapReserve field
		/// </summary>
		public ulong SizeOfHeapReserve => sizeOfHeapReserve;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.SizeOfHeapCommit field
		/// </summary>
		public ulong SizeOfHeapCommit => sizeOfHeapCommit;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.LoaderFlags field
		/// </summary>
		public uint LoaderFlags => loaderFlags;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.NumberOfRvaAndSizes field
		/// </summary>
		public uint NumberOfRvaAndSizes => numberOfRvaAndSizes;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER.DataDirectories field
		/// </summary>
		public ImageDataDirectory[] DataDirectories => dataDirectories;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="totalSize">Total size of this optional header (from the file header)</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageOptionalHeader32(ref DataReader reader, uint totalSize, bool verify) {
			if (totalSize < 0x60)
				throw new BadImageFormatException("Invalid optional header size");
			if (verify && (ulong)reader.Position + totalSize > reader.Length)
				throw new BadImageFormatException("Invalid optional header size");
			SetStartOffset(ref reader);
			magic = reader.ReadUInt16();
			majorLinkerVersion = reader.ReadByte();
			minorLinkerVersion = reader.ReadByte();
			sizeOfCode = reader.ReadUInt32();
			sizeOfInitializedData = reader.ReadUInt32();
			sizeOfUninitializedData = reader.ReadUInt32();
			addressOfEntryPoint = (RVA)reader.ReadUInt32();
			baseOfCode = (RVA)reader.ReadUInt32();
			baseOfData = (RVA)reader.ReadUInt32();
			imageBase = reader.ReadUInt32();
			sectionAlignment = reader.ReadUInt32();
			fileAlignment = reader.ReadUInt32();
			majorOperatingSystemVersion = reader.ReadUInt16();
			minorOperatingSystemVersion = reader.ReadUInt16();
			majorImageVersion = reader.ReadUInt16();
			minorImageVersion = reader.ReadUInt16();
			majorSubsystemVersion = reader.ReadUInt16();
			minorSubsystemVersion = reader.ReadUInt16();
			win32VersionValue = reader.ReadUInt32();
			sizeOfImage = reader.ReadUInt32();
			sizeOfHeaders = reader.ReadUInt32();
			checkSum = reader.ReadUInt32();
			subsystem = (Subsystem)reader.ReadUInt16();
			dllCharacteristics = (DllCharacteristics)reader.ReadUInt16();
			sizeOfStackReserve = reader.ReadUInt32();
			sizeOfStackCommit = reader.ReadUInt32();
			sizeOfHeapReserve = reader.ReadUInt32();
			sizeOfHeapCommit = reader.ReadUInt32();
			loaderFlags = reader.ReadUInt32();
			numberOfRvaAndSizes = reader.ReadUInt32();
			for (int i = 0; i < dataDirectories.Length; i++) {
				uint len = reader.Position - (uint)startOffset;
				if (len + 8 <= totalSize)
					dataDirectories[i] = new ImageDataDirectory(ref reader, verify);
				else
					dataDirectories[i] = new ImageDataDirectory();
			}
			reader.Position = (uint)startOffset + totalSize;
			SetEndoffset(ref reader);
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_OPTIONAL_HEADER64 PE section
	/// </summary>
	public sealed class ImageOptionalHeader64 : FileSection, IImageOptionalHeader {
		readonly ushort magic;
		readonly byte majorLinkerVersion;
		readonly byte minorLinkerVersion;
		readonly uint sizeOfCode;
		readonly uint sizeOfInitializedData;
		readonly uint sizeOfUninitializedData;
		readonly RVA addressOfEntryPoint;
		readonly RVA baseOfCode;
		readonly ulong imageBase;
		readonly uint sectionAlignment;
		readonly uint fileAlignment;
		readonly ushort majorOperatingSystemVersion;
		readonly ushort minorOperatingSystemVersion;
		readonly ushort majorImageVersion;
		readonly ushort minorImageVersion;
		readonly ushort majorSubsystemVersion;
		readonly ushort minorSubsystemVersion;
		readonly uint win32VersionValue;
		readonly uint sizeOfImage;
		readonly uint sizeOfHeaders;
		readonly uint checkSum;
		readonly Subsystem subsystem;
		readonly DllCharacteristics dllCharacteristics;
		readonly ulong sizeOfStackReserve;
		readonly ulong sizeOfStackCommit;
		readonly ulong sizeOfHeapReserve;
		readonly ulong sizeOfHeapCommit;
		readonly uint loaderFlags;
		readonly uint numberOfRvaAndSizes;
		readonly ImageDataDirectory[] dataDirectories = new ImageDataDirectory[16];

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.Magic field
		/// </summary>
		public ushort Magic => magic;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MajorLinkerVersion field
		/// </summary>
		public byte MajorLinkerVersion => majorLinkerVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MinorLinkerVersion field
		/// </summary>
		public byte MinorLinkerVersion => minorLinkerVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfCode field
		/// </summary>
		public uint SizeOfCode => sizeOfCode;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfInitializedData field
		/// </summary>
		public uint SizeOfInitializedData => sizeOfInitializedData;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfUninitializedData field
		/// </summary>
		public uint SizeOfUninitializedData => sizeOfUninitializedData;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.AddressOfEntryPoint field
		/// </summary>
		public RVA AddressOfEntryPoint => addressOfEntryPoint;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.BaseOfCode field
		/// </summary>
		public RVA BaseOfCode => baseOfCode;

		/// <summary>
		/// Returns 0 since BaseOfData is not present in IMAGE_OPTIONAL_HEADER64
		/// </summary>
		public RVA BaseOfData => 0;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.ImageBase field
		/// </summary>
		public ulong ImageBase => imageBase;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SectionAlignment field
		/// </summary>
		public uint SectionAlignment => sectionAlignment;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.FileAlignment field
		/// </summary>
		public uint FileAlignment => fileAlignment;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MajorOperatingSystemVersion field
		/// </summary>
		public ushort MajorOperatingSystemVersion => majorOperatingSystemVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MinorOperatingSystemVersion field
		/// </summary>
		public ushort MinorOperatingSystemVersion => minorOperatingSystemVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MajorImageVersion field
		/// </summary>
		public ushort MajorImageVersion => majorImageVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MinorImageVersion field
		/// </summary>
		public ushort MinorImageVersion => minorImageVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MajorSubsystemVersion field
		/// </summary>
		public ushort MajorSubsystemVersion => majorSubsystemVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.MinorSubsystemVersion field
		/// </summary>
		public ushort MinorSubsystemVersion => minorSubsystemVersion;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.Win32VersionValue field
		/// </summary>
		public uint Win32VersionValue => win32VersionValue;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfImage field
		/// </summary>
		public uint SizeOfImage => sizeOfImage;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfHeaders field
		/// </summary>
		public uint SizeOfHeaders => sizeOfHeaders;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.CheckSum field
		/// </summary>
		public uint CheckSum => checkSum;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.Subsystem field
		/// </summary>
		public Subsystem Subsystem => subsystem;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.DllCharacteristics field
		/// </summary>
		public DllCharacteristics DllCharacteristics => dllCharacteristics;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfStackReserve field
		/// </summary>
		public ulong SizeOfStackReserve => sizeOfStackReserve;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfStackCommit field
		/// </summary>
		public ulong SizeOfStackCommit => sizeOfStackCommit;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfHeapReserve field
		/// </summary>
		public ulong SizeOfHeapReserve => sizeOfHeapReserve;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.SizeOfHeapCommit field
		/// </summary>
		public ulong SizeOfHeapCommit => sizeOfHeapCommit;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.LoaderFlags field
		/// </summary>
		public uint LoaderFlags => loaderFlags;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.NumberOfRvaAndSizes field
		/// </summary>
		public uint NumberOfRvaAndSizes => numberOfRvaAndSizes;

		/// <summary>
		/// Returns the IMAGE_OPTIONAL_HEADER64.DataDirectories field
		/// </summary>
		public ImageDataDirectory[] DataDirectories => dataDirectories;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="totalSize">Total size of this optional header (from the file header)</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageOptionalHeader64(ref DataReader reader, uint totalSize, bool verify) {
			if (totalSize < 0x70)
				throw new BadImageFormatException("Invalid optional header size");
			if (verify && (ulong)reader.Position + totalSize > reader.Length)
				throw new BadImageFormatException("Invalid optional header size");
			SetStartOffset(ref reader);
			magic = reader.ReadUInt16();
			majorLinkerVersion = reader.ReadByte();
			minorLinkerVersion = reader.ReadByte();
			sizeOfCode = reader.ReadUInt32();
			sizeOfInitializedData = reader.ReadUInt32();
			sizeOfUninitializedData = reader.ReadUInt32();
			addressOfEntryPoint = (RVA)reader.ReadUInt32();
			baseOfCode = (RVA)reader.ReadUInt32();
			imageBase = reader.ReadUInt64();
			sectionAlignment = reader.ReadUInt32();
			fileAlignment = reader.ReadUInt32();
			majorOperatingSystemVersion = reader.ReadUInt16();
			minorOperatingSystemVersion = reader.ReadUInt16();
			majorImageVersion = reader.ReadUInt16();
			minorImageVersion = reader.ReadUInt16();
			majorSubsystemVersion = reader.ReadUInt16();
			minorSubsystemVersion = reader.ReadUInt16();
			win32VersionValue = reader.ReadUInt32();
			sizeOfImage = reader.ReadUInt32();
			sizeOfHeaders = reader.ReadUInt32();
			checkSum = reader.ReadUInt32();
			subsystem = (Subsystem)reader.ReadUInt16();
			dllCharacteristics = (DllCharacteristics)reader.ReadUInt16();
			sizeOfStackReserve = reader.ReadUInt64();
			sizeOfStackCommit = reader.ReadUInt64();
			sizeOfHeapReserve = reader.ReadUInt64();
			sizeOfHeapCommit = reader.ReadUInt64();
			loaderFlags = reader.ReadUInt32();
			numberOfRvaAndSizes = reader.ReadUInt32();
			for (int i = 0; i < dataDirectories.Length; i++) {
				uint len = reader.Position - (uint)startOffset;
				if (len + 8 <= totalSize)
					dataDirectories[i] = new ImageDataDirectory(ref reader, verify);
				else
					dataDirectories[i] = new ImageDataDirectory();
			}
			reader.Position = (uint)startOffset + totalSize;
			SetEndoffset(ref reader);
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Represents the IMAGE_SECTION_HEADER PE section
	/// </summary>
	[DebuggerDisplay("RVA:{virtualAddress} VS:{virtualSize} FO:{pointerToRawData} FS:{sizeOfRawData} {displayName}")]
	public sealed class ImageSectionHeader : FileSection {
		readonly string displayName;
		readonly byte[] name;
		readonly uint virtualSize;
		readonly RVA virtualAddress;
		readonly uint sizeOfRawData;
		readonly uint pointerToRawData;
		readonly uint pointerToRelocations;
		readonly uint pointerToLinenumbers;
		readonly ushort numberOfRelocations;
		readonly ushort numberOfLinenumbers;
		readonly uint characteristics;

		/// <summary>
		/// Returns the human readable section name, ignoring everything after
		/// the first nul byte
		/// </summary>
		public string DisplayName => displayName;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.Name field
		/// </summary>
		public byte[] Name => name;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.VirtualSize field
		/// </summary>
		public uint VirtualSize => virtualSize;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.VirtualAddress field
		/// </summary>
		public RVA VirtualAddress => virtualAddress;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.SizeOfRawData field
		/// </summary>
		public uint SizeOfRawData => sizeOfRawData;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.PointerToRawData field
		/// </summary>
		public uint PointerToRawData => pointerToRawData;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.PointerToRelocations field
		/// </summary>
		public uint PointerToRelocations => pointerToRelocations;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.PointerToLinenumbers field
		/// </summary>
		public uint PointerToLinenumbers => pointerToLinenumbers;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.NumberOfRelocations field
		/// </summary>
		public ushort NumberOfRelocations => numberOfRelocations;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.NumberOfLinenumbers field
		/// </summary>
		public ushort NumberOfLinenumbers => numberOfLinenumbers;

		/// <summary>
		/// Returns the IMAGE_SECTION_HEADER.Characteristics field
		/// </summary>
		public uint Characteristics => characteristics;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify section</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public ImageSectionHeader(ref DataReader reader, bool verify) {
			SetStartOffset(ref reader);
			name = reader.ReadBytes(8);
			virtualSize = reader.ReadUInt32();
			virtualAddress = (RVA)reader.ReadUInt32();
			sizeOfRawData = reader.ReadUInt32();
			pointerToRawData = reader.ReadUInt32();
			pointerToRelocations = reader.ReadUInt32();
			pointerToLinenumbers = reader.ReadUInt32();
			numberOfRelocations = reader.ReadUInt16();
			numberOfLinenumbers = reader.ReadUInt16();
			characteristics = reader.ReadUInt32();
			SetEndoffset(ref reader);
			displayName = ToString(name);
		}

		static string ToString(byte[] name) {
			var sb = new StringBuilder(name.Length);
			foreach (var b in name) {
				if (b == 0)
					break;
				sb.Append((char)b);
			}
			return sb.ToString();
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Converts <see cref="RVA"/>s to/from <see cref="FileOffset"/>s
	/// </summary>
	public interface IRvaFileOffsetConverter {
		/// <summary>
		/// Converts a <see cref="FileOffset"/> to an <see cref="RVA"/>, returns 0 if out of range
		/// </summary>
		/// <param name="offset">The file offset to convert</param>
		/// <returns>The RVA</returns>
		RVA ToRVA(FileOffset offset);

		/// <summary>
		/// Converts an <see cref="RVA"/> to a <see cref="FileOffset"/>, returns 0 if out of range
		/// </summary>
		/// <param name="rva">The RVA to convert</param>
		/// <returns>The file offset</returns>
		FileOffset ToFileOffset(RVA rva);
	}

	/// <summary>
	/// Interface to access a PE image
	/// </summary>
	public interface IPEImage : IRvaFileOffsetConverter, IDisposable {
		/// <summary>
		/// <c>true</c> if image layout is the same as the raw PE image layout, <c>false</c>
		/// if it's the same layout as a PE image loaded by the OS PE loader.
		/// </summary>
		bool IsFileImageLayout { get; }

		/// <summary>
		/// <c>true</c> if some of the memory where the image is located could be unavailable.
		/// This could happen if it's been loaded by the OS loader.
		/// </summary>
		bool MayHaveInvalidAddresses { get; }

		/// <summary>
		/// The filename or null if the data is not from a file
		/// </summary>
		string Filename { get; }

		/// <summary>
		/// Returns the DOS header
		/// </summary>
		ImageDosHeader ImageDosHeader { get; }

		/// <summary>
		/// Returns the NT headers
		/// </summary>
		ImageNTHeaders ImageNTHeaders { get; }

		/// <summary>
		/// Returns the section headers
		/// </summary>
		IList<ImageSectionHeader> ImageSectionHeaders { get; }

		/// <summary>
		/// Returns the debug directories
		/// </summary>
		IList<ImageDebugDirectory> ImageDebugDirectories { get; }

		/// <summary>
		/// Gets/sets the Win32 resources. This is <c>null</c> if there are no Win32 resources.
		/// </summary>
		Win32Resources Win32Resources { get; set; }

		/// <summary>
		/// Gets the <see cref="DataReader"/> factory
		/// </summary>
		DataReaderFactory DataReaderFactory { get; }

		/// <summary>
		/// Creates a <see cref="DataReader"/> from <paramref name="offset"/> to the end of the image
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <returns></returns>
		DataReader CreateReader(FileOffset offset);

		/// <summary>
		/// Creates a <see cref="DataReader"/>
		/// </summary>
		/// <param name="offset">Offset of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		DataReader CreateReader(FileOffset offset, uint length);

		/// <summary>
		/// Creates a <see cref="DataReader"/> from <paramref name="rva"/> to the end of the image
		/// </summary>
		/// <param name="rva">RVA of data</param>
		/// <returns></returns>
		DataReader CreateReader(RVA rva);

		/// <summary>
		/// Creates a <see cref="DataReader"/>
		/// </summary>
		/// <param name="rva">RVA of data</param>
		/// <param name="length">Length of data</param>
		/// <returns></returns>
		DataReader CreateReader(RVA rva, uint length);

		/// <summary>
		/// Creates a <see cref="DataReader"/> that can read the whole image
		/// </summary>
		/// <returns></returns>
		DataReader CreateReader();
	}

	/// <summary>
	/// Interface to access a PE image
	/// </summary>
	public interface IInternalPEImage : IPEImage {
		/// <summary>
		/// Call this to disable memory mapped I/O if it was used to open the file. This must only
		/// be called if no other code is trying to access the memory since that could lead to an
		/// exception.
		/// </summary>
		void UnsafeDisableMemoryMappedIO();

		/// <summary>
		/// <c>true</c> if memory mapped I/O is enabled
		/// </summary>
		bool IsMemoryMappedIO { get; }
	}

	public static partial class PEExtensions {
		/// <summary>
		/// Finds a <see cref="ResourceData"/>
		/// </summary>
		/// <param name="self">this</param>
		/// <param name="type">Type</param>
		/// <param name="name">Name</param>
		/// <param name="langId">Language ID</param>
		/// <returns>The <see cref="ResourceData"/> or <c>null</c> if none found</returns>
		public static ResourceData FindWin32ResourceData(this IPEImage self, ResourceName type, ResourceName name, ResourceName langId) =>
			self.Win32Resources?.Find(type, name, langId);
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Converts a <see cref="FileOffset"/> to/from an <see cref="RVA"/>
	/// </summary>
	interface IPEType {
		/// <summary>
		/// Converts a <see cref="FileOffset"/> to an <see cref="RVA"/>, returns 0 if out of range
		/// </summary>
		/// <param name="peInfo">The PEInfo context</param>
		/// <param name="offset">The file offset to convert</param>
		/// <returns>The RVA</returns>
		RVA ToRVA(PEInfo peInfo, FileOffset offset);

		/// <summary>
		/// Converts an <see cref="RVA"/> to a <see cref="FileOffset"/>, returns 0 if out of range
		/// </summary>
		/// <param name="peInfo">The PEInfo context</param>
		/// <param name="rva">The RVA to convert</param>
		/// <returns>The file offset</returns>
		FileOffset ToFileOffset(PEInfo peInfo, RVA rva);
	}
}




namespace dnlib.PE {
	/// <summary>
	/// IMAGE_FILE_HEADER.Machine enum
	/// </summary>
	public enum Machine : ushort {
		/// <summary>Unknown machine</summary>
		Unknown		= 0,
		/// <summary>x86</summary>
		I386		= 0x014C,
		/// <summary>MIPS little-endian, 0x160 big-endian</summary>
		R3000		= 0x0162,
		/// <summary>MIPS little-endian</summary>
		R4000		= 0x0166,
		/// <summary>MIPS little-endian</summary>
		R10000		= 0x0168,
		/// <summary>MIPS little-endian WCE v2</summary>
		WCEMIPSV2	= 0x0169,
		/// <summary>Alpha_AXP</summary>
		ALPHA		= 0x0184,
		/// <summary>SH3 little-endian</summary>
		SH3			= 0x01A2,
		/// <summary></summary>
		SH3DSP		= 0x01A3,
		/// <summary>SH3E little-endian</summary>
		SH3E		= 0x01A4,
		/// <summary>SH4 little-endian</summary>
		SH4			= 0x01A6,
		/// <summary>SH5</summary>
		SH5			= 0x01A8,
		/// <summary>ARM Little-Endian</summary>
		ARM			= 0x01C0,
		/// <summary>ARM Thumb/Thumb-2 Little-Endian</summary>
		THUMB		= 0x01C2,
		/// <summary>ARM Thumb-2 Little-Endian</summary>
		ARMNT		= 0x01C4,
		/// <summary></summary>
		AM33		= 0x01D3,
		/// <summary>IBM PowerPC Little-Endian</summary>
		POWERPC		= 0x01F0,
		/// <summary></summary>
		POWERPCFP	= 0x01F1,
		/// <summary>IA-64</summary>
		IA64		= 0x0200,
		/// <summary></summary>
		MIPS16		= 0x0266,
		/// <summary></summary>
		ALPHA64		= 0x0284,
		/// <summary></summary>
		MIPSFPU		= 0x0366,
		/// <summary></summary>
		MIPSFPU16	= 0x0466,
		/// <summary>Infineon</summary>
		TRICORE		= 0x0520,
		/// <summary></summary>
		CEF			= 0x0CEF,
		/// <summary>EFI Byte Code</summary>
		EBC			= 0x0EBC,
		/// <summary>x64</summary>
		AMD64		= 0x8664,
		/// <summary>M32R little-endian</summary>
		M32R		= 0x9041,
		/// <summary></summary>
		ARM64		= 0xAA64,
		/// <summary></summary>
		CEE			= 0xC0EE,

		// Search for IMAGE_FILE_MACHINE_NATIVE and IMAGE_FILE_MACHINE_NATIVE_OS_OVERRIDE here:
		//		https://github.com/dotnet/coreclr/blob/master/src/inc/pedecoder.h
		// Note that IMAGE_FILE_MACHINE_NATIVE_OS_OVERRIDE == 0 if it's Windows

#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
		I386_Native_Apple = I386 ^ 0x4644,
		AMD64_Native_Apple = AMD64 ^ 0x4644,
		ARMNT_Native_Apple = ARMNT ^ 0x4644,
		ARM64_Native_Apple = ARM64 ^ 0x4644,
		S390X_Native_Apple = Unknown ^ 0x4644,

		I386_Native_FreeBSD = I386 ^ 0xADC4,
		AMD64_Native_FreeBSD = AMD64 ^ 0xADC4,
		ARMNT_Native_FreeBSD = ARMNT ^ 0xADC4,
		ARM64_Native_FreeBSD = ARM64 ^ 0xADC4,
		S390X_Native_FreeBSD = Unknown ^ 0xADC4,

		I386_Native_Linux = I386 ^ 0x7B79,
		AMD64_Native_Linux = AMD64 ^ 0x7B79,
		ARMNT_Native_Linux = ARMNT ^ 0x7B79,
		ARM64_Native_Linux = ARM64 ^ 0x7B79,
		S390X_Native_Linux = Unknown ^ 0x7B79,

		I386_Native_NetBSD = I386 ^ 0x1993,
		AMD64_Native_NetBSD = AMD64 ^ 0x1993,
		ARMNT_Native_NetBSD = ARMNT ^ 0x1993,
		ARM64_Native_NetBSD = ARM64 ^ 0x1993,
		S390X_Native_NetBSD = Unknown ^ 0x1993,

		I386_Native_Sun = I386 ^ 0x1992,
		AMD64_Native_Sun = AMD64 ^ 0x1992,
		ARMNT_Native_Sun = ARMNT ^ 0x1992,
		ARM64_Native_Sun = ARM64 ^ 0x1992,
		S390X_Native_Sun = Unknown ^ 0x1992,
#pragma warning restore 1591 // Missing XML comment for publicly visible type or member
	}

	/// <summary>
	/// Extensions
	/// </summary>
	public static class MachineExtensions {
		/// <summary>
		/// Checks if <paramref name="machine"/> is a 64-bit machine
		/// </summary>
		/// <param name="machine">Machine</param>
		/// <returns></returns>
		public static bool Is64Bit(this Machine machine) {
			switch (machine) {
			case Machine.IA64:

			case Machine.AMD64:
			case Machine.AMD64_Native_Apple:
			case Machine.AMD64_Native_FreeBSD:
			case Machine.AMD64_Native_Linux:
			case Machine.AMD64_Native_NetBSD:
			case Machine.AMD64_Native_Sun:

			case Machine.ARM64:
			case Machine.ARM64_Native_Apple:
			case Machine.ARM64_Native_FreeBSD:
			case Machine.ARM64_Native_Linux:
			case Machine.ARM64_Native_NetBSD:
			case Machine.ARM64_Native_Sun:
				return true;

			// It uses value 0==Unknown but we can't assume it's always s390x
			//case Machine.Unknown:
			case Machine.S390X_Native_Apple:
			case Machine.S390X_Native_FreeBSD:
			case Machine.S390X_Native_Linux:
			case Machine.S390X_Native_NetBSD:
			case Machine.S390X_Native_Sun:
				return true;

			default:
				return false;
			}
		}

		/// <summary>
		/// Checks if <paramref name="machine"/> is <see cref="Machine.I386"/>, <see cref="Machine.I386_Native_Apple"/>, etc...
		/// </summary>
		/// <param name="machine">Machine</param>
		/// <returns></returns>
		public static bool IsI386(this Machine machine) {
			switch (machine) {
			case Machine.I386:
			case Machine.I386_Native_Apple:
			case Machine.I386_Native_FreeBSD:
			case Machine.I386_Native_Linux:
			case Machine.I386_Native_NetBSD:
			case Machine.I386_Native_Sun:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks if <paramref name="machine"/> is <see cref="Machine.AMD64"/>, <see cref="Machine.AMD64_Native_Apple"/>, etc...
		/// </summary>
		/// <param name="machine">Machine</param>
		/// <returns></returns>
		public static bool IsAMD64(this Machine machine) {
			switch (machine) {
			case Machine.AMD64:
			case Machine.AMD64_Native_Apple:
			case Machine.AMD64_Native_FreeBSD:
			case Machine.AMD64_Native_Linux:
			case Machine.AMD64_Native_NetBSD:
			case Machine.AMD64_Native_Sun:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks if <paramref name="machine"/> is <see cref="Machine.ARMNT"/>, <see cref="Machine.ARMNT_Native_Apple"/>, etc...
		/// </summary>
		/// <param name="machine">Machine</param>
		/// <returns></returns>
		public static bool IsARMNT(this Machine machine) {
			switch (machine) {
			case Machine.ARMNT:
			case Machine.ARMNT_Native_Apple:
			case Machine.ARMNT_Native_FreeBSD:
			case Machine.ARMNT_Native_Linux:
			case Machine.ARMNT_Native_NetBSD:
			case Machine.ARMNT_Native_Sun:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks if <paramref name="machine"/> is <see cref="Machine.ARM64"/>, <see cref="Machine.ARM64_Native_Apple"/>, etc...
		/// </summary>
		/// <param name="machine">Machine</param>
		/// <returns></returns>
		public static bool IsARM64(this Machine machine) {
			switch (machine) {
			case Machine.ARM64:
			case Machine.ARM64_Native_Apple:
			case Machine.ARM64_Native_FreeBSD:
			case Machine.ARM64_Native_Linux:
			case Machine.ARM64_Native_NetBSD:
			case Machine.ARM64_Native_Sun:
				return true;
			default:
				return false;
			}
		}

		/// <summary>
		/// Checks if <paramref name="machine"/> is s390x, <see cref="Machine.S390X_Native_Apple"/>, etc...
		/// </summary>
		/// <param name="machine">Machine</param>
		/// <returns></returns>
		public static bool IsS390x(this Machine machine) {
			switch (machine) {
			// It uses value 0==Unknown but we can't assume it's always s390x
			//case Machine.Unknown:
			case Machine.S390X_Native_Apple:
			case Machine.S390X_Native_FreeBSD:
			case Machine.S390X_Native_Linux:
			case Machine.S390X_Native_NetBSD:
			case Machine.S390X_Native_Sun:
				return true;
			default:
				return false;
			}
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Extension methods
	/// </summary>
	public static partial class PEExtensions {
		/// <summary>
		/// Calculates a PE checksum
		/// </summary>
		/// <param name="stream">PE image stream positioned at the MZ bytes</param>
		/// <param name="length">Length of image</param>
		/// <param name="checkSumOffset">Offset of checksum</param>
		/// <returns>PE checksum</returns>
		internal static uint CalculatePECheckSum(this Stream stream, long length, long checkSumOffset) {
			if ((length & 1) != 0)
				ThrowInvalidOperationException("Invalid PE length");
			var buffer = new byte[(int)Math.Min(length, 0x2000)];
			uint checkSum = 0;
			checkSum = CalculatePECheckSum(stream, checkSumOffset, checkSum, buffer);
			const int ChecksumFieldSize = 4;
			stream.Position += ChecksumFieldSize;
			checkSum = CalculatePECheckSum(stream, length - checkSumOffset - ChecksumFieldSize, checkSum, buffer);
			ulong cks = (ulong)checkSum + (ulong)length;
			return (uint)cks + (uint)(cks >> 32);
		}

		static uint CalculatePECheckSum(Stream stream, long length, uint checkSum, byte[] buffer) {
			for (long offset = 0; offset < length;) {
				int len = (int)Math.Min(length - offset, buffer.Length);
				int count = stream.Read(buffer, 0, len);
				if (count != len)
					ThrowInvalidOperationException("Couldn't read all bytes");

				for (int i = 0; i < count;) {
					checkSum += buffer[i++] | ((uint)buffer[i++] << 8);
					checkSum = (ushort)(checkSum + (checkSum >> 16));
				}

				offset += count;
			}
			return checkSum;
		}

		static void ThrowInvalidOperationException(string message) => throw new InvalidOperationException(message);
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Image layout
	/// </summary>
	public enum ImageLayout {
		/// <summary>
		/// Use this if the PE file has a normal structure (eg. it's been read from a file on disk)
		/// </summary>
		File,

		/// <summary>
		/// Use this if the PE file has been loaded into memory by the OS PE file loader
		/// </summary>
		Memory,
	}

	/// <summary>
	/// Accesses a PE file
	/// </summary>
	public sealed class PEImage : IInternalPEImage {
		// Default to false because an OS loaded PE image may contain memory holes. If there
		// are memory holes, other code (eg. .NET resource creator) must verify that all memory
		// is available, which will be slower.
		const bool USE_MEMORY_LAYOUT_WITH_MAPPED_FILES = false;

		static readonly IPEType MemoryLayout = new MemoryPEType();
		static readonly IPEType FileLayout = new FilePEType();

		DataReaderFactory dataReaderFactory;
		IPEType peType;
		PEInfo peInfo;
		UserValue<Win32Resources> win32Resources;
#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		sealed class FilePEType : IPEType {
			public RVA ToRVA(PEInfo peInfo, FileOffset offset) => peInfo.ToRVA(offset);
			public FileOffset ToFileOffset(PEInfo peInfo, RVA rva) => peInfo.ToFileOffset(rva);
		}

		sealed class MemoryPEType : IPEType {
			public RVA ToRVA(PEInfo peInfo, FileOffset offset) => (RVA)offset;
			public FileOffset ToFileOffset(PEInfo peInfo, RVA rva) => (FileOffset)rva;
		}

		/// <inheritdoc/>
		public bool IsFileImageLayout => peType is FilePEType;

		/// <inheritdoc/>
		public bool MayHaveInvalidAddresses => !IsFileImageLayout;

		/// <inheritdoc/>
		public string Filename => dataReaderFactory.Filename;

		/// <inheritdoc/>
		public ImageDosHeader ImageDosHeader => peInfo.ImageDosHeader;

		/// <inheritdoc/>
		public ImageNTHeaders ImageNTHeaders => peInfo.ImageNTHeaders;

		/// <inheritdoc/>
		public IList<ImageSectionHeader> ImageSectionHeaders => peInfo.ImageSectionHeaders;

		/// <inheritdoc/>
		public IList<ImageDebugDirectory> ImageDebugDirectories {
			get {
				if (imageDebugDirectories is null)
					imageDebugDirectories = ReadImageDebugDirectories();
				return imageDebugDirectories;
			}
		}
		ImageDebugDirectory[] imageDebugDirectories;

		/// <inheritdoc/>
		public DataReaderFactory DataReaderFactory => dataReaderFactory;

		/// <inheritdoc/>
		public Win32Resources Win32Resources {
			get => win32Resources.Value;
			set {
				IDisposable origValue = null;
				if (win32Resources.IsValueInitialized) {
					origValue = win32Resources.Value;
					if (origValue == value)
						return;
				}
				win32Resources.Value = value;

				if (origValue is not null)
					origValue.Dispose();
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="dataReaderFactory">Data reader factory</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(DataReaderFactory dataReaderFactory, ImageLayout imageLayout, bool verify) {
			try {
				this.dataReaderFactory = dataReaderFactory;
				peType = ConvertImageLayout(imageLayout);
				var reader = dataReaderFactory.CreateReader();
				peInfo = new PEInfo(ref reader, verify);
				Initialize();
			}
			catch {
				Dispose();
				throw;
			}
		}

		void Initialize() {
			win32Resources.ReadOriginalValue = () => {
				var dataDir = peInfo.ImageNTHeaders.OptionalHeader.DataDirectories[2];
				if (dataDir.VirtualAddress == 0 || dataDir.Size == 0)
					return null;
				return new Win32ResourcesPE(this);
			};
#if THREAD_SAFE
			win32Resources.Lock = theLock;
#endif
		}

		static IPEType ConvertImageLayout(ImageLayout imageLayout) =>
			imageLayout switch {
				ImageLayout.File => FileLayout,
				ImageLayout.Memory => MemoryLayout,
				_ => throw new ArgumentException("imageLayout"),
			};

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="filename">Name of the file</param>
		/// <param name="mapAsImage"><c>true</c> if we should map it as an executable</param>
		/// <param name="verify">Verify PE file data</param>
		internal PEImage(string filename, bool mapAsImage, bool verify)
			: this(DataReaderFactoryFactory.Create(filename, mapAsImage), mapAsImage ? ImageLayout.Memory : ImageLayout.File, verify) {
			try {
				if (mapAsImage && dataReaderFactory is MemoryMappedDataReaderFactory)
					((MemoryMappedDataReaderFactory)dataReaderFactory).SetLength(peInfo.GetImageSize());
			}
			catch {
				Dispose();
				throw;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="filename">Name of the file</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(string filename, bool verify)
			: this(filename, USE_MEMORY_LAYOUT_WITH_MAPPED_FILES, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="filename">Name of the file</param>
		public PEImage(string filename)
			: this(filename, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="filename">Filename or null</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(byte[] data, string filename, ImageLayout imageLayout, bool verify)
			: this(ByteArrayDataReaderFactory.Create(data, filename), imageLayout, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(byte[] data, ImageLayout imageLayout, bool verify)
			: this(data, null, imageLayout, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(byte[] data, bool verify)
			: this(data, null, ImageLayout.File, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="filename">Filename or null</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(byte[] data, string filename, bool verify)
			: this(data, filename, ImageLayout.File, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		public PEImage(byte[] data)
			: this(data, null, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="data">The PE file data</param>
		/// <param name="filename">Filename or null</param>
		public PEImage(byte[] data, string filename)
			: this(data, filename, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="length">Length of PE image</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public unsafe PEImage(IntPtr baseAddr, uint length, ImageLayout imageLayout, bool verify)
			: this(NativeMemoryDataReaderFactory.Create((byte*)baseAddr, length, filename: null), imageLayout, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="length">Length of PE image</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(IntPtr baseAddr, uint length, bool verify)
			: this(baseAddr, length, ImageLayout.Memory, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="length">Length of PE image</param>
		public PEImage(IntPtr baseAddr, uint length)
			: this(baseAddr, length, true) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="imageLayout">Image layout</param>
		/// <param name="verify">Verify PE file data</param>
		public unsafe PEImage(IntPtr baseAddr, ImageLayout imageLayout, bool verify)
			: this(NativeMemoryDataReaderFactory.Create((byte*)baseAddr, 0x10000, filename: null), imageLayout, verify) {
			try {
				((NativeMemoryDataReaderFactory)dataReaderFactory).SetLength(peInfo.GetImageSize());
			}
			catch {
				Dispose();
				throw;
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		/// <param name="verify">Verify PE file data</param>
		public PEImage(IntPtr baseAddr, bool verify)
			: this(baseAddr, ImageLayout.Memory, verify) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="baseAddr">Address of PE image</param>
		public PEImage(IntPtr baseAddr)
			: this(baseAddr, true) {
		}

		/// <inheritdoc/>
		public RVA ToRVA(FileOffset offset) => peType.ToRVA(peInfo, offset);

		/// <inheritdoc/>
		public FileOffset ToFileOffset(RVA rva) => peType.ToFileOffset(peInfo, rva);

		/// <inheritdoc/>
		public void Dispose() {
			IDisposable id;
			if (win32Resources.IsValueInitialized && (id = win32Resources.Value) is not null)
				id.Dispose();
			dataReaderFactory?.Dispose();
			win32Resources.Value = null;
			dataReaderFactory = null;
			peType = null;
			peInfo = null;
		}

		/// <inheritdoc/>
		public DataReader CreateReader(FileOffset offset) =>
			DataReaderFactory.CreateReader((uint)offset, DataReaderFactory.Length - (uint)offset);

		/// <inheritdoc/>
		public DataReader CreateReader(FileOffset offset, uint length) =>
			DataReaderFactory.CreateReader((uint)offset, length);

		/// <inheritdoc/>
		public DataReader CreateReader(RVA rva) => CreateReader(ToFileOffset(rva));

		/// <inheritdoc/>
		public DataReader CreateReader(RVA rva, uint length) => CreateReader(ToFileOffset(rva), length);

		/// <inheritdoc/>
		public DataReader CreateReader() => DataReaderFactory.CreateReader();

		void IInternalPEImage.UnsafeDisableMemoryMappedIO() {
			if (dataReaderFactory is MemoryMappedDataReaderFactory creator)
				creator.UnsafeDisableMemoryMappedIO();
		}

		bool IInternalPEImage.IsMemoryMappedIO {
			get {
				var creator = dataReaderFactory as MemoryMappedDataReaderFactory;
				return creator is null ? false : creator.IsMemoryMappedIO;
			}
		}

		ImageDebugDirectory[] ReadImageDebugDirectories() {
			try {
				var dataDir = ImageNTHeaders.OptionalHeader.DataDirectories[6];
				if (dataDir.VirtualAddress == 0)
					return Array2.Empty<ImageDebugDirectory>();
				var reader = DataReaderFactory.CreateReader();
				if (dataDir.Size > reader.Length)
					return Array2.Empty<ImageDebugDirectory>();
				int count = (int)(dataDir.Size / 0x1C);
				if (count == 0)
					return Array2.Empty<ImageDebugDirectory>();
				reader.CurrentOffset = (uint)ToFileOffset(dataDir.VirtualAddress);
				if ((ulong)reader.CurrentOffset + dataDir.Size > reader.Length)
					return Array2.Empty<ImageDebugDirectory>();
				var res = new ImageDebugDirectory[count];
				for (int i = 0; i < res.Length; i++)
					res[i] = new ImageDebugDirectory(ref reader, true);
				return res;
			}
			catch (IOException) {
			}
			return Array2.Empty<ImageDebugDirectory>();
		}
	}
}





namespace dnlib.PE {
	/// <summary>
	/// Reads all PE sections from a PE stream, for more information see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format
	/// </summary>
	sealed class PEInfo {
		readonly ImageDosHeader imageDosHeader;
		readonly ImageNTHeaders imageNTHeaders;
		readonly ImageSectionHeader[] imageSectionHeaders;

		/// <summary>
		/// Returns the DOS header
		/// </summary>
		public ImageDosHeader ImageDosHeader => imageDosHeader;

		/// <summary>
		/// Returns the NT headers
		/// </summary>
		public ImageNTHeaders ImageNTHeaders => imageNTHeaders;

		/// <summary>
		/// Returns the section headers
		/// </summary>
		public ImageSectionHeader[] ImageSectionHeaders => imageSectionHeaders;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="reader">PE file reader pointing to the start of this section</param>
		/// <param name="verify">Verify sections</param>
		/// <exception cref="BadImageFormatException">Thrown if verification fails</exception>
		public PEInfo(ref DataReader reader, bool verify) {
			reader.Position = 0;
			imageDosHeader = new ImageDosHeader(ref reader, verify);

			if (verify && imageDosHeader.NTHeadersOffset == 0)
				throw new BadImageFormatException("Invalid NT headers offset");
			reader.Position = imageDosHeader.NTHeadersOffset;
			imageNTHeaders = new ImageNTHeaders(ref reader, verify);

			reader.Position = (uint)imageNTHeaders.OptionalHeader.StartOffset + imageNTHeaders.FileHeader.SizeOfOptionalHeader;
			int numSections = imageNTHeaders.FileHeader.NumberOfSections;
			if (numSections > 0) {
				// Mono doesn't verify the section count
				var tempReader = reader;
				tempReader.Position += 0x14;
				uint firstSectionOffset = tempReader.ReadUInt32();
				numSections = Math.Min(numSections, (int)((firstSectionOffset - reader.Position) / 0x28));
			}
			imageSectionHeaders = new ImageSectionHeader[numSections];
			for (int i = 0; i < imageSectionHeaders.Length; i++)
				imageSectionHeaders[i] = new ImageSectionHeader(ref reader, verify);
		}

		/// <summary>
		/// Returns the first <see cref="ImageSectionHeader"/> that has data at file offset
		/// <paramref name="offset"/>
		/// </summary>
		/// <param name="offset">The file offset</param>
		/// <returns></returns>
		public ImageSectionHeader ToImageSectionHeader(FileOffset offset) {
			foreach (var section in imageSectionHeaders) {
				if ((uint)offset >= section.PointerToRawData && (uint)offset < section.PointerToRawData + section.SizeOfRawData)
					return section;
			}
			return null;
		}

		/// <summary>
		/// Returns the first <see cref="ImageSectionHeader"/> that has data at RVA
		/// <paramref name="rva"/>
		/// </summary>
		/// <param name="rva">The RVA</param>
		/// <returns></returns>
		public ImageSectionHeader ToImageSectionHeader(RVA rva) {
			uint alignment = imageNTHeaders.OptionalHeader.SectionAlignment;
			foreach (var section in imageSectionHeaders) {
				if (rva >= section.VirtualAddress && rva < section.VirtualAddress + DotNet.Utils.AlignUp(section.VirtualSize, alignment))
					return section;
			}
			return null;
		}

		/// <summary>
		/// Converts a <see cref="FileOffset"/> to an <see cref="RVA"/>, returns 0 if out of range
		/// </summary>
		/// <param name="offset">The file offset to convert</param>
		/// <returns>The RVA</returns>
		public RVA ToRVA(FileOffset offset) {
			// In pe headers
			if (imageSectionHeaders.Length == 0)
				return (RVA)offset;

			// In pe additional data, like digital signature, won't be loaded into memory
			var lastSection = imageSectionHeaders[imageSectionHeaders.Length - 1];
			if ((uint)offset > lastSection.PointerToRawData + lastSection.SizeOfRawData)
				return 0;

			// In a section
			var section = ToImageSectionHeader(offset);
			if (section is not null)
				return (uint)(offset - section.PointerToRawData) + section.VirtualAddress;

			// In pe headers
			return (RVA)offset;
		}

		/// <summary>
		/// Converts an <see cref="RVA"/> to a <see cref="FileOffset"/>, returns 0 if out of range
		/// </summary>
		/// <param name="rva">The RVA to convert</param>
		/// <returns>The file offset</returns>
		public FileOffset ToFileOffset(RVA rva) {
			// Check if rva is larger than memory layout size
			if ((uint)rva >= imageNTHeaders.OptionalHeader.SizeOfImage)
				return 0;

			var section = ToImageSectionHeader(rva);
			if (section is not null) {
				uint offset = rva - section.VirtualAddress;
				// Virtual size may be bigger than raw size and there may be no corresponding file offset to rva
				if (offset < section.SizeOfRawData)
					return (FileOffset)offset + section.PointerToRawData;
				return 0;
			}

			// If not in any section, rva is in pe headers and don't convert it
			return (FileOffset)rva;
		}

		static ulong AlignUp(ulong val, uint alignment) => (val + alignment - 1) & ~(ulong)(alignment - 1);

		/// <summary>
		/// Returns size of image rounded up to <see cref="IImageOptionalHeader.SectionAlignment"/>
		/// </summary>
		/// <remarks>It calculates the size itself, and does not return <see cref="IImageOptionalHeader.SizeOfImage"/></remarks>
		/// <returns>Size of image in bytes</returns>
		public uint GetImageSize() {
			var optHdr = ImageNTHeaders.OptionalHeader;
			uint alignment = optHdr.SectionAlignment;
			if (imageSectionHeaders.Length == 0)
				return (uint)AlignUp(optHdr.SizeOfHeaders, alignment);

			// Section headers must be in ascending order and adjacent
			var section = imageSectionHeaders[imageSectionHeaders.Length - 1];
			return (uint)Math.Min(AlignUp((ulong)section.VirtualAddress + section.VirtualSize, alignment), uint.MaxValue);
		}
	}
}





namespace dnlib.PE {
	static class ProcessorArchUtils {
		static Machine cachedMachine = 0;

		public static Machine GetProcessCpuArchitecture() {
			if (cachedMachine == 0)
				cachedMachine = GetProcessCpuArchitectureCore();
			return cachedMachine;
		}

		static class RuntimeInformationUtils {
#if NETSTANDARD
			public static bool TryGet_RuntimeInformation_Architecture(out Machine machine) =>
				TryGetArchitecture((int)RuntimeInformation.ProcessArchitecture, out machine);
#else
			static Assembly RuntimeInformationAssembly => typeof(object).Assembly;
			static Type System_Runtime_InteropServices_RuntimeInformation => RuntimeInformationAssembly.GetType("System.Runtime.InteropServices.RuntimeInformation", throwOnError: false);

			public static bool TryGet_RuntimeInformation_Architecture(out Machine machine) {
				machine = 0;
				var processArchitectureMethod = System_Runtime_InteropServices_RuntimeInformation?.GetMethod("get_ProcessArchitecture", Array2.Empty<Type>());
				if (processArchitectureMethod is null)
					return false;

				var result = processArchitectureMethod.Invoke(null, Array2.Empty<object>());
				return TryGetArchitecture((int)result, out machine);
			}
#endif

			static bool TryGetArchitecture(int architecture, out Machine machine) {
				switch (architecture) {
				case 0: // Architecture.X86
					Debug.Assert(IntPtr.Size == 4);
					machine = Machine.I386;
					return true;

				case 1: // Architecture.X64
					Debug.Assert(IntPtr.Size == 8);
					machine = Machine.AMD64;
					return true;

				case 2: // Architecture.Arm
					Debug.Assert(IntPtr.Size == 4);
					machine = Machine.ARMNT;
					return true;

				case 3: // Architecture.Arm64
					Debug.Assert(IntPtr.Size == 8);
					machine = Machine.ARM64;
					return true;

				default:
					Debug.Fail($"Unknown process architecture: {architecture}");
					machine = 0;
					return false;
				}
			}
		}

		static Machine GetProcessCpuArchitectureCore() {
			if (WindowsUtils.TryGetProcessCpuArchitecture(out var machine))
				return machine;
			try {
				if (RuntimeInformationUtils.TryGet_RuntimeInformation_Architecture(out machine))
					return machine;
			}
			catch (PlatformNotSupportedException) {
			}

			Debug.WriteLine("Couldn't detect CPU arch, assuming x86 or x64");
			return IntPtr.Size == 4 ? Machine.I386 : Machine.AMD64;
		}

		static class WindowsUtils {
			[DllImport("kernel32")]
			static extern void GetSystemInfo(out SYSTEM_INFO lpSystemInfo);

			struct SYSTEM_INFO {
				public ushort wProcessorArchitecture;
				public ushort wReserved;
				public uint dwPageSize;
				public IntPtr lpMinimumApplicationAddress;
				public IntPtr lpMaximumApplicationAddress;
				public IntPtr dwActiveProcessorMask;
				public uint dwNumberOfProcessors;
				public uint dwProcessorType;
				public uint dwAllocationGranularity;
				public ushort wProcessorLevel;
				public ushort wProcessorRevision;
			}

			enum ProcessorArchitecture : ushort {
				INTEL		= 0,
				ARM			= 5,
				IA64		= 6,
				AMD64		= 9,
				ARM64		= 12,
				UNKNOWN		= 0xFFFF,
			}

			public static bool TryGetProcessCpuArchitecture(out Machine machine) {
				if (canTryGetSystemInfo) {
					try {
						GetSystemInfo(out var sysInfo);
						switch ((ProcessorArchitecture)sysInfo.wProcessorArchitecture) {
						case ProcessorArchitecture.INTEL:
							Debug.Assert(IntPtr.Size == 4);
							machine = Machine.I386;
							return true;

						case ProcessorArchitecture.ARM:
							Debug.Assert(IntPtr.Size == 4);
							machine = Machine.ARMNT;
							return true;

						case ProcessorArchitecture.IA64:
							Debug.Assert(IntPtr.Size == 8);
							machine = Machine.IA64;
							return true;

						case ProcessorArchitecture.AMD64:
							Debug.Assert(IntPtr.Size == 8);
							machine = Machine.AMD64;
							return true;

						case ProcessorArchitecture.ARM64:
							Debug.Assert(IntPtr.Size == 8);
							machine = Machine.ARM64;
							return true;

						case ProcessorArchitecture.UNKNOWN:
						default:
							break;
						}
					}
					catch (EntryPointNotFoundException) {
						canTryGetSystemInfo = false;
					}
					catch (DllNotFoundException) {
						canTryGetSystemInfo = false;
					}
				}

				machine = 0;
				return false;
			}
			static bool canTryGetSystemInfo = true;
		}
	}
}




namespace dnlib.PE {
	/// <summary>
	/// Represents an RVA (relative virtual address)
	/// </summary>
	public enum RVA : uint {
	}

	partial class PEExtensions {
		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="rva">this</param>
		/// <param name="alignment">Alignment</param>
		public static RVA AlignUp(this RVA rva, uint alignment) => (RVA)(((uint)rva + alignment - 1) & ~(alignment - 1));

		/// <summary>
		/// Align up
		/// </summary>
		/// <param name="rva">this</param>
		/// <param name="alignment">Alignment</param>
		public static RVA AlignUp(this RVA rva, int alignment) => (RVA)(((uint)rva + alignment - 1) & ~(alignment - 1));
	}
}




namespace dnlib.PE {
	/// <summary>
	/// IMAGE_OPTIONAL_HEADER.Subsystem
	/// </summary>
	public enum Subsystem : ushort {
		/// <summary>Unknown subsystem.</summary>
		Unknown = 0,
		/// <summary>Image doesn't require a subsystem.</summary>
		Native = 1,
		/// <summary>Image runs in the Windows GUI subsystem.</summary>
		WindowsGui = 2,
		/// <summary>Image runs in the Windows character subsystem.</summary>
		WindowsCui = 3,
		/// <summary>image runs in the OS/2 character subsystem.</summary>
		Os2Cui = 5,
		/// <summary>image runs in the Posix character subsystem.</summary>
		PosixCui = 7,
		/// <summary>image is a native Win9x driver.</summary>
		NativeWindows = 8,
		/// <summary>Image runs in the Windows CE subsystem.</summary>
		WindowsCeGui = 9,
		/// <summary/>
		EfiApplication = 10,
		/// <summary/>
		EfiBootServiceDriver = 11,
		/// <summary/>
		EfiRuntimeDriver = 12,
		/// <summary/>
		EfiRom = 13,
		/// <summary/>
		Xbox = 14,
		/// <summary/>
		WindowsBootApplication = 16,
	}
}





namespace dnlib.PE {
	/// <summary>
	/// IMAGE_FILE_HEADER.Characteristics flags
	/// </summary>
	[Flags]
	public enum Characteristics : ushort {
		/// <summary>Relocation info stripped from file.</summary>
		RelocsStripped		= 0x0001,
		/// <summary>File is executable  (i.e. no unresolved externel references).</summary>
		ExecutableImage		= 0x0002,
		/// <summary>Line nunbers stripped from file.</summary>
		LineNumsStripped	= 0x0004,
		/// <summary>Local symbols stripped from file.</summary>
		LocalSymsStripped	= 0x0008,
		/// <summary>Agressively trim working set</summary>
		AggressiveWsTrim	= 0x0010,
		/// <summary>App can handle >2gb addresses</summary>
		LargeAddressAware	= 0x0020,
		/// <summary/>
		Reserved1			= 0x0040,
		/// <summary>Bytes of machine word are reversed.</summary>
		BytesReversedLo		= 0x0080,
		/// <summary>32 bit word machine.</summary>
		Bit32Machine		= 0x0100,
		/// <summary>Debugging info stripped from file in .DBG file</summary>
		DebugStripped		= 0x0200,
		/// <summary>If Image is on removable media, copy and run from the swap file.</summary>
		RemovableRunFromSwap= 0x0400,
		/// <summary>If Image is on Net, copy and run from the swap file.</summary>
		NetRunFromSwap		= 0x0800,
		/// <summary>System File.</summary>
		System				= 0x1000,
		/// <summary>File is a DLL.</summary>
		Dll					= 0x2000,
		/// <summary>File should only be run on a UP machine</summary>
		UpSystemOnly		= 0x4000,
		/// <summary>Bytes of machine word are reversed.</summary>
		BytesReversedHi		= 0x8000,
	}
}





namespace dnlib.PE {
	/// <summary>
	/// IMAGE_OPTIONAL_HEADER.DllCharacteristics
	/// </summary>
	[Flags]
	public enum DllCharacteristics : ushort {
		/// <summary/>
		Reserved1			= 0x0001,
		/// <summary/>
		Reserved2			= 0x0002,
		/// <summary/>
		Reserved3			= 0x0004,
		/// <summary/>
		Reserved4			= 0x0008,
		/// <summary/>
		Reserved5			= 0x0010,
		/// <summary>Image can handle a high entropy 64-bit virtual address space.</summary>
		HighEntropyVA		= 0x0020,
		/// <summary>DLL can move.</summary>
		DynamicBase			= 0x0040,
		/// <summary>Code Integrity Image</summary>
		ForceIntegrity		= 0x0080,
		/// <summary>Image is NX compatible</summary>
		NxCompat			= 0x0100,
		/// <summary>Image understands isolation and doesn't want it</summary>
		NoIsolation			= 0x0200,
		/// <summary>Image does not use SEH.  No SE handler may reside in this image</summary>
		NoSeh				= 0x0400,
		/// <summary>Do not bind this image.</summary>
		NoBind				= 0x0800,
		/// <summary>Image should execute in an AppContainer</summary>
		AppContainer		= 0x1000,
		/// <summary>Driver uses WDM model</summary>
		WdmDriver			= 0x2000,
		/// <summary>Image supports Control Flow Guard.</summary>
		GuardCf				= 0x4000,
		/// <summary/>
		TerminalServerAware	= 0x8000,
	}
}





namespace dnlib.Threading {
	/// <summary>
	/// Cancellation token interface
	/// </summary>
	public interface ICancellationToken {
		/// <summary>
		/// Throws a <see cref="OperationCanceledException"/> if the operation should be canceled
		/// </summary>
		void ThrowIfCancellationRequested();
	}
}





namespace dnlib.Threading {
#if THREAD_SAFE
	[Serializable]
	class LockException : Exception {
		public LockException() {
		}

		public LockException(string msg)
			: base(msg) {
		}

		protected LockException(SerializationInfo info, StreamingContext context)
			: base(info, context) {
		}
	}

	/// <summary>
	/// Simple class using Monitor.Enter() and Monitor.Exit()
	/// and just like <c>ReaderWriterLockSlim</c> it prevents recursive locks. It doesn't support
	/// multiple readers. A reader lock is the same as a writer lock.
	/// </summary>
	class Lock {
		readonly object lockObj;
		int recurseCount;

		/// <summary>
		/// Creates a new instance of this class
		/// </summary>
		/// <returns></returns>
		public static Lock Create() => new Lock();

		/// <summary>
		/// Constructor
		/// </summary>
		Lock() {
			lockObj = new object();
			recurseCount = 0;
		}

		/// <summary>
		/// Enter read mode
		/// </summary>
		public void EnterReadLock() {
			Monitor.Enter(lockObj);
			if (recurseCount != 0) {
				Monitor.Exit(lockObj);
				throw new LockException("Recursive locks aren't supported");
			}
			recurseCount++;
		}

		/// <summary>
		/// Exit read mode
		/// </summary>
		public void ExitReadLock() {
			if (recurseCount <= 0)
				throw new LockException("Too many exit lock method calls");
			recurseCount--;
			Monitor.Exit(lockObj);
		}

		/// <summary>
		/// Enter write mode
		/// </summary>
		public void EnterWriteLock() {
			Monitor.Enter(lockObj);
			if (recurseCount != 0) {
				Monitor.Exit(lockObj);
				throw new LockException("Recursive locks aren't supported");
			}
			recurseCount--;
		}

		/// <summary>
		/// Exit write mode
		/// </summary>
		public void ExitWriteLock() {
			if (recurseCount >= 0)
				throw new LockException("Too many exit lock method calls");
			recurseCount++;
			Monitor.Exit(lockObj);
		}
	}
#endif
}





namespace dnlib.Utils {
	/// <summary>
	/// Interface to access a lazily initialized list
	/// </summary>
	/// <typeparam name="TValue">Type to store in list</typeparam>
	interface ILazyList<TValue> : IList<TValue> {
	}
}





namespace dnlib.Utils {
	/// <summary>
	/// Gets notified of list events
	/// </summary>
	/// <typeparam name="TListValue">List value</typeparam>
	public interface IListListener<TListValue> {
		/// <summary>
		/// Called before a new value is lazily added to the list.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		/// <param name="index">Index where the value will be added</param>
		/// <param name="value">Value that will be added to the list. It can be modified by
		/// the callee.</param>
		void OnLazyAdd(int index, ref TListValue value);

		/// <summary>
		/// Called before a new value is added to the list.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		/// <param name="index">Index where the value will be added</param>
		/// <param name="value">Value that will be added to the list</param>
		void OnAdd(int index, TListValue value);

		/// <summary>
		/// Called before a value is removed from the list. If all elements are removed,
		/// <see cref="OnClear()"/> is called, and this method is not called.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		/// <param name="index">Index of value</param>
		/// <param name="value">The value that will be removed</param>
		void OnRemove(int index, TListValue value);

		/// <summary>
		/// Called after the list has been resized (eg. an element has been added/removed). It's not
		/// called when an element is replaced.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		/// <param name="index">Index where the change occurred.</param>
		void OnResize(int index);

		/// <summary>
		/// Called before the whole list is cleared.
		/// </summary>
		/// <remarks>If you must access this list, you can only call <c>_NoLock()</c> methods
		/// since a write lock is now held by this thread.</remarks>
		void OnClear();
	}

	/// <summary>
	/// Implements a <see cref="IList{T}"/> that is lazily initialized
	/// </summary>
	/// <typeparam name="TValue">Type to store in list</typeparam>
	[DebuggerDisplay("Count = {Count}")]
	[DebuggerTypeProxy(typeof(CollectionDebugView<>))]
	public class LazyList<TValue> : ILazyList<TValue> where TValue : class {
		private protected readonly List<Element> list;
		int id = 0;
		private protected readonly IListListener<TValue> listener;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <summary>
		/// Stores a simple value
		/// </summary>
		private protected class Element {
			protected TValue value;

			/// <summary>
			/// <c>true</c> if it has been initialized, <c>false</c> otherwise
			/// </summary>
			public virtual bool IsInitialized_NoLock => true;

			/// <summary>
			/// Default constructor
			/// </summary>
			protected Element() {
			}

			/// <summary>
			/// Constructor that should be used when new elements are inserted into <see cref="LazyList{T}"/>
			/// </summary>
			/// <param name="data">User data</param>
			public Element(TValue data) => value = data;

			/// <summary>
			/// Gets the value
			/// </summary>
			/// <param name="index">Index in the list</param>
			public virtual TValue GetValue_NoLock(int index) => value;

			/// <summary>
			/// Sets the value
			/// </summary>
			/// <param name="index">Index in the list</param>
			/// <param name="value">New value</param>
			public virtual void SetValue_NoLock(int index, TValue value) => this.value = value;

			/// <inheritdoc/>
			public override string ToString() => value?.ToString() ?? string.Empty;
		}

		/// <inheritdoc/>
		public int Count {
			get {
#if THREAD_SAFE
				theLock.EnterReadLock(); try {
#endif
				return Count_NoLock;
#if THREAD_SAFE
				} finally { theLock.ExitReadLock(); }
#endif
			}
		}

		/// <inheritdoc/>
		internal int Count_NoLock => list.Count;

		/// <inheritdoc/>
		public bool IsReadOnly => false;

		/// <inheritdoc/>
		public TValue this[int index] {
			get {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				return Get_NoLock(index);
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
			set {
#if THREAD_SAFE
				theLock.EnterWriteLock(); try {
#endif
				Set_NoLock(index, value);
#if THREAD_SAFE
				} finally { theLock.ExitWriteLock(); }
#endif
			}
		}

		internal TValue Get_NoLock(int index) => list[index].GetValue_NoLock(index);

		void Set_NoLock(int index, TValue value) {
			if (listener is not null) {
				listener.OnRemove(index, list[index].GetValue_NoLock(index));
				listener.OnAdd(index, value);
			}
			list[index].SetValue_NoLock(index, value);
			id++;
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public LazyList()
			: this(null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="listener">List listener</param>
		public LazyList(IListListener<TValue> listener) {
			this.listener = listener;
			list = new List<Element>();
		}

		private protected LazyList(int length, IListListener<TValue> listener) {
			this.listener = listener;
			list = new List<Element>(length);
		}

		/// <inheritdoc/>
		public int IndexOf(TValue item) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return IndexOf_NoLock(item);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		int IndexOf_NoLock(TValue item) {
			for (int i = 0; i < list.Count; i++) {
				if (list[i].GetValue_NoLock(i) == item)
					return i;
			}
			return -1;
		}

		/// <inheritdoc/>
		public void Insert(int index, TValue item) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			Insert_NoLock(index, item);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		void Insert_NoLock(int index, TValue item) {
			if (listener is not null)
				listener.OnAdd(index, item);
			list.Insert(index, new Element(item));
			if (listener is not null)
				listener.OnResize(index);
			id++;
		}

		/// <inheritdoc/>
		public void RemoveAt(int index) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			RemoveAt_NoLock(index);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		void RemoveAt_NoLock(int index) {
			if (listener is not null)
				listener.OnRemove(index, list[index].GetValue_NoLock(index));
			list.RemoveAt(index);
			if (listener is not null)
				listener.OnResize(index);
			id++;
		}

		/// <inheritdoc/>
		public void Add(TValue item) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			Add_NoLock(item);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		void Add_NoLock(TValue item) {
			int index = list.Count;
			if (listener is not null)
				listener.OnAdd(index, item);
			list.Add(new Element(item));
			if (listener is not null)
				listener.OnResize(index);
			id++;
		}

		/// <inheritdoc/>
		public void Clear() {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			Clear_NoLock();
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		void Clear_NoLock() {
			if (listener is not null)
				listener.OnClear();
			list.Clear();
			if (listener is not null)
				listener.OnResize(0);
			id++;
		}

		/// <inheritdoc/>
		public bool Contains(TValue item) => IndexOf(item) >= 0;

		/// <inheritdoc/>
		public void CopyTo(TValue[] array, int arrayIndex) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			CopyTo_NoLock(array, arrayIndex);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		void CopyTo_NoLock(TValue[] array, int arrayIndex) {
			for (int i = 0; i < list.Count; i++)
				array[arrayIndex + i] = list[i].GetValue_NoLock(i);
		}

		/// <inheritdoc/>
		public bool Remove(TValue item) {
#if THREAD_SAFE
			theLock.EnterWriteLock(); try {
#endif
			return Remove_NoLock(item);
#if THREAD_SAFE
			} finally { theLock.ExitWriteLock(); }
#endif
		}

		bool Remove_NoLock(TValue item) {
			int index = IndexOf_NoLock(item);
			if (index < 0)
				return false;
			RemoveAt_NoLock(index);
			return true;
		}

		internal bool IsInitialized(int index) {
#if THREAD_SAFE
			theLock.EnterReadLock(); try {
#endif
			return IsInitialized_NoLock(index);
#if THREAD_SAFE
			} finally { theLock.ExitReadLock(); }
#endif
		}

		bool IsInitialized_NoLock(int index) {
			if ((uint)index >= (uint)list.Count)
				return false;
			return list[index].IsInitialized_NoLock;
		}

		/// <summary>
		/// Enumerator
		/// </summary>
		public struct Enumerator : IEnumerator<TValue> {
			readonly LazyList<TValue> list;
			readonly int id;
			int index;
			TValue current;

			internal Enumerator(LazyList<TValue> list) {
				this.list = list;
				index = 0;
				current = default;
#if THREAD_SAFE
				list.theLock.EnterReadLock(); try {
#endif
				id = list.id;
#if THREAD_SAFE
				} finally { list.theLock.ExitReadLock(); }
#endif
			}

			/// <summary>
			/// Gets the current value
			/// </summary>
			public TValue Current => current;
			object IEnumerator.Current => current;

			/// <summary>
			/// Moves to the next element in the collection
			/// </summary>
			/// <returns></returns>
			public bool MoveNext() {
#if THREAD_SAFE
				list.theLock.EnterWriteLock(); try {
#endif
				if (list.id == id && index < list.Count_NoLock) {
					current = list.list[index].GetValue_NoLock(index);
					index++;
					return true;
				}
				else
					return MoveNextDoneOrThrow_NoLock();
#if THREAD_SAFE
				} finally { list.theLock.ExitWriteLock(); }
#endif
			}

			bool MoveNextDoneOrThrow_NoLock() {
				if (list.id != id)
					throw new InvalidOperationException("List was modified");
				current = default;
				return false;
			}

			/// <summary>
			/// Disposes the enumerator
			/// </summary>
			public void Dispose() { }

			void IEnumerator.Reset() => throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the list enumerator
		/// </summary>
		/// <returns></returns>
		public Enumerator GetEnumerator() => new Enumerator(this);

		IEnumerator<TValue> IEnumerable<TValue>.GetEnumerator() => GetEnumerator();

		internal IEnumerable<TValue> GetEnumerable_NoLock() {
			int id2 = id;
			for (int i = 0; i < list.Count; i++) {
				if (id != id2)
					throw new InvalidOperationException("List was modified");
				yield return list[i].GetValue_NoLock(i);
			}
		}

		/// <inheritdoc/>
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}

	/// <summary>
	/// Implements a <see cref="IList{T}"/> that is lazily initialized
	/// </summary>
	/// <typeparam name="TValue">Type to store in list</typeparam>
	/// <typeparam name="TContext">Type of the context passed to the read-value delegate</typeparam>
	[DebuggerDisplay("Count = {Count}")]
	[DebuggerTypeProxy(typeof(CollectionDebugView<,>))]
	public class LazyList<TValue, TContext> : LazyList<TValue>, ILazyList<TValue> where TValue : class {
		/*readonly*/ TContext context;
		readonly Func<TContext, int, TValue> readOriginalValue;

		/// <summary>
		/// Stores data and keeps track of the original index and whether the data has been
		/// initialized or not.
		/// </summary>
		sealed class LazyElement : Element {
			internal readonly int origIndex;
			LazyList<TValue, TContext> lazyList;

			/// <inheritdoc/>
			public override bool IsInitialized_NoLock => lazyList is null;

			/// <inheritdoc/>
			public override TValue GetValue_NoLock(int index) {
				if (lazyList is not null) {
					value = lazyList.ReadOriginalValue_NoLock(index, origIndex);
					lazyList = null;
				}
				return value;
			}

			/// <inheritdoc/>
			public override void SetValue_NoLock(int index, TValue value) {
				this.value = value;
				lazyList = null;
			}

			/// <summary>
			/// Constructor that should only be called when <see cref="LazyList{TValue, TContext}"/> is initialized.
			/// </summary>
			/// <param name="origIndex">Original index of this element</param>
			/// <param name="lazyList">LazyList instance</param>
			public LazyElement(int origIndex, LazyList<TValue, TContext> lazyList) {
				this.origIndex = origIndex;
				this.lazyList = lazyList;
			}

			/// <inheritdoc/>
			public override string ToString() {
				if (lazyList is not null) {
					value = lazyList.ReadOriginalValue_NoLock(this);
					lazyList = null;
				}
				return value is null ? string.Empty : value.ToString();
			}
		}

		/// <summary>
		/// Default constructor
		/// </summary>
		public LazyList() : this(null) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="listener">List listener</param>
		public LazyList(IListListener<TValue> listener) : base(listener) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Initial length of the list</param>
		/// <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
		/// <param name="readOriginalValue">Delegate instance that returns original values</param>
		public LazyList(int length, TContext context, Func<TContext, int, TValue> readOriginalValue)
			: this(length, null, context, readOriginalValue) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Initial length of the list</param>
		/// <param name="listener">List listener</param>
		/// <param name="context">Context passed to <paramref name="readOriginalValue"/></param>
		/// <param name="readOriginalValue">Delegate instance that returns original values</param>
		public LazyList(int length, IListListener<TValue> listener, TContext context, Func<TContext, int, TValue> readOriginalValue) : base(length, listener) {
			this.context = context;
			this.readOriginalValue = readOriginalValue;
			for (int i = 0; i < length; i++)
				list.Add(new LazyElement(i, this));
		}

		TValue ReadOriginalValue_NoLock(LazyElement elem) => ReadOriginalValue_NoLock(list.IndexOf(elem), elem.origIndex);

		TValue ReadOriginalValue_NoLock(int index, int origIndex) {
			var newValue = readOriginalValue(context, origIndex);
			listener?.OnLazyAdd(index, ref newValue);
			return newValue;
		}
	}
}





namespace dnlib.Utils {
	/// <summary>
	/// A readonly list that gets initialized lazily
	/// </summary>
	/// <typeparam name="T">Any class type</typeparam>
	[DebuggerDisplay("Count = {Length}")]
	sealed class SimpleLazyList<T> where T : class {
		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		readonly T[] elements;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly Func<uint, T> readElementByRID;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly uint length;

		/// <summary>
		/// Gets the length of this list
		/// </summary>
		public uint Length => length;

		/// <summary>
		/// Access the list
		/// </summary>
		/// <param name="index">Index</param>
		/// <returns>The element or <c>null</c> if <paramref name="index"/> is invalid</returns>
		public T this[uint index] {
			get {
				if (index >= length)
					return null;
				if (elements[index] is null)
					Interlocked.CompareExchange(ref elements[index], readElementByRID(index + 1), null);
				return elements[index];
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Length of the list</param>
		/// <param name="readElementByRID">Delegate instance that lazily reads an element. It might
		/// be called more than once for each <c>rid</c> in rare cases. It must never return
		/// <c>null</c>.</param>
		public SimpleLazyList(uint length, Func<uint, T> readElementByRID) {
			this.length = length;
			this.readElementByRID = readElementByRID;
			elements = new T[length];
		}
	}

	/// <summary>
	/// A readonly list that gets initialized lazily
	/// </summary>
	/// <typeparam name="T">Any class type</typeparam>
	[DebuggerDisplay("Count = {Length}")]
	sealed class SimpleLazyList2<T> where T : class, IContainsGenericParameter2 {
		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		readonly T[] elements;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly Func<uint, GenericParamContext, T> readElementByRID;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		readonly uint length;

		/// <summary>
		/// Gets the length of this list
		/// </summary>
		public uint Length => length;

		/// <summary>
		/// Access the list
		/// </summary>
		/// <param name="index">Index</param>
		/// <param name="gpContext">Generic parameter context</param>
		/// <returns>The element or <c>null</c> if <paramref name="index"/> is invalid</returns>
		public T this[uint index, GenericParamContext gpContext] {
			get {
				if (index >= length)
					return null;
				if (elements[index] is null) {
					var elem = readElementByRID(index + 1, gpContext);
					// Don't cache it if it contains GPs since each GP could hold a reference
					// to the type/method context. These GPs can't be shared.
					if (elem.ContainsGenericParameter)
						return elem;
					Interlocked.CompareExchange(ref elements[index], elem, null);
				}
				return elements[index];
			}
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="length">Length of the list</param>
		/// <param name="readElementByRID">Delegate instance that lazily reads an element. It might
		/// be called more than once for each <c>rid</c>. It must never return <c>null</c>.</param>
		public SimpleLazyList2(uint length, Func<uint, GenericParamContext, T> readElementByRID) {
			this.length = length;
			this.readElementByRID = readElementByRID;
			elements = new T[length];
		}
	}
}





namespace dnlib.Utils {
	/// <summary>
	/// Lazily returns the original value if the user hasn't overwritten the value
	/// </summary>
	/// <typeparam name="TValue">Value type</typeparam>
	[DebuggerDisplay("{value}")]
	struct UserValue<TValue> {
#if THREAD_SAFE
		Lock theLock;
#endif
		Func<TValue> readOriginalValue;
		TValue value;
		bool isUserValue;
		bool isValueInitialized;

#if THREAD_SAFE
		/// <summary>
		/// Sets the lock that protects the data
		/// </summary>
		public Lock Lock {
			set => theLock = value;
		}
#endif

		/// <summary>
		/// Set a delegate instance that will return the original value
		/// </summary>
		public Func<TValue> ReadOriginalValue {
			set => readOriginalValue = value;
		}

		/// <summary>
		/// Gets/sets the value
		/// </summary>
		/// <remarks>The getter returns the original value if the value hasn't been initialized.</remarks>
		public TValue Value {
			get {
#if THREAD_SAFE
				theLock?.EnterWriteLock(); try {
#endif
				if (!isValueInitialized) {
					value = readOriginalValue();
					readOriginalValue = null;
					isValueInitialized = true;
				}
				return value;
#if THREAD_SAFE
				} finally { theLock?.ExitWriteLock(); }
#endif
			}
			set {
#if THREAD_SAFE
				theLock?.EnterWriteLock(); try {
#endif
				this.value = value;
				readOriginalValue = null;
				isUserValue = true;
				isValueInitialized = true;
#if THREAD_SAFE
				} finally { theLock?.ExitWriteLock(); }
#endif
			}
		}

		/// <summary>
		/// Returns <c>true</c> if the value has been initialized
		/// </summary>
		public bool IsValueInitialized {
#if THREAD_SAFE
			get {
				theLock?.EnterReadLock();
				try {
					return isValueInitialized;
				}
				finally { theLock?.ExitReadLock(); }
			}
#else
			get => isValueInitialized;
#endif
		}

		/// <summary>
		/// Returns <c>true</c> if the value was set by the user
		/// </summary>
		public bool IsUserValue {
#if THREAD_SAFE
			get {
				theLock?.EnterReadLock();
				try {
					return isUserValue;
				}
				finally { theLock?.ExitReadLock(); }
			}
#else
			get => isUserValue;
#endif
		}
	}
}




// System namespace so it can easily be replaced with Array.Empty<T> later
namespace System {
	static class Array2 {
		public static T[] Empty<T>() => EmptyClass<T>.Empty;

		static class EmptyClass<T> {
			public static readonly T[] Empty = new T[0];
		}
	}
}





namespace dnlib.Utils {
	class CollectionDebugView<TValue> {
		readonly ICollection<TValue> list;
		public CollectionDebugView(ICollection<TValue> list) => this.list = list ?? throw new ArgumentNullException(nameof(list));

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public TValue[] Items {
			get {
				var array = new TValue[list.Count];
				list.CopyTo(array, 0);
				return array;
			}
		}
	}

	class CollectionDebugView<TValue, TOther> : CollectionDebugView<TValue> {
		public CollectionDebugView(ICollection<TValue> list) : base(list) { }
	}

	sealed class LocalList_CollectionDebugView : CollectionDebugView<Local> {
		public LocalList_CollectionDebugView(LocalList list) : base(list) { }
	}

	sealed class ParameterList_CollectionDebugView : CollectionDebugView<Parameter> {
		public ParameterList_CollectionDebugView(ParameterList list) : base(list) { }
	}
}




namespace dnlib.W32Resources {
	/// <summary>
	/// Base class of <see cref="ResourceDirectory"/> and <see cref="ResourceData"/>
	/// </summary>
	public abstract class ResourceDirectoryEntry {
		ResourceName name;

		/// <summary>
		/// Gets/sets the name
		/// </summary>
		public ResourceName Name {
			get => name;
			set => name = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		protected ResourceDirectoryEntry(ResourceName name) => this.name = name;

		/// <inheritdoc/>
		public override string ToString() => name.ToString();
	}
}





namespace dnlib.W32Resources {
	/// <summary>
	/// A Win32 resource name. It can be either an integer or a string.
	/// </summary>
	public readonly struct ResourceName : IComparable<ResourceName>, IEquatable<ResourceName> {
		readonly int id;
		readonly string name;

		/// <summary>
		/// <c>true</c> if <see cref="Id"/> is valid
		/// </summary>
		public bool HasId => name is null;

		/// <summary>
		/// <c>true</c> if <see cref="Name"/> is valid
		/// </summary>
		public bool HasName => name is not null;

		/// <summary>
		/// The ID. It's only valid if <see cref="HasId"/> is <c>true</c>
		/// </summary>
		public int Id => id;

		/// <summary>
		/// The name. It's only valid if <see cref="HasName"/> is <c>true</c>
		/// </summary>
		public string Name => name;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="id">ID</param>
		public ResourceName(int id) {
			this.id = id;
			name = null;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public ResourceName(string name) {
			id = 0;
			this.name = name;
		}

		/// <summary>Converts input to a <see cref="ResourceName"/></summary>
		public static implicit operator ResourceName(int id) => new ResourceName(id);

		/// <summary>Converts input to a <see cref="ResourceName"/></summary>
		public static implicit operator ResourceName(string name) => new ResourceName(name);

		/// <summary>Overloaded operator</summary>
		public static bool operator <(ResourceName left, ResourceName right) => left.CompareTo(right) < 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator <=(ResourceName left, ResourceName right) => left.CompareTo(right) <= 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator >(ResourceName left, ResourceName right) => left.CompareTo(right) > 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator >=(ResourceName left, ResourceName right) => left.CompareTo(right) >= 0;

		/// <summary>Overloaded operator</summary>
		public static bool operator ==(ResourceName left, ResourceName right) => left.Equals(right);

		/// <summary>Overloaded operator</summary>
		public static bool operator !=(ResourceName left, ResourceName right) => !left.Equals(right);

		/// <inheritdoc/>
		public int CompareTo(ResourceName other) {
			if (HasId != other.HasId) {
				// Sort names before ids
				return HasName ? -1 : 1;
			}
			if (HasId)
				return id.CompareTo(other.id);
			else
				return name.ToUpperInvariant().CompareTo(other.name.ToUpperInvariant());
		}

		/// <inheritdoc/>
		public bool Equals(ResourceName other) => CompareTo(other) == 0;

		/// <inheritdoc/>
		public override bool Equals(object obj) {
			if (!(obj is ResourceName))
				return false;
			return Equals((ResourceName)obj);
		}

		/// <inheritdoc/>
		public override int GetHashCode() {
			if (HasId)
				return id;
			return name.GetHashCode();
		}

		/// <inheritdoc/>
		public override string ToString() => HasId ? id.ToString() : name;
	}
}





namespace dnlib.W32Resources {
	/// <summary>
	/// Win32 resources base class
	/// </summary>
	public abstract class Win32Resources : IDisposable {
		/// <summary>
		/// Gets/sets the root directory
		/// </summary>
		public abstract ResourceDirectory Root { get; set; }

		/// <summary>
		/// Finds a <see cref="ResourceDirectory"/>
		/// </summary>
		/// <param name="type">Type</param>
		/// <returns>The <see cref="ResourceDirectory"/> or <c>null</c> if none found</returns>
		public ResourceDirectory Find(ResourceName type) {
			var dir = Root;
			if (dir is null)
				return null;
			return dir.FindDirectory(type);
		}

		/// <summary>
		/// Finds a <see cref="ResourceDirectory"/>
		/// </summary>
		/// <param name="type">Type</param>
		/// <param name="name">Name</param>
		/// <returns>The <see cref="ResourceDirectory"/> or <c>null</c> if none found</returns>
		public ResourceDirectory Find(ResourceName type, ResourceName name) {
			var dir = Find(type);
			if (dir is null)
				return null;
			return dir.FindDirectory(name);
		}

		/// <summary>
		/// Finds a <see cref="ResourceData"/>
		/// </summary>
		/// <param name="type">Type</param>
		/// <param name="name">Name</param>
		/// <param name="langId">Language ID</param>
		/// <returns>The <see cref="ResourceData"/> or <c>null</c> if none found</returns>
		public ResourceData Find(ResourceName type, ResourceName name, ResourceName langId) {
			var dir = Find(type, name);
			if (dir is null)
				return null;
			return dir.FindData(langId);
		}

		/// <inheritdoc/>
		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		/// <summary>
		/// Dispose method
		/// </summary>
		/// <param name="disposing"><c>true</c> if called by <see cref="Dispose()"/></param>
		protected virtual void Dispose(bool disposing) {
			if (!disposing)
				return;
			Root = null;	// Property handler will call Dispose()
		}
	}

	/// <summary>
	/// Win32 resources class created by the user
	/// </summary>
	public class Win32ResourcesUser : Win32Resources {
		ResourceDirectory root = new ResourceDirectoryUser(new ResourceName("root"));

		/// <inheritdoc/>
		public override ResourceDirectory Root {
			get => root;
			set => Interlocked.Exchange(ref root, value);
		}
	}

	/// <summary>
	/// Win32 resources class created from a PE file
	/// </summary>
	public sealed class Win32ResourcesPE : Win32Resources {
		/// <summary>
		/// Converts data RVAs to file offsets in <see cref="dataReader_factory"/>
		/// </summary>
		readonly IRvaFileOffsetConverter rvaConverter;

		/// <summary>
		/// This reader only reads the raw data. The data RVA is found in the data header and
		/// it's first converted to a file offset using <see cref="rvaConverter"/>. This file
		/// offset is where we'll read from using this reader.
		/// </summary>
		DataReaderFactory dataReader_factory;
		uint dataReader_offset;
		uint dataReader_length;
		bool owns_dataReader_factory;

		/// <summary>
		/// This reader only reads the directory entries and data headers. The data is read
		/// by <see cref="dataReader_factory"/>
		/// </summary>
		DataReaderFactory rsrcReader_factory;
		uint rsrcReader_offset;
		uint rsrcReader_length;
		bool owns_rsrcReader_factory;

		UserValue<ResourceDirectory> root;

#if THREAD_SAFE
		readonly Lock theLock = Lock.Create();
#endif

		/// <inheritdoc/>
		public override ResourceDirectory Root {
			get => root.Value;
			set {
				if (root.IsValueInitialized) {
					var origValue = root.Value;
					if (origValue == value)
						return;
				}
				root.Value = value;
			}
		}

		/// <summary>
		/// Gets the resource reader
		/// </summary>
		internal DataReader GetResourceReader() => rsrcReader_factory.CreateReader(rsrcReader_offset, rsrcReader_length);

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="rvaConverter"><see cref="RVA"/>/<see cref="FileOffset"/> converter</param>
		/// <param name="rsrcReader_factory">Reader for the whole Win32 resources section (usually
		/// the .rsrc section). It's used to read <see cref="ResourceDirectory"/>'s and
		/// <see cref="ResourceData"/>'s but not the actual data blob.</param>
		/// <param name="rsrcReader_offset">Offset of resource section</param>
		/// <param name="rsrcReader_length">Length of resource section</param>
		/// <param name="owns_rsrcReader_factory">true if this instance can dispose of <paramref name="rsrcReader_factory"/></param>
		/// <param name="dataReader_factory">Data reader (it's used after converting an <see cref="RVA"/>
		/// to a <see cref="FileOffset"/>)</param>
		/// <param name="dataReader_offset">Offset of resource section</param>
		/// <param name="dataReader_length">Length of resource section</param>
		/// <param name="owns_dataReader_factory">true if this instance can dispose of <paramref name="dataReader_factory"/></param>
		public Win32ResourcesPE(IRvaFileOffsetConverter rvaConverter, DataReaderFactory rsrcReader_factory, uint rsrcReader_offset, uint rsrcReader_length, bool owns_rsrcReader_factory, DataReaderFactory dataReader_factory, uint dataReader_offset, uint dataReader_length, bool owns_dataReader_factory) {
			this.rvaConverter = rvaConverter ?? throw new ArgumentNullException(nameof(rvaConverter));
			this.rsrcReader_factory = rsrcReader_factory ?? throw new ArgumentNullException(nameof(rsrcReader_factory));
			this.rsrcReader_offset = rsrcReader_offset;
			this.rsrcReader_length = rsrcReader_length;
			this.owns_rsrcReader_factory = owns_rsrcReader_factory;
			this.dataReader_factory = dataReader_factory ?? throw new ArgumentNullException(nameof(dataReader_factory));
			this.dataReader_offset = dataReader_offset;
			this.dataReader_length = dataReader_length;
			this.owns_dataReader_factory = owns_dataReader_factory;
			Initialize();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="peImage">The PE image</param>
		public Win32ResourcesPE(IPEImage peImage)
			: this(peImage, null, 0, 0, false) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="peImage">The PE image</param>
		/// <param name="rsrcReader_factory">Reader for the whole Win32 resources section (usually
		/// the .rsrc section) or <c>null</c> if we should create one from the resource data
		/// directory in the optional header</param>
		/// <param name="rsrcReader_offset">Offset of resource section</param>
		/// <param name="rsrcReader_length">Length of resource section</param>
		/// <param name="owns_rsrcReader_factory">true if this instance can dispose of <paramref name="rsrcReader_factory"/></param>
		public Win32ResourcesPE(IPEImage peImage, DataReaderFactory rsrcReader_factory, uint rsrcReader_offset, uint rsrcReader_length, bool owns_rsrcReader_factory) {
			rvaConverter = peImage ?? throw new ArgumentNullException(nameof(peImage));
			dataReader_factory = peImage.DataReaderFactory;
			dataReader_offset = 0;
			dataReader_length = dataReader_factory.Length;
			if (rsrcReader_factory is not null) {
				this.rsrcReader_factory = rsrcReader_factory;
				this.rsrcReader_offset = rsrcReader_offset;
				this.rsrcReader_length = rsrcReader_length;
				this.owns_rsrcReader_factory = owns_rsrcReader_factory;
			}
			else {
				var dataDir = peImage.ImageNTHeaders.OptionalHeader.DataDirectories[2];
				if (dataDir.VirtualAddress != 0 && dataDir.Size != 0) {
					var reader = peImage.CreateReader(dataDir.VirtualAddress, dataDir.Size);
					this.rsrcReader_factory = peImage.DataReaderFactory;
					this.rsrcReader_offset = reader.StartOffset;
					this.rsrcReader_length = reader.Length;
				}
				else {
					this.rsrcReader_factory = ByteArrayDataReaderFactory.Create(Array2.Empty<byte>(), filename: null);
					this.rsrcReader_offset = 0;
					this.rsrcReader_length = 0;
				}
			}
			Initialize();
		}

		void Initialize() {
			root.ReadOriginalValue = () => {
				var rsrcReader_factory = this.rsrcReader_factory;
				if (rsrcReader_factory is null)
					return null;    // It's disposed
				var reader = rsrcReader_factory.CreateReader(rsrcReader_offset, rsrcReader_length);
				return new ResourceDirectoryPE(0, new ResourceName("root"), this, ref reader);
			};
#if THREAD_SAFE
			root.Lock = theLock;
#endif
		}

		/// <summary>
		/// Creates a new data reader
		/// </summary>
		/// <param name="rva">RVA of data</param>
		/// <param name="size">Size of data</param>
		/// <returns></returns>
		public DataReader CreateReader(RVA rva, uint size) {
			GetDataReaderInfo(rva, size, out var dataReaderFactory, out uint dataOffset, out uint dataLength);
			return dataReaderFactory.CreateReader(dataOffset, dataLength);
		}

		internal void GetDataReaderInfo(RVA rva, uint size, out DataReaderFactory dataReaderFactory, out uint dataOffset, out uint dataLength) {
			dataOffset = (uint)rvaConverter.ToFileOffset(rva);
			if ((ulong)dataOffset + size <= dataReader_factory.Length) {
				dataReaderFactory = dataReader_factory;
				dataLength = size;
				return;
			}
			else {
				dataReaderFactory = ByteArrayDataReaderFactory.Create(Array2.Empty<byte>(), filename: null);
				dataOffset = 0;
				dataLength = 0;
			}
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing) {
			if (!disposing)
				return;
			if (owns_dataReader_factory)
				dataReader_factory?.Dispose();
			if (owns_rsrcReader_factory)
				rsrcReader_factory?.Dispose();
			dataReader_factory = null;
			rsrcReader_factory = null;
			base.Dispose(disposing);
		}
	}
}





namespace dnlib.W32Resources {
	/// <summary>
	/// A resource blob
	/// </summary>
	public sealed class ResourceData : ResourceDirectoryEntry {
		readonly DataReaderFactory dataReaderFactory;
		readonly uint resourceStartOffset;
		readonly uint resourceLength;

		uint codePage;
		uint reserved;

		/// <summary>
		/// Gets the data reader
		/// </summary>
		/// <returns></returns>
		public DataReader CreateReader() => dataReaderFactory.CreateReader(resourceStartOffset, resourceLength);

		/// <summary>
		/// Gets/sets the code page
		/// </summary>
		public uint CodePage {
			get => codePage;
			set => codePage = value;
		}

		/// <summary>
		/// Gets/sets the reserved field
		/// </summary>
		public uint Reserved {
			get => reserved;
			set => reserved = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public ResourceData(ResourceName name)
			: this(name, ByteArrayDataReaderFactory.Create(Array2.Empty<byte>(), filename: null), 0, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="dataReaderFactory">Data reader factory</param>
		/// <param name="offset">Offset of resource data</param>
		/// <param name="length">Length of resource data</param>
		/// <param name="name">Name</param>
		public ResourceData(ResourceName name, DataReaderFactory dataReaderFactory, uint offset, uint length)
			: this(name, dataReaderFactory, offset, length, 0, 0) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="dataReaderFactory">Data reader factory</param>
		/// <param name="offset">Offset of resource data</param>
		/// <param name="length">Length of resource data</param>
		/// <param name="name">Name</param>
		/// <param name="codePage">Code page</param>
		/// <param name="reserved">Reserved value</param>
		public ResourceData(ResourceName name, DataReaderFactory dataReaderFactory, uint offset, uint length, uint codePage, uint reserved)
			: base(name) {
			this.dataReaderFactory = dataReaderFactory ?? throw new ArgumentNullException(nameof(dataReaderFactory));
			resourceStartOffset = offset;
			resourceLength = length;
			this.codePage = codePage;
			this.reserved = reserved;
		}
	}
}





namespace dnlib.W32Resources {
	/// <summary>
	/// A Win32 resource directory (see IMAGE_RESOURCE_DIRECTORY in the Windows SDK)
	/// </summary>
	public abstract class ResourceDirectory : ResourceDirectoryEntry {
		/// <summary>See <see cref="Characteristics"/></summary>
		protected uint characteristics;
		/// <summary>See <see cref="TimeDateStamp"/></summary>
		protected uint timeDateStamp;
		/// <summary>See <see cref="MajorVersion"/></summary>
		protected ushort majorVersion;
		/// <summary>See <see cref="MinorVersion"/></summary>
		protected ushort minorVersion;
		/// <summary>See <see cref="Directories"/></summary>
		private protected LazyList<ResourceDirectory> directories;
		/// <summary>See <see cref="Data"/></summary>
		private protected LazyList<ResourceData> data;

		/// <summary>
		/// Gets/sets the characteristics
		/// </summary>
		public uint Characteristics {
			get => characteristics;
			set => characteristics = value;
		}

		/// <summary>
		/// Gets/sets the time date stamp
		/// </summary>
		public uint TimeDateStamp {
			get => timeDateStamp;
			set => timeDateStamp = value;
		}

		/// <summary>
		/// Gets/sets the major version number
		/// </summary>
		public ushort MajorVersion {
			get => majorVersion;
			set => majorVersion = value;
		}

		/// <summary>
		/// Gets/sets the minor version number
		/// </summary>
		public ushort MinorVersion {
			get => minorVersion;
			set => minorVersion = value;
		}

		/// <summary>
		/// Gets all directory entries
		/// </summary>
		public IList<ResourceDirectory> Directories => directories;

		/// <summary>
		/// Gets all resource data
		/// </summary>
		public IList<ResourceData> Data => data;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		protected ResourceDirectory(ResourceName name)
			: base(name) {
		}

		/// <summary>
		/// Finds a <see cref="ResourceDirectory"/> by name
		/// </summary>
		/// <param name="name">Name</param>
		/// <returns>A <see cref="ResourceDirectory"/> or <c>null</c> if it wasn't found</returns>
		public ResourceDirectory FindDirectory(ResourceName name) {
			foreach (var dir in directories) {
				if (dir.Name == name)
					return dir;
			}
			return null;
		}

		/// <summary>
		/// Finds a <see cref="ResourceData"/> by name
		/// </summary>
		/// <param name="name">Name</param>
		/// <returns>A <see cref="ResourceData"/> or <c>null</c> if it wasn't found</returns>
		public ResourceData FindData(ResourceName name) {
			foreach (var d in data) {
				if (d.Name == name)
					return d;
			}
			return null;
		}
	}

	/// <summary>
	/// A Win32 resource directory created by the user
	/// </summary>
	public class ResourceDirectoryUser : ResourceDirectory {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="name">Name</param>
		public ResourceDirectoryUser(ResourceName name)
			: base(name) {
			directories = new LazyList<ResourceDirectory>();
			data = new LazyList<ResourceData>();
		}
	}

	/// <summary>
	/// A Win32 resource directory created from a PE file
	/// </summary>
	public sealed class ResourceDirectoryPE : ResourceDirectory {
		/// <summary>
		/// To make sure we don't get stuck in an infinite loop, don't allow more than this
		/// many sub directories.
		/// </summary>
		const uint MAX_DIR_DEPTH = 10;

		/// <summary>Owner</summary>
		readonly Win32ResourcesPE resources;
		/// <summary>Directory depth. When creating more <see cref="ResourceDirectoryPE"/>'s,
		/// the instances get this value + 1</summary>
		uint depth;

		/// <summary>
		/// Info about all <see cref="ResourceData"/>'s we haven't created yet
		/// </summary>
		List<EntryInfo> dataInfos;

		/// <summary>
		/// Info about all <see cref="ResourceDirectory"/>'s we haven't created yet
		/// </summary>
		List<EntryInfo> dirInfos;

		readonly struct EntryInfo {
			public readonly ResourceName name;

			/// <summary>Offset of resource directory / data</summary>
			public readonly uint offset;

			public EntryInfo(ResourceName name, uint offset) {
				this.name = name;
				this.offset = offset;
			}

			public override string ToString() => $"{offset:X8} {name}";
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="depth">Starts from 0. If it's big enough, we'll stop reading more data.</param>
		/// <param name="name">Name</param>
		/// <param name="resources">Resources</param>
		/// <param name="reader">Reader positioned at the start of this resource directory</param>
		public ResourceDirectoryPE(uint depth, ResourceName name, Win32ResourcesPE resources, ref DataReader reader)
			: base(name) {
			this.resources = resources;
			this.depth = depth;
			Initialize(ref reader);
		}

		/// <summary>
		/// Reads the directory header and initializes <see cref="ResourceDirectory.directories"/> and
		/// <see cref="ResourceDirectory.data"/>.
		/// </summary>
		/// <param name="reader"></param>
		void Initialize(ref DataReader reader) {
			if (depth > MAX_DIR_DEPTH || !reader.CanRead(16U)) {
				InitializeDefault();
				return;
			}

			characteristics = reader.ReadUInt32();
			timeDateStamp = reader.ReadUInt32();
			majorVersion = reader.ReadUInt16();
			minorVersion = reader.ReadUInt16();
			ushort numNamed = reader.ReadUInt16();
			ushort numIds = reader.ReadUInt16();

			int total = numNamed + numIds;
			if (!reader.CanRead((uint)total * 8)) {
				InitializeDefault();
				return;
			}

			dataInfos = new List<EntryInfo>();
			dirInfos = new List<EntryInfo>();
			uint offset = reader.Position;
			for (int i = 0; i < total; i++, offset += 8) {
				reader.Position = offset;
				uint nameOrId = reader.ReadUInt32();
				uint dataOrDirectory = reader.ReadUInt32();
				ResourceName name;
				if ((nameOrId & 0x80000000) != 0)
					name = new ResourceName(ReadString(ref reader, nameOrId & 0x7FFFFFFF) ?? string.Empty);
				else
					name = new ResourceName((int)nameOrId);

				if ((dataOrDirectory & 0x80000000) == 0)
					dataInfos.Add(new EntryInfo(name, dataOrDirectory));
				else
					dirInfos.Add(new EntryInfo(name, dataOrDirectory & 0x7FFFFFFF));
			}

			directories = new LazyList<ResourceDirectory, object>(dirInfos.Count, null, (ctx, i) => ReadResourceDirectory(i));
			data = new LazyList<ResourceData, object>(dataInfos.Count, null, (ctx, i) => ReadResourceData(i));
		}

		/// <summary>
		/// Reads a string
		/// </summary>
		/// <param name="reader">Reader</param>
		/// <param name="offset">Offset of string</param>
		/// <returns>The string or <c>null</c> if we could not read it</returns>
		static string ReadString(ref DataReader reader, uint offset) {
			reader.Position = offset;
			if (!reader.CanRead(2U))
				return null;
			int size = reader.ReadUInt16();
			int sizeInBytes = size * 2;
			if (!reader.CanRead((uint)sizeInBytes))
				return null;
			try {
				return reader.ReadUtf16String(sizeInBytes / 2);
			}
			catch {
				return null;
			}
		}

		ResourceDirectory ReadResourceDirectory(int i) {
			var info = dirInfos[i];
			var reader = resources.GetResourceReader();
			reader.Position = Math.Min(reader.Length, info.offset);
			return new ResourceDirectoryPE(depth + 1, info.name, resources, ref reader);
		}

		ResourceData ReadResourceData(int i) {
			var info = dataInfos[i];
			var reader = resources.GetResourceReader();
			reader.Position = Math.Min(reader.Length, info.offset);

			ResourceData data;
			if (reader.CanRead(16U)) {
				var rva = (RVA)reader.ReadUInt32();
				uint size = reader.ReadUInt32();
				uint codePage = reader.ReadUInt32();
				uint reserved = reader.ReadUInt32();
				resources.GetDataReaderInfo(rva, size, out var dataReaderFactory, out uint dataOffset, out uint dataLength);
				data = new ResourceData(info.name, dataReaderFactory, dataOffset, dataLength, codePage, reserved);
			}
			else
				data = new ResourceData(info.name);

			return data;
		}

		void InitializeDefault() {
			directories = new LazyList<ResourceDirectory>();
			data = new LazyList<ResourceData>();
		}
	}
}


